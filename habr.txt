Dagaz: Вторжение в трёхмерность

<a href="https://dagazproject.github.io/checkmate/raumschach.htm"><img align="left" src="https://habrastorage.org/webt/is/sw/lj/isswljuzd2h_vz_qvpkmfweapdk.jpeg" /></a><b><i>Представь себе, что ты находишься в Плоскомире, и вдруг кто-то предлагает тебе заглянуть в мир трех измерений. Разве это не покажется тебе безумием?

Эдвин Эбботт, "<a href="https://ru.wikipedia.org/wiki/Флатландия">Флатландия</a>"</i>
</b>

Эта статья про застарелые комплексы, а также про успешное их преодоление. Восемь лет назад, <a href="https://dagazproject.github.io/">Dagaz</a> создавался не на пустом месте. В его основу легли <a href="https://www.zillions-of-games.com/">Zillions</a>, <a href="https://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> и... <a href="https://jocly.jcfrog.com/joclymatch/gamespanel.php">Jocly</a>. Как раз с последним и было связано больше всего терзаний. Сейчас Jocly выглядит как 100%-ый 3D-проект, но так было не всегда. Когда-то в нём были 2D-игры (например манкалы). Где они теперь? Всё просто, разработчики выпилили их из проекта, поскольку посчитали, что те не вписались в новую концепцию трёхмерности. Было понятно, что это не путь для Dagaz, но какой путь для Dagaz было непонятно...
<cut>
3D - это красиво, но, положа руку на сердце, существует совершенно ничтожный процент настольных игр, для которых 3D необходимо. Кроме того, 3D - это очень трудоёмко! Подготовка трёхмерных моделей и текстур для них требует гораздо больше времени чем простое рисование картинок в Paint-е. По этой причине, перевод всего массива игр Dagaz в 3D вряд ли оправдан. Но есть игры, в которых трёхмерность весьма востребована.

<a href="https://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2457">
<img align="center" src="https://habrastorage.org/webt/y2/rg/79/y2rg79tvhrdh0trivbyjf9fw2gg.png" /></a>
У <a href="https://games.dtco.ru/mirror/upload/margo-basics.pdf">MarGo</a> долгая история. И как легко убедиться, кликнув по картинке (кстати, все картинки в этой статье кликабельные), видом сверху в ней вполне можно обойтись, но... настоящая трёхмерная реализация выглядит гораздо <a href="https://dagazproject.github.io/go/margo-3d-board.htm">приятнее</a>. Её можно повертеть, рассматривая с разных сторон, изменить масштаб...

Поскольку в этой игре не требуется сложных моделей для отображения фигур, и нет анимации перемещений, она послужила неплохой отправной точкой для начала работы с трёхмерной графикой.

<spoiler title="Как это было">
Прежде всего, в 2D эта игра уже <a href="https://dagazproject.github.io/go/margo-board.htm">была</a> реализована. Потребовалось всего лишь <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/go/scripts/margo-3d.js#L362-L654">добавить Z-координату</a> к пунктам доски. Конечно, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/3d-view.js">представление</a> и <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/3d-app.js">контроллер</a> игры пришлось разрабатывать с нуля (на базе <a href="https://threejs.org/">Three.js</a>, разумеется). Сама реализация каких-то сюрпризов не принесла, за исключением того, что в этом месте пришлось впервые столкнуться с <a href="https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>. В общем, если приложение <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L401-L407">загружает</a> модели или текстуры, для отладки придётся поднимать Web-сервер, либо пользоваться экзотическими флагами:

<source>
chrome.exe --disable-web-security --user-data-dir="C:/Temp"
</source>
Другим интересным моментом стала подсветка допустимых ходов, при прохождении над их позициями курсора мыши (к сожалению, в мобильных приложениях это не работает). Прежде всего, во всех пунктах доски были созданы <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L162-L169">прозрачные</a> <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L524-L525">меши</a>. Далее, используется <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L100">трассировщик лучей</a>. При прохождении мыши, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1117-L1120">ищется пересечение</a> с одной из допустимых позиций, после чего, материал меша <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1127">меняется</a> на полупрозрачный. 
</spoiler>
Следующими на очереди были игры в <a href="https://ru.wikipedia.org/wiki/Го">Го</a> на трёхмерных досках (есть такая забавная <a href="https://github.com/leweyg/FreedGames">программка</a>, но к ней ни бот прикрутить ни по сети поиграть). Кубическая сетка в приложении к Го не очень интересна, но, например, такие доски:

<a href="https://dagazproject.github.io/go/diamond-atari-go.htm">
<img align="center" src="https://habrastorage.org/webt/ne/-q/rr/ne-qrr_rhirx0mk4929gf66_bss.png" /></a>
Первая хороша тем, что на ней, как и на обычной доске, есть "углы" и "края" (но и того и другого больше), а на второй ни того ни другого нет и все пункты равнозначны.

<spoiler title="Подробности">
Прежде всего, было необходимо отобразить сетку. В этом помог <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/3d-view-directions.js">модуль</a>, аугментирующий доску отображением всех заданных направлений (подобная визуализация есть в Zillions и хорошо помогает в процессе разработки). Кроме того, пришлось озадачиться визуализацией правила <a href="https://ru.wikipedia.org/wiki/Правило_ко">Ко</a>.

<a href="https://dagazproject.github.io/go/diamond-go-board.htm?selector=1&setup=+16;0:2;+1;0:2;+6;0:1;+2;0:1;+6;0:2;+15;0:1+1;+24;&turn=1">
<img align="center" src="https://habrastorage.org/webt/9j/qr/m8/9jqrm85exdmqfeatgks6l0akhy8.png" /></a>
Конечно, больше для полноты картины. Разработка полноценного бота для игры в Го - задача не тривиальная, да и людям ориентироваться в трёхмерных досках совсем не просто. По этим причинам, к доскам был прикручен простенький бот для игры в "<a href="https://senseis.xmp.net/?AtariGo">Атари Го</a>" (до первого захвата), а в такой игре ситуация Ко, по понятным причинам, возникнуть не может.

<a href="https://dagazproject.github.io/go/diamond-atari-go.htm?selector=1">
<img align="center" src="https://habrastorage.org/webt/o3/fo/-m/o3fo-mvs7rliwrz1_ulrcwzxx2m.png" /></a>
С этой менюшечкой тоже пришлось повозиться. Прежде всего, понадобился ещё один <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/go/diamond-atari-go.htm#L21">канвас</a> для 2D-элементов (на размеры внимания не обращайте, они устанавливаются динамически). Само отображение меню и отрисовка tooltip-ов выглядят довольно <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L667-L705">тривиально</a>.

С оверлейным канвасом был связан забавный баг, особенно проявлявшийся на мобильных устройствах, с их экстремально небольшим экраном. Для управления камерой в проекте используется <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/underscore/orbit-controls.js">OrbitControls</a>. В тех случаях, когда события мыши попадали на 2D-канвас, до OrbitControls они просто не доходили и управление камерой не работало.
</spoiler>
Далее, пришло время разбираться с движущимися фигурами:

<a href="https://dagazproject.github.io/morris/3d-morris.htm?setup=+7;0:1;0:2;0:1;+3;0:2;+4;0:2;+1;0:1;+1;&turn=0&reserve=0,;0,">
<img align="center" src="https://habrastorage.org/webt/t0/b5/v3/t0b5v3onunqswme1w9n_tyliwm0.png" /></a>
Это вариация "<a href="https://en.wikipedia.org/wiki/Three_men%27s_morris">Танца трёх мужчин</a>" на необычной доске. У каждого игрока по 3 шара, они ходят по очереди в любой пункт доски, стараясь выстроить три своих шара в ряд. Если это не удалось, игроки каждым своим ходом перемещают один из своих шаров на пустой соседний пункт. Цель игры та же - тот кто первым выстроит 3 своих шара в ряд победил. В указанной выше позиции красные почти победили, но синие пока ещё могут двигаться. Зелёные сферы показывают куда можно переместиться.

<spoiler title="Как двигать сферы?">
Превращение последовательности кликов в допустимый ход - не такое простое дело. <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/move-list-v5.js">MoveList</a> может показаться избыточным, но только до тех пор пока не придётся столкнуться с составными ходами в таких играх, как например <a href="https://ru.wikipedia.org/wiki/Шашки">Шашки</a>. Но даже в максимально простом виде, он решает ряд важных задач:

<ul>
	<li>Индикация стартовых позиций (с которых может начаться ход)</li>
	<li>Индикация целевых позиций, после выбора стартовой</li>
	<li>Завершение хода при выборе целевой позиции</li>
	<li>Отмена хода при повторном выборе стартовой позиции</li>
	<li>Начало другого хода при смене стартовой позиции</li>
</ul>
Попробуем проследить всю цепочку. Контроллер <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L265">создаёт</a> MoveList для текущего состояния доски (генерируется список допустимых ходов). Сформированный список стартовых позиций <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1225-L1227">используется</a> для управления курсором, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L368">подсветки</a> drop-ходов и отработки <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1206">кликов</a> по стартовым позициям. Получив стартовую позицию, MoveList формирует список целевых позиций, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L237">передаваемых</a> в представление для отображения "зелёных шаров". При выполнении <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L243">клика</a> по отмеченной целевой позиции, MoveList завершает поиск выбранного хода и <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L196">передаёт</a> его в контроллер для выполнения.

В процессе выполнения хода, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L440">изменяется</a> состояние модели и ход <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L431">передаётся</a> представлению. Ход состоит из последовательности действий: <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L902-L908">добавления</a>, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L980-L989">удаления</a> и <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L917-L965">перемещения</a> фигур. Завершающий <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L991-L1000">commit</a> запускает анимацию. В <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L19">нашем случае</a>, анимация перемещения сводится к <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L878-L880">пошаговому изменению координат</a> меша позиции в сторону целевой, переключения его в невидимое состояние и возврат на исходное место, при <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L884-L888">завершении анимации</a>.
</spoiler>
Следующей 3D-игрой стал "<a href="https://ru.wikipedia.org/wiki/Кубик_Рубика">Кубик Рубика</a>". В некотором роде, это был шаг в сторону, но уж больно тема интересная.

<a href="https://dagazproject.github.io/index-map-rubik.html">
<img align="center" src="https://habrastorage.org/webt/mr/ia/l3/mrial3iygi6ukqacxfs7li9mop0.png" /></a>
Прежде всего, для 3x3x3, каждая из <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/rubik/scripts/rubik-3x3x3.js#L87-L112">26</a> (центр можно оставить пустым) фигур - это куб, грани которого раскрашены в разные цвета. Такой раскрашенный куб может иметь <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/rubik/scripts/rubik-3x3x3.js#L124-L147">24</a> ориентации, для каждой из которых определён свой тип фигуры. <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/rubik/scripts/rubik-3x3x3-extension.js#L122-L138">Поворачивая</a> грань, важно не забыть <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/rubik/scripts/rubik-3x3x3-extension.js#L118-L120">превратить</a> каждую фигуру в куб правильной ориентации.

<spoiler title="Сложности начинаются далее">
Раскрасить каждую грань <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L339-L346">несложно</a>. Визуально отделить одни кубы от других помогает <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L353-L359">EdgesGeometry</a> (а группирование позволяет манипулировать кубом и его каркасом как единым целым). Далее, поскольку клики по отдельным граням фигур несколько не укладывались в концепцию MoveList-а, скопились <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1140-L1156">некоторые залежи</a> технического долга. Саму грань <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1145">легко</a> идентифицировать по <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1105-L1108">её нормали</a> (мы ведь сами ориентировали кубик), а перед <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1159-L1167">вращением</a>, кубики придётся <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L299-L316">перегруппировать</a>.

Все эти манипуляции только выглядят страшно, поскольку, после завершения анимации, представление куба <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1185-L1190">будет пересоздано</a>, согласно обновлённому состоянию модели. Кстати, обратите внимание как <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L1175-L1180">звук</a> вплетается в анимацию хода, для достижения хоть какой-то синхронности.

<a href="https://dagazproject.github.io/rubik/rubik-3x3x3.htm">
<img align="center" src="https://habrastorage.org/webt/6p/zl/kr/6pzlkr0bexqcjv-ppkdlbvvqcuw.png" /></a> 
Анимация - это красиво, но медленно. Те из вас, кто торопятся, могут нажать иконку с глазом.
</spoiler>
Кстати, меню стало <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/rubik/scripts/rubik-3x3x3.js#L151-L175">двухуровневым</a> (чтобы начинать игру не только с собранного или перемешанного кубика, но и с бесчисленного количества пасьянсов):

<a href="https://dagazproject.github.io/rubik/rubik-3x3x3.htm">
<img align="center" src="https://habrastorage.org/webt/ao/hj/xq/aohjxq1-y5ca1u3b1ndpiyrp8kw.png" /></a>
Некоторым продолжением темы послужила <a href="https://kvant.mccme.ru/1987/07/perevertyshi.htm">головоломка</a>, опубликованная в одном из номеров журнала <a href="https://kvant.mccme.ru/">Квант</a>.

<a href="https://dagazproject.github.io/sliding-puzzles/flippers.htm">
<img align="center" src="https://habrastorage.org/webt/z1/6w/tq/z16wtqkcaex0ir4-5gtrrtniuuk.png" /></a>
Что-то вроде <a href="https://ru.wikipedia.org/wiki/Игра_в_15">пятнашек</a>, но с перекатывающимися кубиками. Пришлось помучаться с анимацией, поскольку здесь кубы вращаются не вокруг оси, проходящей через центр. Вероятно, <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L787-L795">это</a> не единственный способ решения задачи, но он работает. 

Ну вот, мы и добрались до самого главного.

<a href="https://dagazproject.github.io/checkmate/raumschach.htm"><img align="center" src="https://habrastorage.org/webt/s7/6_/y6/s76_y642vay6vorbzquc167uw9m.png" /></a>

<spoiler title="Технические детали">
Зелёные круги пришлось заменить на что-то более сообразное. С <a href="https://github.com/DagazProject/DagazProject.github.io/tree/master/res/fairy">моделями</a> тоже вышла заминка. Дело в том, что <a href="https://threejs.org/">Three.js</a> перестала поддерживать JSONLoader, начиная с верcии r99 (довольно давно). Поскольку морочиться с <a href="https://ru.wikipedia.org/wiki/Blender">Blender</a>-ом и переконвертациями не хотелось, пришлось использовать более старую <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/underscore/three.98.min.js">версию</a> библиотеки. Грузить приходится всего и много, поэтому за этим приходится внимательно <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L584-L605">следить</a>. Ну и всё что было сказано про CORS выше, остаётся в силе.

В части механики анимации ходов, пришлось добавить <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-app.js#L313-L324">небольшой фикс</a>, для того чтобы взятая фигура убиралась с доски (ещё немного технического долга), а также предусмотреть <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/common-scripts/3d-view.js#L952-L962">превращение</a> пешек (выбор типа фигуры на 2D-канвасе - в планах на следующие релизы).
</spoiler>Что касается самой игры, <a href="https://en.wikipedia.org/wiki/Three-dimensional_chess#Raumschach">Raumschach</a> - это, на мой взгляд, наиболее последовательный и продуманный перенос шахматных правил на трёхмерную доску. Прежде всего, это выражается в адекватном размере доски. Кроме того, все шахматные фигуры сохраняют правила своих перемещений как в вертикальных, так и горизонтальных секущих плоскостях. Появляются новые фигуры "единорогов", перемещающихся по тригоналям. Рокировок, прыжков пешек и взятий на проходе в игре нет.

<spoiler title="Про AI">
Было понятно, что бота для игры делать надо и это было не совсем тривиально, поскольку <a href="https://www.chessprogramming.org/Garbochess-JS">GarboChess</a>, традиционно используемый мной для шахматных игр, для 3D-досок вообще-то не задумывался. Пришлось увеличить размер <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/garbo-ai-v5.js#L31">некоторых</a> <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/garbo-ai-v5.js#L62">массивов</a>, а также внести изменения в кодирование <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/checkmate/scripts/raumschach-ai.js#L291-L301">позиций</a> и <a href="https://github.com/DagazProject/DagazProject.github.io/blob/03e464fc2a347810988a564826482482718bce20/checkmate/scripts/raumschach-ai.js#L303-L306">ходов</a>. Также, надеюсь временно, пришлось отказаться от некоторых оптимизаций. 

В целом, движок вроде бы заработал. Оценить качество его игры пока затруднительно, поскольку Advisor (механизм, подсказывающий ходы игроку) пришлось перенести на следующий релиз, отчасти из-за того, что вылезли баги в интеграции нового контроллера с <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/common-scripts/session-manager-v2.js">session-manager</a>-ом (по этой причине, временно отключены стрелочки "вперёд" и "назад".
</spoiler>
Вот такой вышел <a href="https://github.com/DagazProject/DagazProject.github.io/commit/03e464fc2a347810988a564826482482718bce20">релиз</a>. Внимательным читателям, в качестве <a href="https://dagazproject.github.io/custodian/reversi-3d.htm">бонуса</a>, могу предложить свою реализацию трёхмерного <a href="https://en.wikipedia.org/wiki/Reversi">Реверси</a>.
</cut>

Играем в кости с Дейви Джонсом

<a href="https://spacerangers.gitlab.io/#/userquest/fmxQV6ovEXVm6cm97PkCRhykE7P2/pkm"><img align="left" src="https://habrastorage.org/webt/2o/fd/sp/2ofdsp5psctpp3hnxwj_nptn_ws.png" /></a>В этот раз, поговорим о текстовых квестах. В далёких 2000-ых годах, легендой российского геймдева стала (и надолго осталась впоследствии) выдающаяся во многих отношениях игра - "<a href="https://ru.wikipedia.org/wiki/Космические_рейнджеры">Космические рейнджеры</a>". В немалой степени, своим оглушительным успехом она была обязана текстовым квестам, очень атмосферным и разнообразным. Квесты с самого начала жили своей жизнью, а затем, благодаря Василию Рогину, появился <a href="https://spacerangers.gitlab.io/#/quests">Web-плейер</a> с удобным <a href="https://spacerangers.gitlab.io/#/editor">графическим редактором</a>, во многом подстегнувший процесс кустарного изготовления собственных квестов. Правда само программирование на нём традиционно очень далёко от "нормального". Окунёмся же в этот безумный мир, попутно разработав что-нибудь нетривиально-увлекательное...
<cut>
Вот как всё это выглядит:

<a href="https://github.com/DagazProject/DagazBotV3/blob/master/upload/pkm.qmm">
<img align="center" src="https://habrastorage.org/webt/hp/98/kj/hp98kjzbrnmg4cxfmklbdrva3a8.png" /></a>
но будем двигаться по порядку...

Прежде всего, имеет смысл определиться с тематикой квеста. Поскольку мы уже договорились, что собираемся делать что-то не тривиальное, обычный текстовый квест-бродилка нас не устроит. Помните, в "<a href="https://ru.wikipedia.org/wiki/Пираты_Карибского_моря:_Сундук_мертвеца">Сундуке мертвеца</a>" пираты играли в кости? Оказывается, это реально существующая <a href="https://ru.wikipedia.org/wiki/Перудо">игра</a> с весьма непростыми правилами.

Итак, в Перудо играют группами по 4-5 человек (можно больше). Вдвоём играть тоже можно, но не так интересно. В начале игры, каждый игрок имеет по 5 игровых кубиков (костей). Начиная раунд, все бросают свои кости, смотрят выпавшие очки, но другим игрокам не показывают. Цель игры - угадать сколько костей с определённым номиналом выпало у всех игроков.

Один из игроков делает ставку, называя номинал и количество выпавших костей, при этом, в большинстве случаев, "единички" играют роль "джокеров", заменяя собой любой номинал. Например, игрок говорит: "на столе четыре шестёрки" - это означает, что на всех костях, включая закрытые, не менее четырёх должно выпасть с указанным номиналом (шестёркой) или единичкой.

Следующий игрок может повысить ставку или сказать: "не верю" (в этом случае все кости вскрываются и подчитывается количество костей с требуемым номиналом). Ставка повышается в соответствии с следующими правилами:

<ul>
	<li>Количество костей в ставке можно только повышать, за одним исключением: игрок вправе уменьшить количество костей в ставке в два раза (округление в большую сторону), если он называет номинал "единицы" (Например, после ставки "пять пятёрок" или после ставки "шесть шестёрок" можно сказать "три единицы")</li>
	<li>Если количество костей в ставке остаётся прежним, номинал должен быть увеличен (Например, можно сказать "три шестёрки" после ставки "три пятёрки", однако нельзя сказать "пять пятёрок" после ставки "пять шестёрок")</li>
	<li>Если количество костей в ставке увеличивается, то номинал костей может быть назван любой</li>
	<li>Если номинал предыдущей ставки был «единицы», игрок вправе изменить ставку только увеличив количество костей в «единицах» или сделав ход в другом номинале, но с количеством костей на одну больше, чем двойное число ставки в единицах предыдущего игрока (Например, после ставки "две единицы" необходимо сказать "пять двоек" или "три единицы")</li></ul>Если игрок не согласен с предыдущей ставкой, производится подсчёт очков. Если костей названного номинала на столе оказывается меньше количества фигурировавшего в ставке, игрок делавший ставку считается проигравшим и лишается одной игральной кости. В противном случае, проигрывает игрок вскрывший ставку. Игрок лишившийся всех своих костей выбывает из игры.

Есть ещё одно правило: игрок, у которого осталась всего одна кость, может объявить специальный раунд "Мапуто" (в квесте, для простоты, будем считать, что специальный раунд объявляется автоматически), в рамках которого действуют следующие правила:

<ul>
	<li>"Единички" не являются джокерами</li>
	<li>Нельзя изменять номинал в последующих ставках</li>
</ul><spoiler title="Немного математики">
Чтобы успешно играть в Перудо, необходимо уметь оценивать вероятность выпадения количества <b>k</b> костей требуемого номинала из общего числа <b>n</b> костей. Сразу оговоримся, что делая ставку, мы видим перед собой несколько открытых костей. Так вот, эти кости ни в <b>n</b> ни в <b>k</b> не входят, а просто позволяют увеличить ставку.

Перед нами классическая <a href="https://ru.wikipedia.org/wiki/Комбинаторика">комбинаторная</a> задача. Имеется <b>n</b> закрытых костей, номинал которых (от 1 до 6) выпадает равновероятно и независимо. Нас интересуют те случаи, когда k из этих костей выпали с требуемым номиналом. Интересующие нас <b>k</b> костей могут быть рассредоточены среди <b>n</b> количеством способов, равном числу <a href="https://ru.wikipedia.org/wiki/Сочетание">сочетаний</a> <b>k</b> из <b>n</b> (кто хочет, может сам проверить). При этом, искомый номинал на них, очевидным образом, может выпасть единственным образом. Остальные кости (на которых номинал не выпал) дают количество <a href="https://ru.wikipedia.org/wiki/Размещение">размещений</a> с повторениями оставшихся <b>5</b>-ти значений на <b>(n-k)</b> костей:

<img align="center" src="https://habrastorage.org/webt/28/pz/02/28pz02_9sqfkfpr6toieg-kps1o.png" />
Это числитель (да и то не весь), а нам нужна была вероятность. В знаменателе будет количество размещений с повторениями всех <b>6</b>-ти значений на <b>n</b> костях. Ну и вспоминаем, что нам интересны не только <b>k</b> но и большие количества правильно выпавших костей вплоть до самого <b>n</b>. Значит, в числителе будет сумма:

<img align="center" src="https://habrastorage.org/webt/n_/aq/cb/n_aqcbdrd_pf8c1m7dqhtfjx160.png" />
Вдоволь полюбовавшись на формулу, вспоминаем про единички-джокеры и выдаём финальный итог формулы (это упражнение традиционно оставляется на откуп пытливому читателю):

<img align="center" src="https://habrastorage.org/webt/xa/m7/d9/xam7d93wtpuy69fkccasrjgx870.png" />
теперь можно и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/utils/perudo.pl">посчитать</a>. Если зафиксировать <b>n=15</b> и перебрать все <b>k</b> начиная с <b>1</b>, получится красивая картинка:

<img align="center" src="https://habrastorage.org/webt/uv/ww/7m/uvww7mcmczkqmtirmbbwiwqvnm4.jpeg" />
Но, вообще-то, вероятности нам нужны для бота. Вот как вычислитель нашей формулы выглядит на языке текстовых квестов:

<img align="center" src="https://habrastorage.org/webt/en/yq/nw/enyqnwzbyuiqjign39z9wyyehug.png" />
Циклы здесь - для вычисления умножениями и делениями всяких степеней и факториалов, действия же производятся над параметрами квеста. Главная проблема заключается в том, что все вычисления целочисленные, что не лучшим образом отражается на их точности. В целом же... этот подход работает.
</spoiler>
Квест начинается с параметров - единственных переменных величин, которыми мы можем манипулировать в рамках квеста. Параметры управляют переходами, отображением текстов, могут отображаться в текстах, информационной панели и т.п. Это числовые значения, которые необходимо объявить. Вот так, например, выглядит объявление параметра, управляющего текущей ставкой в игре:

<img align="center" src="https://habrastorage.org/webt/u1/yc/hk/u1ychkie3tlauxka6uqy1wdnfdw.png" />
Здесь можно заметить как вполне понятные (ограничения максимального и минимального значений параметра, стартовое значение), так и более экзотические настройки. В частности, параметр можно объявить провальным, успешным или смертельным (завершающим квест при достижении критического значения), привязать к деньгам игрока, но всё это только половина дела. Переключившись на правую вкладку можно управлять отображением параметра:

<img align="center" src="https://habrastorage.org/webt/4k/2l/29/4k2l29p9ffii3g6eepjovwr9f9s.png" />
Разумеется, только этим изобразительные возможности не ограничиваются. Вот здесь, например, отображается подстановка числового значения параметра:

<img align="center" src="https://habrastorage.org/webt/7n/mk/8n/7nmk8ni60iydsndktwlfjvu43fw.png" />
а здесь подставляется <b>текстовое</b> значение других параметров:

<img align="center" src="https://habrastorage.org/webt/uj/pj/iy/ujpjiyhcvwpejb4t_fkrcvuj1fo.png" />
Для подстановки <b>числовых</b> значений используется <b>[pN]</b>, а вообще можно подставить значение вычисления любого допустимого арифметического выражения, обернув его в фигурные скобки. Такие же подстановки работают в текстах локаций и переходов.
<spoiler title="Больше подробностей">
Рассмотрим работу с параметрами на примере:

<img align="center" src="https://habrastorage.org/webt/j7/mm/q_/j7mmq_qthln_7a4-9_dzxm6dsvu.png" />
Игру начинаем с выбрасывания костей. Выражение <b>[1..6]</b> возвращает случайное число в указанном диапазоне. Выбрасываем все кости (по 5 у каждого из 4 игроков). Дальше почистим лишние. Количество костей - это параметры <b>p61</b> по <b>p64</b>. Дуги графа выполняются в соответствии с заданными условиями:

<img align="center" src="https://habrastorage.org/webt/w5/z6/zd/w5z6zd9pfl-u04wigk4dwzw1b5g.png" />
Так, если у первого игрока осталась всего одна кость, обнуляем кости со 2-ой по 5-ую и дополнительно к этому устанавливаем специальный режим игры "Мапуто". Повторяем это для всех четырёх игроков, учитывая то, что последние два могут просто отсутствовать (в этом случае, обнуляем им все 5 костей). Далее надо показать расклад игроку, скрыв кости выпавшие ботам. Для взаимодействия с игроком предназначены промежуточные локации (в графе квеста отображаются белым). Кроме того, локация может отображать несколько вариантов текстовки (в нашем случае, это состав игроков, управляемый параметром <b>p32</b>:

<img align="center" src="https://habrastorage.org/webt/rv/39/cs/rv39csda-f3litntyhboxeg7zqg.png" />
Здесь есть хитрость: для первого игрока мы показываем выброшенные очки, но для всех остальных закрытые кости (знаками вопроса). Но как быть с тем, что костей может быть меньше 5-ти? Здесь нам помогает возможность гибкой настройки отображения значений параметров:

<img align="center" src="https://habrastorage.org/webt/w0/rq/he/w0rqhemoazz7eku5ajc2sokk4zg.png" />
Внимательный читатель может спросить: а что это за параметр <b>p76</b>? Это подсказка. Если разыграть квестовую часть правильно, Прихлоп будет показывать выпавшие ему очки:

<img align="center" src="https://habrastorage.org/webt/19/3h/1x/193h1xdxyhk9xaypn5elfwvdc5w.png" />
Эта возможность сильно помогает в игре, но количество таких подсказок ограничено.
</spoiler>
Формулы редактора квестов - инструмент безусловно мощный, но при неправильном употреблении способный отнять много сил и нервов. Приведу небольшой пример:

<img align="center" src="https://habrastorage.org/webt/km/dr/mq/kmdrmq4ocubfsvxe6qmk94ubfzi.png" />
Цель этой хитрой формулы - определение количества очков в текущей ставке и раньше это было простое деление. К сожалению, выяснилось что деление в формулах квеста хоть и целочисленное, но с округлением в ближайшую сторону. С учётом отсутствия дробей, это правильно, но напрочь ломало всю логику. Баг с подсчётом вскрытых очков пришлось искать несколько дней. К счастью, в формулах действует неявное преобразование булевских значений в числовые, что и позволило написать эту ступенчатую функцию. Аналогичным образом осуществляется и сам подсчёт очков:

<img align="center" src="https://habrastorage.org/webt/6t/q8/v1/6tq8v1ywbbdj75zxdghcd47w8lm.png" />
<spoiler title="Про реиграбельность">
Чтобы с удовольствием играть в один и тот же квест снова и снова, важно обеспечить его вариативность. По-разному отыгрывая квестовую составляющую, можно подойти к игре с различными начальными условиями (или просто досрочно помереть). Прихлоп может вообще не участвовать в игре, а может помогать крайне полезными советами. Наконец, у него можно попросить денег:

<img align="center" src="https://habrastorage.org/webt/1f/hd/zr/1fhdzr7rx-acillgagp86g1nkjq.png" />
Это очень важный момент, поскольку "Деньги игрока" - внешний по отношению к квесту параметр и может получиться так, что у игрока не окажется денег, а чтобы начать игру, какую-то минимальную сумму иметь необходимо. Так что, денег можно попросить у Прихлопа (правда помогать в игре он после этого уже больше не будет).
<spoiler title="Кстати, это не единственный способ заработать перед началом игры">
Ночью можно обыскать каюту Капитана. Проявив некоторую настойчивость и изобретательность можно не только заработать немного денег, но и прийти к альтернативной выигрышной концовке (к проигрышным концовкам прийти тоже можно). Но... это будет сложнее чем просто сыграть в кости.

<img align="center" src="https://habrastorage.org/webt/z8/gy/78/z8gy789qrh2pzrboju8qwazpnao.png" />
Надо, всего-навсего, погасить все плюсики. Каждый новый плюсик добавляет Капитану тревожности (и приближает момент, когда он очнётся). Те из вас, кто играли в "<a href="https://ru.wikipedia.org/wiki/Братья_Пилоты:_По_следам_полосатого_слона">Братьев Пилотов</a>", наверняка помнят сейф Карбофоса (кстати, квест про открывание сейфа тоже <a href="https://spacerangers.gitlab.io/#/userquest/fmxQV6ovEXVm6cm97PkCRhykE7P2/lightoff">есть</a>).

<img align="center" src="https://habrastorage.org/webt/ff/za/_x/ffza_x3ptnlegvwxacvumehzfzi.jpeg" />
В случае с капитанскими "тревожными мыслями", суть та же, просто паттерн переключения другой. В общем, это известная математическая головоломка <a href="https://ru.wikipedia.org/wiki/Lights_Out_(игра)">LightOut</a>. После первого успеха игрок получает случайное денежное вознаграждение и переходит к следующему раунду, приносящему вожделенный <b>ключ</b>. Кстати, потренироваться с различными вариантами этой головоломки можно <a href="https://dagazproject.github.io/index-map-lightoff.html">здесь</a>:

<a href="https://dagazproject.github.io/index-map-lightoff.html"><img align="center" src="https://habrastorage.org/webt/c1/3v/9z/c13v9zdk4wso7iaqqexd9uqrtnk.png" /></a>
В <a href="https://github.com/DagazProject/DagazBotV3/blob/master/upload/perudo.qmm">версию</a> квеста для Telegram внесены некоторые декоративные изменения. Например, такое меню в миниигре, на мой взгляд, выглядит более наглядно:

<a href="https://t.me/DagazQuestBot?start=60">
<img align="center" src="https://habrastorage.org/webt/17/un/kv/17unkvkfmgx3tp2dteu5x_xy2he.png" /></a>
</spoiler>Тот же Прихлоп знакомит нас с правилами игры (причём делает это в двух совершенно различных локациях):

<img align="center" src="https://habrastorage.org/webt/fu/es/y7/fuesy7zlzgb_zqhxqnzwvyiuubk.png" />
Это тоже очень важно, поскольку пользователь запустивший квест может ничего не знать о правилах и необходимо ввести его в курс дела (но эти объяснения можно и пропустить, если не хочется перечитывать одно и то же много раз).

Важной составляющей реиграбельности является различное поведение игроков бота. Прихлоп нам подсказывает (или нет, в зависимости от отыгрыша квеста), но Кок, Боцман и Капитан также обладают своей индивидуальностью. Как это достигается?

<img align="center" src="https://habrastorage.org/webt/z0/s_/5a/z0s_5aqshcvvftbegzpkigg5q7m.png" />
Для каждого из игроков бота заданы индивидуальные пороговые вероятности. Значения с <b>Q2</b> по <b>Q4</b> управляют "доверчивостью" игрока и определяет будет ли он вскрывать предыдущую ставку. В свою очередь <b>P2</b> по <b>P4</b> - это "оптимизм" в его собственных ставках. По задумке, Кок, например - это самый доверчивый и оптимистичный игрок, который вылетает из игры первым, после чего к игре присоединяется Капитан и проигрыш в игре переквалифицируется в "смерть" главного героя.

<img align="center" src="https://habrastorage.org/webt/03/aq/78/03aq781adczhcaewwu2ul5ni4ek.png" />
Все эти значения задаются случайным образом (но в заданных диапазонах), в зависимости от расстановки игроков. Всё перечисленное служит тому, чтобы сделать весь квест как можно более реиграбельным.
</spoiler>
Немного расскажу о том, как со всем этим иметь дело. Прежде всего, есть <a href="https://spacerangers.gitlab.io/#/quests">Web-плейер</a> с уже имеющимся огромным количеством готовых квестов. В нём есть <a href="https://spacerangers.gitlab.io/#/editor">редактор</a>, в котором можно запустить любой из имеющихся квестов, загрузить qm или qmm-файл с клиента или создать его с нуля в самом редакторе. В какой-то момент вам захочется дать ссылку на один из собственноручно разработанных квестов. Это немного менее очевидно и начинается с <a href="https://spacerangers.gitlab.io/#/offlinemode">установки</a> <a href="https://ru.wikipedia.org/wiki/Прогрессивное_веб-приложение">PWA</a>-приложения. Далее, приложение синхронизируется с облаком и уже в его редакторе вы можете загрузить собственный квест, после чего нажать на иконку с облаком:

<img align="center" src="https://habrastorage.org/webt/q1/ex/-v/q1ex-v8zdfntmpdus_5n2rcpjxg.png" />
Здесь не забудьте включить чекбокс "Доступен для всех" и нажать кнопку "Сохранить", после чего появится ссылка. Также, можно открыть в редакторе чужую <a href="https://spacerangers.gitlab.io/#/userquest/fmxQV6ovEXVm6cm97PkCRhykE7P2/pkm">ссылку</a>, если возникнет желание разобраться в том как работает квест.
</cut>

Текстовые квесты… на Telegram

<a href="https://t.me/DagazQuestBot?start"><img align="left" src="https://habrastorage.org/webt/hj/au/rk/hjaurkrxvjgxhdoj1-nf9mxgyxy.png" /></a>Давным-давно, около <a href="https://habr.com/ru/articles/783440/">полугода</a> назад, мне в голову пришла интересная идея: а не запустить ли текстовые квесты из "<a href="https://ru.wikipedia.org/wiki/Космические_рейнджеры">Космических рейнджеров</a>" под управлением Telegram-бота? Скажу сразу, что как и всё с упоминанием "<a href="https://dagazproject.github.io/index-map.html">Dagaz</a>" в заголовке, <a href="https://github.com/DagazProject/DagazBotV3">проект</a> полностью бесплатный, с открытыми исходными кодами и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/LICENSE">MIT-лицензией</a>. Если вы неравнодушны к теме, всё ещё помните неповторимую атмосферу легендарной игры или любите играть в текстовые квесты, просто кликните по картинке в начале этой статьи и перейдите в уютный Telegram. В том же случае, если вам как и мне гораздо более интересны технические подробности, добро пожаловать в мою статью...
<cut>
Прежде всего, хочу поблагодарить Василия Рогина за превосходную <a href="https://spacerangers.gitlab.io/#/quests">реинкарнацию</a> квестов "Космических рейнджеров". Исходные тексты его <a href="https://github.com/roginvs/space-rangers-quest">проекта</a> также доступны по MIT-лицензии и сэкономили мне немало сил и времени.
<spoiler title="Историческое отступление">
Хотя текстовые квесты вносят ощутимый вклад в атмосферу игры, они стоят несколько особняком от основного игрового процесса. Наравне с RTS-ми планетарными боями роботов и аркадными пострелушками внутри чёрных дыр, текстовые квесты представляют из себя своего рода "игру внутри игры". Для их разработки, разработчики <a href="https://ru.wikipedia.org/wiki/Elemental_Games">Elemental Games</a> создали специальный графический редактор TGE, впоследствии "ушедший в народ". При помощи этого инструмента, создавать, редактировать и запускать квесты может любой желающий. Выглядит этот процесс примерно так:

<img align="center" src="https://habrastorage.org/webt/tp/ax/k8/tpaxk8fusogympd8t0c-9peljkm.png" />
Стоит заметить, что TGE не так прост, как может показаться на первый взгляд. Например, при создании квестов активно используются формулы на специальном встроенном языке, позволяющем производить арифметические и логические действия над числовыми интервалами, а также инкапсулирующие в себе генерацию случайных значений. В <a href="https://habr.com/ru/articles/647251/">этой</a> статье можно найти некоторые подробности.

TGE позволяет создавать квесты, но был разработан довольно давно, содержит некоторое количество неприятных багов и продолжительное время не поддерживается. Именно здесь в нашей истории появляется Василий Рогин, выпустивший (помимо web-плейера) фактически <a href="https://spacerangers.gitlab.io/#/editor">новую версию</a> графического редактора квестов.

<img align="center" src="https://habrastorage.org/webt/hq/rt/w7/hqrtw7bbmaeiykcyynrlluvqfge.png" />
Это выглядит гораздо современнее, содержит меньше багов и, что самое главное, значительно удобнее в работе. Кроме того, web-редактор использует новый формат хранения (qmm) снимающий некоторые лимиты квестов (например, на максимальное количество параметров) и допускающий привязку медиа-элементов к сценам и переходам (раньше это приходилось делать <a href="https://rangers.fandom.com/ru/wiki/Текстовые_планетарные_квесты#AddQuest">отдельной программой</a>).

<img align="center" src="https://habrastorage.org/webt/cz/zu/c9/czzuc9e0uwxh9zxpnxlpdrwlvmu.png" />
Кстати, вот так выглядит в web-плейере сам игровой процесс.
</spoiler>
На Хабре уже <a href="https://habr.com/ru/articles/740796/">были</a> <a href="https://habr.com/ru/articles/543676/">статьи</a>, посвящённые разработке Telegram-ботов, поэтому на эту тему повторяться не буду. Исходники <a href="https://github.com/DagazProject/DagazBotV3">здесь</a>. Запускается всё в <a href="https://nodejs.org/en">Node.js</a>. В качестве базы данных используется <a href="https://www.postgresql.org/">PostgreSQL</a>.
<spoiler title="Больше подробностей">
<img align="center" src="https://habrastorage.org/webt/zy/gw/cn/zygwcnisl3s3tzuaap-1qzqplsq.png" />
Понимаю, что это может напугать, но вкратце расскажу про основные таблички. В <b>users</b> будут попадать все пользователи. Наиболее важные поля: <b>user_id</b> - идентификатор пользователя в Telegram, <b>chat_id</b> - туда будем слать сообщения, <b>lang</b> - язык (определяется автоматически, но потом можно поменять).

Сервис (приложение) может поддерживать сразу несколько Telegram-ботов, токены которых будем хранить в <b>service.token</b> (сам токен для бота можно получить у <a href="https://t.me/BotFather">BotFather</a>). Факт подключения пользователя к боту будет сохраняться в таблице <b>user_service</b>, поле <b>is_developer</b> которой будет включать некоторые полезные дополнительные команды.

Таблички <b>command</b> и <b>action</b> хранят сценарии. Это достаточно гибкий механизм для произвольного ввода/вывода, вызова хранимых процедур, REST-сервисов, а также запуска квестов. Сами квесты хранятся в <b>script</b> и привязаны к <b>service</b>. Язык квеста хранится в <b>lang</b>, благодаря чему не русскоязычные пользователи видят квесты на английском языке (которых правда сильно меньше):

<img align="center" src="https://habrastorage.org/webt/mj/by/ar/mjbyarhlcza3s7dueohnjxoxt5w.png" />
Важной табличкой является <b>user_context</b>, в которой сохраняются контексты выполнения как квестов, так и обычных команд. К ней привязывается <b>param_value</b>, в которой сохраняются значения параметров (благодаря этому квест может быть продолжен даже после перезагрузки сервиса). В свою очередь, <b>global_value</b> сохраняет значения между запусками команд и квестов (там хранится статистика запусков, побед и поражений, а также кредиты пользователей, используемые в некоторых квестах).
</spoiler>
Начать было решено с обратной связи. Действительно, к чему заморачиваться с почтой, когда под рукой есть Telegram? Конечно, каждый пользователь общается только с ботом, но что нам мешает передавать сообщения другим пользователям? Например, сообщения обычных пользователей передавать администраторам, а сообщения администраторов всем пользователям с совпадающими языковыми настройками. Конечно, помимо широковещательной рассылки, полезно дать администраторам возможность адресного ответа на какой-то вопрос пользователя:

<img align="center" src="https://habrastorage.org/webt/mi/ac/wd/miacwdqnjcs4skn9scrgwtevaeo.png" />
Попробуем разобраться, что здесь произошло:

<ol>
	<li>Администратор написал в чат сообщение "Вопрос"</li>
	<li>Поскольку администратор является пользователем с подходящей языковой настройкой, он получает продублированное сообщение...</li>
	<li>И может на него ответить средствами Telegram</li>
	<li>В результате чего получает адресный ответ на своё самое первое сообщение</li>
</ol><spoiler title="Как всё это работает?">
Прежде всего, любое сообщение в чат (если это не команда) попадает <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/app.ts#L94">сюда</a>. Далее, в зависимости от того администратор это или обычный пользователь, используются <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L448-L472">две различные схемы</a> для пересылки сообщения. Разумеется, это будут уже не те же самые сообщения и для сохранения их идентификаторов требуется отдельная таблица:

<img align="center" src="https://habrastorage.org/webt/fy/hj/xu/fyhjxu5odk8_cude0mftprahuo0.png" />
Теперь, если <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L444-L446">установлено поле</a> <b>reply_to_message</b>, мы можем <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/data-source.ts#L149-L161">найти</a> исходное сообщение и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L452">ответить</a> на него.
</spoiler>
Посмотрим как выполняется запуск квеста. Можно выполнить команду "<b>/start</b>" с указанием идентификатора квеста, передав её в чат или просто перейдя <a href="https://t.me/DagazQuestBot?start=1">по ссылке</a>.

<img align="center" src="https://habrastorage.org/webt/ll/fe/v8/llfev8uv1mdwhpn77-vubayicd4.png" />
<spoiler title="Что происходит?">
Прежде всего, <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/app.ts#L36">создаём или обновляем</a> параметры аккаунта и однократно <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/app.ts#L37">выводим текст приветствия</a> в чате, после чего переходим к обработке команды. Команда <b>/start</b> прописана в табличке <b>command</b> и содержит всего одно действие (<b>action</b>) - запуск квеста. При <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/app.ts#L88">вводе команды</a>, мы <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L501">принимаем</a> параметры командной строки, а затем <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/migration/1710502781744-sp.ts#L79-L81">создаём</a> и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L518">запускаем</a> контекст выполнения (в рамках которого создаются и изменяются параметры). 

Далее, последовательно <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L155-L378">выполняются</a> все действия, составляющие команду. После этого контекст удаляется в <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/migration/1710502781744-sp.ts#L231-L232">setNextAction</a>. Рассмотрим <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L332-L373">действие запуска квеста</a> более подробно:

<ol>
	<li>Получаем id квеста <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L334">из параметра</a> командной строки</li>
	<li>Читаем <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L336">описание скрипта</a> из таблицы <b>script</b> (здесь нам требуется имя файла)</li>
	<li>Далее <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L339">загружаем</a> файл из каталога upload (<a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L119">разбирая</a> его в процессе)</li>
	<li>Здесь же <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L120-L127">инициализируем параметры</a> (и впервые сталкиваемся с <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qm/formula/index.ts">формулами</a>)</li>
	<li><a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L345">Закрываем</a> предыдущие контексты квестов если они есть</li>
	<li>И <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L346">создаём</a> новый контекст квеста, <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L347">добавляя его в кэш</a> (теперь квест может быть продолжен даже после перезагрузки сервиса)</li>
	<li>Некоторые квесты используют специальный параметр, помеченный флагом "Деньги игрока". <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L349-L360">Читаем</a> значение этого параметра из <b>global_value</b>, используя привязки</li>
	<li><a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L361-L367">Выводим</a> текст приветствия квеста, если он есть</li>
	<li>И <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L368">наконец</a> собираем первый диалог квеста для передачи его пользователю</li>
</ol>
Следует отметить необходимость двойного кэширования. Прежде всего, разбор qm-файла - дорогостоящая операция, разобранный же квест может занимать большой объём памяти. По этой причине, бот хранит в памяти не более <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L7">пяти</a> разобранных файлов. К счастью, эти данные не изменяются после разбора, могут совместно использоваться несколькими пользователями и их выгрузка не сломает выполнение квеста, а всего лишь приводит к ещё одному дополнительному разбору.

Второй уровень - это <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L10">контексты</a>, которые надо хранить все, благо они не такие большие как сами квесты. Здесь необходимо фиксировать в БД изменения <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L67-L74">локаций</a> и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/qmhash.ts#L84-L94">параметров</a>, на тот случай, если выполнение квеста придётся продолжить после перезагрузки сервиса.
</spoiler>
Далее, выполняем квест, выбирая соответствующие пункты меню. Обратите внимание, что меню после активации одного из его пунктов удаляется, прежде всего по той причине, что меню, оставшееся в чате вне контекста его выполнения - не самая лучшая идея. Выбор меню обрабатывается как <b>callback_query</b>.

<img align="center" src="https://habrastorage.org/webt/kg/zg/zm/kgzgzmnxbdlflqgps1jght4lyl0.png" />
<spoiler title="Вы обратили внимание что образец и ключ расположены вертикально?">
Сценарий квеста пришлось отредактировать, поскольку горизонтальная расстановка не влезала в Telegram по ширине.

<img align="center" src="https://habrastorage.org/webt/xh/yf/zx/xhyfzx2rpixafx66e2y9fwiqnt0.png" />
Две локации по восемь вариантов в каждой. И это скорее правило чем исключение. Телеграм имеет свою специфику (например, не любит длинные тексты в переходах от одной локации к другой). Практически все квесты приходится редактировать, если только они не создавались под Telegram изначально.
</spoiler>
Меню переключения языка сделано чуть сложнее. Прежде всего, эта команда отображается в меню (для этого она прописана в таблице <b>command</b> с установленным флагом <b>is_visible</b>).

<img align="center" src="https://habrastorage.org/webt/ra/pf/qp/rapfqpulclx54sfnecyydpmqeng.png" />
В результате ввода команды открывается меню:

<img align="center" src="https://habrastorage.org/webt/79/mq/wv/79mqwvtfo8cmyijcpuwtxt77nce.png" />
<spoiler title="Что внутри?">
В отличии от <b>/start</b>, эта команда состоит из нескольких действий (таблица <b>action</b>):

<img align="center" src="https://habrastorage.org/webt/hv/lp/bt/hvlpbtf41elkjew1ocg7qwxqhzy.png" />
Можно заметить, что это дерево. Дочерние узлы скрипта привязаны к родительским через <b>parent_id</b>. Выполняемые узлом действия определяются значением <b>type_id</b> и обрабатываются <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L161">здесь</a>.

Значение <b>type_id=5</b> определяет меню (в поле <b>width</b> можно указать ширину, то есть количество пунктов размещаемых на одной строке). Заголовок <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/data-source.ts#L268-L285">берётся</a> из таблицы <b>localized_string</b> (обратите внимание, что он привязан к языку пользователя). Аналогичным образом из дочерних узлов <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L229">собираются</a> наименования пунктов меню. В качестве идентификаторов берутся id дочерних узлов и меню <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L245-L257">передаётся</a> пользователю.

Тип дочерних узлов <b>type_id=1</b> - это просто папка содержащая другие действия. <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/migration/1710502781744-sp.ts#L176-L193">Ищем</a> в глубину первую не папку и добираемся до <b>type_id=6</b> - вызова хранимки <b>setLang</b>. Здесь всё просто: <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/migration/1710502781744-sp.ts#L118-L128">меняем</a> значение поля <b>lang</b> в табличке <b>users</b>. Параметры вызова описываются табличкой <b>request_param</b>.

По хорошему, следовало бы ещё вывести сообщение об успешном переключении языка, а также попытаться переключить текущую локацию квеста на другой язык (если такое возможно), но это я оставил на будущее.
</spoiler>
Главная команда этого бота конечно другая: <b>/quest</b> выводит список подготовленных для загрузки квестов и обеспечивает их запуск. При этом анализируется язык пользователя. Фокус здесь в том, что эту команду можно выполнять как без параметров, так и указав имя квеста:

<img align="center" src="https://habrastorage.org/webt/mb/_2/j0/mb_2j0ukzyhdb7rrvum_8yisqmy.png" />
<spoiler title="Подробности">
Как и в случае с командой <b>/start</b>, параметр команды описан в таблице <b>command_param</b>, но если в <b>/start</b> передавался числовой идентификатор (это удобно при вызове квеста через URL), то в <b>/quest</b> передаётся строковое значение, которое может содержать имя файла либо локализованное или не локализованное имя квеста. Введённое значение передаётся в хранимку <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/migration/1710502781744-sp.ts#L446">getQuests</a>. Результат поиска сохраняется в параметр <b>menu</b>, описанный в таблице <b>response_param</b>.

<img align="center" src="https://habrastorage.org/webt/r3/4g/lf/r34glfpeini66czmzk3uhstrt2c.png" />
Если найдено более одного квеста (например при вызове команды без параметров), в <b>result_code</b> помещается значение 1 и <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L262-L294">обработчик</a> вызова хранимой процедуры <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L288">переключает</a> управление на дочерний узел, выводящий меню выбора квеста.

<img align="center" src="https://habrastorage.org/webt/db/a3/ux/dba3uxwi3d94yiqgd6vbel-hpeo.png" />
В противном случае (если дочерний узел не найден), <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L290">setNextAction</a> идёт дальше и мы попадаем на узел запуска текстового квеста (такой же, как в обработчике команды <b>/start</b>). Параметр <b>5</b>, на этот момент, уже содержит найденный ранее id квеста.
</spoiler>
Как уже упоминалось выше, отображение квестов в Telegram имеет свою специфику. Например, вряд ли имеет смысл выводить картинки в каждой локации и переходе. В некоторых случаях обойтись без картинок никак нельзя (как в квесте "<a href="https://t.me/DagazQuestBot?start=12">Дальнобойщик</a>"), но это скорее исключение чем правило.

<img align="center" src="https://habrastorage.org/webt/wj/zx/8z/wjzx8z1tnuwnzkcn03j1s1q-ohm.png" />
<spoiler title="Передаваемый ботом трафик стоит экономить">
Имеются определённые ограничения на количество сообщений передаваемых ботом за единицу времени, а тексты "Космических рейнджеров" бывают очень многословны. Помимо отказа от вывода лишних картинок имеется ещё один, менее заметный аспект, связанный с этим. Вы уже могли заметить, что при выборе пункта меню сам диалог удаляется из чата. Делать это необходимо, поскольку в противном случае в ленте будут оставаться меню не связанные с контекстом выполнения и в лучшем случае при выборе их пунктов не будет происходить ничего.

В некоторых случаях, текст этих диалогов важен и его полезно иметь перед глазами в дальнейшем. По этой причине, после удаления, текст диалога обычной локации <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L1240-L1242">выводится снова</a>, уже без меню. Но это ещё одно сообщение, которое может спровоцировать срабатывание антиспам-фильтра! Чтобы таких сообщений было меньше, тип промежуточных узлов квеста следует заменять на "пустой" (диалоги всё равно будут выводиться, но не будут дублироваться после удаления).

Если антиспам всё таки сработал, может получиться так, что очередной диалог квеста, который сервис бота будет считать уже отосланным, на самом деле не попадёт в ленту чата (и пользователь не сможет продолжить квест). Чтобы такого не происходило, все подобные отсылки оборачиваются в функцию <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L58-L84">send</a>, фиксирующую факт этой отправки, а также выполняемые после неё некоторые <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L72-L74">действия</a>. Если идентификатор переданного сообщения не был получен, сообщение будет продублировано по расписанию <a href="https://github.com/DagazProject/DagazBotV3/blob/master/src/utils.ts#L125">фоновым процессом</a>.
</spoiler>
Пользователи могут загружать свои изображения и квесты. Здесь следует понимать, что все загружаемые файлы будут переименованы:

<img align="center" src="https://habrastorage.org/webt/n4/ta/is/n4taisgg7uiqg-yesvpy8k8cfx0.png" />
Делается это для того, чтобы избежать конфликта имён файлов, загруженных разными пользователями. Исходные наименования загружаемых изображений сохраняются в привязке к пользователям и могут быть использованы в загружаемых ими квестах. Что касается самих загружаемых квестов, в общем доступе (до согласования с администратором) они не появляются, но могут быть загружены их владельцами в режиме отладки.
<spoiler title="Опции разработчика">
В тот момент когда пользователь загружает в чат свой первый сценарий квеста, он становится разработчиком (устанавливается флаг <b>is_developer</b> в таблице <b>user_service</b>). В результате, ему становится доступно несколько дополнительных полезных команд:

<ul>
	<li><b>/load file_N.qmm</b> - Загрузка сценария квеста аналогична команде <b>/start</b>, но вместо id квеста указывается имя загруженного файла сценария (после переименования). В отличии от команд <b>/start</b> и <b>/quest</b>, команда <b>/load</b> не создаёт контекст выполнения квеста в базе данных и, как следствие, не изменяет значений глобальных счётчиков пользователя (статистики) в результате выполнения квеста (подкрутить таким образом кредиты тоже не получится).</li>
	<li><b>/show id</b> - Отображает в чате идентификатор текущей локации квеста.</li>
	<li><b>/set pN V</b> - Присваивает заданное значение параметру квеста. Например, если кредиты внутри квеста сохраняются в параметре <b>p1</b>, улучшить благосостояние поможет команда "<b>/set p1 10000</b>".</li>
	<li><b>/calc formula</b> - Очень полезная команда, вычисляющая значение формул квеста. Текущие значения параметров учитываются, поэтому для просмотра значения параметра <b>p1</b>, например, достаточно выполнить команду "<b>/calc [p1]</b>", а формулы из редактора квестов можно просто копипастить в чат.</li>
</ul>
</spoiler>
Помимо этого, есть ещё одна возможность, доступная всем пользователям. Команда <b>/save</b> может быть полезна для прохождения сложных квестов.

<img align="center" src="https://habrastorage.org/webt/gv/gl/wj/gvglwj7fguzwx8oee_e5zt12twa.png" />
Сохраняем qms-файл себе на диск, а потом, если квест пошёл как-то не так, кидаем его обратно в чат:

<img align="center" src="https://habrastorage.org/webt/pw/vt/l8/pwvtl8dpi3fssjc8ot_dflqbuyi.png" />
Важный нюанс заключается в том, что загруженный таким образом квест не влияет на статистику пользователя (очки и кредиты таким образом накрутить невозможно).
<spoiler title="Мой личный рейтинг квестов">
Не все квесты одинаково удачны и интересны. Хочу порекомендовать вашему вниманию несколько, понравившихся мне особенно:

<a href="https://t.me/DagazQuestBot?start=28"><img align="left" src="https://habrastorage.org/webt/vb/ag/4c/vbag4cjlpc0lhzpj8snm--k1evs.png" /></a><a href="https://t.me/DagazQuestBot?start=28">ПроПролог</a> - Невероятно атмосферный квест воссоздающий атмосферу "Космических рейнджеров". Здесь есть и борьба с ботами и сражения с пиратами и даже планетарные квесты. Проходится не просто и далеко не с первого раза. Обещаю массу положительных эмоций.

<a href="https://t.me/DagazQuestBot?start=11"><img align="right" src="https://habrastorage.org/webt/lh/vw/fn/lhvwfnzuewrzx4smkxsxcphup58.png" /></a><a href="https://t.me/DagazQuestBot?start=11">Главный редактор</a> - Также очень атмосферный квест, посвящённый непростой жизни главного редактора компьютерного журнала в глубоко тоталитарном обществе. Квест очень объёмный, но при этом обильно приправленный юмором. Верстайте журнал, распределяйте тираж и, самое главное, постарайтесь не упасть в глазах совета цензоров!

<a href="https://t.me/DagazQuestBot?start=27"><img align="left" src="https://habrastorage.org/webt/5s/6l/kr/5s6lkrf6ixdcf7klnotspxjuuaa.png" /></a><a href="https://t.me/DagazQuestBot?start=27">Злой гений</a> - Если вы чувствуете себя достаточно гадким, примерьте роль планетарного диктатора. Личная армия миньонов, регулярные рейды правительственных войск, а также визиты наёмных убийц обильно украсят ваше существование.

<a href="https://t.me/DagazQuestBot?start=33"><img align="right" src="https://habrastorage.org/webt/2q/g4/ze/2qg4ze6gcgqhpi_ke93lar6pbrq.png" /></a><a href="https://t.me/DagazQuestBot?start=33">Мастер Иике-Бааны</a> - Пожалуй, самый сложный квест в "Космических рейнджерах". Это практически полноценная ролевая игра с оригинальной магической системой. Убивайте монстров и сразитесь с верховным магом. Только таким образом вы сможете вызволить господина Дуу-Рака из пучин виртуального мира.

<a href="https://t.me/DagazQuestBot?start=9"><img align="left" src="https://habrastorage.org/webt/5w/f1/b4/5wf1b425duxjwtnbekcyociisv0.png" /></a><a href="https://t.me/DagazQuestBot?start=9">Лыжный курорт</a> - отличный экономический симулятор. <a href="https://t.me/DagazQuestBot?start=10">Имеется англоязычная версия</a>. Развивайте инфраструктуру и постарайтесь не прогореть. <a href="https://t.me/DagazQuestBot?start=21">Космолинии</a> - альтернатива на случай если космос нравится вам больше чем лыжи. Тоже с <a href="https://t.me/DagazQuestBot?start=22">английской версией</a>.

<a href="https://t.me/DagazQuestBot?start=12"><img align="right" src="https://habrastorage.org/webt/ri/b3/vo/rib3voyhwhmpzf40ebvimqpailm.png" /></a><a href="https://t.me/DagazQuestBot?start=12">Дальнобойщик</a> - Выкупаем задолжавшего бандитам Ролана, зарабатывая на жизнь извозом на грузовичке. Не забываем исследовать местность, грузовичок можно модернизировать! Подвозим попутчиков. Периодически сталкиваемся с бандитами и следим за показателями здоровья! Английская версия <a href="https://t.me/DagazQuestBot?start=13">в наличии</a>.

<a href="https://t.me/DagazQuestBot?start=16"><img align="left" src="https://habrastorage.org/webt/5h/z8/0f/5hz80f7fndbsqovajhcq7j6blnu.png" /></a><a href="https://t.me/DagazQuestBot?start=16">Колонизация</a> - Для поклонников игры "<a href="https://ru.wikipedia.org/wiki/Civilization_(серия_игр)">Цивилизация"</a>. Я не шучу, это полноценная стратегическая игра! Стройте здания, завоёвывайте варваров и готовьтесь к прилёту комиссии (космопорт вам придётся построить самостоятельно).

<a href="https://t.me/DagazQuestBot?start=14"><img align="right" src="https://habrastorage.org/webt/bc/0y/7-/bc0y7-ojjc5mfmf9df7jqv19rcs.png" /></a><a href="https://t.me/DagazQuestBot?start=14">Цитадели</a> - Ещё одна стратежка (но эта больше похожа на "<a href="https://ru.wikipedia.org/wiki/Magic:_The_Gathering">Magic: The Gathering")</a>. Собираем колоду, строим базу, собираем ресурсы (энергия, металл, электроника), ломаем базу противника. Если хочется посоревноваться в чём-нибудь попроще, то к вашим услугам "<a href="https://t.me/DagazQuestBot?start=7">Роботы</a>" (для которых имеется <a href="https://t.me/DagazQuestBot?start=8">английская версия)</a>.

<a href="https://t.me/DagazQuestBot?start=20"><img align="left" src="https://habrastorage.org/webt/9m/kn/zu/9mknzurlc1usptgx8gqwwtppmui.png" /></a><a href="https://t.me/DagazQuestBot?start=20">Гайднет</a> - Для тех кто хочет почувствовать себя хакером. Вообще, это такой динамический лабиринт, но сделан очень атмосферно. Как раз тот случай, когда легче запустить и посмотреть самому чем пытаться всё это объяснить.

Разумеется, это далеко не всё. Есть куча мелких квестов, в которых можно поиграть в сложную <a href="https://t.me/DagazQuestBot?start=3">малокскую игру</a> (есть на <a href="https://t.me/DagazQuestBot?start=4">английском</a>), очень маленькую <a href="https://t.me/DagazQuestBot?start=17">манкалу</a>, попытаться <a href="https://t.me/DagazQuestBot?start=18">вскрыть сейф</a> из "<a href="https://ru.wikipedia.org/wiki/Братья_Колобки">Братьев Пилотов</a>", поперекладывать "<a href="https://t.me/DagazQuestBot?start=29">Ханойские башни</a>" и даже поиграть в <a href="https://t.me/DagazQuestBot?start=34">домино</a>. И разумеется, квесты будут ещё добавляться.
<spoiler title="Кстати, для Ханойских башен пришлось придумать новый тэг">
<img align="center" src="https://habrastorage.org/webt/dq/xv/yj/dqxvyjvj6xpicgjq9wv3xtcqagm.png" />
Тэг <b>nobr</b> в web-реализации пока не поддерживается. Он был добавлен для упрощения кодирования отображения параметров и убирает следующий перевод строки, склеивая строки. В результате получается следующее:

<a href="https://t.me/DagazQuestBot?start=29">
<img align="center" src="https://habrastorage.org/webt/ns/7y/sa/ns7ysa6eytgbbctuinmeszgtg2u.png" /></a>
</spoiler>
</spoiler>
Что дальше? Текстовые квесты "Космических рейнджеров" в Telegram - это уже прекрасно, но что если дать возможность играть в <a href="https://t.me/DagazQuestBot?start=14">Цитадели</a> или в тех же <a href="https://t.me/DagazQuestBot?start=7">Роботов</a> не против квестов, а друг с другом? Организовать, своего рода, квестовую арену? Разумеется, сценарии придётся полностью переделывать. Что касается самого движка...
<spoiler title="На мой взгляд, достаточно всего двух доработок">
Вот <a href="https://github.com/DagazProject/DagazBotV3/blob/master/upload/spock.qmm">здесь</a>, реализован прототип простейшей соревновательной игры для двух человек. Это расширенная версия игры "<a href="https://ru.wikipedia.org/wiki/Камень,_ножницы,_бумага">Камень, Ножницы, Бумага</a>" из "<a href="https://ru.wikipedia.org/wiki/Теория_Большого_взрыва_(телесериал)">Теории большого взрыва</a>". Можно заметить обработку двух переходов специального вида.

<img align="center" src="https://habrastorage.org/webt/sy/hz/wt/syhzwtzeigjysfetrhywcqzlod0.png" />
Переход будет выполняться автоматически, как и при отсутствии заголовка. Попутно (при проходе через <b>!session</b>) будет производиться подключение пользователя к сессии.

<img align="center" src="https://habrastorage.org/webt/wz/vb/5h/wzvb5hm3fd3eerkhwwx-xsdzb_s.png" />
Первый пользователь, прошедший через <b>!session</b>, создаст сессию (в таблице <b>session</b>), а следующий к ней подключится (<b>user_session</b>). В сессии могут участвовать и более двух игроков (как например, в игре <a href="https://ru.wikipedia.org/wiki/Перудо">Перудо</a>). Обратите внимание, что к одной записи <b>session_type</b> могут быть подключены несколько скриптов. Это позволит соревноваться игрокам с различными языковыми настройками.

Минимальное и максимальное количество игроков задаётся в <b>session_type</b>. Там же определяются параметры, через которые будет осуществляться взаимодействие. Прежде всего, это <b>start_param</b>, определяющий номер параметра, с которого будут начинаться блоки синхронизации. Поле <b>param_count</b> будет задавать размер блока (количество параметров передаваемых каждым пользователем). Нулевой блок предлагается использовать для задания исходящих значений параметров.

<img align="center" src="https://habrastorage.org/webt/-3/rs/wo/-3rswovaogwog3b5g1hhnrzqhdw.png" />
Здесь начинается магия. Прежде всего, это единственное место, в котором игроки ждут друг друга (в <b>!session</b> также может указываться таймаут на подключение в миллисекундах, но там ожидание производиться не будет). В первый раз выполнив <b>!wait</b>, игрок будет ожидать наполнения сессии (в соответствии с настройками), в течении суммарного таймаута обеих команд.

Если наполнения сессии дождаться не удастся - ничего страшного, <b>!wait</b> сбросит параметр индекса игрока (заданный в <b>session_type.index_param</b>). В нашем случае, это параметр <b>p1</b>. После чего, каждый игрок продолжит игру независимо друг от друга, уже против бота:

<img align="center" src="https://habrastorage.org/webt/tq/gs/tx/tqgstxhkmj4hpyapg7qgesfnsak.png" />
Что произойдёт если ожидание всех игроков завершится удачно? Перед выполнением <b>!wait</b>, каждый из игроков заполнит исходящие параметры в нулевом блоке. Задача <b>!wait</b> - переложить параметры каждого игрока в соответствующий по счёту блок синхронизации, после чего "пробудить" всех игроков, продолжив квест. Для дополнительного удобства, определяются строковые подстановки <b><1></b>, <b><2></b> и т.д., заменяющиеся именами соответствующих игроков.

<img align="center" src="https://habrastorage.org/webt/a-/mx/px/a-mxpxekzjp8up3gaqiotq-t5as.png" />
</spoiler>
В общем, как концепт, это вроде <a href="https://t.me/DagazQuestBot?start=1001">работает</a>, но работы по отладке предстоит ещё очень много (и отлаживаться с двух сессий в Телеграмме до чёртиков неудобно). Таймауты пока не реализованы и с партнёром надо предварительно договариваться, чтобы он присоединился между "Конечно, я приму участие в игре" и самым первым ходом (Камень, Ножницы, Бумага, Ящерица или Спок). В противном случае, противником будет назначен бот.

<a href="https://t.me/DagazQuestBot?start=1001">
<img align="center" src="https://habrastorage.org/webt/qm/y_/2h/qmy_2h0xvwr8rvcgk9fwmr0-aks.png" /></a>

Такой вот задел на будущее...
</cut>

DagazBot — Хранитель ключей и мётел

<a href="https://t.me/DagazGamesBot"><img align="left" src="https://habrastorage.org/webt/c_/dl/gn/c_dlgndgzlsjcpia4ztpeogwc9w.jpeg" /></a>История проекта <a href="https://dagazproject.github.io/index-map.html">Dagaz</a> прошла у вас перед глазами. Когда я только <a href="https://habr.com/ru/articles/211100">начинал</a> писать про <a href="https://www.zillions-of-games.com/">Zillions</a>, главным возражением было то, что платформа эта платная и запускается только под Windows. Появился <a href="https://habr.com/ru/articles/320474/">Dagaz</a> - полностью бесплатный проект с <a href="https://github.com/DagazProject/DagazProject.github.io/blob/master/LICENSE.txt">открытой лицензией</a> и общедоступным <a href="https://github.com/DagazProject/DagazProject.github.io">исходным кодом</a>, игры которого можно запускать из браузера, даже на мобилках. Блокирующим фактором стало отсутствие адекватных ботов. Пришлось осваивать <a href="https://habr.com/ru/articles/486082/">GarboChess</a> и разрабатывать <a href="https://habr.com/ru/articles/523714/">DagazServer</a>, на котором игроки могли бы играть по сети друг с другом. Это стало большим шагом вперёд, но на сервере требуется авторизация, а логины и пароли - это как раз то, что забывается легче всего. Счастлив сообщить, что теперь их запоминать не надо.
<cut>
Разумеется, существуют разнообразные схемы восстановления забытых паролей с использованием почты и SMS, но я решил с ними не связываться. В основном потому, что пользователи не очень-то любят вводить на сайтах свои почтовые адреса и номера телефонов, справедливо опасаясь спама. Есть способ лучше! Заботу о сохранении учётных данных возьмёт на себя <a href="https://t.me/DagazGamesBot">бот</a>.

Напомню, какой технологический стек я использую. UI <a href="https://games.dtco.ru/map/0">сервера</a> разработан с использованием <a href="https://angular.io/">Angular</a>, а бакенд построен на фреймворке <a href="https://nestjs.com/">NestJS</a> и использует для хранения данных СУБД <a href="https://www.postgresql.org/">PostgreSQL</a>. <a href="https://github.com/DagazProject/DagazBotV2">DagazBot</a> разработан в том же ключе, разве что Nest не используется. Всё запускается под <a href="https://nodejs.org/en">Node.js</a>. Вопрос разработки Telegram-бота на этой платформе уже разбирался на Хабре <a href="https://habr.com/ru/articles/740796/">ранее</a>, поэтому подробно останавливаться на этом не буду, сосредоточившись на специфике своего проекта. Итак, что я хотел получить в результате:

<ul>
	<li>Компактное и не требовательное к ресурсам сервера приложение</li>
	<li>Надёжное хранение учётных данных для доступа на DagazServer</li>
	<li>Простая авторизация на DagazServer не требующая запоминания логинов и паролей</li>
	<li>Возможность работы с несколькими учётными записями DagazServer</li>
	<li>Уведомление пользователей об играх на сервере, ожидающих их хода</li>
	<li>Средство коммуникации пользователей с администраторами бота</li>
</ul>
Требование компактности заставило отказаться от иcпользования NestJS и последующего прикручивания UI на Angular-е в пользу простейшего <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js">приложения</a> на JavaScript. Интеграция с DagazServer осуществляется по REST, с использованием библиотеки <a href="https://www.npmjs.com/package/axios">Axios</a>. База данных у бота своя, отдельная от сервера, но тоже на PostgreSQL. Зависимости проекта <a href="https://github.com/DagazProject/DagazBotV2/blob/master/package.json#L12">следующие</a>. Упрощённая схема данных выглядит как-то так:

<img align="center" src="https://habrastorage.org/webt/po/pt/ks/poptksbctzsbdiv8gak0vxbnbgu.png" />
<spoiler title="Вкратце о назначении таблиц">
<b>server</b> - Здесь перечислены сервера, с которыми работает бот: Telegram и DagazServer. Тип сервера определяется словарём <b>server_type</b>. В <b>server_option</b> хранится ключ для подключения бота к Telegram (разумеется, в <a href="https://github.com/DagazProject/DagazBot/blob/master/src/migration/1693392897178-init.ts#L14">репозитории</a> и <a href="https://github.com/DagazProject/DagazBotV2/blob/master/sql/dagaz-bot.sql">дампе</a> этого ключа нет). Также, в <a href="https://github.com/DagazProject/DagazBot/blob/master/src/migration/1693392897178-init.ts#L12">записи</a> для DagazServer есть два важных поля: в <b>api</b> хранится URL для интеграции с сервером, а <b>url</b> используется для переадресации запросов на сервер.

<b>users</b> (множественное число, чтобы не конфликтовать с зарезервированным словом PostgreSQL) - учётные записи пользователей в Telegram. Не повторяйте моих ошибок, поле <b>from.username</b> из сообщений, хотя и является уникальным, ключём служить не может, поскольку в профилях пользователей Telegram присутствует далеко не всегда. Когда я это понял, в БД уже было несколько пользователей и мне пришлось <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L150">подставлять</a> <b>from.id</b> при отсутствии <b>username</b>-а. Кстати, к сведению параноиков: номер телефона, на который заведён Telegram в бот <b>не</b> передаётся!

<b>account</b> - Учётные записи на DagazServer (как я уже сказал, у одного Telegram-пользователя их может быть несколько). Вся конкретика с логинами и паролями хранится в <b>user_param</b>, там же сохраняются временные переменные, необходимые для работы скриптов, типы которых перечислены в <b>param_type</b>.

<b>script</b> - команды, которые можно выполнять на сервере (связь с сервером через табличку <b>server_script</b>). Составные кирпичики этих скриптов, <b>action</b> - отдельные действия, такие как: ввод и вывод строк, меню, обращение к хранимым процедурам в БД и REST-запросы.

<b>common_context</b> (не придумал лучшего названия) - та сущность, на которой выполняются <b>action</b>-ы. Первоначально всё это хранилось в <b>users</b>, но выяснилось, что могут быть кейсы, когда скрипты должны выполняться не на <b>user</b>-ах, а на <b>account</b>-ах. В <b>command_queue</b> очередь входящих команд (пока одна не отработала, другая не начнётся).
</spoiler>
Вся работа с БД и REST вынесена в <a href="https://github.com/DagazProject/DagazBotV2/blob/master/service.js">service.js</a>, в <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js">index.js</a> взаимодействие с Telegram. Обратите внимание на <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L73">deleteMessage</a>. Из чата удаляются использованные меню (поскольку повторный выбор их пунктов ни к чему хорошему не приведёт), а также введённые пароли (или любые другие параметры, тип которых помечен как <b>is_hidden</b>). Помимо <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L128">callback-ов</a>, отрабатывающих получение от Telegam текста и пунктов меню, имеется две функции, периодически выполняющихся по таймеру.

Функция <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L110">run</a> выполняется достаточно часто, чтобы обеспечить приемлемое время отклика бота, но если нет данных для обработки её выполнение приостанавливается. Функция <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L110">schedule</a> выполняется реже и запрашивает с DagazServer-а данные об ожидании ответного хода. Получение данных от Telegram (и от DagazServer) инициирует возобновление выполнения <b>run</b>.

<spoiler title="В этом месте я словил состояние гонок">
Асинхронные конструкции async/await создают иллюзию последовательного выполнения однопоточного кода. На самом деле это не так, любой await (при обращении к БД, например) приостанавливает выполнение и функция run может быть вызвана повторно. В этом случае начинаются всякие труднообъяснимые чудеса и чтобы их не было в код добавлен флаг <a href="https://github.com/DagazProject/DagazBotV2/blob/master/index.js#L14">isProcessing</a>.
</spoiler>
Разумеется, в <a href="https://github.com/DagazProject/DagazServer">DagazServer</a> были добавлены новые эндпойнты, а чтобы работал редирект с авторизацией пришлось доработать и <a href="https://github.com/DagazProject/DagazServerUI">UI</a> тоже. DagazServer создаёт одноразовые <a href="https://github.com/DagazProject/DagazServer/blob/master/src/entity/tickets.ts">тикеты</a> по запросу бота (поскольку оба они выполняются на одном сервере, пароли никуда дальше loopback-а не улетают). В app-routing был добавлен новый <a href="https://github.com/DagazProject/DagazServerUI/blob/master/src/app/app-routing.module.ts#L16">маршрут</a>, а в компонент авторизации дополнительный <a href="https://github.com/DagazProject/DagazServerUI/blob/master/src/app/auth/auth.component.ts#L35">код</a>, использующий тикет, полученный из url, для авторизации.

<spoiler title="Как всем этим пользоваться">
Заходим в <a href="https://t.me/DagazGamesBot">бот</a> и жмём кнопку 'START':

<img align="center" src="https://habrastorage.org/webt/vd/mf/qt/vdmfqtekuo_uvrmzpaqfgvh80j0.jpeg" />
Выбираем подключение к учётной записи DagazServer или создание новой (если что-то пойдёт не так, не страшно, команду '/start' всегда можно будет вызвать позднее через меню).

<img align="center" src="https://habrastorage.org/webt/ka/dr/jf/kadrjfbwhpt-ilyn1isgifrz28u.jpeg" />
Далее бот запрашивает логин, пароль и EMail, причём пароль удаляется из чата сразу же после ввода. Для входа на DagazServer выполните команду '/enter':

<img align="center" src="https://habrastorage.org/webt/mg/sk/nb/mgsknb_yrrcy7kacmou6pf-crf8.jpeg" />
... и просто перейдите по ссылке. Похожие ссылки бот будет присылать, по собственной инициативе, для входа в партии, ожидающие вашего хода.
</spoiler>
Отдельно стоит упомянуть о переписке администраторов с пользователями. Любое сообщение администратора ретранслируется всем пользователям имеющим тот же язык локали, а сообщения пользователей передаются всем администраторам. Пока что обрабатываются только текстовые сообщения, но есть возможность ответа на сообщение (и над её реализацией пришлось поломать голову).

<img align="center" src="https://habrastorage.org/webt/4k/p1/ij/4kp1ij6voov-k96nn1m5grnvv8o.png" />
Любое сообщение в чат бота (<b>message</b>) ретранслируется нескольким получателям. <b>Id</b> этих сообщений фиксируются в таблице <b>client_message</b> и ответ будет осуществляться на эти сообщения. Получив такой ответ, надо найти <b>id</b> сообщения инициировавшего то сообщение, на которое выполнен ответ и отвечать уже на него. Сейчас всё выглядит довольно просто, но я потратил около получаса, чтобы отладить это. 

Итак, я разработал <a href="https://t.me/DagazGamesBot">бота</a>, облегчающего жизнь пользователям <a href="https://games.dtco.ru/">DagazServer</a>-а и поделился с вами историей его создания. Разумеется, я не собираюсь останавливаться на достигнутом и буду расширять его функциональность, но это всё уже в следующем году, а пока...

<i><b>Всех с наступающим Новым Годом!</b></i>
</cut>

Hex: Мастерим бота

<a href="https://dagazproject.github.io/arrange/hex-advisor-board.htm?turn=0;&setup=92/92/4a5A/6A1a2/3A2a2a1/3B6/2bAaA4/3Aa6/2DaA3/1e5/2A8-w"><img align="left" src="https://habrastorage.org/webt/lm/8u/to/lm8utotsmphixvl9yxlrkp1j27y.png" /></a><b><i>— Стало быть, эта штуковина только выглядит так, будто умеет думать? — Э… да.
— А на самом деле не думает? — Э… нет.
— То есть просто создаёт впечатление, будто бы думает, а на самом деле это всё показуха? 
— Э… да. — Ну точь-в-точь как все мы.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Терри Пратчетт "<a href="https://ru.wikipedia.org/wiki/Санта-Хрякус">Санта-Хрякус</a>"
</i></b>
Триумфальные победы <a href="https://ru.wikipedia.org/wiki/AlphaGo">AlphaGo</a> (и впоследствии <a href="https://ru.wikipedia.org/wiki/AlphaZero">AlphaZero</a>) всколыхнули интерес общественности как к нейросетям, так и к настольным играм. Конечно, <a href="https://habr.com/ru/company/meanotek/blog/690668/">есть люди</a>, которые считают, что AlphaZero "побеждает нечестно", поскольку на самом деле учится не совсем с нуля, а использует поиск <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a>, в дополнение к тому, что ему советует нейросеть (говоря серьёзно, использование языковых моделей, в применении к настольным играм, выглядит интригующим и я желаю всяческих успехов в этом направлении), но хочется поэкспериментировать с чем-то не требующим грандиозных вычислительных мощностей и получить на выходе что-то, пусть и не играющее "на уровне Бога", но вполне пригодное для того чтобы играть с ним было интересно. 

Мне важен результат и я готов использовать <a href="https://ru.wikipedia.org/wiki/Минимакс">минимакс</a>, Монте-Карло или даже нейросети, лишь бы добиться хоть какого-то успеха (особенно с учётом некоторых ограничений накладываемых JavaScript на производительность, по сравнению с компилируемыми языками и массовым использованием <a href="https://ru.wikipedia.org/wiki/Графический_процессор">GPU</a>). Разумеется, начинать эксперименты с <a href="https://ru.wikipedia.org/wiki/Го">Го</a> несколько самонадеянно. К счастью, это не проблема. Я знаю <a href="https://games.dtco.ru/map">много</a> других игр.
<cut>
Игра "<a href="https://ru.wikipedia.org/wiki/Гекс">Гекс</a>", независимо придуманная двумя известными математиками, <a href="https://en.wikipedia.org/wiki/Piet_Hein_(scientist)">Питом Хейном</a> и <a href="https://en.wikipedia.org/wiki/John_Forbes_Nash_Jr.">Джоном Нэшем</a> в 40-ых годах прошлого века, выглядит достойным кандидатом для экспериментов. Правила очень простые: игроки по очереди ставят по одному камню своего цвета на пустые поля доски. Для победы необходимо соединить противоположные стороны доски непрерывной цепочкой камней своего цвета. В целях компенсации преимущества первого хода, используется "правило пирога": второй игрок может сменить цвет, сразу же после выполнения в игре самого первого хода.

<a href="https://games.dtco.ru/dagaz/hex.html?sid=9840">
<img align="center" src="https://habrastorage.org/webt/sz/eb/kp/szebkputiey6vs9lmtqy-2eqvvs.png" /></a>
Эта игра словно предназначена для машинного обучения. Камни, поставленные на доску, впоследствии не перемещаются и не убираются с доски, что ограничивает максимальную продолжительность партии. Кроме того, довольно очевидно, что один из игроков обязательно победит, а поскольку цели игроков исключают друг друга, никакие ничьи в игре невозможны.

В то же время, тактика игры вовсе <a href="https://trmph.com/hexwiki/Basic_strategy_guide.html">не тривиальна</a>. Прежде всего, как и в Го, в Гексе существуют "хорошие формы". Речь идёт о неразрезаемости. Конечно, если мы играем вплотную, камень к камню, разрезать такое соединение нельзя, но соединяясь таким образом, мы продвигаемся по доске слишком медленно. При размещении камней по диагонали, продвижение идёт гораздо быстрее, без какого либо ущерба надёжности. Если удастся соединить неразрезаемыми формами обе свои стороны, мы победили!

<img align="center" src="https://habrastorage.org/webt/to/_y/fv/to_yfv_pqmocywfhybbxv3-m058.png" />
Если конечно не забывать ставить камень в парную точку, при попытке разрезания формы противником. Соединение по диагонали ("мост") самая простая и чаще всего используемая форма. Вообще же, известных форм <a href="https://www.drking.org.uk/hexagons/hex/templates.html">довольно много</a>. Кроме того, как показывает практика, в этой игре гораздо плодотворнее думать о том как не дать противнику соединиться, чем пытаться соединить свои стороны самому. Если удастся помешать победить противнику, победа никуда не уйдёт. Теперь, когда мы немного разобрались с тактикой, вот вам задачка от <a href="https://www.amazon.com/Hex-Strategy-Making-Right-Connections/dp/1568811179 ">Камерона Брауна</a>:

<spoiler title="Ход белых">
<img align="center" src="https://habrastorage.org/webt/mv/7w/yv/mv7wyvn8lrxjoc1207lq7fbic14.png" />

<spoiler title="Решение">
<img align="center" src="https://habrastorage.org/webt/ad/nn/b0/adnnb0gorx-7k9d08ftori-k06m.png" />
Начинаем с попытки разрезания моста (11). Чёрные отвечают вполне закономерно и ход может показаться бесполезным, но это не так.

<img align="center" src="https://habrastorage.org/webt/8m/5o/id/8m5oidslgiwrtuvl_tczconglzm.png" />
Прорываемся сквозь строй белых (13). У чёрных есть отличный ответ и попытка была бы обречена на неудачу, если бы не предыдущий ход. Соединяемся (15):
<img align="center" src="https://habrastorage.org/webt/d1/ya/di/d1yadicncdq4j6fq_7wxluy1u8g.png" />
и победа у белых в кармане...
</spoiler>
</spoiler>
Cтоит сказать о том, почему <a href="https://www.chessprogramming.org/Main_Page">алгоритмы</a>, столь хорошо зарекомендовавшие себя в Шахматах, для Гекса малоприменимы. Прежде всего, коэффициент ветвления дерева состояний в игре Гекс очень высок. Если в Шахматах, из начальной позиции, доступно всего 20 ходов, то в Гексе, на доске 11x11, их более сотни. Может показаться что разница не так велика, но при углублении перебора мы сталкиваемся со степенной функцией.

Вторая причина заключается в отсутствии удобной оценочной функции. В Шахматах, в первом приближении, оценка сводится к подсчёту <a href="https://www.chessprogramming.org/Material">материала</a> (фигур на доске). Это очень быстро и хорошо работает, поскольку значение функции оценки монотонно и достаточно плавно увеличивается, по мере приближения игрока к победе. В Гексе, как и в Го, отдельные камни на доске не имеют значения. Важно их взаимное расположение. В результате, поскольку у нас нет оценочной функции, мы не можем останавливать перебор на какой-то фиксированной глубине, как это делается в <a href="https://www.chessprogramming.org/Iterative_Deepening">шахматных алгоритмах</a>.

<spoiler title="Строго говоря, это не совсем так">
Ещё в 1950-ом году, <a href="https://en.wikipedia.org/wiki/Claude_Shannon">Клод Шеннон</a> и <a href="https://en.wikipedia.org/wiki/Edward_F._Moore">Эдвард Мур</a> сконструировали аналоговую машину, довольно неплохо игравшую в Гекс. Машина представляла собой сеть сопротивлений с выключателями в ячейках доски. Ход человека размыкал электрические цепи, а измерение напряжения на отдельных узлах сети (визуализируемое простыми электрическими лампочками) подсказывало лучший ответный ход.

<a href="https://www.researchgate.net/publication/228909062_The_machine_intelligence_Hex_project"><img align="center" src="https://habrastorage.org/webt/dl/uy/1i/dluy1iq4yoxdyciudgcuaad0fbi.png" /></a>
Я <a href="https://github.com/GlukKazan/HexAuto/blob/master/garbo-ai.js">экспериментировал</a> с этим, <a href="https://github.com/GlukKazan/HexAuto/blob/master/graph.js">вычисляя</a> максимальный поток в графе. К сожалению, успеха на этом направлении добиться не удалось. Такая оценка ресурсозатратна сама по себе, а высокий коэффициент ветвления буквально свёл на нет все усилия. За 10 секунд перебора мне удавалось углубиться всего на 2 полухода, чего совершенно недостаточно для того чтобы начали работать какие либо оптимизации <a href="https://www.chessprogramming.org/Alpha-Beta">альфа-бета отсечения</a>. Возможно это работало бы в нейтивных сборках на C++, но для JavaScript этот путь, по всей видимости, закрыт.
</spoiler>
К счастью, при использовании метода <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a>, этого и не требуется. Суть подхода заключается в том, что симуляция игры каждый раз ведётся до победы одного из игроков. При этом, все допустимые ходы из начальной позиции и все ответы противника проверяются полностью, а последующие ходы выбираются случайно. Количество просмотров и количество побед для каждого хода из начальной позиции фиксируются. Очевидно, что при таком подходе вычислять оценочную функцию не требуется, но возникает другой вопрос: в соответствии с каким критерием выбирать начальные ходы, чтобы максимально исследовать наилучшие ходы, с одной стороны и при этом не забывать о всех остальных ходах? Решению этого вопроса посвящена знаменитая "<a href="https://habr.com/ru/company/surfingbird/blog/168611/">задача о многоруком бандите</a>".

<img align="center" src="https://habrastorage.org/webt/ia/kk/5w/iakk5wx-9esejgn35-9qh15lwma.png" />
Здесь <b>w[i]</b> - количество побед при выборе <b>i</b>-го хода, <b>n[i]</b> - количество проверок хода, а <b>N</b> - общее количество симуляций. Коэффициент <b>c</b> подбирается экспериментально и определяет насколько значима разведка ещё не исследованных ходов по сравнению с более глубоким исследованием ходов, обеспечивающих большее количество побед. По завершении всех симуляций (или когда закончится время на обдумывание хода) выбирается ход с наибольшим количеством проверок (ход с наибольшим количеством побед может оказаться просто недостаточно исследованным). Можно ли как-то улучшить этот алгоритм? Конечно.

<spoiler title="И это приводит нас к нейросетям">
Как я уже сказал, допустимых правилами ходов в Гексе много. Особенно в начале игры, когда это действительно важно. Конечно, <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">MCTS</a> должен просмотреть их все, но небольшая подсказка поможет сконцентрироваться на наиболее перспективных ходах. Как отличить хорошие ходы от плохих? Прежде всего, нельзя допускать разрезания мостов. Это должно работать даже не как AI, а скорее на уровне <a href="https://github.com/GlukKazan/HexBotV2/blob/master/forced.js">инстинктов</a>.

Далее, мы можем захотеть сделать игру нашего бота более похожей на то, как играют люди. Это просто - надо взять достаточно большую <a href="http://hex.kosmanor.com/hex-bin/board/">базу данных</a> игр людей друг с другом, и обучить <a href="https://github.com/GlukKazan/HexFit/blob/master/model.js">нейросеть</a> на её основе. Обученная модель будет предсказывать наиболее вероятные ходы из той или иной позиции. Полученные вероятности <b>Q[i]</b> называются <a href="https://ru.wikipedia.org/wiki/Априорная_вероятность">априорными</a>. Просто добавим их к нашему <a href="https://github.com/GlukKazan/HexBotV2/blob/master/ai.js#L17">критерию</a> выбора в качестве дополнительного слагаемого, не забыв поделить на <b>N</b>, для того чтобы обеспечить уменьшение их влияния, по мере получения результатов симуляций.

<img align="center" src="https://habrastorage.org/webt/xq/05/1a/xq051aicnljvctprfkga3soezt0.png" />
Архитектура модели почерпнута из замечательной <a href="https://www.manning.com/books/deep-learning-and-the-game-of-go">книги</a>, посвященной использованию нейросетей в применении к игре <a href="https://ru.wikipedia.org/wiki/Го">Го</a>. Несколько свёрточных слоёв определяют наличие на доске базовых паттернов, после чего плотные слои формируют матрицу априорных вероятностей для возможных ходов. Поскольку речь идёт о вероятностях и выборе одного хода из нескольких возможных, <a href="https://js.tensorflow.org/api/latest/#layers.softmax">softmax</a> используется в качестве функции активации в последнем слое, а <a href="https://ru.wikipedia.org/wiki/Перекрёстная_энтропия">categoricalCrossentropy</a> определяет функцию потерь. Функция активации <a href="https://js.tensorflow.org/api/latest/#layers.reLU">relu</a>, в промежуточных слоях, помогает бороться с возможными проблемами <a href="https://ru.wikipedia.org/wiki/Переобучение">переобучения</a> посредством <a href="https://ru.wikipedia.org/wiki/Регуляризация_(математика)">регуляризации</a>.

Потребовалось несколько суток для получения исходных <a href="https://github.com/GlukKazan/HexExtract/blob/master/hex.zip">данных</a>, после чего выяснилось, что подавляющее число игр велось на доске 10x10. Впрочем, 15255 игр, для первичного обучения модели, оказалось вполне достаточно. Ещё один важный момент: данные для обучения крайне желательно перемешивать таким образом, чтобы позиции относящиеся к одной и той же игре не следовали друг за другом (и не попадали таким образом в один пакет обучения). Всякого рода сортировками я предпочитаю заниматься внутри базы данных. Просто <a href="https://github.com/GlukKazan/HexLoader">выгружаем</a> результат разбора игр, добавляя к каждой строке случайное число, потом сортируем и выгружаем в <a href="https://ru.wikipedia.org/wiki/CSV">csv</a> для последующего <a href="https://github.com/GlukKazan/HexFitV2">обучения</a>. 

<spoiler title="Пара слов о форматах данных">
Прежде всего, я позволил себе внести небольшие изменения в <a href="https://ru.wikipedia.org/wiki/Нотация_Форсайта_—_Эдвардса">FEN</a>-нотацию. Поскольку все фигуры в игре одного типа, буквы от 'a' до 'k' кодирует непрерывные последовательности камней одного цвета. Заглавные буквы используются для камней первого игрока. Цифры от '1' до '9' по прежнему кодируют пустые поля. Позиция на доске задаётся числом от 0 до 120 (просто перебираем позиции по порядку: сверху-вниз и слева-направо). Исходные данные выглядят <a href="http://hex.kosmanor.com/hex-bin/newdump/1">иначе</a>:

<source>
BbFeDfChEgEhGgGhHhFgGeHgDhCjDiDjEiHcEdFbDcDbEb
</source>
Каждая пара символов определяет очередной ход. Первая буква задаёт столбец, вторая строку (мне пришлось потратить некоторое количество времени чтобы выяснить это). Этот формат данных также был расширен. Мне понадобилось хранить оценку позиции на момент выполнения хода (ниже я расскажу, для чего это понадобилось). Поскольку это число из интервала (-1, 1), достаточно записывать знак и несколько цифр после десятичной точки. В результате получилось что-то в этом духе:

<source>
Eb-08FgHf03GhHh03GiHi03HgIg03CiGe03IfEf03DhJf-JeKd03KeGd03BjEg03EhFh03GgCh03JcAj03Ak
</source>
Вас может сбить с толку, что числа записаны не перед каждой парой символов, но этому есть простое объяснение. Оценку позиции в этой игре производил только второй игрок.
</spoiler>
Есть ещё кое что важное, о чём стоит упомянуть. В какой-то момент бот начал вести себя <a href="https://games.dtco.ru/dagaz/hex.html?sid=9817">странно</a>. Он выигрывал, но делал это не благодаря, а скорее вопреки своим ходам. Вообще, складывалось впечатление, что бот пытается соединить верх и низ доски, пытаясь играть за первого, а не за второго игрока. Попытки исправить это продолжались довольно долго, пока я не понял, что чтобы не путать себя и бота, любую позицию следует рассматривать с точки зрения первого игрока, при необходимости <a href="https://github.com/GlukKazan/HexBotV2/blob/master/utils.js#L75">отразив</a> доску относительно главной диагонали. Это всё сильно упростило и дело пошло на лад.

Если отражение доски использовалось как при обучении модели так и в ходе работы бота, то <a href="https://github.com/GlukKazan/HexFit/blob/master/game.js#L43">поворот</a> доски имел отношение только к процессу обучения. Когда я <a href="https://habr.com/ru/post/583028/">работал</a> с уже обученной моделью для игры Го, то заметил, что рекомендуемые ей ходы не симметричны. Так первый ход всегда выполнялся в пункт 4-4 в правый верхний угол (понятно, что начальные ходы в остальные три угла совершенно равноценны). В тот момент (поскольку модель была уже обучена), я заменил один вызов predict шестнадцатью, восемь раз повернув и отразив доску и изменив цвет камней (лучший ход противника - это и твой лучший ход), но более правильным решением было бы добавление всех этих отражений и поворотов в обучающую выборку. При обработке изображений, такая операция называется обогащением исходных данных. В случае Гекса, доска более хитрая и достаточно всего одного поворота (относительно центра доски).
</spoiler>
Технология разработки бота для <a href="https://games.dtco.ru/map">DagazServer</a> была уже отработана <a href="https://habr.com/ru/post/583028/">ранее</a>. Полученный в результате <a href="https://github.com/GlukKazan/HexBotV2">бот</a> играет в Гекс довольно неплохо, но сила его игры зависит, в первую очередь, от качества обучения модели. Обучение с учителем - это только первый шаг, поскольку не позволяет играть лучше тех людей, игры которых составили обучающую выборку. Чтобы двигаться дальше, требуется ещё один <a href="https://github.com/GlukKazan/HexAuto">инструмент</a>, позволяющий боту играть самому с собой или с другой версией бота.

<spoiler title="Что на счёт REINFORCE?">
Обучающие данные - это то, чего больше всего не хватает при обучении с учителем. По этой причине, мы используем данные повторно, снова и снова, проводя обучение на большом количестве эпох. Было бы лучше обучаться на уникальных данных, но исходные данные слишком ценны. Их всегда недостаточно! Но даже если данные имеются в достаточном количестве, мы не всегда можем быть уверены в их качестве. Вот одна игра, из тех что я <a href="https://github.com/GlukKazan/HexExtract/blob/master/hex.zip">скачал</a>. Самая <a href="http://hex.kosmanor.com/hex-bin/newdump/2623">первая</a> (картинка кликабельна)!

<a href="https://games.dtco.ru/dagaz/hex.html?sid=10359">
<img align="center" src="https://habrastorage.org/webt/iy/mr/p7/iymrp7laziv5ycagv4obztynb8q.png" /></a>
Серьёзно, кто-то практиковался в абстрактном искусстве, а в результате игра попала в обучающие данные. Чему хорошему может научиться модель на таких примерах? К сожалению, данных действительно очень много и совершенно невозможно проверить их все вручную. Но мы всегда можем получить новые данные, заставив бота играть самого с собой.

Это одно из назначений <a href="https://github.com/GlukKazan/HexAuto">HexAuto</a>. Другое его применение заключается в том, что мы можем автоматизировать сравнение силы различных ботов по итогом серий их игр друг с другом. Победы в одной игре недостаточно для того чтобы определить что один бот сильнее другого. Слабый бот мог победить вследствие случайного стечения обстоятельств. Для более корректной оценки используется <a href="https://www.codecamp.ru/blog/binomial-test-python/">биномиальный тест</a>.

<source>
>>> from scipy.stats import binom_test
>>> binom_test(51, 100, 0.5)
0.9204107626128211
>>> binom_test(60, 100, 0.5)
0.056887933640980784
</source>
Если один бот победил другого 51 раз в серии из 100 игр, можно сделать вывод от том, что они равны по силе (0.5) с вероятностью 92%. Если же побед было 60, равенство ботов по силе маловероятно (5%). Нам необходимо большое количество игр, как для дообучения модели, так и для сравнительной оценки ботов. Насколько качественно будут играть боты зависит от выбранного алгоритма. Можно просто <a href="https://github.com/GlukKazan/HexAuto/blob/master/sample-ai.js#L47">семплировать</a> вероятности предсказанных ходов (что будет работать экстремально быстро), либо запустить полноценный <a href="https://github.com/GlukKazan/HexAuto/blob/master/mcts-ai.js">MCTS</a>, используя вероятности полученные от модели в качестве априорных. Разница очевидна:

<spoiler title="sample-ai">
<source>
Won [1]: Fc03GfFg03HdGh448IdHc03AfEf03AkJb03JdBi999HfIg999DeCj991ChBg03GgFh330JjBh03AdKc03BdBa553IcIb666GiDd03BkCc03IfBe03CdDc03CeCk03AeHh03FaBb03EhJg03AjCi03EkKf03AiAh03EdKd03EcFe03BcKb03GbCb03CaFd03AgGc03GeDa03GjCf03BfGa03FbDh03EgDg03CgFf03DfDj03HiFi03FjKh03AbAc03AaJi03DkHg03HkIk03KiIj03HjEi03DiEj03HbIa
 o * o * . o * . * . .
  o * * . . o o o * * *
   * o * * o * * * o . *
    o o o * o * . o o o *
     o * o o . * o . . . .
      o o * o * * o o o . *
       o * o * o * o * * * .
        * * o * o * * * . . *
         o * * o * * o o . * o
          o . * * * o o o * o .
           o o * o o . . o * . .

FEN: aAaA1aA1A2/aB2cC/AaBaCa1A/cAaA1cA/aAb1Aa4/bAaBc1A/aAaAaAaC1/BaAaC2A/aBaBb1Aa/a1CcAa1/bAb2aA2-w
Total: 9/1 (10), time = 23.952</source>
</spoiler>
<spoiler title="mcts-ai">
<source>
Lose [2]:Hc03IiFf445EhDg03CiGg03FhHh03GiGj03HiJh03JiGh03FiKi03KhBi03BjAk03AjDi03Dh
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . * . . .
    . . . . . . . . . . .
     . . . . . . . . . . .
      . . . . . * . . . . .
       . . . * . . * . . . .
        . . . o o o * * . * o
         . * o * . o o o o o *
          o o . . . . * . . . .
           * . . . . . . . . . .

FEN: 92/92/7A3/92/92/5A5/3A2A4/3cB1Aa/1AaA1eA/b4A4/A91-w
Total: 2/8 (10), time = 1773.71
</source>
</spoiler>
В 77 раз медленнее, но зато гораздо осмысленнее! Кстати, обратите внимание: модели в этих двух прогонах использовались одни и те же, но при использовании sample-ai уверено лидировал первый игрок, в то время как для mcts-ai вторая модель подошла гораздо лучше. Объяснением этому может быть то, что вторая модель менее обучена и предоставляет MCTS большую свободу в выборе хода. В любом случае, достаточно очевидно, что обучать модель следует с учётом того как она будет использоваться. То что хорошо подходит для простого алгоритма, может оказаться неподходящим для более продвинутого.

Как бы там ни было, теперь у нас имеется потенциально бесконечный источник качественных данных. Каким образом это использовать? От "обучения с учителем" можно перейти к "обучению с подкреплением". По завершении игры, мы знаем кто из игроков победил. Это означает, что можно формировать обучающие данные таким образом, чтобы подкрепить ходы победителя и сделать менее вероятными выбор ходов ведущих к поражению. <abbr title="REward Increment = Nonnegative Factor * Offset Reinforcement * Characteristic Eligibility">REINFORCE</abbr> именно об этом.

Однако, здесь есть одна проблема: не все ходы выполненные в ходе игры вносят равноценный вклад в достижение победы. Подкрепляя слабые ходы мы можем не только затянуть процесс обучения, но и научить модель плохому. Интуитивно понятно, что ход "переломивший игру", выполненный из проигрышного положения, намного ценнее обычного тихого хода из позиции, в которой игроку ничего не угрожает, но как это формализовать? Мне нравится метод "актор-критик", формирующий подкрепление в зависимости от оценки позиции, с точки зрения игрока. Откуда взять оценку? У нас есть нейросеть, вот пусть она и считает!

<img align="center" src="https://habrastorage.org/webt/cy/2s/fh/cy2sfhhq5tpeeme4zc1rjmkae6a.png" />
Здесь, помимо выхода политики, добавлен дополнительный выход оценки (для чего пришлось перейти от <a href="https://js.tensorflow.org/api/latest/#sequential">последовательного</a> API к <a href="https://js.tensorflow.org/api/latest/#model">функциональному</a>). Подкрепление каждого хода формируется как <b>R-E</b> (где <b>R</b> означает награду - 1 у победителя и -1 у проигравшего, а <b>E</b> - оценку текущей позиции с точки зрения игрока). Поскольку выход оценки - непрерывное вещественное значение, в качестве функции потерь берётся <a href="https://ru.wikipedia.org/wiki/Среднеквадратическое_отклонение">mse</a>, а <a href="https://js.tensorflow.org/api/latest/#tanh">tanh</a> используется как функция активации в последнем слое.

<spoiler title="В этом месте начинаются проблемы">
Прежде всего, два выхода модели вычисляются по разному и значения функций потерь на них вполне могут различаться на порядки (что для процесса обучения очень плохо). К сожалению, перенос масштабирующих коэффициентов из <a href="https://www.tensorflow.org/api_docs/python/tf/keras/Model#compile">Tensorflow</a> пока ещё только <a href="https://github.com/tensorflow/tfjs/blob/tfjs-v3.19.0/tfjs-layers/src/engine/training.ts#L600-L601">в планах</a>. В моём случае, значения функций потерь на выходах различаются примерно в 4 раза и с этим можно жить. Второй момент более странный и выглядит более проблемным.

В своей <a href="https://www.manning.com/books/deep-learning-and-the-game-of-go">книге</a>, Max Pumperla и Kevin Ferguson утверждают, что при использовании в качестве функции потерь  <a href="https://ru.wikipedia.org/wiki/Перекрёстная_энтропия">categoricalCrossentropy</a>, изменение знака подкрепления приводит к обращению вектора градиента политики, что даёт возможность уменьшать вероятность не успешных ходов. К сожалению, как только я передаю на выход политики отрицательные значения подкрепления, всё сразу же ломается: значения функции потерь уходят в отрицательную область (чего быть не должно) и обучение уже больше никуда не идёт. Возможно, знающие люди подскажут в чём тут дело.
</spoiler>
Настройка обучения с подкреплением имеет свою специфику. Как правило, такие модели обучаются "с нуля" и качество обучающих данных, по крайней мере в начале процесса обучения, далеко от идеального (а по правде сказать, близко к рандомному). По этой причине, к таким данным следует относиться с крайней осторожностью. Не следует использовать такие данные повторно, устанавливая количество эпох больше 1, а размер пакета следует выбирать побольше (например 1024), чтобы как-то сгладить возможные огрехи в обучающих данных.

Также, при обучении с подкреплением, не следует использовать адаптивные алгоритмы оптимизации, такие как <a href="https://js.tensorflow.org/api/latest/#train.adagrad">adagrad</a> или <a href="https://js.tensorflow.org/api/latest/#train.adam">adam</a>, отдав предпочтение старому доброму <a href="https://js.tensorflow.org/api/latest/#train.sgd">стохастическому градиенту</a>. Скоростью обучения рекомендуется управлять вручную, задавая в начале малые значения (~0.001) и постепенно увеличивая по мере необходимости. Это может помочь не пролетать мимо минимума функции потерь в процессе обучения.
</spoiler>
За 20 суток непрерывной работы <a href="https://github.com/GlukKazan/HexAuto">HexAuto</a> получил около 10000 <a href="https://github.com/GlukKazan/HexAuto/blob/master/hexbot.zip">качественных партий</a> в Гекс (как я уже говорил, MCTS-бот работает <abbr title="особенно на CPU">не быстро</abbr>). Осталось понять, что с этим делать. Можно было бы запустить дообучение исходной модели, но у меня возникла идея получше. Обучение новой модели "с нуля", на новых исходных данных, позволит оставить за скобками все те <a href="https://games.dtco.ru/dagaz/hex.html?sid=10359">странные игры</a>, попавшие в первоначальную обучающую выборку по недоразумению (без кропотливой ручной проверки более чем 15000 партий). Это данные, в которых я уверен.

Кроме того, помните я говорил, что обучение с учителем не позволяет научить модель играть лучше чем худший из игроков в обучающей выборке? Так оно и было бы, используй бот рекомендации нейросети напрямую, но в нашем случае основную работу выполняет MCTS, а нейросеть просто даёт ему подсказки. Из этого следует, что мы можем получить новый опыт из игр MCTS-бота и использовать его для лучшего обучения модели.

<spoiler title="Как проходит обучение?">
Поскольку данных мало и они качественные, используем их по полной, в большом количестве эпох. Размер пакета берётся большим (1024), чтобы сглаживать возможные огрехи в игре ботов. Обучение протекает довольно шустро:

<spoiler title="accuracy">
<img align="center" src="https://habrastorage.org/webt/uu/yc/d_/uuycd_yd3yd2kldszcijywbue74.png" />
</spoiler>
<spoiler title="loss">
<img align="center" src="https://habrastorage.org/webt/w8/wp/rn/w8wprncxldsz_prv3nnhdqoz5ke.png" />
</spoiler>
Это обнадёживает. Ставим количество эпох побольше (100) и...

<spoiler title="accuracy">
<img align="center" src="https://habrastorage.org/webt/qh/xu/j8/qhxuj8zliamf2ov-o0m3urzzedy.png" />
</spoiler>
<spoiler title="loss">
<img align="center" src="https://habrastorage.org/webt/_s/qr/al/_sqralvf818ja90of6l8xfh4vc8.png" />
</spoiler>
Так выглядит переобучение. До какого-то момента модель обучается прекрасно, но потом новые данные идут "мимо кассы". Как с этим бороться? Нам поможет <a href="https://js.tensorflow.org/api/latest/#layers.dropout">прореживание</a>! Добавляем дополнительные <a href="https://github.com/GlukKazan/HexFitV2/blob/master/model.js#L52">слои</a> и запускаем процесс. Это медленнее (примерно в 2 раза), но результат выглядит обнадёживающе:

<spoiler title="accuracy">
<img align="center" src="https://habrastorage.org/webt/ok/i6/gs/oki6gsb_rlahmfzkjkfdl8cxyrg.png" />
</spoiler>
<spoiler title="loss">
<img align="center" src="https://habrastorage.org/webt/cw/lq/uc/cwlqucbqiior6hfispoxywrneky.png" />
</spoiler>
Похоже на то, что теперь дальнейшее обучение модели просто вопрос времени.
</spoiler>
Вы можете сами увидеть, насколько хорошо играет <a href="https://games.dtco.ru/launch/29/225">бот</a>, зарегистрировавшись на <a href="https://games.dtco.ru/reg">DagazServer</a> (регистрация бесплатная и не требует ввода персональных данных). Если же вариант с регистрацией вас решительно не устраивает, можно посмотреть на версию <a href="https://glukkazan.github.io/arrange/hex-advisor.htm">игры</a> на <a href="https://glukkazan.github.io/">GitHub Pages</a>. Должен предупредить, что в этом случае взаимодействие с ботом более опосредованное и иногда "виснет" (перезагрузка страницы по F5 в таких случаях обычно помогает). Обратите внимание на подсветку рекомендуемых ходов на доске (это просто рекомендация модели, MCTS не задействован). На текущий момент, мне удаётся его обыгрывать (особенно когда я не зеваю), но я всерьёз рассчитываю на то, что дальнейшее обучение позволит значительно улучшить качество игры.

<spoiler title="Update 17.11.2022">
Вчерашний запуск показал не очень качественную игру бота против человека. По результатам разбора полётов <a href="https://github.com/GlukKazan/HexBotV2/commit/43e993d4a1adeec9684f0eb9e992a0c97e8bdc7f#diff-11d8386343dd879c8c1037d63c5d366cb1a938622c37eeeb28686623a296ce1dR7-R8">ужесточил</a> обработку первого хода и вернулся к одной из старых моделей.

<spoiler title="Локально она показала неплохую игру">
<source>
> hex-bot-v2@1.0.0 start C:\Users\User\hex-bot-v2
> node index.js

INIT
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=0;&setup=92/92/92/92/92/92/92/92/92/92/92-w',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954
}
[10604] fen = 92/92/92/92/92/92/92/92/92/92/92
move = g6, value=1000, time = 1
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/92/92/92/6A4/92/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/92/92/92/5aA4/92/92/92/92/92
cpu

============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details.
============================
Load time: 989
Predict time: 267
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . + + . . . .
    . . . . . + . . . . .
     . . . + + . . + . . .
      . . . + + o * + . . .
       . . + + + . . . . . .
        . + . . . . . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

d7: n = 113, w = 56, p = 0.3562183678150177, e = 0
e7: n = 113, w = 66, p = 0.03258887678384781, e = 0
f9: n = 106, w = 61, p = 0.0000028124461550760316, e = 0
d6: n = 100, w = 56, p = 0.008620398119091988, e = 0
j2: n = 99, w = 56, p = 0.00024358583323191851, e = 0
c6: n = 96, w = 53, p = 0.0007067034021019936, e = 0
e5: n = 95, w = 50, p = 0.09140952676534653, e = 0
d8: n = 93, w = 51, p = 0.00036295480094850063, e = 0
b6: n = 89, w = 48, p = 0.000013703950571652967, e = 0
j11: n = 88, w = 47, p = 0.0000015722501984782866, e = 0
Time = 7070, N = 7500
move = e7, value=15.064658045593921, time = 7070
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/92/92/92/5aA4/4A6/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/92/92/92/4bA4/4A6/92/92/92/92
Load time: 0
Predict time: 152
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . + . . + . .
    . . . + . . . . . . .
     . . . + + . . . . . .
      . . . . o o * . . . .
       . . + + * + + . . . .
        . + . . . + . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

g5: n = 188, w = 121, p = 0.00007440061017405242, e = 0
f7: n = 156, w = 67, p = 0.9311296343803406, e = 0
b8: n = 138, w = 70, p = 0.3800925016403198, e = 0
f9: n = 132, w = 77, p = 1.770902713360556e-7, e = 0
a10: n = 126, w = 72, p = 9.020714486496217e-8, e = 0
f8: n = 122, w = 60, p = 0.29038721323013306, e = 0
d10: n = 120, w = 67, p = 0.0071227047592401505, e = 0
c8: n = 113, w = 62, p = 0.000010491111424926203, e = 0
d7: n = 111, w = 60, p = 0.0267222598195076, e = 0
i5: n = 110, w = 60, p = 4.7156991200836273e-8, e = 0
Time = 7074, N = 8900
move = g5, value=21.121222334569147, time = 7074
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/92/92/6A4/4bA4/4A6/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/92/92/6A4/4bA4/4Aa5/92/92/92/92
Load time: 0
Predict time: 113
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . . . . .
    . . . . . + . . . . .
     . . . . + . * . . . .
      . . . . o o * . . . .
       . . . . * o + . . . .
        . . . . . + . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

g7: n = 179, w = 91, p = 0.46867063641548157, e = 0
f4: n = 129, w = 64, p = 0.13096025586128235, e = 0
d6: n = 124, w = 64, p = 0.000011476244253572077, e = 0
g8: n = 124, w = 64, p = 0.000003983141141361557, e = 0
k2: n = 122, w = 63, p = 1.2536909821392328e-7, e = 0
i5: n = 120, w = 61, p = 1.782942149475275e-7, e = 0
b6: n = 118, w = 60, p = 8.086317393463105e-7, e = 0
g9: n = 118, w = 60, p = 2.03362304773691e-8, e = 0
h9: n = 117, w = 59, p = 6.810767505527338e-10, e = 0
f5: n = 110, w = 54, p = 0.000002063915189864929, e = 0
Time = 7039, N = 9200
move = g7, value=19.45440712965982, time = 7039
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/92/92/6A4/4bA4/4AaA4/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/7a3/92/6A4/4bA4/4AaA4/92/92/92/92
Load time: 0
Predict time: 112
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . o . . .
    . . . . . + . . . . .
     . . . . . . * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

f4: n = 232, w = 125, p = 0.999126136302948, e = 0
h7: n = 147, w = 87, p = 0.0007273855153471231, e = 0
d6: n = 135, w = 78, p = 5.328457675091158e-9, e = 0
g3: n = 134, w = 77, p = 2.233676710261534e-8, e = 0
i5: n = 130, w = 74, p = 8.75612613526755e-7, e = 0
j9: n = 122, w = 68, p = 2.209392824942258e-12, e = 0
k1: n = 122, w = 68, p = 3.030690365335431e-8, e = 0
d5: n = 121, w = 67, p = 8.176841959084413e-8, e = 0
c3: n = 116, w = 63, p = 2.543234423581166e-15, e = 0
i4: n = 116, w = 63, p = 4.464618896804495e-9, e = 0
Time = 7024, N = 9100
move = f4, value=25.491704208328755, time = 7024
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/7a3/5A5/6A4/4bA4/4AaA4/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/6b3/5A5/6A4/4bA4/4AaA4/92/92/92/92
Load time: 0
Predict time: 195
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . + o o . . .
    . . . . . * . . . . .
     . . . . . . * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

f3: n = 219, w = 128, p = 0.9999359846115112, e = 0
g2: n = 163, w = 110, p = 7.888054653903964e-9, e = 0
f9: n = 162, w = 109, p = 9.721892268999e-8, e = 0
h9: n = 127, w = 80, p = 1.6378491445034893e-12, e = 0
i4: n = 125, w = 78, p = 2.1828991739192283e-11, e = 0
c4: n = 114, w = 69, p = 2.1093462532206786e-9, e = 0
c9: n = 105, w = 62, p = 7.274028046566627e-9, e = 0
f10: n = 103, w = 60, p = 2.509963508146029e-7, e = 0
j1: n = 102, w = 59, p = 1.9311984900127754e-8, e = 0
e1: n = 101, w = 58, p = 1.8024677583827753e-10, e = 0
Time = 7059, N = 8500
move = f3, value=25.761675097047405, time = 7059
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/5Ab3/5A5/6A4/4bA4/4AaA4/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/5Ab3/5Aa4/6A4/4bA4/4AaA4/92/92/92/92
Load time: 0
Predict time: 119
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . . . + * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

f5: n = 264, w = 163, p = 1.8999639749526978, e = 0
h9: n = 158, w = 119, p = 5.8430742510336576e-15, e = 0
f9: n = 146, w = 108, p = 2.722197800508752e-9, e = 0
h8: n = 136, w = 99, p = 1.742388316960941e-10, e = 0
g2: n = 124, w = 88, p = 2.6496033145306797e-10, e = 0
c4: n = 115, w = 80, p = 1.9052490696225277e-9, e = 0
i10: n = 113, w = 78, p = 1.6652832067411312e-14, e = 0
j2: n = 109, w = 74, p = 4.1680041817926394e-7, e = 0
i9: n = 105, w = 71, p = 6.396081581039326e-13, e = 0
b7: n = 103, w = 69, p = 9.847889170799817e-10, e = 0
Time = 7036, N = 8700
move = f5, value=30.34134007585335, time = 7036
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/92/92/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/92/5a5/92/92
Load time: 1
Predict time: 111
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . + . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . + . + + . .
         . . . . . o + . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

h8: n = 247, w = 163, p = 0.776493489742279, e = 0
g9: n = 174, w = 121, p = 0.012051773257553577, e = 0
f8: n = 156, w = 105, p = 0.03498733788728714, e = 0
e8: n = 138, w = 91, p = 0.00007620630640303716, e = 0
g8: n = 138, w = 91, p = 0.0002636779972817749, e = 0
i8: n = 131, w = 81, p = 0.1347949057817459, e = 0
g2: n = 117, w = 73, p = 0.00012349066673777997, e = 0
h7: n = 113, w = 70, p = 0.00015255737525876611, e = 0
d7: n = 113, w = 70, p = 0.00024106141063384712, e = 0
j8: n = 111, w = 68, p = 0.00011995271052001044, e = 0
Time = 7056, N = 9100
move = h8, value=27.13987473903967, time = 7056
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5a5/92/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5a2a2/92/92
Load time: 0
Predict time: 106
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . + + . * . . .
         . . . . + o . . o . .
          . . . . . . + + . . .
           . . . . . . . . . . .

g10: n = 460, w = 404, p = 0.3124961853027344, e = 0
f8: n = 294, w = 231, p = 0.5743585824966431, e = 0
h9: n = 155, w = 115, p = 0.0020819492638111115, e = 0
k8: n = 139, w = 101, p = 0.00010255465895170346, e = 0
k9: n = 125, w = 88, p = 0.000009723629773361608, e = 0
c9: n = 124, w = 87, p = 0.0001435191952623427, e = 0
g9: n = 123, w = 86, p = 0.0004532948660198599, e = 0
a8: n = 120, w = 83, p = 1.2418826145221828e-7, e = 0
c10: n = 115, w = 79, p = 0.0001548130385344848, e = 0
e2: n = 114, w = 78, p = 0.0000010005476269725477, e = 0
Time = 7025, N = 9100
move = g10, value=50.5438962751346, time = 7025
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5a2a2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5b1a2/6A4/92
Load time: 0
Predict time: 118
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . * . . .
         . . . . . o o + o . .
          . . . . . . * . . . .
           . . . . . . . . . . .

h9: n = 316, w = 281, p = 1.899999976158142, e = 0
g2: n = 146, w = 138, p = 1.2555153801610747e-16, e = 0
f2: n = 146, w = 139, p = 1.4711345155709656e-19, e = 0
e2: n = 124, w = 114, p = 5.351740423408923e-22, e = 0
a10: n = 123, w = 113, p = 1.7834925973268616e-18, e = 0
g1: n = 123, w = 113, p = 1.412217530349207e-23, e = 0
d4: n = 123, w = 113, p = 2.3861010277243758e-20, e = 0
b7: n = 119, w = 108, p = 6.675623821627526e-18, e = 0
c3: n = 119, w = 108, p = 1.0351424215503468e-21, e = 0
e3: n = 115, w = 104, p = 1.7145580017148948e-20, e = 0
Time = 7069, N = 9400
move = h9, value=33.61344537815126, time = 7069
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=92/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 6a4/92/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92
Load time: 0
Predict time: 188
 . . . . . . o . . . .
  . . . . + . + . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . * . . .
         . . . . . o o * o . .
          . . . . . . * . . . .
           . . . . . . . . . . .

e2: n = 303, w = 298, p = 0.9087823033332825, e = 0
g2: n = 177, w = 173, p = 0.07272938638925552, e = 0
f2: n = 165, w = 162, p = 0.0044675408862531185, e = 0
h2: n = 145, w = 139, p = 0.0002212047402281314, e = 0
j3: n = 138, w = 131, p = 0.000039961047150427476, e = 0
c10: n = 118, w = 108, p = 4.582106694073218e-9, e = 0
h1: n = 116, w = 106, p = 0.00016876423615030944, e = 0
c2: n = 116, w = 106, p = 9.981785353829764e-8, e = 0
i4: n = 116, w = 106, p = 1.4992888708320606e-8, e = 0
c7: n = 116, w = 106, p = 4.5079733723696336e-8, e = 0
Time = 7016, N = 9600
move = e2, value=31.559212582022703, time = 7016
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=6a4/4A6/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 5b4/4A6/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92
Load time: 0
Predict time: 109
 . . . . + o o . . . .
  . . . . * . + . . . .
   . . . . . * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . + . * . . .
         . . . . . o o * o . .
          . . . . . . * . . . .
           . . . . . . . . . . .

e1: n = 299, w = 291, p = 1.8437700271606445, e = 0
c6: n = 111, w = 110, p = 0.000030445729862549342, e = 0
g2: n = 111, w = 109, p = 0.03426429256796837, e = 0
g8: n = 110, w = 109, p = 7.1233769993739315e-9, e = 0
k9: n = 110, w = 109, p = 1.709794084092664e-8, e = 0
d7: n = 110, w = 109, p = 7.816795459802961e-7, e = 0
a11: n = 106, w = 104, p = 3.5467370707031876e-10, e = 0
e11: n = 106, w = 104, p = 0.00000770689166529337, e = 0
b10: n = 106, w = 104, p = 8.142529850374558e-8, e = 0
h4: n = 106, w = 104, p = 2.86959431911038e-11, e = 0
Time = 7001, N = 9900
move = e1, value=30.1989698010302, time = 7001
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=4Ab4/4A6/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 4Ab4/4Aa5/5Ab3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92
Load time: 0
Predict time: 107
 . . . . * o o . . . .
  . . . . * o . . . . .
   . . . . + * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * . . . .
        . . . . . . . * . . .
         . . . . . o o * o . .
          . . . . . . * . . . .
           . . . . . . . . . . .

e3: n = 329, w = 324, p = 1.8999874591827393, e = 0
j6: n = 117, w = 116, p = 6.977174914213347e-13, e = 0
i1: n = 114, w = 112, p = 3.2668245886213754e-10, e = 0
a11: n = 112, w = 110, p = 8.904922928548004e-19, e = 0
h4: n = 112, w = 109, p = 1.3495988765630765e-15, e = 0
a3: n = 112, w = 110, p = 4.1308729774602034e-18, e = 0
h2: n = 112, w = 110, p = 1.8529665649080762e-11, e = 0
i6: n = 112, w = 110, p = 1.954497536038602e-10, e = 0
a6: n = 112, w = 110, p = 8.364533024551868e-13, e = 0
j3: n = 112, w = 110, p = 7.436654764214623e-11, e = 0
Time = 7020, N = 10000
move = e3, value=32.9, time = 7020
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=4Ab4/4Aa5/4Bb3/5Aa4/5B4/4bA4/4AaA4/7A3/5bAa2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 4Ab4/4Aa5/4Bb3/5Aa4/5B4/4bA4/4AaA4/6aA3/5bAa2/6A4/92
Load time: 0
Predict time: 106
 . . . . * o o . . . .
  . . . . * o + . . . .
   . . . . * * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * + . . .
        . . . . . . o * . . .
         . . . . . o o * o . .
          . . . . . . * . . . .
           . . . . . . . . . . .

h7: n = 330, w = 329, p = 1.7807644605636597, e = 0
j6: n = 118, w = 117, p = 3.947205584609037e-8, e = 0
d2: n = 118, w = 117, p = 3.888484201297615e-9, e = 0
c8: n = 118, w = 116, p = 3.167467355069675e-8, e = 0
b7: n = 118, w = 117, p = 2.261221654364931e-9, e = 0
f10: n = 118, w = 117, p = 2.9993076165052424e-13, e = 0
c5: n = 118, w = 117, p = 4.85928658422452e-12, e = 0
k4: n = 118, w = 117, p = 2.305140800462624e-11, e = 0
g11: n = 118, w = 117, p = 2.4010398647078546e-7, e = 0
a8: n = 118, w = 117, p = 9.024734771135808e-16, e = 0
Time = 6938, N = 10000
move = h7, value=33, time = 6938
{
  id: 10604,
  setup_required: true,
  game_id: 29,
  variant_id: 225,
  ai_flags: null,
  width: null,
  height: null,
  game: 'Hex',
  filename: 'hex',
  players_total: 2,
  last_setup: '?turn=1;&setup=4Ab4/4Aa5/4Bb3/5Aa4/5B4/4bA4/4AaB3/6aA3/5bAa2/6A4/92-b',
  is_dice: 0,
  is_admin: false,
  ai_timeout: 1000,
  player_num: 1,
  uid: 14954,
  time_limit: null,
  additional_time: 0
}
[10604] fen = 4Ab4/4Aa5/4Bb3/5Aa4/5B4/4bA4/4AaB3/6aA3/5bAa2/6A4/6a4
Load time: 0
Predict time: 105
 . . . . * o o . . . .
  . . . . * o + . . . .
   . . . . * * o o . . .
    . . . . . * o . . . .
     . . . . . * * . . . .
      . . . . o o * . . . .
       . . . . * o * * . . .
        . . . . . . o * . . .
         . . . . . o o * o . .
          . . . . . . * + . . .
           . . . . . + o . . . .

f11: n = 246, w = 245, p = 1.163718342781067, e = 0
h10: n = 176, w = 175, p = 0.534814715385437, e = 0
g2: n = 124, w = 123, p = 0.12146802991628647, e = 0
j1: n = 108, w = 107, p = 0.002648537512868643, e = 0
i10: n = 108, w = 107, p = 0.0014305689837783575, e = 0
e10: n = 107, w = 106, p = 0.0000034792210499290377, e = 0
i11: n = 107, w = 106, p = 0.0000024592443423898658, e = 0
k3: n = 107, w = 106, p = 1.1634190855147608e-7, e = 0
d1: n = 107, w = 106, p = 0.000015162101590249222, e = 0
k1: n = 107, w = 106, p = 0.000004100490059499862, e = 0
Time = 6774, N = 10000
move = f11, value=24.6, time = 6774
</source>
</spoiler>
Попутно выяснилось, что производительность бота на сервере (виртуалка) серьёзно уступает ПК на котором я отлаживаюсь.

<spoiler title="Всё очень печально">
<source>
info: 11:07:11 - [10607] fen = 92/92/92/6A4/2Aa2A4/2AaA2A3/a1Ab1A2a1/1AaAd3/1AaBaA4/1a9/92
info: 11:07:21 - a11: n = 1716, w = 974, p = 0.03789157420396805, e = 0
info: 11:07:21 - e3: n = 152, w = 23, p = 0.7905672788619995, e = 0
info: 11:07:21 - a10: n = 131, w = 37, p = 0.0037098501343280077, e = 0
info: 11:07:21 - k7: n = 125, w = 34, p = 0.0031722544226795435, e = 0
info: 11:07:21 - i7: n = 101, w = 23, p = 0.0003447399358265102, e = 0
info: 11:07:21 - c1: n = 92, w = 19, p = 4.2609440242813434e-7, e = 0
info: 11:07:21 - i8: n = 89, w = 17, p = 0.019992226734757423, e = 0
info: 11:07:21 - b5: n = 85, w = 16, p = 0.00009703390969661996, e = 0
info: 11:07:21 - j10: n = 85, w = 16, p = 0.00016607441648375243, e = 0
info: 11:07:21 - a1: n = 78, w = 13, p = 2.968519652313262e-7, e = 0
info: 11:07:21 - Time = 10064, N = 7600
info: 11:07:21 - move = a11, value=225.75976845151953, time = 10064
info: 11:07:29 - [10607] fen = 92/92/92/6A4/2Aa2A4/2AaA2A3/a1Ab1A2a1/1AaAd3/1AaBaA4/b9/A91
info: 11:07:39 - e3: n = 143, w = 4, p = 0.7782242894172668, e = 0
info: 11:07:39 - i7: n = 122, w = 20, p = 0.00003623754673753865, e = 0
info: 11:07:39 - i8: n = 117, w = 17, p = 0.032243840396404266, e = 0
info: 11:07:39 - f7: n = 114, w = 17, p = 7.779815405228874e-7, e = 0
info: 11:07:39 - k7: n = 114, w = 17, p = 0.00437212735414505, e = 0
info: 11:07:39 - j3: n = 108, w = 15, p = 0.000016538942873012275, e = 0
info: 11:07:39 - j5: n = 103, w = 13, p = 0.000005267845153866801, e = 0
info: 11:07:39 - i10: n = 103, w = 13, p = 0.0000021333116819732822, e = 0
info: 11:07:39 - k2: n = 103, w = 13, p = 1.892011880499922e-7, e = 0
info: 11:07:39 - i9: n = 100, w = 12, p = 0.0028137783519923687, e = 0
info: 11:07:39 - Time = 10051, N = 7600
info: 11:07:39 - move = i7, value=16.050519668464677, time = 10051
info: 11:07:54 - [10607] fen = 92/92/92/6A4/2Aa2A4/2AaA2A3/a1Ab1A1Aa1/1AaAe2/1AaBaA4/b9/A91
info: 11:08:04 - e5: n = 119, w = 1, p = 0.40592119097709656, e = 0
info: 11:08:04 - k6: n = 106, w = 9, p = 0.0023655954282730818, e = 0
info: 11:08:04 - b3: n = 92, w = 5, p = 9.913237590808421e-7, e = 0
info: 11:08:04 - e3: n = 91, w = 0, p = 0.15580372512340546, e = 0
info: 11:08:04 - k7: n = 89, w = 4, p = 0.00490249739959836, e = 0
info: 11:08:04 - c11: n = 89, w = 4, p = 0.0018651771824806929, e = 0
info: 11:08:04 - h11: n = 88, w = 4, p = 0.000028602476959349588, e = 0
info: 11:08:04 - j6: n = 85, w = 3, p = 0.0007209799368865788, e = 0
info: 11:08:04 - h4: n = 85, w = 3, p = 0.0009782741544768214, e = 0
info: 11:08:04 - b2: n = 85, w = 3, p = 0.0000020216734810674097, e = 0
info: 11:08:04 - Time = 10095, N = 7000
</source>
</spoiler>
Пришлось увеличить время обработки хода до 10 секунд, но всё равно заветные 10000 итераций не добираются даже ближе к концу игры (а они очень нужны в самом начале). Так что бот на сервере играет закономерно хуже. Есть ещё кое какие идеи по поводу последующего обучения модели, но это уже на следующей неделе, поскольку обучение занимает много времени и я могу этим заниматься только в выходные.
</spoiler>
<spoiler title="Update 21.11.2022">
Пятичасовое обучение на дополненных <a href="https://github.com/GlukKazan/HexFitV2/blob/master/data/hex-11.zip">данных</a>, в 100 эпохах с прореживанием (rate = 0.1) можно считать успешным. Графики обучения выглядят идеально:

<spoiler title="accuracy">
<img align="center" src="https://habrastorage.org/webt/x9/_a/-u/x9_a-u2wtzlpnhzrm7nbrxrmkpi.png" />
</spoiler>
<spoiler title="loss">
<img align="center" src="https://habrastorage.org/webt/ih/qm/xc/ihqmxc2pmdd5sbcjcefrrnff-6m.png" />
</spoiler>
Играть тоже стало <a href="https://games.dtco.ru/dagaz/hex.html?sid=10734">заметно</a> <a href="https://games.dtco.ru/dagaz/hex.html?sid=10736">лучше</a>.

<spoiler title="HexAuto">
<source>
C:\Users\User\hex-auto>npm start

> hex-auto@1.0.0 start C:\Users\User\hex-auto
> node index.js

cpu

============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details.
============================
Lose [2]: Kj551FfEd03FeDf03DgCh03CgEg03EfDh03GeFh03GgIc03IfHg03HfBg03BhGh03JdAi335AhGf555HeEk226FgKk03AkEh113DkIh991JfIj990BeKe999Kf
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . . * . .
    . . . . * . . . . o .
     . o . . . o o o . . *
      . . . * o o * o o o o
       . * o o * o o * . . .
        o o * * * * * . * . .
         * . . . . . . . . . .
          . . . . . . . . * . *
           o . . o * . . . . . *

FEN: 92/92/8A2/4A4a1/1a3c2A/3AbAd/1AbAbA3/bE1A2/A91/8A1A/a2aA5A-w
Lose [2]: Ch03DfDh-449JcIg-112GdGh03FeEc03BgCg110CfKb557IcJd554KcHc991HdEf999EeAh999Ag
 . . . . . . . . . . .
  . . . . . . . . . . *
   . . . . * . . * o o o
    . . . . . . o o . * .
     . . . . o o . . . . .
      . . o o * . . . . . .
       o o * . . . . . * . .
        * . * * . . * . . . .
         . . . . . . . . . . .
          . . . . . . . . . . .
           . . . . . . . . . . .

FEN: 92/91A/4A2Ac/6b1A1/4b5/2bA6/bA5A2/A1B2A4/92/92/92-w
Won [1]: Dd-441GhCc03EiDh03EfCj03EeCg03BkDe03CkDj03BbDk03DbCb03EcDc03CfDf03DgCh03CiDi03CaDa
 . . o * . . . . . . .
  . o * o . . . . . . .
   . . * * o . . . . . .
    . . . * . . . . . . .
     . . . * o . . . . . .
      . . o * o . . . . . .
       . . * o . . . . . . .
        . . * * . . o . . . .
         . . o * o . . . . . .
          . . * * . . . . . . .
           . o o * . . . . . . .

FEN: 2aA7/1aAa7/2Ba6/3A7/3Aa6/2aAa6/2Aa7/2B2a4/2aAa6/2B7/1bA7-w
Lose [2]: Ek03FfGf03FgFh03EiGg990EhFe997FiGe-999DgGi-222GhHg-999HhBi-999IhBh03CfDf03CgAg03BgAh03BfBe03AfKg03JiEg772DhKi775EfKh884JfKe998KfIg889Jg
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . . . . .
    . . . . . . . . . . .
     . * . . . * * . . . *
      o o o * o o * . . o o
       * o o o * o * * * o *
        * * . o o * o o o . *
         . * . . o o * . . o *
          . . . . . . . . . . .
           . . . . * . . . . . .

FEN: 92/92/92/92/1A3B3A/cAbA2b/AcAaCaA/B1bAc1A/1A2bA2aA/92/4A6-w
Won [1]: Hb03FfFi03BhId03HgJe03JfGg887HfHe996GfIg664IfCh668DeJj996EfBg999CgAh999AiKd999CfDf999DgKf999EeKe999JgKg999JhKh999JiKi991IeIc999JdKc880JcKb03JbKa03IkJk
 . . . . . . . . . . *
  . . . . . . . * . o *
   . . . . . . . . * o *
    . . . . . . . . * o *
     . . . o o . . * o * *
      . . o * o o o o o o *
       . * o o . . * o * o *
        * o * . . . . . . o *
         o . . . . * . . . o *
          . . . . . . . . . * .
           . . . . . . . . o * .

FEN: 91A/7A1aA/8AaA/8AaA/3b2AaB/2aAfA/1Ab2AaAaA/AaA6aA/a4A3aA/9A1/8aA1-w
Lose [2]: Kh03DeFd03FgEf-663DhCh558CiBj03BiEh03EgHh772FhIe03GeIf03IdHd887HeJc03JdIc03HfKc03KdBe03CfBc336CgAj226DgBh330AiFf999Gf
 . . . . . . . . . . .
  . . . . . . . . . . .
   . * . . . . . . * * *
    . . . . . * . * o o o
     . * . o . . o o * . .
      . . o . * * o o * . .
       . . o o o o . . . . .
        . * * o * o . * . . *
         o o o . . . . . . . .
          * * . . . . . . . . .
           . . . . . . . . . . .

FEN: 92/92/1A6C/5A1Ac/1A1a2bA2/2a1BbA2/2d5/1BaAa1A2A/c8/B9/92-w
Lose [2]: Fj03GbKi-774JbEg-773IbBf-995BiFb03EkFk-999EeGc03DiFh-884GdHc03IiHd03FcHb03EiFi03CgFe03FdGe03EfFf-118CeHa03FgGa03EhGg03GfHe03HfCi03DhCh03DgJf03JeIe03IfBh03BgAg03CfBe03AhKd03AiJd03Ke
 . . . . . . * * . . .
  . . . . . * o * o o .
   . . . . . o * * . . .
    . . . . . o o * . * *
     . * o . o * * * * o o
      . * o . o * o o o * .
       * o o o * o * . . . .
        o * * o o * . . . . .
         o o * o o * . . o . *
          . . . . . * . . . . .
           . . . . o * . . . . .

FEN: 6B3/5AaAb1/5aB3/5bA1B/1Aa1aDb/1Aa1aAcA1/AcAaA4/aBbA5/bAbA2a1A/5A5/4aA5-w
Won [1]: Ie03HbJb03IfJf03FdJe03IdJc03JdKc03HcKd03JaKa03KhIh03GdHj03HiIi03IgJg03HkGk
 . . . . . . . . . o *
  . . . . . . . o . * .
   . . . . . . . o . * *
    . . . . . o o . o o *
     . . . . . . . . * * .
      . . . . . . . . o * .
       . . . . . . . . o * .
        . . . . . . . . * . o
         . . . . . . . o * . .
          . . . . . . . * . . .
           . . . . . . * o . . .

FEN: 9aA/7a1A1/7a1B/5b1bA/8B1/8aA1/8aA1/8A1a/7aA2/7A3/6Aa3-w
Won [1]: Fd116EgDe03JeFg03EhGg887DgEi03FfHe-663IaIc-110AbFh-224DiGd-337BjJb03HfGf03HdHc03IdGe03IeEj03CgKa03EkDk
 . . . . . . . . o . *
  o . . . . . . . . * .
   . . . . . . . * * . .
    . . . . . * * o o . .
     . . . * . . * * o o .
      . . . . . o * o . . .
       . . o o o * * . . . .
        . . . . o * . . . . .
         . . . o * . . . . . .
          . o . . * . . . . . .
           . . . * o . . . . . .

FEN: 8a1A/a8A1/7B2/5Bb2/3A2Bb1/5aAa3/2cB4/4aA5/3aA6/1a2A6/3Aa6-w
Lose [2]: Gc03EeHf03DiCf03GbDd03BjIc03EjFc03HbHe03HhJe03FiDj03FhEh03EiJg03IiKh03JjIf03HkKj03KiIj03HjJi03IkCi03CjGj03FaIh03HiGh03GiAj03Ak
 . . . . . o . . . . .
  . . . . . . o o . . .
   . . . . . * * . * . .
    . . . * . . . . . . .
     . . . . o . . * . * .
      . . * . . . . * * . .
       . . . . . . . . . * .
        . . . . * o * o * . *
         . . * o o o o o o * o
          * o o * o . * o * o *
           o . . . . . . o o . .

FEN: 5a5/6b3/5B1A2/3A7/4a2A1A1/2A4B2/9A1/4AaAaA1A/2AfAa/AbAa1AaAaA/a6b2-w
Total: 4/6 (10), time = 1774.211

C:\Users\User\hex-auto>npm start

> hex-auto@1.0.0 start C:\Users\User\hex-auto
> node index.js

cpu

============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details.
============================
Lose [2]: CjEe778CfDg330HfIj-995DeBh-778EfDf-557JbHb-777IdGh-772DhEg-887CgCh-993IgHi-999FgEh-994EiFh-03JhKi-999JjJi-998HjIi-990HhGi-999BfEd-999FfAi
 . . . . . . . . . . .
  . . . . . . . o . * .
   . . . . . . . . . . .
    . . . . o . . . * . .
     . . . * o . . . . . .
      . * * o * * . * . . .
       . . * o o * . . * . .
        . o o * o o o * . * .
         o . . . * . o o o o o
          . . * . . . . * o * .
           . . . . . . . . . . .

FEN: 92/7a1A1/92/4a3A2/3Aa6/1BaB1A3/2AbA2A2/1bAcA1A1/a3A1e/2A4AaA1/92-w
Lose [2]: GeHb-115EdFh03EgDi03HcBj889EhEi03HfHg03GhGg03JiJf03KdIf03CiCj03KfKe03AjAk
 . . . . . . . . . . .
  . . . . . . . o . . .
   . . . . . . . * . . .
    . . . . * . . . . . *
     . . . . . . * . . . o
      . . . . . . . * o o *
       . . . . * . o o . . .
        . . . . * o * . . . .
         . . * o o . . . . * .
          * o o . . . . . . . .
           o . . . . . . . . . .

FEN: 92/7a3/7A3/4A5A/6A3a/7AbA/4A1b3/4AaA4/2Ab4A1/Ab8/a91-w
Lose [2]: CiCb559DaBg556GdDb03IbFf03DgEe03BaHe03FeEf03GfGe03CjCf03IeId03DeDf03JdJc03KbKc03AfFa03DhBc03AjAh
 . * . * . o . . . . .
  . . o o . . . . * . *
   . o . . . . . . . o o
    . . . . . . * . o * .
     . . . * o * o o * . .
      * . o o o o * . . . .
       . o . * . . . . . . .
        o . . * . . . . . . .
         . . * . . . . . . . .
          * . * . . . . . . . .
           . . . . . . . . . . .

FEN: 1A1A1a5/2b4A1A/1a7b/6A1aA1/3AaAbA2/A1dA4/1a1A7/a2A7/2A8/A1A8/92-w
Won [1]: ChGj03EgJf03JbGd03IdFh03GfFi556EiBj03EhEj03DjDk03CkFg03FfBe03IeIc332JcIb03AjJa03KaDd03CiAk03BiHd03FeFd03He
 . . . . . . . . . o *
  . . . . . . . . o * .
   . . . . . . . . o * .
    . . . o . o o o * . .
     . o . . . * . * * . .
      . . . . . * * . . o .
       . . . . * o . . . . .
        . . * . * o . . . . .
         . * * . * o . . . . .
          * o . * o . o . . . .
           o . * o . . . . . . .

FEN: 9aA/8aA1/8aA1/3a1cA2/1a3A1B2/5B2a1/4Aa5/2A1Aa5/1B1Aa5/Aa1Aa1a4/a1Aa7-w
Lose [2]: BdFf-776FhGf03IgEg03HgDi03DhEh03IcIe03CjJd03CgCi03KdKc03HeHf03AjBj03AkBi03BhAi
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . . * . o
    . * . . . . . . . o *
     . . . . . . . * o . .
      . . . . . o o o . . .
       . . * . o . . * * . .
        . * . * o * . . . . .
         o o o o . . . . . . .
          * o * . . . . . . . .
           * . . . . . . . . . .

FEN: 92/92/8A1a/1A7aA/7Aa2/5c3/2A1a2B2/1A1AaA5/d7/AaA8/A91-w
Lose [2]: GaGg-996HgGc03JfBk03CcBj03IcHe03KdDe03JdGh03GiHh03JgIi03KhJj03KjKi03IhHi03JiIj03JhEi03IgDj03FhFi03CjCk03EkJc03AjAk
 . . . . . . * . . . .
  . . . . . . . . . . .
   . . * . . . o . * o .
    . . . . . . . . . * *
     . . . o . . . o . . .
      . . . . . . . . . * .
       . . . . . . o * * * .
        . . . . . * o o * * *
         . . . . o o * o o * o
          * o * o . . . . o o *
           o o o . * . . . . . .

FEN: 6A4/92/2A3a1Aa1/9B/3a3a3/9A1/6aC1/5AbC/4bAbAa/AaAa4bA/c1A6-w
Lose [2]: GeBi03CgEi03AjAi03CiCh03FgDh03HcGh03FiFh03DiEh03IdIg03FeJf03BjDj03HgHh03KgKe
 . . . . . . . . . . .
  . . . . . . . . . . .
   . . . . . . . * . . .
    . . . . . . . . * . .
     . . . . . * * . . . o
      . . . . . . . . . o .
       . . * . . * . * o . *
        . . o o o o o o . . .
         o o * * o * . . . . .
          * * . o . . . . . . .
           . . . . . . . . . . .

FEN: 92/92/7A3/8A2/5B3a/9a1/2A2A1Aa1A/2f3/bBaA5/B1a7/92-w
Lose [2]: JjFf03JaGc776FjDi03HcFi03EhId226DjEi338FgCi03KcHh03GhGi03JfJe03KdKe03CfBj03IeJd03JhIf03IgHg03AjAk
 . . . . . . . . . * .
  . . . . . . . . . . .
   . . . . . . o * . . *
    . . . . . . . . o o *
     . . . . . . . . * o o
      . . * . . o . . o * .
       . . . . . * . o * . .
        . . . . * . * o . * .
         . . o o o o o . . . .
          * o . * . * . . . * .
           o . . . . . . . . . .

FEN: 9A1/92/6aA2A/8bA/8Ab/2A2a2aA1/5A1aA2/4A1Aa1A1/2e4/Aa1A1A3A1/a91-w
Won [1]: AdHj03FfGb03HgKf03EfFe03JdEd03GdIb03HbGe03EeFd03JcHc03JbGc03DdHf03DeJf03IfIe03JeDh-223GiEk03FkJa03KaGj03FjGh04Hh
 . . . . . . . . . o *
  . . . . . . o * o * .
   . . . . . . o o . * .
    * . . * o o * . . * .
     . . . * * o o . o * .
      . . . . * * . o * o o
       . . . . . . . * . . .
        . . . o . . o * . . .
         . . . . . . * . . . .
          . . . . . * o o . . .
           . . . . o * . . . . .

FEN: 9aA/6aAaA1/6b1A1/A2AbA2A1/3Bb1aA1/4B1aAb/7A3/3a2aA3/6A4/5Ab3/4aA5-w
Lose [2]: FdCh-445GdHc446DdDi-558FhGb-445GfEj03GiFb03HbGc03IcIb03JbHd03IdHe03HfIe03GjJf03EbEd03DeEe03FcEc999JeIf772DcDf03BfBi03AjAi03KeKf03CgDg
 . . . . . . . . . . .
  . . . . * o o * o * .
   . . . * o * o o * . .
    . . . * o * * o * . .
     . . . * o . . o o * *
      . * . o . . * * o o o
       . . * o . . . . . . .
        . . o . . * . . . . .
         o o . o . . * . . . .
          * . . . o . * . . . .
           . . . . . . . . . . .

FEN: 92/4AbAaA1/3AaAbA2/3AaBaA2/3Aa2bB/1A1a2Bc/2Aa7/2a2A5/b1a2A4/A3a1A4/92-w
Total: 2/8 (10), time = 1602.262
</source>
</spoiler>
В первом прогоне новая модель играла за первого, во втором - за второго игрока. Стал проверять таким образом, поскольку из за того что первый ход в HexAuto выполняется случайно (что хорошо рандомизирует игру), становится заметно преимущество второго игрока.
</spoiler>
</cut>

Го: Дообучаем модель

<img align="left" src="https://habrastorage.org/webt/ma/t7/op/mat7opewu6mgpb-yxeczusk_qfu.png" /><b><i>What will we do with a drunken sailor,
What will we do with a drunken sailor,
What will we do with a drunken sailor,
Early in the morning?

Drunken Sailor</i></b>

В прошлый <a href="https://habr.com/ru/post/583028/">раз</a> мы остановились на том, что модели на основе <a href="https://ru.wikipedia.org/wiki/Свёрточная_нейронная_сеть">свёрточных нейросетей</a>, вполне способны подсказывать интересные и неочевидные ходы и, таким образом, могут использоваться как основа для построения бота для игры <a href="https://ru.wikipedia.org/wiki/Го">Го</a>. Напомню, что источником <a href="https://games.dtco.ru/model/model.json">модели</a> послужила вот эта замечательная <a href="https://www.manning.com/books/deep-learning-and-the-game-of-go">книга</a>. Для того чтобы двигаться дальше: дообучать модель, просто с ней экспериментировать или вообще полностью переделать и обучить с нуля, требовались вычислительные ресурсы. И они появились...
<cut>
За неоднократное проведение <a href="https://habr.com/ru/post/514426/">хакатонов</a>, <a href="https://habr.com/ru/post/541086/">митапов</a> и прочих мероприятий, Руководство Компании презентовало меня <a href="https://www.citilink.ru/product/noutbuk-dell-g15-5510-i7-10870h-16gb-ssd1tb-rtx-3050-ti-4gb-15-6-fhd-w-1534288/properties/">ноутбуком</a>. Наличием видеокарты, позволяющей задействовать <b>GPU</b> в экспериментах с Machine Learning-ом, было грех не воспользоваться.

<spoiler title="Разумеется, видеокарты, самой по себе, недостаточно">
Один день пришлось потратить на установку и настройку необходимого софта. Помимо <a href="https://nodejs.org/en/download/">Node.js</a>, речь идёт о <a href="https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64">CUDA</a> и <a href="https://developer.nvidia.com/rdp/cudnn-download">cuDNN</a>. Дистрибутивы большие, релизы выходят часто, а подобрать их <a href="https://punndeeplearningblog.com/development/tensorflow-cuda-cudnn-compatibility/">совместимые</a> версии, с первого раза, удаётся не всегда. Мне пришлось откатиться к связке CUDA 11.5.0 + cuDNN 8.3.2, чтобы всё заработало. Кстати, чтобы скачать cuDNN необходимо зарегистрироваться. Вот <a href="https://medium.com/analytics-vidhya/tensorflow-gpu-how-to-install-tensorflow-with-nvidia-cuda-cudnn-and-gpu-support-on-windows-6158cffc1c29">здесь</a> можно найти подробную, хотя и несколько устаревшую, инструкцию.
</spoiler> 
<a href="https://www.manning.com/books/deep-learning-and-the-game-of-go">
<img align="center" src="https://habrastorage.org/webt/qa/pm/vn/qapmvnnf5fg-vpjgju_bfxm_0tg.jpeg" /></a>
Первоначально, <a href="https://github.com/maxpumperla/deep_learning_and_the_game_of_go/blob/master/code/dlgo/networks/small.py">модель</a> была разработана авторами упомянутой выше книги, на языке Python, с использованием фреймворка <a href="https://www.tensorflow.org/api_docs/python/tf">TensorFlow</a>, под управлением API <a href="https://keras.io/api/">Keras</a>. Модель была обучена на основе 100 игр, взятых из <a href="https://u-go.net/gamerecords/">архива</a> KGS, а результаты обучения также были выгружены в <a href="https://github.com/maxpumperla/deep_learning_and_the_game_of_go/tree/master/code/checkpoints">GitHub</a>. Для преобразования модели в формат, поддерживаемый <a href="https://www.tensorflow.org/js">Tensorflow.js</a>, потребовался <a href="https://github.com/tensorflow/tfjs-converter/tree/master/tfjs-converter">конвертер</a>.

Прежде всего, хотелось дообучить модель на большем объёме входных данных. Архивы <a href="https://www.gokgs.com/">KGS</a> ведутся с 2001-го года и в них представлены партии, в которых один из игроков имел 7-ой дан и выше или оба игрока имели 6-ой дан. За каждый год были сыграны тысячи партий и какие-то 100 игр, на фоне этих объёмов, представляют собой совершенно ничтожную выборку.

<spoiler title="Попутно, появились ещё две идеи">
Во первых, формат <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>, с использованием которого игры закодированы, содержит сопроводительную информацию. В частности, тег <b>RE</b> кодирует результат партии. Например, '<b>RE[W+Resign]</b>' означает, победу белых, в связи со сдачей противника. Это позволяет отфильтровать из записи партии только ходы победителя, чтобы использовать их для последующего обучения модели.

<spoiler title="Кстати, разбор SGF-нотации - не такая тривиальная задача, как может показаться.">
Дело даже не в том, что требуется <a href="https://github.com/GlukKazan/SGFLoader/blob/master/parser.js">распарсить</a> сам <a href="https://github.com/GlukKazan/SGFLoader/blob/master/data/2000-7-19-1.sgf">SGF-файл</a>. Нотация формируется с учётом правил игры <a href="https://ru.wikipedia.org/wiki/Го#Основные_правила">Го</a>. Записывается только постановка камней на доску. Если выполнение какого-то хода привело к "смерти" одной или нескольких групп, удаление с доски входящих в них камней нотацией не фиксируется. Для нас это означает необходимость "проигрывания" позиции, в процессе чтения SGF-нотации.

<spoiler title="Примерно вот так это выглядит">
<source lang="javascript">
function RedoMove(move, ko) {
    let captured = []; let f = true;
    _.each([1, -1, SIZE, -SIZE], function(dir) {
        let p = navigate(move, dir);
        if (p < 0) return;
        let ix = stat.map[p];
        if (_.isUndefined(ix)) return;
        if (!isEnemy(stat.res[ix].type)) {
            f = false;
            return;
        }
        if (stat.res[ix].dame.length > 1) return;
        _.each(stat.res[ix].group, function (q) {
            board[q] = 0;
            captured.push(q);
        });
    });
    if (captured.length == 1 && f) {
        ko.push(captured[0]);
    }
    board[move] = 1;
    return board;
}
</source></spoiler>
</spoiler>
&nbsp;

Вторая идея связана с симметрией доски. Если позиция не симметрична, мы можем получить до 8 различных равнозначных позиций, используя повороты и отражения. Выполнение этих преобразований в боте, на этапе предсказания хода (<b>predict</b>) - не очень хорошее решение. Вычислительные ресурсы бота слишком ценны. При использовании поиска в глубину (например, с использованием <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">MCTS</a>) операция предсказания хода может быть выполнена тысячи раз. Кроме того, бот может выполняться в окружении, в котором использование быстродействующих бакендов Tensorflow.js невозможно, например в браузере. Гораздо разумнее использовать повороты и отражения, чтобы сгенерировать больший объем данных перед выполнением обучения (<b>fit</b>).
</spoiler>
В общем, получился вот <a href="https://github.com/GlukKazan/SGFLoader">такой</a> загрузчик. Но, перед тем как приступать к обучению модели, следовало определиться с производительностью. Дело в том, что для выполнения вычислений Tensorflow.js может использовать различные бакенды. Самый простой в использовании (и самый медленный) - '<b>cpu</b>', подразумевает выполнение всех вычислений в JavaScript-е. Использование <b>@tensorflow/tfjs-node</b> позволяет выполнять вычисления непосредственно с использованием <b>CPU</b>, а <b>@tensorflow/tfjs-node-gpu</b> (при наличии необходимых драйверов) предоставляет возможность задействовать видеокарту. Помимо перечисленного, при помощи <b>@tensorflow/tfjs-backend-wasm</b> можно использовать бакенд '<b>wasm</b>', с точки зрения производительности представляющий собой промежуточное решение между '<b>cpu</b>' и '<b>tensorflow</b>':

<ul>
	<li><b>cpu</b> - 6199,47 ms</li>
	<li><b>wasm</b> - 31,65 ms</li>
	<li><b>tensorflow</b> (cpu) - 19,57 ms</li>
	<li><b>tensorflow</b> (gpu) - 2,51 ms</li>
</ul>
Тут стоит сказать пару слов о том, что именно измерялось. Довольно быстро выяснилось, что при увеличении размера блока данных, затраты времени на выполнение вычислений для всех бакендов растут линейно. Это касается как предсказания хода, так и обучения (в последнем случае, увеличение количества эпох также ведёт к линейному увеличению затрат времени). По этой причине, данные приведены для условного выполнения <b>fit</b> по отношению к одной строке выборки (то есть паре, состоящей из текущей позиции и рекомендуемого хода). В любом случае, здесь больше важны не абсолютные значения (которые могут меняться, в зависимости от характеристик оборудования), а скорее их соотношение.

<spoiler title="Существует ещё один способ для увеличения производительности">
Используемая модель состоит из нескольких <a href="https://keras.io/api/layers/convolution_layers/convolution2d/">свёрточных слоёв</a>, за которыми следуют <a href="https://keras.io/api/layers/core_layers/dense/">плотные слои</a>. Задача свёрточных слоёв - выявление базовых паттернов: хороших и плохих форм, в терминологии игры Го. Плотные слои формируют решение - ответный ход, наилучший в этой позиции, с точки зрения модели. Поскольку мы работаем с уже обученной моделью, то можем рассчитывать что часть слоёв достаточно хорошо выполняют свою работу и не нуждаются в дополнительном обучении. Мы можем "заморозить" эти слои, установив свойство '<b>trainable</b>' в <b>false</b>. Разумеется, это ускорит процесс обучения, поскольку для "замороженных" слоёв не требуется выполнять изменение коэффициентов при выполнении <a href="https://neerc.ifmo.ru/wiki/index.php?title=Обратное_распространение_ошибки">обратного распространения ошибки</a>:

<img align="center" src="https://habrastorage.org/webt/pr/8r/kz/pr8rkzk1fsivmutdquyefafvf84.png" />
Графики показывают, что при выполнении вычислений с использованием <b>CPU</b>, "замораживание" свёрточных слоёв позволяет значительно увеличить скорость обучения, приблизившись по производительности к <b>GPU</b>. В то же время, при использовании быстрого <b>GPU</b>-бакенда, "замораживание" слоёв вряд ли стоит рассматривать как средство возможной оптимизации, поскольку прирост производительности, в этом случае, ничтожен. Впрочем, есть ещё одна причина для исключения части слоёв из процесса обучения:

<source lang="javascript">
RuntimeError: abort(Error: Kernel 'Conv2DBackpropFilter' not registered for backend 'wasm'). Build with -s ASSERTIONS=1 for more info.
    at process.abort (C:\Users\valen\SGFLoader\node_modules\@tensorflow\tfjs-backend-wasm\dist\tf-backend-wasm.node.js:5262:9549)
    at process.emit (node:events:390:28)
    at emit (node:internal/process/promises:136:22)
    at processPromiseRejections (node:internal/process/promises:242:25)
    at processTicksAndRejections (node:internal/process/task_queues:97:32)
</source>
Как выяснилось, '<b>wasm</b>' бакенд, в настоящее время, не поддерживает обратное распространение в свёрточных слоях. Это достаточно распространённая ситуация и Tensorflow.js позволяет <a href="https://github.com/tensorflow/tfjs/issues/5110">доопределить</a> недостающие функции, но в нашем случае возможных путей решения проблемы всего два: можно "заморозить" часть проблемных слоёв модели либо использовать другой бакенд.
</spoiler>
Загрузка данных за 3 года (2001-2003) продолжалась около 9 часов. Обучение проводилось блоками по 128 строк, в течение 7 эпох, с отделением 0.1 входных данных для выполнения валидации. В качестве функции потерь использовалась '<a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses/CategoricalCrossentropy">categoricalCrossentropy</a>'. Значение метрики '<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy">accuracy</a>' по завершении 7-ой эпохи обучения, изменялось следующим образом:

<img align="center" src="https://habrastorage.org/webt/02/gf/jl/02gfjl8kqxmlwiocjptwrf-frjq.png" />
График минимизации функции потерь:

<img align="center" src="https://habrastorage.org/webt/qs/cc/qi/qsccqirs5dohdkoajry1lm0sqji.png" />
Возможно, в дальнейшем, придётся подумать об изменении архитектуры модели и, скорее всего, представления входных данных, но в настоящий момент, более интересны практические результаты.

<a href="https://games.dtco.ru/dagaz/go-19x19.html?sid=6764">
<img align="center" src="https://habrastorage.org/webt/6s/iq/m7/6siqm7x3ef0lhcvd6fccoq2cpx8.png" /></a>
Картинка кликабельна. Бот под управлением дообученной модели играл чёрными. Обе модели, время от времени, рекомендовали крайне странные ходы, но чёрные, в этой игре, безусловно победили. Разумеется, не стоит ждать сильной игры от очень простого <a href="https://github.com/GlukKazan/GoBot">бота</a>, руководствующегося однократным вызовом <b>predict</b>, для выбора лучшего хода. Использование <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">MCTS</a> должно значительно улучшить качество игры. Это потребует большего количества обращений к модели, что не должно стать проблемой, поскольку вопрос с производительностью, на текущий момент, можно считать решённым.
</cut>

Го: Долгая дорога к боту

<a href="https://dagazproject.github.io/go/go-19x19-advisor.htm?turn=1;&setup=991/991/95b4/3w93b2/991/991/991/991/991/991/991/991/991/991/3w92b3/94w5/97b2/991/991"><img align="left" src="https://habrastorage.org/webt/vb/ec/-l/vbec-lydceg5dprlbik-oho3ztu.png" /></a><b><i>There is no difference between theory and practice in theory, 
but there is often a great deal of difference between theory 
and practice in practice.

<a href="https://quoteinvestigator.com/2018/04/14/theory/#more-18386">Yogi Berra</a>

Я слепым вместо глаз вставил звезды и синее небо.

<a href="http://chords.seriyps.ru/short/ddt::ya-ostanovil-vremya/">Юрий Шевчук</a></i>
</b>
Тема игровых ботов с самого начала была для меня довольно чувствительной. Используя <a href="https://github.com/GlukKazan/Dagaz">Dagaz</a>, я научился воссоздавать самые <a href="https://dagazproject.github.io/">разнообразные игры</a>, но что в них толку, если с тобой никто не играет? <a href="https://nestjs.com/">Nest</a> позволил разработать <a href="https://games.dtco.ru/map">сервер</a>, для игры по сети, но до тех пор пока на нём не слишком много народу, боты продолжают оставаться актуальными. Универсальные боты, которые я писал, были медленными и слабыми. К счастью, знакомство с <a href="https://www.chessprogramming.org/Garbochess">Garbochess</a> позволило <a href="https://habr.com/ru/post/541086/">переломить ситуацию</a>, по крайней мере в том, что касалось шахматных игр. Признаюсь честно, я никогда не думал, что у меня появится бот для игры в <a href="https://ru.wikipedia.org/wiki/Го">Го</a>...
<cut>
до тех пор, пока не прочитал эту книгу:

<a href="https://www.manning.com/books/deep-learning-and-the-game-of-go">
<img align="center" src="https://habrastorage.org/webt/qa/pm/vn/qapmvnnf5fg-vpjgju_bfxm_0tg.jpeg" /></a>
Дело в том, что с точки зрения AI, игра Го, по многим причинам, считается одной из самых сложных настольных игр. Разумеется, боты для этой игры разрабатывались и ранее, но их сила не превышала <a href="https://ru.wikipedia.org/wiki/Го#Японская_система_рангов">2-3 дан</a>, что по меркам игрового сообщества является довольно средним показателем. Возможность разработки для Го сильного бота всерьёз не рассматривалась, вплоть до триумфальной победы <a href="https://ru.wikipedia.org/wiki/AlphaGo">Alpha Go</a> в марте 2016 года. В своей книге, Макс Памперла и Кевин Фергюсон, подробно и двигаясь от простого к сложному, объясняют, как это стало возможно и каким образом устроены как Alpha Go, так и результат дальнейшего развития этого проекта - <a href="https://ru.wikipedia.org/wiki/AlphaZero">AlphaGo Zero</a>.

<h3>А внутре у ей нейронка!</h3>
Разумеется, дело не обошлось без нейросетей. Тактика игры Го основана на построении "<a href="https://clubgo.ru/classic-school/#хорошие-и-плохие-формы">хороших форм</a>", позволяющих захватить большую территорию, защитив её оптимальным образом. Оценка позиции, таким образом, сводится к оценке форм - образов, возникающих на доске в процессе игры. Нейросети, в особенности <a href="https://ru.wikipedia.org/wiki/Свёрточная_нейронная_сеть">свёрточные</a>, и методы <a href="https://ru.wikipedia.org/wiki/Глубокое_обучение">глубокого обучения</a>, со своей стороны, хорошо зарекомендовали себя в задачах распознавания образов. Было вполне логично попытаться применить одно к другому. Результат оказался неожиданным, хотя и выглядит довольно закономерным, в ретроспективе.

Помимо книги, авторы предоставили доступ к исходным кодам в <a href="https://github.com/maxpumperla/deep_learning_and_the_game_of_go">GitHub-репозитории</a>. Конечно же, для разработки использовался <a href="https://ru.wikipedia.org/wiki/Python">Python</a>, ставший фактическим стандартом в приложениях машинного обучения. Также, в проекте были использованы библиотеки <a href="https://www.tensorflow.org/">Tensorflow</a> и <a href="https://keras.io/">Keras</a>.

<spoiler title="Я немедленно окунулся в неповторимую атмосферу Python-а">
Как человеку, столкнувшемуся с этим языком программирования во второй раз в жизни (в первый раз, я помогал дочке с домашним заданием), мне так и не удалось распутать гордиев узел <a href="https://github.com/maxpumperla/deep_learning_and_the_game_of_go/blob/master/code/requirements.txt">зависимостей</a> этого проекта. Разумеется, у людей более опытных, мои потуги могут вызвать лишь усмешку. Выглядели они примерно следующим образом:

<source>
valentin@ecomdev2:/opt/go$ source venv/bin/activate
(venv) valentin@ecomdev2:/opt/go$ pip3 install -r requirements.txt
...
ERROR: dlgo 0.2 has requirement keras==2.2.2, but you'll have keras 2.6.0 which is incompatible.
ERROR: dlgo 0.2 has requirement numpy<=1.14.5, but you'll have numpy 1.21.2 which is incompatible.
ERROR: tensorflow 2.6.0 has requirement numpy~=1.19.2, but you'll have numpy 1.21.2 which is incompatible.
...
(venv) valentin@ecomdev2:/opt/go$ pip3 install tensorflow==2.2.2
...
ERROR: keras 2.2.2 has requirement keras-preprocessing==1.0.2, but you'll have keras-preprocessing 1.1.2 which is incompatible.
ERROR: dlgo 0.2 has requirement numpy<=1.14.5, but you'll have numpy 1.18.5 which is incompatible.
...
(venv) valentin@ecomdev2:/opt/go$ pip3 install keras-preprocessing==1.0.2
...
ERROR: tensorflow 2.2.2 has requirement keras-preprocessing>=1.1.0, but you'll have keras-preprocessing 1.0.2 which is incompatible.
ERROR: dlgo 0.2 has requirement numpy<=1.14.5, but you'll have numpy 1.18.5 which is incompatible.
...
(venv) valentin@ecomdev2:/opt/go$ pip3 install "keras-preprocessing>=1.1.0"
...
ERROR: keras 2.2.2 has requirement keras-preprocessing==1.0.2, but you'll have keras-preprocessing 1.1.2 which is incompatible.
ERROR: dlgo 0.2 has requirement numpy<=1.14.5, but you'll have numpy 1.18.5 which is incompatible.
...
(venv) valentin@ecomdev2:/opt/go/code$ pip3 install "keras==2.2.2"
...
ERROR: tensorflow 2.2.2 has requirement keras-preprocessing>=1.1.0, but you'll have keras-preprocessing 1.0.2 which is incompatible.
ERROR: tensorflow 2.2.2 has requirement numpy<1.19.0,>=1.16.0, but you'll have numpy 1.14.5 which is incompatible.
ERROR: scipy 1.7.1 has requirement numpy<1.23.0,>=1.16.5, but you'll have numpy 1.14.5 which is incompatible.
...
(venv) valentin@ecomdev2:/opt/go/code$ pip3 install "numpy<1.23.0,>=1.16.5"
...
ERROR: tensorflow 2.2.2 has requirement keras-preprocessing>=1.1.0, but you'll have keras-preprocessing 1.0.2 which is incompatible.
ERROR: tensorflow 2.2.2 has requirement numpy<1.19.0,>=1.16.0, but you'll have numpy 1.21.2 which is incompatible.
ERROR: dlgo 0.2 has requirement numpy<=1.14.5, but you'll have numpy 1.21.2 which is incompatible.
...
</source> 
Вероятно, если бы я строил весь проект, со всеми его зависимостями, с нуля, я смог бы разобраться с этой головоломкой, но добиться работоспособности проекта скачанного с GitHub-а мне так и не удалось. К счастью, этого и не требовалось. 
</spoiler>
В седьмой главе книги, авторы провели <a href="https://ru.wikipedia.org/wiki/Обучение_с_учителем">обучение с учителем</a>, взяв за основу данные 100 игр с сервера <a href="https://www.gokgs.com/">KGS</a> - международной игровой площадки для игры в Го. <a href="https://u-go.net/gamerecords/">Записи</a> ведутся в формате <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>, начиная с 2001  года и содержат только те партии, в которых один из игроков имел 7-ой дан и выше или оба игрока имели 6-ой дан. Результат обучения можно посмотреть по следующей <a href="https://demos.badukai.com/static/play_predict_19.html">ссылке</a>:

<a href="https://demos.badukai.com/static/play_predict_19.html">
<img align="center" src="https://habrastorage.org/webt/68/ly/ok/68lyokvlywithraiak9jpy4ooxg.png" /></a>
Следует отметить, что игра бота выглядит вполне разумно. Результаты обучения модели, по завершении 5 эпох, можно <a href="https://github.com/maxpumperla/deep_learning_and_the_game_of_go/tree/master/code/checkpoints">загрузить</a> с GitHub-а и сконвертировать, при помощи <a href="https://github.com/tensorflow/tfjs-converter/tree/master/tfjs-converter">tensorflowjs_converter</a>-а.

<source>
$ tensorflowjs_converter --input_format=keras small_model_epoch_5.h5 small_model_epoch_5
</source>
<spoiler title="Модель получилась вот такая">
<source lang="json">
{
   "format":"graph-model",
   "generatedBy":"2.6.0",
   "convertedBy":"TensorFlow.js Converter v3.9.0",
   "signature":{
      "inputs":{
         "zero_padding2d_1_input":{
            "name":"zero_padding2d_1_input:0",
            "dtype":"DT_FLOAT",
            "tensorShape":{
               "dim":[
                  {
                     "size":"-1"
                  },
                  {
                     "size":"1"
                  },
                  {
                     "size":"19"
                  },
                  {
                     "size":"19"
                  }
               ]
            }
         }
      },
      "outputs":{
         "dense_2":{
            "name":"Identity:0",
            "dtype":"DT_FLOAT",
            "tensorShape":{
               "dim":[
                  {
                     "size":"-1"
                  },
                  {
                     "size":"361"
                  }
               ]
            }
         }
      }
   },
   "modelTopology":{
      "node":[
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_1/Pad/paddings",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_INT32"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_INT32",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"4"
                           },
                           {
                              "size":"2"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_1/Conv2D/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"7"
                           },
                           {
                              "size":"7"
                           },
                           {
                              "size":"1"
                           },
                           {
                              "size":"48"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_1/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"48"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_2/Pad/paddings",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_INT32",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"4"
                           },
                           {
                              "size":"2"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_INT32"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_2/Conv2D/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"5"
                           },
                           {
                              "size":"5"
                           },
                           {
                              "size":"48"
                           },
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_2/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_3/Pad/paddings",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_INT32"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_INT32",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"4"
                           },
                           {
                              "size":"2"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_3/Conv2D/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"5"
                           },
                           {
                              "size":"5"
                           },
                           {
                              "size":"32"
                           },
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_3/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_4/Pad/paddings",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_INT32"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_INT32",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"4"
                           },
                           {
                              "size":"2"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_4/Conv2D/ReadVariableOp",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"5"
                           },
                           {
                              "size":"5"
                           },
                           {
                              "size":"32"
                           },
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_4/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"32"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/flatten_1/Const",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_INT32"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_INT32",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"2"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_1/MatMul/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"11552"
                           },
                           {
                              "size":"512"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_1/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"512"
                           }
                        ]
                     }
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_2/MatMul/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"512"
                           },
                           {
                              "size":"361"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_2/BiasAdd/ReadVariableOp",
            "op":"Const",
            "attr":{
               "dtype":{
                  "type":"DT_FLOAT"
               },
               "value":{
                  "tensor":{
                     "dtype":"DT_FLOAT",
                     "tensorShape":{
                        "dim":[
                           {
                              "size":"361"
                           }
                        ]
                     }
                  }
               }
            }
         },
         {
            "name":"zero_padding2d_1_input",
            "op":"Placeholder",
            "attr":{
               "shape":{
                  "shape":{
                     "dim":[
                        {
                           "size":"-1"
                        },
                        {
                           "size":"1"
                        },
                        {
                           "size":"19"
                        },
                        {
                           "size":"19"
                        }
                     ]
                  }
               },
               "dtype":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_1/Pad",
            "op":"Pad",
            "input":[
               "zero_padding2d_1_input",
               "StatefulPartitionedCall/sequential/zero_padding2d_1/Pad/paddings"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "Tpaddings":{
                  "type":"DT_INT32"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_1/Conv2D",
            "op":"Conv2D",
            "input":[
               "StatefulPartitionedCall/sequential/zero_padding2d_1/Pad",
               "StatefulPartitionedCall/sequential/conv2d_1/Conv2D/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "strides":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "dilations":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "padding":{
                  "s":"VkFMSUQ="
               },
               "use_cudnn_on_gpu":{
                  "b":true
               },
               "data_format":{
                  "s":"TkNIVw=="
               },
               "explicit_paddings":{
                  "list":{
                     
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_1/BiasAdd",
            "op":"BiasAdd",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_1/Conv2D",
               "StatefulPartitionedCall/sequential/conv2d_1/BiasAdd/ReadVariableOp"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/activation_1/Relu",
            "op":"Relu",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_1/BiasAdd"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_2/Pad",
            "op":"Pad",
            "input":[
               "StatefulPartitionedCall/sequential/activation_1/Relu",
               "StatefulPartitionedCall/sequential/zero_padding2d_2/Pad/paddings"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "Tpaddings":{
                  "type":"DT_INT32"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_2/Conv2D",
            "op":"Conv2D",
            "input":[
               "StatefulPartitionedCall/sequential/zero_padding2d_2/Pad",
               "StatefulPartitionedCall/sequential/conv2d_2/Conv2D/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "use_cudnn_on_gpu":{
                  "b":true
               },
               "data_format":{
                  "s":"TkNIVw=="
               },
               "padding":{
                  "s":"VkFMSUQ="
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "explicit_paddings":{
                  "list":{
                     
                  }
               },
               "dilations":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "strides":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_2/BiasAdd",
            "op":"BiasAdd",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_2/Conv2D",
               "StatefulPartitionedCall/sequential/conv2d_2/BiasAdd/ReadVariableOp"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/activation_2/Relu",
            "op":"Relu",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_2/BiasAdd"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_3/Pad",
            "op":"Pad",
            "input":[
               "StatefulPartitionedCall/sequential/activation_2/Relu",
               "StatefulPartitionedCall/sequential/zero_padding2d_3/Pad/paddings"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "Tpaddings":{
                  "type":"DT_INT32"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_3/Conv2D",
            "op":"Conv2D",
            "input":[
               "StatefulPartitionedCall/sequential/zero_padding2d_3/Pad",
               "StatefulPartitionedCall/sequential/conv2d_3/Conv2D/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "dilations":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "use_cudnn_on_gpu":{
                  "b":true
               },
               "padding":{
                  "s":"VkFMSUQ="
               },
               "strides":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "explicit_paddings":{
                  "list":{
                     
                  }
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_3/BiasAdd",
            "op":"BiasAdd",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_3/Conv2D",
               "StatefulPartitionedCall/sequential/conv2d_3/BiasAdd/ReadVariableOp"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/activation_3/Relu",
            "op":"Relu",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_3/BiasAdd"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/zero_padding2d_4/Pad",
            "op":"Pad",
            "input":[
               "StatefulPartitionedCall/sequential/activation_3/Relu",
               "StatefulPartitionedCall/sequential/zero_padding2d_4/Pad/paddings"
            ],
            "attr":{
               "Tpaddings":{
                  "type":"DT_INT32"
               },
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_4/Conv2D",
            "op":"Conv2D",
            "input":[
               "StatefulPartitionedCall/sequential/zero_padding2d_4/Pad",
               "StatefulPartitionedCall/sequential/conv2d_4/Conv2D/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "padding":{
                  "s":"VkFMSUQ="
               },
               "dilations":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               },
               "explicit_paddings":{
                  "list":{
                     
                  }
               },
               "strides":{
                  "list":{
                     "i":[
                        "1",
                        "1",
                        "1",
                        "1"
                     ]
                  }
               },
               "use_cudnn_on_gpu":{
                  "b":true
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/conv2d_4/BiasAdd",
            "op":"BiasAdd",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_4/Conv2D",
               "StatefulPartitionedCall/sequential/conv2d_4/BiasAdd/ReadVariableOp"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "data_format":{
                  "s":"TkNIVw=="
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/activation_4/Relu",
            "op":"Relu",
            "input":[
               "StatefulPartitionedCall/sequential/conv2d_4/BiasAdd"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/flatten_1/Reshape",
            "op":"Reshape",
            "input":[
               "StatefulPartitionedCall/sequential/activation_4/Relu",
               "StatefulPartitionedCall/sequential/flatten_1/Const"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               },
               "Tshape":{
                  "type":"DT_INT32"
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/activation_5/Relu",
            "op":"_FusedMatMul",
            "input":[
               "StatefulPartitionedCall/sequential/flatten_1/Reshape",
               "StatefulPartitionedCall/sequential/dense_1/MatMul/ReadVariableOp",
               "StatefulPartitionedCall/sequential/dense_1/BiasAdd/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "num_args":{
                  "i":"1"
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "fused_ops":{
                  "list":{
                     "s":[
                        "Qmlhc0FkZA==",
                        "UmVsdQ=="
                     ]
                  }
               },
               "transpose_a":{
                  "b":false
               },
               "epsilon":{
                  "f":0.0
               },
               "transpose_b":{
                  "b":false
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_2/BiasAdd",
            "op":"_FusedMatMul",
            "input":[
               "StatefulPartitionedCall/sequential/activation_5/Relu",
               "StatefulPartitionedCall/sequential/dense_2/MatMul/ReadVariableOp",
               "StatefulPartitionedCall/sequential/dense_2/BiasAdd/ReadVariableOp"
            ],
            "device":"/device:CPU:0",
            "attr":{
               "epsilon":{
                  "f":0.0
               },
               "num_args":{
                  "i":"1"
               },
               "T":{
                  "type":"DT_FLOAT"
               },
               "transpose_a":{
                  "b":false
               },
               "transpose_b":{
                  "b":false
               },
               "fused_ops":{
                  "list":{
                     "s":[
                        "Qmlhc0FkZA=="
                     ]
                  }
               }
            }
         },
         {
            "name":"StatefulPartitionedCall/sequential/dense_2/Softmax",
            "op":"Softmax",
            "input":[
               "StatefulPartitionedCall/sequential/dense_2/BiasAdd"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         },
         {
            "name":"Identity",
            "op":"Identity",
            "input":[
               "StatefulPartitionedCall/sequential/dense_2/Softmax"
            ],
            "attr":{
               "T":{
                  "type":"DT_FLOAT"
               }
            }
         }
      ],
      "library":{
         
      },
      "versions":{
         "producer":808
      }
   },
   "weightsManifest":[
      {
         "paths":[
            "group1-shard1of6.bin",
            "group1-shard2of6.bin",
            "group1-shard3of6.bin",
            "group1-shard4of6.bin",
            "group1-shard5of6.bin",
            "group1-shard6of6.bin"
         ],
         "weights":[
            {
               "name":"StatefulPartitionedCall/sequential/zero_padding2d_1/Pad/paddings",
               "shape":[
                  4,
                  2
               ],
               "dtype":"int32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_1/Conv2D/ReadVariableOp",
               "shape":[
                  7,
                  7,
                  1,
                  48
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_1/BiasAdd/ReadVariableOp",
               "shape":[
                  48
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/zero_padding2d_2/Pad/paddings",
               "shape":[
                  4,
                  2
               ],
               "dtype":"int32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_2/Conv2D/ReadVariableOp",
               "shape":[
                  5,
                  5,
                  48,
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_2/BiasAdd/ReadVariableOp",
               "shape":[
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/zero_padding2d_3/Pad/paddings",
               "shape":[
                  4,
                  2
               ],
               "dtype":"int32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_3/Conv2D/ReadVariableOp",
               "shape":[
                  5,
                  5,
                  32,
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_3/BiasAdd/ReadVariableOp",
               "shape":[
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/zero_padding2d_4/Pad/paddings",
               "shape":[
                  4,
                  2
               ],
               "dtype":"int32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_4/Conv2D/ReadVariableOp",
               "shape":[
                  5,
                  5,
                  32,
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/conv2d_4/BiasAdd/ReadVariableOp",
               "shape":[
                  32
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/flatten_1/Const",
               "shape":[
                  2
               ],
               "dtype":"int32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/dense_1/MatMul/ReadVariableOp",
               "shape":[
                  11552,
                  512
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/dense_1/BiasAdd/ReadVariableOp",
               "shape":[
                  512
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/dense_2/MatMul/ReadVariableOp",
               "shape":[
                  512,
                  361
               ],
               "dtype":"float32"
            },
            {
               "name":"StatefulPartitionedCall/sequential/dense_2/BiasAdd/ReadVariableOp",
               "shape":[
                  361
               ],
               "dtype":"float32"
            }
         ]
      }
   ]
}</source></spoiler>
Самое главное, что, начиная с этого момента, с нейросетью можно работать уже в <a href="https://www.tensorflow.org/js">TensorFlow.js</a>, в браузере, либо, с недавнего времени, и в <a href="https://nodejs.org/en/">Node.js</a>.

<source lang="javascript">
const tf = require('@tensorflow/tfjs');

model = await tf.loadLayersModel('https://games.dtco.ru/model/model.json');

board = new Float32Array(19 * 19);
const shape = [1, 1, 19, 19];
const d = tf.tensor4d(board, shape, 'float32');

const p = await model.predict(d);
const x = await p.data();

d.dispose();
p.dispose();
</source>
Здесь, как человек неопытный, я некоторое время потупил с размерностью тензора с входными данными, пока не понял, что можно передавать по нескольку досок за раз. Вторая по счёту единичка - это количество слоёв входных данных. Об этом я ещё скажу позже, пока что же, модель использует однослойное кодирование: свои камни на доске кодируются 1, камни противника -1, а пустые пункты 0. На выходе получаем массив из 361 элемента (слева-направо и сверху-вниз по доске), содержащие вероятности того, что следующий ход будет выполнен именно в этот пункт.

<spoiler title="Обратите внимание на dispose">
Tensorflow.js может использовать различные <a href="https://www.tensorflow.org/js/guide/platform_environment">бакенды</a>, радикально различающиеся в плане производительности. Самый простой и доступный из них - 'cpu', в то же время и самый медленный. Вся ресурсоёмкая математика выполняется в нём непосредственно JavaScript-ом. Немного побыстрее 'wasm', который удалось подключить, при помощи следующих манипуляций:

<source lang="javascript">
const URL = 'https://games.dtco.ru/model/model.json';

const tf = require('@tensorflow/tfjs'); 
const wasm = require('@tensorflow/tfjs-backend-wasm');

await tf.enableProdMode();
await tf.setBackend('wasm');

model = await tf.loadLayersModel(URL);
console.log(tf.getBackend());
</source>
и экспериментального флага --experimental-worker в <a href="https://github.com/GlukKazan/GoBot/blob/master/package.json">package.json</a>. По хорошему, этот вопрос следовало решать обновлением версии Node.js, но на сервере, на этот момент, уже много чего крутилось и не хотелось предпринимать эксперименты, связанные с его возможным падением. Сразу скажу, что переход на бакенд "wasm" полностью себя оправдал, каждый запрос стал обрабатываться, в среднем, за 300 мс, вместо полутора секунд.

Более продвинутые бакенды пощупать не удалось, поскольку подходящих к использованию видеокарт на виртуалке доступно не было. Именно с этими бакендами связана необходимость ручного освобождения памяти. Дело в том, что при их использовании, для хранения весов модели используются текстуры WebGL, освобождать которые автоматически JavaScript не умеет.
</spoiler>
Начиная с этого момента, <a href="https://github.com/GlukKazan/GoBot">бот</a> заработал, но это было не очень увлекательно. Бот просто выполнял ход, выбирая случайным образом одну из наиболее вероятных позиций, но для того чтобы понять, какие альтернативы были у этого хода, приходилось лезть в лог. Настало время задуматься о визуализации.

<a href="https://dagazproject.github.io/go/go-19x19-advisor.htm">
<img align="center" src="https://habrastorage.org/webt/qv/nw/f-/qvnwf-8tsfob0dn7t1nbspqt5mq.png" /></a>
Идея нехитрая - просто собираем наиболее вероятные ходы и передаём их все скопом в UI, для отображения. На пустой доске (перейдя по <a href="https://dagazproject.github.io/go/go-19x19-advisor.htm">ссылке</a> надо немного подождать) видим одну звезду (сейчас их больше), что наводит на мысли. Доска-то у нас симметричная!

<h3>Кручу-верчу, запутать хочу</h3>
Ход в правый верхний звёздный пункт ("<a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points3.html">хоси</a>"), считается, в определённой степени, традиционным. Играя туда, где у оппонента "находится сердце", первый игрок проявляет своё уважение. Сервер KGS - это, несомненно, то самое место, где традиции соблюдаются. Конечно, помимо "хоси", хотелось бы видеть "<a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points4.html">комоку</a>", "<a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points5.html">такамоку</a>", "<a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points2.html">сан-сан</a>" и "<a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points6.html">мокухадзуси</a>", но здесь, по всей видимости, свою негативную роль сыграло крайне малое количество партий, на которых производилось обучение.

<spoiler title="Отражения и повороты">
<source lang="javascript">
const SIZE = 19;

function flipX(pos) {
    const x = pos % SIZE;
    pos -= x;
    return pos + (SIZE - x - 1);
}

function flipY(pos) {
    const y = (pos / SIZE) | 0;
    pos -= y * SIZE;
    return (SIZE - y - 1) * SIZE + pos;
}

function toRight(pos) {
    const x = pos % SIZE;
    const y = (pos / SIZE) | 0;
    return x * SIZE + (SIZE - y - 1);
}

function toLeft(pos) {
    const x = pos % SIZE;
    const y = (pos / SIZE) | 0;
    return (SIZE - x - 1) * SIZE + y;
}
</source></spoiler>
Идеально обученная нейросеть выдавала бы одинаковый, с учётом поворота или отражения, ответ, вне зависимости от ориентации доски, но обучение нашей модели очень далеко от идеала. Если после поворота или отражения доски сеть выдаёт другой ответ, из соображений симметрии понятно, что предложенный ей ход так же хорош как и ход, полученный для оригинальной позиции. Это даёт нам 8 начальных ориентаций доски - своего рода различные точки зрения на одну и ту же позицию. Разумеется, при симметричном расположении камней, часть из них может совпадать друг с другом (так, для пустой доски, все 8 начальных позиций совпадают). 

Кроме того, в Го существует эмпирическое правило: "лучший ход противника - это и твой лучший ход", которое действует не всегда, но достаточно часто. Изменяя знак в начальной расстановке камней, получаем ещё 8 позиций. Чтобы как-то отличить эти ходы от обычных, я отображаю их на доске другим цветом. Наиболее вероятные ходы отображаются крупными звёздами, менее вероятные мелкими:

<a href="https://dagazproject.github.io/go/go-19x19-advisor-board.htm?turn=1;&setup=991/991/95b4/3w93b2/991/991/991/991/991/991/991/991/991/991/3w92b3/94w5/97b2/991/991">
<img align="center" src="https://habrastorage.org/webt/ub/5y/if/ub5yifprm_tow7lvx_klndy5paw.png" /></a>
Есть ещё один важный момент, о котором стоит упомянуть. Своей игрой бот, в настоящее время, напоминает игрока с хорошей интуицией, но крайне рассеянного. Действуя по наитию, он бросается от одного тактического плана к другому, не доводя ни один из них до конца. Более того, поскольку, как я уже писал выше, модель недостаточно хорошо обучена, она вполне может порекомендовать ход, <a href="https://ru.wikipedia.org/wiki/Го#Запрещённые_действия">запрещённый</a> правилами игры - самоубийственный или просто на пункт уже занятый камнем. Что касается <a href="https://ru.wikipedia.org/wiki/Правило_ко">правила Ко</a>, то для его выполнения необходимо передавать боту дополнительную информацию - пункт, ход в который запрещён.

Хорошие ходы в Го можно разделить на "большие" и "срочные". Большие ходы позволяют эффективно захватывать территорию, срочные - защищают построения игрока от захвата и разрушения. Чтобы не проиграть с разгромным счётом, срочные ходы следует делать прежде больших. И как раз с этим у бота проблемы. Большие ходы модель предсказывает неплохо, но на явные угрозы практически не реагирует. Помимо интуиции, боту не помешают "безусловные рефлексы". Чтобы видеть эти рекомендации, я добавил в визуализацию зелёные звёзды. Крупная зелёная звезда, это ход, который бот выберет, даже не обращаясь за помощью к нейросети.

<spoiler title="Основную работу выполняет вот эта функция">
<source lang="javascript">
function analyze(board) {
    let m = []; let r = []; let done = [];
    for (let p = 0; p < SIZE * SIZE; p++) {
        if (!isEmpty(board[p])) continue;
        if (_.indexOf(done, p) >= 0) continue;
        let g = [p]; let c = null; let e = [];
        for (let i = 0; i < g.length; i++) {
            m[ g[i] ] = r.length;
            done.push(g[i]);
            _.each([1, -1, SIZE, -SIZE], function(dir) {
                let q = navigate(g[i], dir);
                if (q < 0) return;
                if (_.indexOf(g, q) >= 0) return;
                if (isEnemy(board[q])) {
                    if (c === null) c = -1;
                    if (isFriend(c)) c = 0;
                    if (_.indexOf(e, q) < 0) e.push(q);
                    return;
                }
                if (isFriend(board[q])) {
                    if (c === null) c = 1;
                    if (isEnemy(c)) c = 0;
                    if (_.indexOf(e, q) < 0) e.push(q);
                    return;
                }
                g.push(q);
            });
        }
        r.push({
            type:  0,
            group: g,
            color: c,
            edge:  e
        });
    }
    for (let p = 0; p < SIZE * SIZE; p++) {
        if (_.indexOf(done, p) >= 0) continue;
        let f = isFriend(board[p]);
        let g = [p]; let d = []; let y = []; let e = [];
        for (let i = 0; i < g.length; i++) {
            m[ g[i] ] = r.length;
            done.push(g[i]);
            _.each([1, -1, SIZE, -SIZE], function(dir) {
                let q = navigate(g[i], dir);
                if (q < 0) return;
                if (_.indexOf(g, q) >= 0) return;
                if (isFriend(board[q])) {
                    if (!f) {
                        if (_.indexOf(e, q) < 0) e.push(q);
                        return;
                    } else {
                        if (_.indexOf(g, q) < 0) g.push(q);
                    }
                } else if (isEnemy(board[q])) {
                    if (f) {
                        if (_.indexOf(e, q) < 0) e.push(q);
                        return;
                    } else {
                        if (_.indexOf(g, q) < 0) g.push(q);
                    }
                } else {
                    if (_.indexOf(d, q) < 0) d.push(q);
                    let ix = m[q];
                    if (_.isUndefined(ix)) return;
                    if (!isEmpty(r[ix].type)) return;
                    if (f) {
                        if (isFriend(r[ix].color)) {
                            if (_.indexOf(y, q) < 0) y.push(q);
                            r[ix].isEye = true;
                        }
                    } else {
                        if (isEnemy(r[ix].color)) {
                            if (_.indexOf(y, q) < 0) y.push(q);
                            r[ix].isEye = true;
                        }
                    }
                }
            });
        }
        r.push({
            type:  f ? 1 : -1,
            group: g,
            dame:  d,
            eyes:  y,
            edge:  e
        });
    }
    return {
        map: m,
        res: r
    }
}
</source>
Она строит, своего рода "карту доски", разделяя её на связные области. Для групп камней одного цвета учитываются <a href="http://go-igo.ru/dictionary-go/dame.html">дамэ</a>, а для пустых пунктов ограничивающие камни. Если группа пустых пунктов граничит с камнями одного цвета, она считается <a href="http://go-igo.ru/theory/20kudoc-d49/where-terr.html">территорией</a>.

<source>
0  0  0  0  0  0  0  0  0  0  0  0  0  7  0  0  0  0  0 
0  0  8  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
0  9  1 10 10  0  0 11  0  0  0  0  0 12  0  0  0  0  0 
0  0 13  2 10  0  0  0  0  0  0  0  0  0  0 14  0  0  0 
0  0 13 13  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
0  0  0 13  0 15  0  0  0  0  0  0  0  0  0  0  0  0  0 
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 16  0  0  0 
0  0 17  0  0  0  0  0 18  0 19 19  0 20  0 16 21  0  0 
0  0  0  0  0  0  0  0  0 22 23 19 24 24 25 21 21  0  0 
0  0  0  0  0  0  0  0  0 22 23 23 26 26  3 27  0  0  0 
0  0  0  0  0  0  0  0  0 28  4 23 23 26  3  3 29  0  0 
0  0  0  0  0  0  0  0  0  0 30 29 23 23 29  3 29  0  0 
0  0  0  0  0  0  0  0  0  0  0 29 29 29 29 29 29  0  0 
0  0  0  0  0 31  0  0  0  0  0 32 32 29 33 33 29 34  0 
0  0  0  0  0 35 36  0 37  0  0  0 38  0 33 39  5 40 40 
0  0  0  0 41  0  0 42  0  0  0  0  0  0  0 39  5  5  5 
0  0  0  0  0  0 42 42  0 43  0  0  0  0 44  6 45 45 45 
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 46 47  0  0 
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
</source></spoiler>
Далее, в ход идут различного рода эвристики. Например, если бот видит несколько групп камней противника в положении "<a href="http://go-igo.ru/dictionary-go/atari.html">атари</a>", он постарается захватить ту из них, которая больше размером. Если под "атари" находится группа камней бота, он постарается спасти её, но только при условии, что своим ходом он увеличивает количество "<a href="http://go-igo.ru/dictionary-go/dame.html">дамэ</a>" группы и при этом не выходит на первую линию. Бот не будет заполнять камнями <a href="https://www.pandanet.co.jp/English/learning_go/learning_go_7.html">глаза</a> своих групп и, по возможности, постарается поставить противнику двойное "атари". Вообще, здесь есть большой простор для творчества. Можно определять ситуации "<a href="http://go-igo.ru/dictionary-go/geta.html">гэта</a>" и "<a href="https://www.sente.ru/2007/08/sityo/">ситё</a>", просчитывать "<a href="https://sport.wikireading.ru/7414">защёлки</a>", определять хорошие и плохие формы. И конечно, это та часть кода, которую просто необходимо покрыть <a href="https://github.com/GlukKazan/Dagaz/blob/master/tests/gobot-test.js">юнит-тестами</a>. Серьёзно, они <a href="https://github.com/GlukKazan/Dagaz/commits/master/tests/gobot.js">уже</a> помогли мне исправить несколько серьёзных багов! 

<h3>Аппетит приходит во время еды</h3>
После конвертации из <a href="https://keras.io/">Keras</a>, я получил модель, которую загружаю при помощи <a href="https://js.tensorflow.org/api/latest/#loadLayersModel">loadLayersModel</a>, но TensorFlow.js умеет работать и с <a href="https://js.tensorflow.org/api/latest/#loadGraphModel">GraphModel</a> тоже. В чём разница? GraphModel работает немного быстрее. Зато LayersModel можно дообучать в процессе использования. Разумеется, мне захотелось сделать это сразу же, как только я узнал об этом. Во многом пришлось действовать методом тыка (а также чтения <a href="https://www.tensorflow.org/js/tutorials">документации</a>) и вот к чему я пришёл:

<source lang="javascript">
board = new Float32Array(N * 19 * 19);
...
const xshape = [N, 1, 19, 19];
const xs = tf.tensor4d(board, xshape, 'float32');
const yshape = [N, 19 * 19];
const ys =  tf.tensor2d(y, yshape, 'float32');
</source>
Здесь я заполняю сразу N начальных расстановок камней и соответствующие им N лучших ходов, в том же формате, в котором их отдаёт модель. Где взять данные для обучения? У нас есть <a href="https://games.dtco.ru/launch/17/2">сервер</a>, на котором люди могут играть <a href="https://dagazproject.github.io/go/go-19x19-advisor-board.htm">друг с другом</a> или <a href="https://dagazproject.github.io/go/go-19x19-advisor.htm">против бота</a>. Никто не мешает мне сохранять сделанные ходы в БД, для последующего обучения модели. Ладно-ладно, ещё у нас есть <a href="https://u-go.net/gamerecords/">записи игр</a> c KGS-сервера, из которых Макс Памперла и Кевин Фергюсон использовали всего 100 партий (их там намного, намного больше). В общем, я сделал <a href="https://github.com/GlukKazan/SGFLoader">загрузчик</a>, для разбора <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>-файлов и последующей подготовки данных для обучения бота.

<source lang="javascript">
const model = await tf.loadLayersModel(URL);
model.compile({optimizer: 'sgd', loss: 'categoricalCrossentropy', metrics: ['accuracy']});
</source>
Хотя в сохранённой <a href="https://games.dtco.ru/model/model.json">модели</a> имеются данные о настройках оптимизатора, если перед обучением не сказать ей "compile", дело кончится сообщением об ошибке. Ситуацию несколько оживляет тот факт, что одни и те же вещи в Keras и Tensorflow.js записываются немного по-разному. К счастью, на сайте Tensorflow имеется исчерпывающий <a href="https://www.tensorflow.org/js/guide/layers_for_keras_users">документ</a> на эту тему.

<source lang="javascript">
const h = await model.fit(xs, ys, {
    batchSize: 100,
    epochs: 3,
    validationSplit: 0.1
});    
xs.dispose();
ys.dispose();
</source>
Следующим, о чём следовало позаботиться, стало сохранение обученной модели. Здесь меня подстерегала <a href="https://github.com/tensorflow/tfjs/issues/723">засада</a>. Вероятно, это связано с тем, что изначально Tensorflow.js разрабатывался для использования в браузерах, а не в Node.js, но "из коробки" простое сохранение на диск не работало. К счастью, Google помог справиться с этой проблемой:

<source lang="javascript">
const {nodeFileSystemRouter} = require('@tensorflow/tfjs-node/dist/io/file_system');
...
tf.io.registerLoadRouter(nodeFileSystemRouter);
tf.io.registerSaveRouter(nodeFileSystemRouter);
...
await model.save(`file:///tmp/${savePath}`);
</source>
Разумеется, работы здесь ещё непочатый край. Можно экспериментировать с размерами батча и количеством эпох. Часть слоёв можно "заморозить", чтобы улучшить производительность обучения (имеет смысл сделать это для свёрточных слоёв модели, поскольку именно они выполняют всю черновую позицию по определению "хороших" и "плохих" форм). Сколько и каких слоёв замораживать - это тоже подходящая тема для экспериментов. Даже простое разделение данных на обучающие и тестовые - далеко не такая простая задача, как может показаться на первый взгляд. Позиции, загруженные в рамках одной партии, зависят друг от друга. Выбор тестовых данных из той же серии может создать иллюзию эффективности обучения модели.

<spoiler title="Пока что, результаты обучения выглядят следующим образом">
<source>
{
  "validationData":null,
  "params":
  {
    "epochs":3,
    "initialEpoch":0,
    "samples":900,
    "steps":null,
    "batchSize":100,
    "verbose":1,
    "doValidation":true,
    "metrics":
    [
      "loss",
      "acc",
      "val_loss",
      "val_acc"
    ]
  }
,
  "epoch":
  [
    0,
    1,
    2
  ]
,
  "history":
  {
    "val_loss":
    [
      6.965572357177734,
      6.191959381103516,
      6.181119918823242
    ]
,
    "val_acc":
    [
      0.019999999552965164,
      0.029999999329447746,
      0.019999999552965164
    ]
,
    "loss":
    [
      9.069977760314941,
      5.387154579162598,
      4.876873970031738
    ]
,
    "acc":
    [
      0.018888888880610466,
      0.057777777314186096,
      0.09222222119569778
    ]
  }
}</source></spoiler>
На обработку этой тысячи позиций потребовалось более 6 минут, с использованием "wasm"-бакенда. Машинное обучение - это тот вид деятельности, в которой производительность имеет первостепенное значение.

<h3>Что дальше?</h3>
Хотя игра бота и выглядит разумной, она очень далека от идеала. К сожалению, используемую в настоящий момент модель можно обучать лишь до определённого предела. В процессе обучения,  качество её игры будет улучшаться всё меньше и меньше. Кроме того, существует проблема возможного <a href="https://wiki.loginom.ru/articles/overtraining.html">переобучения</a>. Бороться с этим можно только изменяя топологию модели, экспериментируя с количеством слоёв, фильтров, функциями активации и прочим. Также, следует подумать о более адекватном представлении входных данных. Используемая в настоящий момент однослойная схема кодирования - не лучший выбор. Мы можем передавать модели гораздо больше полезных данных.

<spoiler title="Можно использовать следующие слои">
<ul>
	<li>Группы вражеских камней с одним  дамэ (которые можно захватить одним ходом)</li>
	<li>Группы вражеских камней с двумя дамэ</li>
	<li>Группы вражеских камней с тремя дамэ и более</li>
	<li>Группы своих камней с одним дамэ (защищать эти группы необходимо не всегда, но очень часто)</li>
	<li>Группы своих камней с двумя дамэ (угроза атари)</li>
	<li>Группы своих камней с тремя дамэ и более (камни в относительной безопасности)</li>
	<li>Пункты, ход на которые запрещён (по крайней мере, правилом Ко)</li>
	<li>Пункты, ход на которые подсказывают "безусловные рефлексы"</li>
</ul>
Два последних слоя - в определённой степени, чит. При достаточном обучении, модель должна "разобраться" во всём сама, но это упирается в вычислительные ресурсы. Если дополнительная информация позволит ускорить обучение, почему бы её не передавать? Функция <a href="https://github.com/GlukKazan/GoBot/blob/master/go.js#L113">analyze</a> всё равно её собирает.
</spoiler>
Другой важный момент - завершение игры. Ближе к концу партии, полезных ходов становится всё меньше, а "больших" ходов не остаётся вовсе. Эта фаза игры называется <a href="https://ru.wikipedia.org/wiki/Ёсэ_(го)">ёсэ</a> и в ней разыгрываются последние очки. Когда ходов не остаётся вовсе, один из игроков говорит "пас" и пропускает ход. Если, вслед за ним, "пас" говорит и его противник, игра завершается и начинается фаза <a href="https://ru.wikipedia.org/wiki/Варианты_правил_го#Способ_подсчёта_очков">подсчёта очков</a>. Бот, в настоящее время, "пас" говорить не умеет, а вместо этого начинает делать глупые ходы, заполняя свою территорию. Эту проблему можно решить, добавив дополнительный, 362-ой пункт в массив выходных данных. Единичка в этом пункте будет означать, что модель пропускает ход. 

<spoiler title="На самом деле, ход предложенный моделью не должен применяться непосредственно">
Даже в случае хорошо обученной модели, такой подход слишком оптимистичен. Во всяком случае, ни <a href="https://ru.wikipedia.org/wiki/AlphaGo">Alpha Go</a> ни <a href="https://ru.wikipedia.org/wiki/AlphaGo#AlphaGo_Zero">AlphaGo Zero</a> так не делают. Вместо этого, рекомендации нейросети предоставляют веса лишь для априорной оценки ходов из текущей позиции. Далее, Alpha Go использует "сильную" модель для формирования набора начальных ходов и "быструю" для доигрывания. 

Этот подход очень требователен к производительности. Для качественной работы <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">MCTS</a>, партия должна быть доиграна до конца тысячи раз. Разумеется, это далеко за пределами моих вычислительных возможностей. Доигрывание можно выполнять всего на несколько ходов вперёд, но оценка промежуточной позиции в Го также является не тривиальной задачей. В Alpha Go, для этой цели, используется третья модель - "оценки".

С моделью оценки связана ещё одна важная возможность. Помимо штатного завершения игры, хороший бот должен уметь признавать своё поражение. Это часть этикета Го - видя своё неминуемое поражение, игрок должен вовремя завершить партию, не злоупотребляя более личным временем победителя. При этом, не следует сдаваться слишком рано, пока ещё остаётся возможность для победы.
</spoiler>
Также, очевидным моментом является то, что никакое "обучение с учителем" не способно натренировать сеть так, чтобы она играла лучше тех людей, на партиях которых её обучали. Эту высоту можно покорить лишь используя "<a href="https://ru.wikipedia.org/wiki/Обучение_с_подкреплением">обучение с подкреплением</a>" таким образом, как это делают <a href="https://ru.wikipedia.org/wiki/AlphaGo">Alpha Go</a> и <a href="https://ru.wikipedia.org/wiki/AlphaGo#AlphaGo_Zero">AlphaGo Zero</a>. Бот должен сыграть сам с собой миллионы партий, чтобы выйти на их уровень. Разумеется, для простого смертного, эта цель недостижима, но обучение с подкреплением вполне можно использовать для более простых игр, таких как "<a href="https://dagazproject.github.io/go/atari-go.htm">Атари Го</a>" или <a href="https://dagazproject.github.io/arrange/hex-board.htm">Hex</a> на небольших досках. Есть много хороших задач, чтобы потренироваться.
</cut>

День программиста на носу

<img align="left" src="https://habrastorage.org/webt/75/kd/bi/75kdbi-osphj-ey74rcrpg3dxjm.png" />Думаю, ни для кого не секрет, какой именно праздник собирается отмечать вся прогрессивная часть общественности 13 сентября сего года. Вот и мы решили отметить. Мы - это компания ТЕНЕТ г.Казань. Отмечать будем путём проведения хакатона (с 11 по 12 сентября) и последующего турнира. Будем писать бота для настольной игры. Все желающие могут поучаствовать в режиме online. Призы будут (мы просто пока не решили какие именно). Подробности под катом.
<cut>
<h3>Правила игры</h3>
Игра "<a href="https://www.chessvariants.com/small.dir/alapo.html">Alapo</a>" была придумана Йоханессом Транелисом в 1982 году. Её описание включено в <a href="https://www.amazon.com/Encyclopedia-Chess-Variants-David-Pritchard/dp/0952414201">знаменитую энциклопедию</a> шахматных игр, составленную Дэвидом Притчардом. Игра проводится на квадратной доске 6x6 полей. В игре участвуют три типа геометрических фигур: треугольник, квадрат и круг, большого и маленького размеров.

<a href="https://glukkazan.github.io/breakthrough/alapo.htm">
<img align="center" src="https://habrastorage.org/webt/0f/ri/zl/0frizl4s4kg6sogk8py539fl3ia.png" /></a>
Игроки по очереди перемещают по одной фигуре своего цвета. Правила перемещения фигур похожи на <a href="https://ru.wikipedia.org/wiki/Шахматы">шахматные</a>. Большие квадраты перемещаются как ладьи – на произвольное количество полей по вертикали или горизонтали. Большие треугольники двигаются как слоны – на произвольное количество полей по диагонали. Большие круги совмещают в себе два этих типа хода, перемещаясь по доске как шахматные ферзи. Малые фигуры перемещаются в тех же направлениях, но только на одну соседнюю клетку. Бой фигур шахматный – если ход завершается на поле занятом вражеской фигурой, она убирается с доски до конца игры.

Фигуры не превращаются. Цель игры – достижение противоположной стороны доски любой из своих фигур. Фигура на последней линии – своего рода <a href="https://ru.wikipedia.org/wiki/Шах_(шахматы)">шах</a> противнику, он обязан побить эту фигуру следующим ходом, если имеет такую возможность. В противном случае, он проигрывает. Также, игрок будет считаться проигравшим, если все его фигуры будут побиты. Можно потренироваться в игре, перейдя по следующей <a href="https://glukkazan.github.io/breakthrough/alapo.htm">ссылке</a>.

<h3>Проведение турнира</h3>
Для проведения турнира будет использована платформа <a href="https://games.dtco.ru/map">DagazServer</a>. Всем участникам необходимо зарегистрировать учётную запись на сервере, перейдя по следующей <a href="https://games.dtco.ru/reg">ссылке</a>. В целях отладки, рекомендуется зарегистрировать по две учётных записи на каждого участника.

<a href="https://games.dtco.ru/reg">
<img align="center" src="https://habrastorage.org/webt/m6/m6/db/m6m6dbd9umyltxixcvut_b0j8iw.png" /></a>
После регистрации учётной записи, можно войти в систему, указав логин и пароль. Впоследствии, параметры учётной записи могут быть изменены, на <a href="https://games.dtco.ru/profile">странице</a> профиля. Участники турнира могут указать в профиле свой EMail, с целью облегчения обратной связи. Указанный адрес электронной почты не будет использоваться в рекламных целях, и не будет передаваться третьим лицам. 

После регистрации учётной записи, участникам потребуется зарегистрироваться для участия в турнире. Для этого, потребуется зайти в систему под учётной записью, от имени которой будет играть бот, и перейти по следующей <a href="https://games.dtco.ru/tournament/30/134">ссылке</a>. 

<a href="https://games.dtco.ru/tournament/30/134">
<img align="center" src="https://habrastorage.org/webt/ce/zm/tf/cezmtfpl07kgtrt1pewlaauihyq.png" /></a>
При переходе по ссылке "Alapo", система предложит присоединить учётную запись к турниру. Турнир будет проводиться по <a href="https://ru.wikipedia.org/wiki/Круговая_система">круговой системе</a>. Право первого хода, в каждой партии, будет определяться случайным образом. В процессе проведения турнира, будет фиксироваться количество сыгранных игр, побед и поражений, а также вестись <a href="https://ru.wikipedia.org/wiki/Рейтинг_Эло">Elo-рейтинг</a> игроков. Игрок набравший максимальное количество побед, при минимальном количестве поражений, будет считаться победителем турнира. При наличии более чем одного игрока, с одинаковым количеством побед и поражений, будет проведён дополнительный турнир среди претендентов, до выявления единственного победителя.

С целью ограничения продолжительности турнира, будет вестись контроль времени. Каждому игроку, в игре, будет выделено по 30 минут основного времени и по 20 секунд дополнительного времени на каждый ход, по истечении основного лимита времени. Игрок нарушивший регламент контроля времени будет автоматически считаться проигравшим. Попытка выполнения игроком хода нарушающего правила игры также будет приводить к немедленному поражению.

<h3>Взаимодействие с сервером</h3>
Взаимодействие с игровой платформой осуществляется по <a href="https://games.dtco.ru/api/swagger/">REST API</a>. С целью упрощения процесса разработки и отладки ботов, на время проведения турнира и хакатона, будет открыт HTTP доступ к серверу. Поскольку сервер использует <a href="https://ru.wikipedia.org/wiki/JSON_Web_Token">JWT</a>, первое, что должен сделать бот при подключении к серверу – это авторизация.

<source lang="javascript">
axios.post(SERVICE + '/api/auth/login', {
    username: USERNAME,
    password: PASSWORD
})
.then(function (response) {
  TOKEN = response.data.access_token;
  app.state = STATE.TURN;
});
</source>
Полученный <b>access_token</b> должен использоваться в каждом последующем запросе. Авторизовавшись в системе, бот должен получить игровую сессию, в рамках которой ожидается его ход:

<source lang="javascript">
axios.get(SERVICE + '/api/session/current/134', {
    headers: { Authorization: `Bearer ${TOKEN}` }
})
.then(function (response) {
    if (response.data.length > 0) {
        sid = response.data[0].id;
        setup = response.data[0].last_setup;
    }
});
</source>
Магическое число в URL-е - идентификатор игры (их на сервере много и будет лучше если бот будет интересоваться только теми играми, в которые умеет играть). Бот не должен предпринимать никаких действий при получении пустого набора строк. Каждая полученная строка будет соответствовать сессии на сервере, в которой от бота ожидается очередной ход. Бот может выбрать любую из полученных строк, сохранив её идентификатор (<b>sid</b>) и описание расстановки фигур в текущей позиции (<b>setup</b>) . Если это поле пусто , бот должен игнорировать игровую сессию до тех пор, пока поле <b>setup</b> не будет заполнено. 

Далее, бот должен получить идентификатор игрока (<b>uid</b>), который должен использоваться для передачи ходов в эту игру. С момента выполнения этого запроса и вплоть до момента передачи на сервер очередного хода лимит времени игрока на сервере будет расходоваться. Если лимит основного и дополнительного времени будет израсходован до получения хода, партия будет прервана, в связи с нарушением регламента контроля времени.

<source lang="javascript">
axios.post(SERVICE + '/api/session/recovery', {
    id: sid,
    setup_required: true,
    ai: true
}, {
    headers: { Authorization: `Bearer ${TOKEN}` }
})
.then(function (response) {
    uid = response.data.uid;
});
</source>
Рассчитав очередной ход, бот должен передать его на сервер . В этом запросе, описание расстановки фигур, полученное после выполнения хода не должно передаваться, поскольку ход будет проверяться арбитром . Арбитр, в любом случае, будет вычислять очередную расстановку фигур и разработчику бота не имеет смысла тратить на это своё время.

<source lang="javascript">
axios.post(SERVICE + '/api/move', {
     uid: uid,
     move_str: move
}, {
     headers: { Authorization: `Bearer ${TOKEN}` }
});
</source>
После этого, бот может вернуться к получению списка сессий, в которых ожидается его очередной ход .

В рамках проведения турнира, участники могут использовать любой язык программирования для разработки ботов. В случае использования JavaScript, в качестве языка разработки, участникам будет предоставлен скелетный <a href="https://github.com/GlukKazan/AlapoBot">проект</a> бота, для запуска его в среде <a href="https://nodejs.org/en/">Node.js</a>.

<h3>Используемые нотации</h3>
Для передачи боту текущей расстановки фигур используется облегчённая <a href="https://ru.wikipedia.org/wiki/Нотация_Форсайта_—_Эдвардса">нотация Форсайта-Эдвардса</a>, в соответствии с которой позиция кодируется построчно, с использованием символа ‘/’, в качестве разделителя. Цифры, от 1 до 6 обозначают последовательности пустых полей, латинские буквы нижнего регистра – чёрные фигуры, а верхнего – белые. Поскольку в игре нет рокировок и взятия на проходе, соответствующие разделы FEN-нотации опускаются. Таким образом, начальная позиция игры кодируется следующим образом:

<code>
rbqqbr/wfkkfw/6/6/WFKKFW/RBQQBR w</code>

Фигуры, соответствующие шахматному слону (<b>B</b>), ладье (<b>R</b>) и ферзю (<b>Q</b>), обозначаются в соответствии с соглашениями принятыми в шахматном сообществе. Для обозначения фигур перемещающихся на одно поле использованы обозначения <a href="https://en.wikipedia.org/wiki/Betza%27s_funny_notation">нотации Betza</a>: фигура перемещающаяся ортогонально – Wazir (<b>W</b>), по диагонали перемещается Ferz (<b>F</b>), а движение во всех 8 направлениях соответствует ходу короля (<b>K</b>). Следует отметить, что хотя маленькие круги в Alapo перемещаются как шахматный король, в игре они не имеют никакого специального значения – защита этих фигур от возможных угроз не является обязательной.

Для кодирования ответных ходов бота используется алгебраическая <a href="https://ru.wikipedia.org/wiki/Шахматная_нотация">шахматная нотация</a>. Столбцы доски обозначаются буквами латинского алфавита от '<b>a</b>' до '<b>f</b>', горизонтали, снизу-вверх, пронумерованы от <b>1</b> до <b>6</b>. Обозначение каждого поля состоит из буквы и цифры. Таким образом, любой ход кодируется обозначениями начальной и конечной позиций, разделёнными символом '<b>-</b>', без пробелов. Например, одним из возможных ходов, из начальной позиции, является '<b>a2-a3</b>'. Обратите внимание на то, что соблюдение этих нотаций очень важно для разработчика бота. Все ходы, передаваемые ботами на сервер, контролируются арбитром. Ход, который не удастся корректно декодировать будет расценен как некорректный, что приведёт к немедленному поражению сформировавшего его бота.

<h3>Рекомендации по разработке бота</h3>
Разработка ботов для шахматных игр имеет давнюю историю. Уже в 1769 году, для развлечения королевы Марии-Терезии, был создан “Механический турок”, предназначенный для игры в шахматы. Разумеется, это было <a href="https://ru.wikipedia.org/wiki/Компьютерные_шахматы">жульничество</a>. Внутри машины сидел живой гроссмейстер. С появлением компьютеров идея обрела второе дыхание. Знаменитые математики Алан Тьюринг и Клод Шеннон стояли у истоков этого движения. Первая компьютерная программа была создана в 1952 году и была предназначена для упрощённого <a href="https://ru.wikipedia.org/wiki/Шахматы_Лос-Аламос">варианта шахмат</a>, на доске 6x6, без шахматных слонов. В настоящее время, существуют три основных подхода к разработке ботов для абстрактных настольных игр с полной информацией:

<ul>
	<li>Минимаксные алгоритмы</li>
	<li>Метод Монте-Карло</li>
	<li>Использование нейросетей и глубокого обучения</li>
</ul>
Начнём с нейросетей. Это самое молодое и, в настоящий момент, наиболее перспективное направление в разработке игровых ботов. Хотя исследования в этой области ведутся ещё <a href="https://ru.wikipedia.org/wiki/Нейронная_сеть#Хронология">с 40-ых годов</a> прошлого века, подлинный триумф нейросетей произошёл в марте 2016 года, когда AlphaGo – программа разработанная компанией Google DeepMind победила обладателя 9-го профессионального дана в игре <a href="https://ru.wikipedia.org/wiki/Го">Го</a>, Ли Седоля со счётом <a href="https://ru.wikipedia.org/wiki/AlphaGo">4:1</a>. В последующем, этот подход был усовершенствован и обобщён на другие игры, в рамках проекта <a href="https://ru.wikipedia.org/wiki/AlphaZero">AlphaZero</a>. В настоящее время существуют и другие, распространяемые под открытой лицензией проекты, по использованию глубокого обучения в настольных играх, такие как <a href="https://github.com/maxpumperla/betago">BetaGo</a> и <a href="https://github.com/LeelaChessZero/">Leela Chess Zero</a>. К сожалению, использование нейросетей крайне ресурсоёмко. Разработка и особенно обучение нейросети для новой игры с нуля – это не та работа, которую можно выполнить за два дня. Тем, кто интересуется этой темой, могу порекомендовать книгу Макса Памперла и Кевина Фергюсона "<a href="https://www.labirint.ru/books/725227/">Глубокое обучение и игра Го</a>", подробно разбирающую особенности и механизмы работы проектов Alpha Go и Alpha Go Zero.

Минимаксные алгоритмы – исторически самое раннее и наиболее развитое направление в разработке игровых ботов для абстрактных игр. Первоначально, критерий минимакса был сформулирован Джеймсом Уолдгрейвом в 1713 году. Впоследствии, Джоном фон Нейманом, в 1928, была <a href="https://ru.wikipedia.org/wiki/Минимакс">доказана теорема Неймана-Моргенштерна о минимаксе</a>, что послужило отправной точкой в становлении теории игр в качестве самостоятельного раздела математики. На практике, применение минимакса связано с различными оптимизациями, наиболее известной из которых является <a href="https://ru.wikipedia.org/wiki/Альфа-бета-отсечение">Альфа-бета-отсечение</a>.

Применение минимаксного алгоритма с альфа-бета отсечением является наиболее очевидным решением, в приложении к нашей задаче. В качестве отправной точки, можно использовать исходный код шахматного бота <a href="https://github.com/glinscott/Garbochess-JS">GarboChess-JS</a>. Это не самый сильный, на настоящий момент, шахматный движок, но важным его достоинством является наличие открытого и понятного исходного кода. 

Прокомментирую основные моменты, на которые стоит обратить внимание. Прежде всего, обратите внимание на то, как кодируется внутреннее представление доски [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1321">1321</a>] . Такое <a href="https://www.chessprogramming.org/Vector_Attacks#16x12">представление</a> оставляет часть полей массива неиспользуемыми, но облегчает доступ к номеру строки и столбца, сводя его к битовым операциям. Кроме того, заполнение "бордюра" вокруг доски зарезервированным значением [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1497">1497</a>] позволяет легко обнаруживать ситуацию выхода за пределы доски, при выполнении очередного хода. Также, обратите внимание на то, как кодируются фигуры [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1136">1136</a>] и выполняется переключение очерёдности хода [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1651">1651</a>].

Генерация ходов [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L2008">2008</a>] отделена от их выполнения [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1649">1649</a>]. Для выполнения отката хода [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1855">1855</a>], используется стек, сохраняющий основные параметры позиции [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L2266">2266</a>], такие как: начальная оценка позиции, фигура взятая ходом, признаки шаха, взятия на проходе и возможности рокировок .

Сам алгоритм поиска лучшего хода [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L194">194</a>] построен в соответствии с концепцией "<a href="https://www.chessprogramming.org/Iterative_Deepening">итеративного углубления</a>". Дело в том, что алгоритм альфа-бета отсечения [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1019">1019</a>] наиболее эффективно работает при выполнении поиска на фиксированную, наперёд заданную глубину. Однако, при наличии ограничений по времени на поиск лучшего хода, мы не можем предсказать заранее, на какую глубину удастся просмотреть дерево игровых состояний полностью. По этой причине, поиск начинается со значения <b>maxPly=1</b> и далее углубляется до тех пор, пока остаётся неиспользованное время.

Конечно, это означает, что позиции в корне дерева будут рассматриваться многократно. По этой причине, записи об этих узлах хэшируются [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L615">615</a>] в оперативной памяти, с использованием механизма "<a href="https://www.chessprogramming.org/Transposition_Table">таблицы транспозиций</a>". Разумеется, это означает, что необходим какой-то ключ, для того, чтобы отличать одну позицию от другой. В качестве такого ключа используется <a href="https://www.chessprogramming.org/Zobrist_Hashing">Zobrist-хэш</a>. Для каждого расположения каждого типа и цвета фигуры на доске генерируется псевдослучайное число [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1354">1354</a>], после чего, эти значения суммируются, с использованием "исключающего или" [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1473">1473</a>]. Бонусом в использовании такого подхода является то, что движок запоминает результаты расчётов предыдущих ходов и сможет за отведённое время углубляться дальше, при условии того, что хэш "таблицы транспозиций" не будет очищаться в промежутке между расчётом ходов .

Ещё одним важным моментом является то, что мы не можем оценивать произвольную позицию, возникшую на доске в середине партии. Для корректной оценки, необходимо “доиграть” позицию до "спокойного" состояния [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L478">478</a>], в котором <a href="https://www.chessprogramming.org/Extensions">нет непосредственных угроз фигурам и королю</a>. Кроме того, любые <a href="https://www.chessprogramming.org/Pruning">отсечения</a>, используемые помимо альфа-бета отсечения, способны значительно улучшить производительность алгоритма [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L817">817</a>]. Обратите внимание на то, каким образом <b>AllCutNode</b> вызывается из функции <b>AlphaBeta</b> [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1069">1069</a>].

Предварительная <a href="https://www.chessprogramming.org/Move_Ordering">сортировка ходов</a> также очень важна для обеспечения высокой производительности. Дело в том, что алгоритм альфа-бета отсечения работает наиболее эффективно в том случае, если лучшие ходы рассматриваются в первую очередь. Проблема заключается в том, что в середине партии, определить, какой ход является лучшим, довольно трудно. Обычно, используется следующий порядок просмотра ходов:

<ul>
	<li>Лучший ход из предыдущей итерации</li>
	<li>Атакующие ходы, ведущие к выгодному размену</li>
	<li>Ходы <a href="https://www.chessprogramming.org/Killer_Heuristic">Killer Heuristic</a></li>
	<li>Тихие ходы</li>
	<li>Невыгодные размены</li>
</ul>
Очевидно, что в разных итерациях <b>maxPly</b>, порядок ходов, для одного и того же узла, может изменяться. В GarboChess, задачу сортировки ходов решает вспомогательный объект <b>MovePicker</b> [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L692">692</a>]. Выгодные размены определяются функцией <b>See</b> [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L2280">2280</a>], с использованием алгоритма "<a href="https://www.chessprogramming.org/Static_Exchange_Evaluation">Static Exchange Evaluation</a>".

Осталось поговорить об оценке позиций [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L431">431</a>]. До завершения игры, оценить позицию на доске можно только приближённо, основываясь на различных эвристиках. Основу оценки составляет <b>g_baseEval</b> – значение, модифицируемое при выполнении каждого хода. Эта оценка включает в себя как <a href="https://www.chessprogramming.org/Material">стоимость материала</a>, так и бонусы, за расположение фигуры на той или иной позиции [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L250">250</a>]. Обратите внимание на использование <b>flipTable</b>, для “переворачивания” доски, при расчёте хода чёрных [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L1367">1367</a>]. Помимо базовой оценки, в оценку включаются бонусы, добавляемые различными эвристиками (например, наличие на доске двух разнопольных слонов даёт бонус к оценке [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L443">443</a>]) и <a href="https://www.chessprogramming.org/Mobility">мобильность</a>. Фактически, мобильность – это количество полей, находящихся под боем фигур, но угроза фигурам противника или защита своих фигур могут оцениваться дополнительно [<a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js#L330">330</a>]. От качества работы функции оценки во многом зависит сила игры всего бота, но нельзя делать эту функцию слишком медленной. То, насколько быстро она работает, напрямую влияет на количество позиций, оцениваемых за выделенное время, а значит и на качество работы всего алгоритма.

Что касается метода <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a> – он проще. Не требуется оценочная функция, какие-то эвристики для выбора лучшего хода и т.п. Из списка возможных ходов просто выбирается ход и доигрывается до завершения игры, с учётом того, что оба игрока выбирает ходы случайным образом (из списка допустимых правилами ходов, конечно). Количество побед и сыгранных игр подсчитывается, после чего, выбирается ход, ведущий к выигрышу в наибольшем количестве сыгранных игр. Достаточно интересна задача частоты выбора первого хода, получившая название "<a href="https://en.wikipedia.org/wiki/Multi-armed_bandit.">задачи многорукого бандита</a>". Одним из возможных решений является применение алгоритма "<a href="https://www.chessprogramming.org/UCT">Upper Confidence bounds applied to Trees</a>". В отличии от детерминированных минимаксных алгоритмов, метод Монте-Карло изначально является стохастическим и в одной и той же позиции может несколько возможных вариантов ответного хода. Метод Монте-Карло требователен к вычислительным ресурсам. Может потребоваться доиграть до конца тысячи партий, чтобы получить адекватную оценку позиции. С другой стороны, в отличии от минимаксных алгоритмов, метод Монте-Карло может быть эффективно распараллелен и линейно горизонтально масштабируется при добавлении вычислительных ресурсов.

<h3>Итак</h3>
Вроде бы всё что надо сказал. 4-го числа - турнир, 2-го и 3-го - подготовка к нему, в форме хакатона. Возможно командное участие. Я буду на связи и с удовольствием помогу как с разработкой бота, так и в плане интеграции с игровой платформой.
</cut>

Путеводитель разработчика по Garbo-боту

<img align="left" src="https://habrastorage.org/webt/cw/gy/1l/cwgy1lbpqtsguk8c-m0q8tjkx9e.png" /><b><i>у него есть два больших преимущества
...
Во-первых, он дешевле; а во-вторых, на обложке у него большими веселыми буквами напечатан дружеский совет: Don’t panic!

Дуглас Адамс</i></b>

Из всего многообразия шахматных движков, <a href="https://www.chessprogramming.org/Garbochess">Garbochess</a> я выбрал по двум причинам: для него есть понятный <a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js">JavaScript-код</a> и он неплохо <a href="http://omerkel.github.io/Garbochess-JS/oliver/">играет</a> в Шахматы. Мне совсем не требовался гроссмейстерский уровень! Если бот играет слишком сильно, то обычных людей (вроде меня) это только отпугивает. Требовалась лишь игра достаточно разумная, похожая на игру человека, без глупых раздражающих ошибок и Garbochess мне всё это дал. К сожалению, как и большинство других шахматных движков, он играл только в одну игру - традиционные <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>. Именно это мне и предстояло исправить.
<cut>
В <a href="https://habr.com/ru/post/537850/">прошлый раз</a> я рассказал о том как подключил шахматного <a href="https://github.com/GlukKazan/GarboChessAI">бота</a> к своему <a href="http://games.dtco.ru/map">DagazServer</a>-у. Разумеется, это было только начало. Моей целью было использование алгоритмов Garbochess в других играх, если не во всех, то по крайней мере, в шахматоподобных. Прежде всего, в моём распоряжении было несколько игр на <a href="https://en.wikipedia.org/wiki/Minichess">малых досках</a>, таких как "<a href="https://glukkazan.github.io/checkmate/gardner-chess.htm">Шахматы Гарднера</a>".

<a href="https://glukkazan.github.io/checkmate/gardner-chess.htm">
<img align="center" src="https://habrastorage.org/webt/45/rc/gx/45rcgxwjkp1qm5kpprmwxsuwv_u.png" /></a>
Здесь всё получилось довольно просто. Прежде всего, изменения касались размеров доски. Текущее её состояние хранится в массиве <b>g_board</b>, размером в 256 байт. Это немного больше чем 8x8 клеток и сделано так для того, чтобы вертикальную и горизонтальную координаты можно было кодировать старшим и младшим полубайтом индекса соответственно. Такое представление ускоряет навигацию по доске, а большая скорость означает большее количество узлов (и соответственно лучшую игру) которое удастся проверить за отведённое время.

<spoiler title="Вот как выглядит это преобразование">
<source lang="javascript">
function MakeSquare(row, column) {
    return ((row + 2) << 4) | (column + 4);
}
</source></spoiler>
Обратите внимание на константы, прибавляемые к координатам, позволяющие разместить рабочую область "в центре" массива. В самом начале <b>InitializeFromFen</b>, весь массив <b>g_board</b> заполняется значением <b>0x80</b>, позволяющим ускорить проверку выхода за границы доски. Рабочая область формируется при разборе <a href="https://ru.wikipedia.org/wiki/Нотация_Форсайта_—_Эдвардса">FEN-нотации</a> начальной позиции. Поскольку размеры строк и столбцов в передаваемом описании меньше, то и доска получается требуемого размера.

<spoiler title="Что касается содержимого массива, фигуры кодируются следующим образом">
<source lang="javascript">
var colorBlack  = 0x10;
var colorWhite  = 0x08;

var pieceEmpty  = 0x00;
var piecePawn   = 0x01;
var pieceKnight = 0x02;
var pieceBishop = 0x03;
var pieceRook   = 0x04;
var pieceQueen  = 0x05;
var pieceKing   = 0x06;
</source>
Таким образом, все проверки на тип фигуры выполняются по маске <b>0x07</b>. Кодирование цвета фигур выглядит немного избыточным, но это сделано для того, чтобы отличать пустые позиции от занятых. Значение <b>colorWhite</b> используется еще и для кодирования очерёдности хода, хранящейся в <b>g_toMove</b>. Здесь всё просто: <b>8</b> кодирует ход белых, <b>0</b> - чёрных. Вот так ход переключается:

<source lang="javascript">
var otherColor = 8 - g_toMove;
...
g_toMove = otherColor;
</source></spoiler>
Далее, следовало позаботиться о том, чтобы пешка превращалась на правильной горизонтали. Кстати, набор фигур, доступных для превращения, пришлось ограничить флагами, поскольку, часто, на малых досках используются не все фигуры.

<spoiler title="Аналогичные флаги используются для ряда других действий">
<source lang="diff">
var moveflagEPC = 0x2 << 16;
var moveflagCastleKing = 0x4 << 16;
var moveflagCastleQueen = 0x8 << 16;
var moveflagPromotion = 0x10 << 16;
var moveflagPromoteKnight = 0x20 << 16;
var moveflagPromoteQueen = 0x40 << 16;
var moveflagPromoteBishop = 0x80 << 16;

+var g_flags = moveflagPromoteKnight | moveflagPromoteQueen | moveflagPromoteBishop | moveflagCastleKing | moveflagCastleQueen | moveflagEPC;

function MovePawnTo(moveStack, start, square) {
    var row = square & 0xF0;
+    var delta = (8 - g_height) << 4;
-    if ((row == 0x90 || (row == 0x20))) {
+    if ((row == (0x90 - delta) || (row == 0x20))) {
+        if (g_flags & moveflagPromoteQueen) {
            moveStack[moveStack.length] = GenerateMove(start, square, 
            moveflagPromotion | moveflagPromoteQueen);
+        }
+        if (g_flags & moveflagPromoteKnight) {
            moveStack[moveStack.length] = GenerateMove(start, square, 
            moveflagPromotion | moveflagPromoteKnight);
+        }
+        if (g_flags & moveflagPromoteBishop) {
            moveStack[moveStack.length] = GenerateMove(start, square, 
            moveflagPromotion | moveflagPromoteBishop);
+        }
        moveStack[moveStack.length] = GenerateMove(start, square, 
        moveflagPromotion);
    }
    else {
        moveStack[moveStack.length] = GenerateMove(start, square, 0);
    }
}
</source>
Как можно заметить, для ладьи флаг не предусмотрен:

<source lang="javascript">
if (move & moveflagPromotion) {
    if (move & moveflagPromoteBishop) result += "=B";
    else if (move & moveflagPromoteKnight) result += "=N";
    else if (move & moveflagPromoteQueen) result += "=Q";
    else result += "=R";
}
</source></spoiler>
Осталась самая малость. Сила фигуры зависит от её расположения на доске. В Garbochess это кодируется специальными <a href="https://www.chessprogramming.org/Simplified_Evaluation_Function#Piece-Square_Tables">таблицами</a>:

<spoiler title="Я не стал с этим заморачиваться">
<source lang="javascript">
var pawnAdj =
[
    0,  0,    0,   0,   0,   0,   0,     0,
  -25, 105, 135, 270, 270, 135, 105,   -25,
  -80,   0,  30, 176, 176,  30,   0,   -80,
  -85,  -5,  25, 175, 175,  25,  -5,   -85,
  -90, -10,  20, 125, 125,  20,  -10,  -90,
  -95, -15,  15,  75,  75,  15,  -15,  -95, 
 -100, -20,  10,  70,  70,  10,  -20, -100, 
    0,   0,   0,   0,   0,   0,    0,    0
];

var knightAdj =
    [-200, -100, -50, -50, -50, -50, -100, -200,
     -100,    0,   0,   0,   0,   0,    0, -100,
      -50,    0,  60,  60,  60,  60,    0,  -50,
      -50,    0,  30,  60,  60,  30,    0,  -50,
      -50,    0,  30,  60,  60,  30,    0,  -50,
      -50,    0,  30,  30,  30,  30,    0,  -50,
     -100,    0,   0,   0,   0,   0,    0, -100,
     -200,  -50, -25, -25, -25, -25,  -50, -200
     ];

var bishopAdj =
    [ -50,-50,-25,-10,-10,-25,-50,-50,
      -50,-25,-10,  0,  0,-10,-25,-50,
      -25,-10,  0, 25, 25,  0,-10,-25,
      -10,  0, 25, 40, 40, 25,  0,-10,
      -10,  0, 25, 40, 40, 25,  0,-10,
      -25,-10,  0, 25, 25,  0,-10,-25,
      -50,-25,-10,  0,  0,-10,-25,-50,
      -50,-50,-25,-10,-10,-25,-50,-50
     ];

var rookAdj =
    [ -60, -30, -10, 20, 20, -10, -30, -60,
       40,  70,  90,120,120,  90,  70,  40,
      -60, -30, -10, 20, 20, -10, -30, -60,
      -60, -30, -10, 20, 20, -10, -30, -60,
      -60, -30, -10, 20, 20, -10, -30, -60,
      -60, -30, -10, 20, 20, -10, -30, -60,
      -60, -30, -10, 20, 20, -10, -30, -60,
      -60, -30, -10, 20, 20, -10, -30, -60
     ];

var kingAdj =
    [  50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
       50, 150, -25, -125, -125, -25, 150, 50,
      150, 250, 75,   -25,   -25,  75, 250, 150
     ];

var emptyAdj =
    [0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 
     ];

pieceSquareAdj[piecePawn] = MakeTable(
((g_width == 8) && (g_height == 8)) ? pawnAdj : emptyAdj);
pieceSquareAdj[pieceKnight] = MakeTable(
((g_width == 8) && (g_height == 8)) ? knightAdj : emptyAdj);
pieceSquareAdj[pieceBishop] = MakeTable(
((g_width == 8) && (g_height == 8)) ? bishopAdj: emptyAdj);
pieceSquareAdj[pieceRook] = MakeTable(
((g_width == 8) && (g_height == 8)) ? rookAdj : emptyAdj);
pieceSquareAdj[pieceQueen] = MakeTable(emptyAdj);
pieceSquareAdj[pieceKing] = MakeTable(
((g_width == 8) && (g_height == 8)) ? kingAdj: emptyAdj);
</source>
В конце концов, на маленьких досках и объёмы вычислений, необходимых для хорошей игры, гораздо меньше. Движок сможет просматривать партию глубже, компенсируя тем самым менее качественную оценочную функцию.
</spoiler>
Следующим шагом стали игры с изменёнными правилами перемещения фигур. Персидский <a href="https://ru.wikipedia.org/wiki/Шатрандж">Шатрандж</a> очень похож на современные шахматы. Это, по всей видимости, первая игра, в которой появились понятия <a href="https://ru.wikipedia.org/wiki/Шах_(шахматы)">шаха</a> и <a href="https://ru.wikipedia.org/wiki/Мат_(шахматы)">мата</a>. Основные отличия связаны с тем как ходят слон и ферзь. Кстати, из-за отсутствия дальнобойных диагональных фигур, Шатрандж - очень неторопливая игра. Часто, дебютная фаза пропускалась и игроки начинали игру с оговоренных <a href="https://ru.wikipedia.org/wiki/Табия">табий</a>, вроде вот такой:

<a href="https://glukkazan.github.io/checkmate/shatranj-1.htm">
<img align="center" src="https://habrastorage.org/webt/a9/jn/q0/a9jnq0wxdfvhw0_hb-8nexbeilu.png" /></a>
Прежде всего, в Шатрандже оказался ненужным весь код, связанный с <a href="https://ru.wikipedia.org/wiki/Рокировка">рокировками</a>, прыжками пешек и <a href="https://ru.wikipedia.org/wiki/Взятие_на_проходе">взятием на проходе</a>. Поскольку <a href="https://ru.wikipedia.org/wiki/Пат">пат</a> в Шатрандже также считается победой, проверки на завершение игры также удалось упростить. Изменились правила превращения. В Шатрандже, пешка умеет превращаться лишь в слабого ферзя.

<spoiler title="Изменилась оценка позиции">
Это касается как стоимости фигур:

<source lang="diff">
-var materialTable = [0, 800, 3350, 3450, 5000, 9750, 600000];
+var materialTable = [0, 800, 3350, 1500, 5000, 2500, 600000];
</source>
так и их мобильности:

<source lang="javascript">
// Bishop mobility
mob = -4;
pieceIdx = (color | 3) << 4;
from = g_pieceList[pieceIdx++];
while (from != 0) {
    mob += mobUnit[g_board[from + 30]];
    mob += mobUnit[g_board[from + 34]];
    mob += mobUnit[g_board[from - 30]];
    mob += mobUnit[g_board[from - 34]];
    from = g_pieceList[pieceIdx++];
}
result += 44 * mob;
...
// Queen mobility
mob = -2;
pieceIdx = (color | 5) << 4;
from = g_pieceList[pieceIdx++];
while (from != 0) {
    mob += mobUnit[g_board[from + 15]];
    mob += mobUnit[g_board[from + 17]];
    mob += mobUnit[g_board[from - 15]];
    mob += mobUnit[g_board[from - 17]];
    from = g_pieceList[pieceIdx++];
}
result += 22 * mob;
</source></spoiler>
<spoiler title="Основные изменения связаны с перемещением фигур">
<source lang="javascript">
// Bishop quiet moves
pieceIdx = (g_toMove | 3) << 4;
from = g_pieceList[pieceIdx++];
while (from != 0) {
    to = from + 30; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from + 34; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from - 30; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from - 34; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    from = g_pieceList[pieceIdx++];
}
...
// Queen quiet moves
pieceIdx = (g_toMove | 5) << 4;
from = g_pieceList[pieceIdx++];
while (from != 0) {
    to = from + 15; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from + 17; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from - 15; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    to = from - 17; 
    if (g_board[to] == 0) 
        moveStack[moveStack.length] = GenerateMove(from, to);
    from = g_pieceList[pieceIdx++];
}
</source>
Кстати, <b>g_pieceList</b> - это структура, позволяющая быстро найти на доске фигуру. Про неё ещё поговорим, чуть позже.
</spoiler>
Но одно дело перемещения, а совсем другое - проверка на бой фигур (и шах, соответственно)! Вы же помните, что в Garbochess всё что можно оптимизировать оптимизируется?

<spoiler title="Вот как это выглядит">
<source lang="javascript">
function IsSquareAttackableFrom(target, from){
    var index = from - target + 128;
    var piece = g_board[from];
    if (g_vectorDelta[index].pieceMask[(piece >> 3) & 1] & 
        (1 << (piece & 0x7))) {
        // Yes, this square is pseudo-attackable.  
        // Now, check for real attack
	var inc = g_vectorDelta[index].delta;
        do {
		from += inc;
		if (from == target)
			return true;
	} while (g_board[from] == 0);
    }
    return false;
}
</source>
Массив <b>g_vectorDelta</b> заполняется следующим образом:

<source lang="javascript">
var g_vectorDelta = new Array(256);

var g_bishopDeltas = [-30, -34, 30, 34];
var g_knightDeltas = [31, 33, 14, -14, -31, -33, 18, -18];
var g_rookDeltas   = [-1, +1, -16, +16];
var g_queenDeltas  = [-15, -17, 15, 17];
var g_kingDeltas   = [-1, +1, -15, +15, -17, +17, -16, +16];
...
var pieceDeltas = [[], [], g_knightDeltas, g_bishopDeltas, g_rookDeltas, 
    g_queenDeltas, g_kingDeltas];

for (var i = 0; i < 256; i++) {
    g_vectorDelta[i] = new Object();
    g_vectorDelta[i].delta = 0;
    g_vectorDelta[i].pieceMask = new Array(2);
    g_vectorDelta[i].pieceMask[0] = 0;
    g_vectorDelta[i].pieceMask[1] = 0;
}
    
// Initialize the vector delta table    
for (var row = 0; row < 0x80; row += 0x10) 
    for (var col = 0; col < 0x8; col++) {
        var square = row | col;
         
        // Pawn moves
        var index = square - (square - 17) + 128;
        g_vectorDelta[index].pieceMask[colorWhite >> 3] |=
             (1 << pieceSarbaz);
        index = square - (square - 15) + 128;
        g_vectorDelta[index].pieceMask[colorWhite >> 3] |= 
            (1 << pieceSarbaz);
            
        index = square - (square + 17) + 128;
        g_vectorDelta[index].pieceMask[0] |= (1 << pieceSarbaz);
        index = square - (square + 15) + 128;
        g_vectorDelta[index].pieceMask[0] |= (1 << pieceSarbaz);
            
        for (var i = pieceAsb; i <= pieceShah; i++) {
            for (var dir = 0; dir < pieceDeltas[i].length; dir++) {
                var target = square + pieceDeltas[i][dir];
                while (!(target & 0x88)) {
                    index = square - target + 128;
                    
                    g_vectorDelta[index].pieceMask[colorWhite >> 3] |= 
                        (1 << i);
                    g_vectorDelta[index].pieceMask[0] |= (1 << i);
                        
                    var flip = -1;
                    if (square < target) 
                        flip = 1;
                     
                    if ((square & 0xF0) == (target & 0xF0)) {
                        // On the same row
                        g_vectorDelta[index].delta = flip * 1;
                    } else if ((square & 0x0F) == (target & 0x0F)) {
                        // On the same column
                        g_vectorDelta[index].delta = flip * 16;
                    } else if ((square % 15) == (target % 15)) {
                        g_vectorDelta[index].delta = flip * 15;
                    } else if ((square % 17) == (target % 17)) {
                        g_vectorDelta[index].delta = flip * 17;
                    }

                    if ((i == pieceAsb) || (i == pieceAlfil) || 
                        (i == pieceFers)) {
                        g_vectorDelta[index].delta = pieceDeltas[i][dir];
                        break;
                    }

                    if (i == pieceShah)
                        break;

                    target += pieceDeltas[i][dir];
                }
            }
        }
    }
</source>
Магия этих приращений становится довольно очевидной при переводе их в шестнадцатеричное представление. Не забывайте, что ферзь в Шатрандже ходит на соседнюю клетку по диагонали. Слон тоже перемещается по диагонали, но через одну клетку.
</spoiler>
В результате, получился <a href="https://github.com/GlukKazan/ShatranjAI">такой вот</a> бот. Вместе с <a href="https://github.com/GlukKazan/GarboChessAI">шахматным</a>, он играет с пользователями на <a href="http://games.dtco.ru/map">сайте</a>. К сожалению, создание отдельного серверного бота для каждой игры - непозволительная роскошь. В конце концов, каждый такой бот - это Node.js приложение, потребляющее CPU и RAM, даже во время простоя, когда с ним никто не играет. 

Чтобы двигаться дальше, требовалось научиться запускать Garbochess непосредственно в браузере. Для "<a href="https://www.chessvariants.com/diffmove.dir/hoppel-poppel.html">Hoppel-Poppel</a>" я так и <a href="https://github.com/GlukKazan/GlukKazan.github.io/blob/master/checkmate/scripts/hoppel-poppel-ai.js">сделал</a> (попутно обернув всё в <a href="https://developer.mozilla.org/ru/docs/Glossary/IIFE">IIFE</a>, чтобы не мусорить переменными). Сама игра не слишком отличается от Шахмат. Изменены всего две фигуры: слон бьёт вражеские фигуры как конь и наоборот (тихие ходы выполняются по шахматным правилам). Кстати, если придумаете как поставить мат из <a href="https://glukkazan.github.io/checkmate/hoppel-poppel.htm?turn=0;&setup=2k5/6B1/8/6K1/8/6N1/8/8">этой</a> позиции, сообщите мне (меня этот вопрос очень интересует):

<a href="https://glukkazan.github.io/checkmate/hoppel-poppel.htm?turn=0;&setup=2k5/6B1/8/6K1/8/6N1/8/8">
<img align="center" src="https://habrastorage.org/webt/79/y6/8t/79y68ttdjlumj2bn5ti7pvlsggs.png" /></a>
Теперь пришло время поговорить о <b>g_pieceList</b>. Как я уже говорил, эта структура предназначена для быстрого поиска позиций, на которых стоят фигуры заданного типа. Быстрый поиск очень важен, поскольку такая операция выполняется очень часто и сканирование по всей доске полностью убило бы всю производительность.

<spoiler title="Работает это вот так">
<source lang="javascript">
var g_pieceIndex = new Array(256);
var g_pieceList = new Array(2 * 8 * 16);
var g_pieceCount = new Array(2 * 8);

function InitializePieceList() {
    for (var i = 0; i < 16; i++) {
        g_pieceCount[i] = 0;
        for (var j = 0; j < 16; j++) {
            // 0 is used as the terminator for piece lists
            g_pieceList[(i << 4) | j] = 0;
        }
    }
    for (var i = 0; i < 256; i++) {
        g_pieceIndex[i] = 0;
        if (g_board[i] & (colorWhite | colorBlack)) {
            var piece = g_board[i] & 0xF;
            g_pieceList[(piece << 4) | g_pieceCount[piece]] = i;
            g_pieceIndex[i] = g_pieceCount[piece];
            g_pieceCount[piece]++;
        }
    }
}
</source>
</spoiler>
В качестве ключа используется побитовая сумма цвета и типа фигуры, а поскольку фигур одного типа может быть несколько, 4 бита резервируем под счётчик. Почему так много? Для кодирования 8-ми пешек действительно хватило бы трёхбитного счётчика, но потенциально мы можем превратить все эти пешки в другие фигуры и получить на доске, например, 10 коней. Теперь посмотрите на эту картинку:

<a href="https://glukkazan.github.io/checkmate/weak.htm">
<img align="center" src="https://habrastorage.org/webt/zh/qy/zm/zhqyzmonzoioe9e1ho6dclevnie.png" /></a>
С учётом возможного превращения пешек, четырёх битов явно не хватает. В общем, это была самая утомительная правка Garbochess, из тех, что я делал на текущий момент.

Теперь, когда я разобрался с AI для шахматных игр, я нахожусь, некоторым образом, на перепутье. Какими играми заняться дальше? Можно попробовать сделать AI для <a href="https://glukkazan.github.io/xiangqi/xiangqi.htm">Сянцы</a>, но там, сходу, доска 9x10 и надо придумывать что-то, чтобы втиснуть её в <b>g_board</b>. Японские <a href="https://glukkazan.github.io/shogi/shogi.htm">Сёги</a> преподносят сюрприз своим <a href="https://ru.wikipedia.org/wiki/Сёги#:~:text=Сброс%20—%20это%20выставление%20на%20доску,сделать%20ход%20фигурой%20на%20доске.">правилом сброса</a> (ну и доска тоже 9x9). Можно делать <a href="https://glukkazan.github.io/checkmate/makruk.htm">Макрук</a> и <a href="https://glukkazan.github.io/checkmate/sittuyin.htm">Суттуйин</a>, но там не будет чего-то принципиально нового. Наконец, можно заняться "<a href="https://glukkazan.github.io/checkmate/belarusian-chess.htm">Белорусскими шахматами</a>" - этот вариант для самых смелых, поскольку как делать составные шашечные ходы в GarboChess пока совсем непонятно. В общем, я прикрепил опрос - голосуйте.
</cut>

DagazServer: Встречайте Garbo Chess

<a href="https://ru.wikipedia.org/wiki/Гарбо,_Грета"><img align="left" src="https://habrastorage.org/webt/ms/nz/yn/msnzynjgeeu6xnpdgdo2d6ttkl0.png" /></a><b><i>Кто мне сказал, - "не получится"? 
Если мне хочется, сбудется!

Земфира

Плюнь тому в глаза, кто скажет, 
что можно объять необъятное!

Козьма Прутков "<a href="http://lib.ru/LITRA/PRUTKOW/plody.txt">Плоды раздумья</a>"</i></b>

Новогодние праздники вновь навалились внезапно. Такое обилие свободного времени было просто необходимо разбавить какой-то осмысленной деятельностью и я решил приделать к своему <a href="https://github.com/GlukKazan/DagazServer">серверу</a> бота для игры в <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>. Готовых шахматных движков существует <a href="http://www.ficgs.com/wiki_en-chess%20engine.html">множество</a>. Я решил остановиться на <a href="https://github.com/glinscott/Garbochess-JS">Garbochess-JS</a> - простой и понятной реализации, на языке JavaScript, названной в честь знаменитой актрисы <a href="https://ru.wikipedia.org/wiki/Гарбо,_Грета">Греты Гарбо</a> (вы можете видеть её на фотографии).
<cut text="О том, что из этого вышло, читайте далее...">
Прежде всего, должен сказать пару слов о своём <a href="http://games.dtco.ru/map">сайте</a>. Поскольку вся идея состоит в том, чтобы люди играли с друг другом по сети, на сайте требуется регистрация. При регистрации не требуется указывать никакой конфиденциальной информации (EMail может быть сохранён в профиле пользователя, по желанию, позже). Ссылка, указанная мной выше и отображающая список всех имеющихся игр, работает без регистрации, но если вы решите пойти дальше, потребуется логин и пароль.

<a href="http://games.dtco.ru/launch/30/31">
<img align="center" src="https://habrastorage.org/webt/we/j1/vr/wej1vrbnazrg7bmxtk0q91u40ho.png" /></a>
Игра, выбранная на карте, запоминается. Поэтому, после ввода логина и пароля, вы попадаете на вкладку запуска этой игры. Вы можете запустить игру (при помощи кнопки "Launch") или просмотреть сессии, ожидающие подключения второго игрока ("Join") и ранее сыгранные игры ("View"), при их наличии. Если вы запустите игру, создастся новая сессия, ожидающая подключения второго игрока. Вы попадёте в игру, сможете сделать ход (если выбрали игру первым игроком), но ожидание ответного хода может занять некоторое время (на самом деле, никто не гарантирует, что кто-нибудь вообще подключится к этой сессии). По этой причине, я рекомендую просматривать список сессий, ожидающих подключения, по интересующей вас игре, перед созданием новой сессии при помощи "Launch". Вы избавите себя от лишнего ожидания и, может быть, доставите удовольствие другому человеку.

Другая возможность реализована не для всех игр, но если на форме имеется чекбокс "Play against AI", вы можете ничего не ждать вовсе. Эта опция запускает режим игры с ботом, отвечающим на сделанные ходы практически немедленно. Как правило, речь идёт об очень простых ботах, без каких-то сложных вычислений (хотя победить <a href="http://games.dtco.ru/launch/31/136">некоторых из них</a>, всё равно, может быть тяжело). Для Шахмат такое решение не подходит вовсе, но возможность поиграть с ботом всё-таки имеется.

<h2>Чего хотелось</h2>
Обычный встраиваемый в игру бот не является для Dagaz чем-то новым. Технически, такая игра представляет собой html-сборку, включающую в себя модуль выбора оптимального для этой игры хода, в зависимости от текущей позиции. К имени html-файла добавляется суффикс "-ai", позволяющий серверу загрузить правильную сборку, при выборе режима игры с ботом. Думаю понятно, что разработать бота, подходящего абсолютно для всех существующих на свете игр невозможно, но можно использовать одни и те же боты для различных, но сходных между собой игр.

<spoiler title="Например, этот бот используется очень часто">
<source lang="javascript">
(function() {

function RandomAi(params) {
  this.params = params;
  if (_.isUndefined(this.params.rand)) {
      this.params.rand = _.random;
  }
}

var findBot = Dagaz.AI.findBot;

Dagaz.AI.findBot = function(type, params, parent) {
  if ((type == "random") || (type == "solver")) {
      return new RandomAi(params);
  } else {
      return findBot(type, params, parent);
  }
}

RandomAi.prototype.setContext = function(ctx, board) {
  ctx.board  = board;
}

RandomAi.prototype.getMove = function(ctx) {
  var moves = Dagaz.AI.generate(ctx, ctx.board);
  if (moves.length == 0) {      
      return { done: true, ai: "nothing" };
  }
  if (moves.length == 1) {
      return { done: true, move: moves[0], ai: "once" };
  }
  var ix = this.params.rand(0, moves.length - 1);
  return {
      done: true,
      move: moves[ix],
      ai:   "random"
  };
}

})();</source></spoiler>
Это не шутка. Дело в том, что в Dagaz боты выстроены в цепочку и бот рандомного выбора хода используется в тех случаях, когда боты, стоящие выше по иерархии, дать ответ отказались (такое возможно в тех случаях, когда любой ход ведёт к поражению). Разумеется, есть и более сложные боты, но, в целом, все они не очень сильные. Прежде всего, это связано с использованием универсальной (а значит медленной) модели, пригодной для абсолютно любых игр, реализуемых Dagaz.

Второе ограничение связано со временем расчёта хода. Для встроенного бота оно не может превышать 2-3 секунд, поскольку все вычисления производятся непосредственно в браузере пользователя и, в силу однопоточности JavaScript, все другие действия, на это время блокируются. Если задержаться слишком долго, браузер выбросит предупреждение о возможном зацикливании на странице или вообще молча остановит все выполняющиеся скрипты (такое случалось в Safari).

Как бороться с этими двумя бедами - понятно. Поскольку у нас есть сервер, надо разработать клиента, соединяющегося с ним по <a href="http://games.dtco.ru/api/swagger/">REST</a> и отвечающего на ходы других пользователей. Иными словами, надо разработать внешнего бота. В качестве языка разработки можно использовать всё тот же JavaScript и запускать бота в Node.js, на одном хосте с сервером (или где-то ещё, это не принципиально).

<spoiler title="Можно добавить дополнительную функциональность">
Если бот ничем не занят, он может создавать для выбранной игры новые игровые сессии, подключаться к ним в качестве второго игрока и ожидать подключения игрока-человека. Все эти хотелки можно реализовать небольшим <a href="https://ru.wikipedia.org/wiki/Конечный_автомат">конечным автоматом</a>, работающим по следующей схеме:

<a href="https://github.com/GlukKazan/GarboChessAI/blob/master/index.js">
<img align="center" src="https://habrastorage.org/webt/fm/ia/u_/fmiau_onqzyjuz3ex-crjj7hmhs.png" /></a>
После старта, бот выполняет инициализацию, авторизуясь на сервере, после чего переходит к циклу опроса: ищет на сервере сессии, в которых он должен выполнить очередной ход (TURN), загружает текущую позицию (RECO), передаёт её описание в Garbo Chess, а полученный ответный ход отправляет на сервер (MOVE). Если сессий ожидающих хода нет, бот переходит к проверке наличия ожидающих сессий, созданных ботом (CHCK), если таковых нет и общее количество сессий, в которых участвует бот, меньше заданного, создаёт новую (SESS).

При возникновении ошибок (например, в случае устаревания JWT-токена), бот возвращается к фазе инициализации (INIT) для выполнения повторной авторизации, а если ошибка возникла уже там (при недоступности сервера или чём-то подобном) переходит к фазе STOP и останавливается. Вот <a href="https://github.com/GlukKazan/GarboChessAI/blob/master/index.js">так</a> всё это выглядит.
</spoiler>
Бот может играть одновременно с несколькими игроками, но в каждый момент времени имеет дело не более чем с одной игрой. Таким образом, если игра ведётся с несколькими людьми, каждому придётся ждать чуть дольше. Кроме того, это не самый эффективный способ использования Garbo Chess. Движок поддерживает режим, при котором анализ игры ведётся непрерывно (запускается в отдельном потоке <a href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API">Web Worker</a>-а), но в этом случае, играть можно только с одним противником.

<h2>SAN-ы, FEN-ы, PGN-ы</h2>
Прежде всего, с шахматным движком было необходимо договориться. В области компьютерных шахмат существует несколько общепринятых <a href="https://en.wikipedia.org/wiki/Chess_notation#Notation_systems_for_computers">нотаций</a>, но, по большому счёту, важно уметь описывать две вещи: текущую расстановку фигур (кто где стоит) и ход (кто куда ходит и как превращается). В первом случае, фактическим стандартом является <a href="https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation">FEN</a> и именно в таком виде описание позиции необходимо передавать в Garbo Chess.

<spoiler title="С этим была небольшая засада">
Разумеется, в Dagaz я тоже описываю позиции. Это функциональность, обойтись без которой очень трудно. Представьте себе, что доиграв до середины партии мы вышли из игры, а потом зашли в неё заново (или просто перегрузили страницу). Было бы глупо прокручивать все ходы с самого начала. DagazServer использует описание позиции, чтобы загрузить правильную расстановку фигур сразу, без утомительной перемотки.

Вернее, он действует ещё хитрее: в случае если ожидается ход противника, загружается последняя расстановка фигур, как и было написано, но если ходить должен игрок, DagazServer загружает предыдущую позицию, возникшую в игре на момент начала последнего хода противника. Следующий ход игра получает обычным образом, уже после загрузки html. Благодаря этому, игрок, загружая игру, всегда видит анимацию последнего хода (или нескольких ходов) противника. А если он не успел рассмотреть этот ход во всех подробностях, всегда можно просто перезагрузить страницу.

Таким образом, модули описания позиции, вроде <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/common-scripts/common-setup-v3.js">этого</a> - важная часть проекта. У меня их несколько и я использую тот или иной, в зависимости от особенностей игры. Почему я не использовал FEN? Просто потому, что Dagaz - это не только Шахматы. Приведу простой пример: возможность <a href="https://ru.wikipedia.org/wiki/Рокировка">рокировки</a>, в FEN кодируется как "KQkq", но такое описание слишком завязано на правила традиционных шахмат! Даже в слегка изменённых шахматных вариантах нотацию приходится <a href="https://en.wikipedia.org/wiki/X-FEN#Encoding_castling_rights">расширять</a>. В любом случае, мне понадобился FEN и я его <a href="https://github.com/GlukKazan/DagazServer/blob/751e628e9c32b63b079cc9d95c5883e2055363d0/public/dagaz/common-scripts/fen-setup.js">сделал</a>.
</spoiler>
В ответ на полученное описание, Garbo Chess, проработав некоторое время, возвращает лучший (по его мнению) ход (просто пара позиций вроде "e2e4" и тип фигуры, при наличии превращения). К сожалению, на момент разработки бота, на сервере было сыграно уже довольно много партий в Шахматы и я хранил описание хода немного в другом виде. Я не хотел, чтобы эти партии сломались и добавил дефис, разделяющий позиции (тот факт, что старые партии не использовали FEN-нотацию роли не играл, при проигрывании уже завершённых партий, описания позиций не используются).

<spoiler title="С нотациями пришлось ещё повозиться">
Одной из особенностей <a href="https://ru.wikipedia.org/wiki/Минимакс">минимаксных алгоритмов</a> является их детерминированность. При одинаковых условиях, будет формироваться один и тот же ход. Это может привести к однообразной игре бота, что не очень приятно. Я вижу два способа борьбы с этим:

<ul>
	<li>Случайное ограничение времени на расчёт хода</li>
	<li>Книга дебютов</li>
</ul>
С первым пунктом всё понятно - вместо того чтобы жёстко ограничивать время на расчёт хода, например одной секундой, можно задать вилку из минимального и максимального значений и каждый раз брать случайное число в этих пределах. Что касается книги дебютов, то она полезна сама по себе. Шахматные движки придуманы для <a href="https://ru.wikipedia.org/wiki/Миттельшпиль">миттельшпиля</a>. В <a href="https://ru.wikipedia.org/wiki/Дебют_(шахматы)">дебюте</a> и <a href="https://ru.wikipedia.org/wiki/Эндшпиль">эндшпиле</a> они не столь эффективны. Для эндшпилей существуют <a href="https://ru.wikipedia.org/wiki/База_данных_шахматных_окончаний">таблицы Налимова</a>, а дебюты обрабатываются специальными <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/data/chess.txt">справочниками</a>, гораздо более компактными. 

В силу своей иерархической организации, дебютные таблицы предоставляют некоторую вариативность. При наличии для позиции нескольких "лучших" ходов, мы можем использовать случайный выбор. Я уже <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/data/chess.js">использовал</a> дебютные таблицы в Dagaz, в формате <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>, но для сервера потребовалось реорганизовать их иначе. Вместо последовательностей ходов от начала партии, мне были нужны FEN-описания позиций со списками соответствующих им лучших ходов (это, кстати, позволяет описывать дебютные ловушки, путём сохранения лучших ходов только одной стороны). Здесь очень помогла утилита <a href="http://blog.kislenko.net/show.php?id=2230">pgn2fen</a>, обнаруженная в блоге Николая Кисленко, работающая как с SAN так и с <a href="https://en.wikipedia.org/wiki/Algebraic_notation_(chess)#Long_algebraic_notation">Long algebraic notation</a>.
</spoiler>
Далее, я создал пользователя, для того чтобы бот мог заходить на сервер и прописал его id в качестве "дежурного бота" шахматным играм, для того чтобы frontend автоматически включал бота в созданную игру, при выборе опции "Play against AI". В целом, новая схема данных выглядела так:

<img align="center" src="https://habrastorage.org/webt/0c/i_/he/0ci_he7mxrqafvgcf_me1qaxim0.png" />
Здесь есть ещё один момент, о котором стоит сказать. Я добавил табличку "ai_settings", для хранения настроек бота по отношению к игроку в конкретной игре. Это, своего рода, рейтинг. Если игрок выигрывает, дополнительное время, выделяемое боту на "раздумье", увеличивается. При поражениях оно уменьшается. Таким образом, бот может подстраиваться к силе игрока, с которым он играет. 

<h2>Что получилось</h2>
<oembed>https://www.youtube.com/watch?v=ypZTEyMs3Xs</oembed>Это <a href="http://games.dtco.ru/dagaz/chess.html?sid=2197&selector=1">одна</a> из игр бота на сайте. И это не дебютная ловушка (можете <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/data/chess.txt">проверить</a> это самостоятельно)! При ограничении времени на расчёт хода в 1-2 секунды, бот вполне разумно играет против человека и умеет ставить <a href="http://games.dtco.ru/dagaz/chess.html?sid=2258&selector=1">красивые</a> <a href="http://games.dtco.ru/dagaz/chess.html?sid=2280&selector=1">маты</a>. Возможности бота не ограничиваются классическими шахматами. Подойдёт любая игра, в которой правила перемещения фигур не изменены, например "<a href="http://games.dtco.ru/launch/30/158">Шахматы Фишера</a>" или "<a href="http://games.dtco.ru/launch/30/31/9">Шахматы Будённого</a>".

<spoiler title="Правда, здесь есть небольшая загвоздка">
Шахматный движок должен знать, с какой позиции началась игра. Если первым ходит человек, никаких проблем нет - после выполнения хода, FEN-описание позиции передаётся на сервер, но если бот ходит первым, описать позицию некому, поскольку сервер ничего не знает о конкретике игры. Мне пришлось применить небольшой трюк - загружать FEN-описание начальной позиции даже в том случае, если игра после загрузки ожидает ход бота.

Может возникнуть, своего рода <a href="https://ru.wikipedia.org/wiki/Состояние_гонки">ситуация "гонок"</a>, когда бот получает описание сессии раньше, чем интерфейс игры успел загрузиться и сохранить FEN начальной позиции. Понятно, что ни к чему хорошему это привести не может, поэтому я добавил атрибут <a href="https://github.com/GlukKazan/GarboChessAI/commit/d071bcc691fd3de081c3b8c3048bcefaa1ef1bbb">setup_required</a>, требующий наличия FEN на момент загрузки сессии. Если FEN ещё не сформирован, сервер возвращает ошибку, получив которую, бот просто переходит к повторной авторизации, после чего продолжает выполнение обычным образом.
</spoiler>
Также, без каких либо изменений, можно играть в "<a href="http://games.dtco.ru/launch/30/64">Шахматы втёмную</a>". Если проявить немного фантазии, можно пойти ещё дальше. Помните, как построены миссии кампании в знаменитой "<a href="https://store.steampowered.com/app/211050/Battle_vs_Chess/?l=russian&cc=nl">Battle vs Chess</a>"?

<oembed>https://www.youtube.com/watch?v=kw1OsIyHhjY</oembed>Здесь, в качестве бота, используется обычный шахматный движок <a href="https://en.wikipedia.org/wiki/Fritz_(chess)">Fritz</a>. Если подумать, это становится понятно. Подрыв на мине - просто потеря фигуры. Бот не будет ходить на мины в том случае если будет их учитывать - это просто невыгодно, а суть миссии как раз в том, чтобы заманивать в ловушку его фигуры. Решение простое - информация о минах просто не должна передаваться боту.

<a href="http://games.dtco.ru/launch/30/162">
<img align="center" src="https://habrastorage.org/webt/kd/kc/bg/kdkcbgkkaorh2qmh0lp4jhqikx8.png" /></a>
Вот что получается: я <a href="https://github.com/GlukKazan/DagazServer/commit/4082030026424c24ad57d72e740e89e672f6bb27#diff-ec0c6f7cf3329150f842f4a388c627d0d81623f5eef95329cececc105b7bc575">добавляю</a> в FEN описание мин, но перед передачей в Garbo Chess, просто <a href="https://github.com/GlukKazan/GarboChessAI/commit/6313b8c994aff2bb0cd41c7f6119b952e32e0302">убираю</a> мины из описания, а после получения ответа возвращаю в позицию те мины, которые не взорвались в результате хода бота. Теперь вы можете заманить бота в ловушку уже на <a href="http://games.dtco.ru/launch/30/162">DagazServer</a>.

<h2>Что дальше</h2>
Есть много шахматных игр: <a href="https://ru.wikipedia.org/wiki/Шатрандж">Шатрандж</a>, <a href="https://ru.wikipedia.org/wiki/Макрук">Макрук</a> - бот может играть в них, надо только добавить в Garbo Chess новые фигуры. Есть игры на <a href="http://games.dtco.ru/launch/30/128">малых досках</a>. Наконец, можно переосмыслить Garbo Chess, создав на его основе универсальный движок, подходящий для более широкого класса игр. Возможностей для развития много, было бы желание.
</cut>

DagazServer: Чему научили пользователи

<a href="https://games.dtco.ru/map">
<img align="left" src="https://habrastorage.org/webt/_t/zi/ws/_tziwsxawauumg0ykje4tmsqfmc.jpeg" /></a><b><i>Детали, мелочи, нюансы. Сочетание пустяков. 
От перестановки слагаемых всё меняется. 
Раз, и будущее – открытая книга.
...
Нюанс за нюансом, подробность за подробностью...
Это была не игра, это была откровенная дерзость.

Генри Лайон Олди "Нюансеры"
</i></b>
Предусмотреть всё невозможно. Именно поэтому умные люди и придумали бета-тестирование. Поскольку, в моём случае, <a href="https://github.com/GlukKazan/DagazServer">проект</a> открытый и бесплатный, оно мало чем отличается от обычного функционирования сайта. Люди играют в игры, а я наблюдаю, исправляю найденные ошибки, извиняюсь и наблюдаю снова. А ещё, я прислушиваюсь к советам, порой неожиданным и, часто, очень полезным.
<cut>
<spoiler title="Прежде всего, должен сказать пару слов о том, как пользоваться сайтом">
Также как <a href="https://glukkazan.github.io/">первоначальный проект</a>, <a href="http://games.dtco.ru/map">DagazServer</a> посвящён популяризации традиционных настольных игр. Проект бесплатный, но игра по сети подразумевает наличие учётной записи. Поэтому, прежде чем двигаться дальше, её придётся создать:

<a href="https://games.dtco.ru/reg">
<img align="center" src="https://habrastorage.org/webt/wm/oe/pi/wmoepiasqxan_s4autjlqcfudj4.png" /></a>
Регистрация свободная и не требует указания никаких конфиденциальных данных, даже адреса электронной почты (вы сможете указать его позже, в профиле пользователя, если захотите). После этого, можно заходить на сайт:

<a href="https://games.dtco.ru/">
<img align="center" src="https://habrastorage.org/webt/fm/sx/bu/fmsxbumljlhfbgzfewh30u_62eu.png" /></a>
Есть ещё <a href="https://games.dtco.ru/map">карта</a>, о которой я расскажу позже,  показывающая все игры и не требующая авторизации, но при переходе к запуску конкретной игры придётся ввести свой логин и пароль.

<a href="https://games.dtco.ru/launch/40/95">
<img align="center" src="https://habrastorage.org/webt/pn/z_/di/pnz_di2ufscznfba30a-5puwsbs.png" /></a>
Здесь можно выбрать игру, её разновидность и, в некоторых случаях, начальную расстановку фигур. Также можно выбрать игрока, за которого вы собираетесь играть и запуститься, но прежде чем это делать, поищите заинтересовавшую вас игру на вкладке "Sessions":

<a href="https://games.dtco.ru/session">
<img src="https://habrastorage.org/webt/og/5d/4d/og5d4dfbnmwepdqewedcyymwh8e.png" /></a>
Возможно, кто-то только того и ждёт, чтобы сыграть с вами. Кстати, партии других игроков тоже можно просматривать (пока только в режиме прокрутки, с самого начала, но я работаю над тем, чтобы сделать пошаговый разбор). Кстати, картинки в этой статье кликабельные, но помните о том, что я говорил о регистрации: для перехода по ссылке, потребуется указать свой логин и пароль.
</spoiler>
<h2>Жмурки и шкурки</h2>
Проект <a href="https://github.com/GlukKazan/DagazServer">DagazServer</a> имеет свою <a href="https://github.com/GlukKazan/Dagaz">предысторию</a>. Я разрабатываю <a href="https://glukkazan.github.io/">настольные игры</a> уже несколько лет и за это время многому научился. Но возможность игры по сети выводит проект на новый, не только социальный, но и технический уровень. Новые требования к интерфейсу ведут к новым решениям. И эти решения совсем не обязательно должны быть сложными. Я могу это проиллюстрировать. Когда люди играют по сети друг с другом, выполняя ход, они хотят видеть доску со своей точки зрения.

<spoiler title="Доска должна поворачиваться">
Впервые эту мысль мне подсказал Ed van Zon. В рамках отказа от устаревшей технологии <a href="https://ru.wikipedia.org/wiki/Java-апплет">Java-апплетов</a>, на своём <a href="https://mindsports.nl/">сайте</a>, он, практически самостоятельно, освоил разработку на Dagaz и за короткое время переписал с его помощью <a href="https://mindsports.nl/index.php/dagaz">кучу игр</a>. Некоторые из его технических решений удивляют даже меня. Одним из таких нововведений стала "игра по переписке". Вы сможете её опробовать, если зарегистрируетесь на сайте MindSports, но я хотел рассказать не совсем об этом.

<a href="https://mindsports.nl/index.php/dagaz/783-chess">
<img align="center" src="https://habrastorage.org/webt/uq/ir/_a/uqir_ahcayfixbh0wh7m-ngeio4.png" /></a>
Здесь, на самом верху, можно заметить кнопочку "Flip board". Эта удобная опция позволяет взглянуть на доску глазами противника. Разумеется, во время игры по переписке, или даже при игре за одной доской в режиме "Hot Seat", эта возможность активно применяется. Я совершенно не задумывался об этом, разрабатывая Dagaz и в результате оказался в положении человека, запирающего ворота вслед за сбежавшей лошадью.

<spoiler title="Я стал придумывать сложные технические решения">
Новая версия <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/view/2d/2d-view-full.js">представления</a>, позволяла описать всё что угодно: разворачивающиеся доски, всплывающие окна, для выбора фигур при превращении, относительное позиционирование внутри этих окон, отображение разных подложек, в зависимости от очерёдности хода - всё это. 

<source lang="javascript">
agaz.View.configure = function(view) {
    var b = view.root.addRegion(0, 0, 604, 604);
    b.addBoard("WhiteBoard", [0]);
    b.addBoard("BlackBoard", [1]); // Другая подложка для второго игрока...
    var g = b.addGrid(2, 2, 50, 50);
    g.addScale("a/b/c/d/e/f/g/h/i/j/k/l", 50, 0);
    g.addScale("12/11/10/9/8/7/6/5/4/3/2/1", 0, 50);
    g.addTurns(0, [0]);
    g.addTurns(1, [1]); // и обратный порядок размещения фигур на доске
    view.addPiece(["WhitePawn", "BlackPawn"], Dagaz.View.drawPawn);
    view.addPiece(["WhiteKnight", "WhiteBishop", "WhiteRook", "WhiteQueen", "WhiteKing", "BlackKnight", "BlackBishop", "BlackRook", "BlackQueen", "BlackKing"]);
}</source>
<a href="https://glukkazan.github.io/checkmate/labyrinth-board.htm">
<img align="center" src="https://habrastorage.org/webt/0v/3q/9a/0v3q9aux7mym_2fajuafbjvmhca.png" /></a>
</spoiler>
Получилось неплохо. С каждым ходом доска разворачивается, как это и было задумано. Но всё это было не только не нужно, но и, возможно, вредно. Постоянные развороты доски "с ног на голову" не несут ничего полезного, а только дезориентируют.
</spoiler>
Серверу известно за какого игрока играет тот или иной пользователь, так почему бы не выгружать разные версии игры? Два описания: <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/scripts/chess.js">это</a> и <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/scripts/chess-black.js">это</a> - различаются только координатами полей доски на экране (вызовы view.defPosition в Dagaz.View.configure) и это решает проблему! Можно пойти ещё дальше.

<a href="https://games.dtco.ru/launch/27/22">
<img align="center" src="https://habrastorage.org/webt/kd/fu/lf/kdfulfciwt5dvzrg4uu0x_vln_k.png" /></a>
В этой <a href="https://en.wikipedia.org/wiki/Game_of_the_Generals">филиппинской игре</a> со скрытой информацией, мы не видим фигур противника, а можем судить об их ранге лишь по результатам взаимного боя с нашими фигурами. Если мы отдаём игрокам <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/gog.html">два</a> <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/gog-blue.html">разных</a> варианта игры, проблема решается элементарно - просто подменяем картинки вражеских фигур серыми прямоугольниками. Вот пример посложнее:

<a href="https://games.dtco.ru/launch/30/64">
<img align="center" src="https://habrastorage.org/webt/aa/2x/j8/aa2xj8kalolpcg4mw7noychujik.png" /></a>
Но принцип тот же - игроки играют в <b>разные</b>, хотя и согласованные между собой, игры. Тот же принцип можно использовать для, своего рода, интернационализации. Думаю, ни для кого не секрет, что люди разбирающиеся в иероглифах предпочитают видеть китайские и японские игры в традиционном исполнении, большинство же других людей подобное оформление лишь отпугивает. Раздавая пользователям <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/annan-shogi.html">разные</a> <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/dagaz/annan-shogi-north-kanji.html">версии</a> одной игры, мы можем обеспечить игру таких людей друг с другом так, что они даже ничего не заметят:

<a href="https://games.dtco.ru/launch/25/100">
<img align="center" src="https://habrastorage.org/webt/z5/ws/qx/z5wsqx91m8bqeptxongjprt5a0s.png" /></a>
Именно стилизации касалась одна из самых первых просьб пользователей. Это может показаться странным, но я совершенно не подумал о том, чтобы запоминать выбранный стиль, а постоянное его переключение (с европейского, на иероглифы),  при каждом подключении к игре, сильно раздражает. Исправление заметили не сразу. Такой, на мой взгляд, и должна быть функциональность сайта: удобной и незаметной.

<h2>Автоботы</h2>
В отличии от простой <a href="https://glukkazan.github.io/">странички</a> с играми, новый <a href="https://games.dtco.ru/map">сайт</a> ориентирован на игру пользователей друг с другом. Играть можно как в online, ожидая хода противника, так и заходя на сайт время от времени. История игры сохраняется на сервере и не теряется при обновлении страницы. За играми других пользователей тоже наблюдать можно: при подключении, все ходы будут воспроизведены с самого начала, после чего игра перейдёт в режим ожидания очередных ходов. Всё это прекрасно, но иногда хочется просто посмотреть на незнакомую игру быстро, не надеясь на то, что кто-то подключится и сделает свой ход.

<a href="https://games.dtco.ru/launch/35/50">
<img align="center" src="https://habrastorage.org/webt/ry/5p/7p/ry5p7peu-4xgllwq7x5ume-ffik.png" /></a>
Именно с этой целью я добавил на сайт ботов. Боты есть не для всех игр, но если игра вычислительно не сложная, почему бы не добавить такую возможность? Нажимая кнопку "Launch" (или просто кликая мышкой по картинке с игрой), пользователь начинает игру с ботом, а поскольку продолжительность "раздумий" ботов исчисляется секундами, игроку не приходится тратить своё время на продолжительное ожидание ответного хода противника. 

<spoiler title="На самом деле, такой бот загружается вместе с самой игрой">
Я вновь использую стилизацию, описанную выше. Игра с ботом - это отдельный html-файл, имя которого заканчивается суффиксом "-ai". Откуда launcher знает, что может загрузить игру с ботом?

<spoiler title="В базе данных есть специальная табличка">
<source lang="javascript">
@Entity()
export class game_bots {
    @PrimaryColumn()
    id: number;

    @Index()
    @Column({ nullable: false })
    game_id: number;
    @ManyToOne(type => games)
    @JoinColumn({ name: "game_id" })
    game: games;

    @Index()
    @Column({ nullable: true })
    variant_id: number;
    @ManyToOne(type => game_variants)
    @JoinColumn({ name: "variant_id" })
    variant: game_variants;

    @Column({ nullable: true })
    selector_value: number;

    @Column({ nullable: true })
    player_num: number;
}
</source>
Здесь стоит немного рассказать о том, как я храню игры.

<img align="center" src="https://habrastorage.org/webt/4r/sy/dy/4rsydyt-ckpf5bdbioce4tu5s4w.png" />
Прежде всего, есть табличка <b>games</b>, которая, на самом деле, описывает скорее не игры, а семейства игр. Более точное указание на игру - табличка <b>game_variants</b>, но запись в ней есть не всегда (например, <a href="https://en.wikipedia.org/wiki/Hex_(board_game)">Hex</a>, пока что, пребывает в своём <a href="https://games.dtco.ru/launch/29">семействе</a> в гордом одиночестве). Но этим дело не ограничивается! Есть ещё одно число, определяющее начальную расстановку фигур. Если я перехожу по ссылке '<a href="https://games.dtco.ru/launch/30/31/1">/launch/30/31/1</a>', то могу сыграть в <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>. Переход же по ссылке '<a href="https://games.dtco.ru/launch/30/31/2">/launch/30/31/2</a>' означает, что я хочу потренироваться в <a href="https://ru.wikipedia.org/wiki/Мат_слоном_и_конём">матовании слоном и конём</a>. В некоторых играх, "расстановки" могут управлять конфигурацией доски и даже нюансами правил самой игры.

<a href="https://games.dtco.ru/launch/26/83/5">
<img align="center" src="https://habrastorage.org/webt/mk/vu/il/mkvuilcdmlcrvrmwvqi2qnqdbow.png" /></a>
Третье число (селектор) - такой же полноправный участник "почтового адреса игры" как и первые два значения. Например, с его помощью я могу привязывать индивидуальные preview к расстановкам, отличающимся от стандартных. Примерно также привязываются боты. Если я укажу только id игры, то разрешу загрузку ботов для всего семейства. Указание <b>variant_id</b> позволяет уточнить привязку, <b>selector_value</b> разрешит загрузку бота только для указанной расстановки. 

Можно пойти ещё дальше и разрешить загрузку бота только для определённого игрока. Это очень удобно для ассиметричных игр. Думаю, должно быть понятно, что разработать бота убегающего от мата гораздо проще, чем бота ставящего мат. Кстати, все эти настройки ничего не говорят о том, какой именно бот (а их несколько разных) будет загружен. Это определяется тем, какие именно js-скрипты загружаются html-файлом, а поскольку благодаря стилизации html-файлы для разных игроков загружаются разные, загрузить им различающихся ботов также не является проблемой.
</spoiler>
Такое техническое решение вполне приемлемо, если игра не сложная и бот "думает" не дольше 2-3 секунд. Страничка ненадолго "подвисает", поскольку JavaScript занят интенсивными вычислениями, но пользователь этого даже не замечает, поскольку всё происходит очень быстро. У меня есть сообщения о проблемах с браузером "Safari", останавливающем скрипт, при обнаружении такого "зацикливания", но пока мне не удалось это воспроизвести. В любом случае, такое решение совершенно не подходит для более сложных игр, таких как <a href="https://games.dtco.ru/launch/30/142">Шахматы</a>.

Я вынашиваю грандиозные планы, относительно прикручивания какого либо популярного шахматного движка (например <a href="https://www.chessprogramming.org/Garbochess-JS">GarboChess</a>) к своему сайту. Такой подход позволит создавать по настоящему мощных ботов и запускать их на сервере. С точки зрения других пользователей, такой бот будет выглядеть как обычный игрок автоматически создающий игровую сессию и ожидающий подключения к ней. Он сможет "думать" дольше и гораздо эффективнее. Конечно, модель игры придётся дублировать в самом боте, но это наименьшее из того на что я готов пойти, чтобы заполучить подобную возможность.
</spoiler>
С технической точки зрения, игра с ботом - такая же игровая сессия, сохраняемая в базе. Пронаблюдать за ней можно точно также как за другими играми. Просто протекает она намного быстрее. 

<h2>Последний ход</h2>
Если игра ведётся в online, игроки видят ходы друг друга в реальном времени, но если кто-то из них выходит из игры и возвращается к ней позже (для этого имеется удобная вкладка "<a href="https://games.dtco.ru/session/2">My Turn</a>"), по текущей позиции бывает трудно понять какой именно ход сделал противник. Довольно быстро стало понятно, что с этим надо что-то делать. Я не хотел отмечать последние походившие фигуры так, как это делается, например, в <a href="https://ru.wikipedia.org/wiki/Го">Го</a>. Такое изменение должно было бы затронуть каждую игру (причём по-разному), кроме того, простая подсветка сходившей фигуры, в таких играх как <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>, малоинформативна.

<spoiler title="Вместо этого, я сделал следующее">
<source lang="javascript">
    async rollbackSess(r: string, sid:number, uid: number): Promise<string> {
        const last_id = await this.getLastId(sid, uid);
        if (last_id) {
            let x = await this.service.query(
                `select setup_str, turn_num
                 from   game_moves
                 where  id = $1`, [last_id]);
            if (!x || x.length == 0) {
                 return null;
            }
            r = x[0].setup_str;
            await this.service.createQueryBuilder("game_moves")
            .update(game_moves)
            .set({ 
                accepted: null
             })
            .where("session_id = :sid and turn_num > :turn", 
                      {sid: sid, turn: x[0].turn_num})
            .execute();
            await this.service.createQueryBuilder("game_sessions")
            .update(game_sessions)
            .set({ 
                last_turn: x[0].turn_num
             })
            .where("id = :sid", {sid: sid})
            .execute();
        }
        return r;
    }

    async recovery(user:number, s: Sess): Promise<Sess> {
        try {
            ...
                if (x[0].last_user && s.uid && !s.ai && 
                   !x[0].result_id && (x[0].last_user != s.uid)) {
                    s.last_setup = await this.rollbackSess(s.last_setup, s.id, s.uid);
                }
            ...
        } catch (error) {
          console.error(error);
          throw new InternalServerErrorException({
              status: HttpStatus.BAD_REQUEST,
              error: error
          });
        }
    }
</source>
Если мы возвращаемся в игру (выполняя <b>recovery</b>) и сейчас наша очередь хода, все последние ходы противника (в некоторых играх их может быть несколько) "откатываются" - помечаются как непрочитанные. В результате, игра загружается в обычном режиме, а подгрузка и анимация последних ходов выполняется в штатном режиме.
</spoiler>
Да, я понимаю, что это не идеальное решение. Хотелось бы иметь возможность "проматывать" ходы назад и вперёд неограниченно. И у меня даже есть такой <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">модуль</a>! Вот <a href="https://glukkazan.github.io/checkmate/chess-board.htm">здесь</a>, например, он прекрасно работает (просто сделайте несколько ходов и увидите наверху стрелочки).

<spoiler title="Но игра по сети вновь привносит свои коррективы">
Например, хотелось бы совместить эту функциональность с механизмом "возврата хода". Если один из игроков нажимает кнопку "назад" в игре, а не в режиме разбора партии, это должно приводить к отмене его последнего хода (и предпоследнего тоже, если он вдруг захочет откатиться ещё дальше). Но здесь возникает дилемма: если его оппонент ещё не успел ответить, ходы можно просто удалять из истории игры. В противном случае, отмена хода должна быть согласована с противником, а если он с ней согласится, история игры превратится в дерево, разделившись с этого момента на две ветви.

<spoiler title="По поводу согласования между игроками, есть ещё кое что, о чём меня очень просили">
Это кнопочки (или ссылочки) "Resign" и "Offer Draw". Иногда совершенно очевидно, что игру следует прервать досрочно. Первоначально такого механизма не было. С признанием поражения всё более менее просто, сервер надо просто уведомить о том, что игровую сессию можно закрыть, с поражением текущего игрока. А вот ничьи необходимо согласовывать. Так появилась табличка <b>game_alerts</b>. Один из игроков помещает в неё предложение ничьей, которое второй игрок видит, при запросе очередного хода. Если он не согласится - запись просто удаляется. В противном случае, сессия закрывается, с указанием ничьей. Конечно, хотелось бы расширить общение игроков, добавив внутриигровой чат, с сообщениями привязанными к ходам, но не всё сразу.
</spoiler>
Выгружать историю игры придётся в формате, поддерживающем хранение деревьев (<a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a> для этого подходит, а <a href="https://ru.wikipedia.org/wiki/Portable_Game_Notation">PGN</a> нет). В некоторых играх (в <a href="https://ru.wikipedia.org/wiki/Го">Го</a>, например) такая функциональность очень востребована. Кстати, понятно, что текущие ходы, полученные во время отката по истории игры назад, анимироваться не должны. Они должны тихонечко складываться в историю игры, для того чтобы игрок смог получить их позже, промотав историю вперёд.
</spoiler>
И это я ещё ничего не говорил о том, что любая игра должна быть устойчива к перезагрузке страницы (по этой причине, игры использующие историю игры (для реализации правила <a href="https://ru.wikipedia.org/wiki/Правило_ко">Ко</a>, например) приходится переписывать), что означает, что историю игры, для выполнения отката, нельзя хранить на клиенте, а придётся получать с сервера. В общем, здесь есть над чем поработать.

<h2>Нам нужна карта</h2>
Вот новшество, действительно горячо поддержанное всеми пользователями. Дело в том, что игр на сайте, в самом деле, довольно много. А поскольку не всегда бывает понятно, к какому именно семейству ту или иную игру отнести, ориентироваться на страничке "<a href="https://games.dtco.ru/launch">Launch</a>" бывает непросто. Меня попросили сделать карту.

<a href="https://games.dtco.ru/map">
<img align="center" src="https://habrastorage.org/webt/bz/ry/f8/bzryf8fjy_3vzmawcm9rqjn3tzc.png" /></a>
Самое прикольное в этой страничке то, что она не требует авторизации. Можно посмотреть на то, какие игры есть на сайте (их список постоянно пополняется), почитать правила (там где мне удалось их найти), выбрать игру (вот в этом месте сайт запросит логин и пароль), перейти к ней (пусть вас не смущает авторизация, мы перейдём к выбранной игре). Всё это не запустит игру, а только откроет страницу "Launch" на том месте, которое нас заинтересовало.

<a href="https://games.dtco.ru/launch/32/23">
<img align="center" src="https://habrastorage.org/webt/cl/tc/ux/cltcuxqusl5romh9dgljsrb7e9u.png" /></a>
Здесь тоже можно почитать правила (ссылка "Rules") и, собственно, запустить игру (кнопка "Launch"), выбрав игрока или игру с ботом, но не торопитесь это делать. Если вы видите кнопку "Join" - это означает, что кто-то из других игроков уже начал игру и ожидает присоединения партнёра.

<a href="https://games.dtco.ru/session/1/32/23">
<img align="center" src="https://habrastorage.org/webt/x6/fd/qj/x6fdqjpcpkgyplcwu8ypveniyoy.png" /></a>
Таких партий может быть несколько. И вы можете выбрать любую. Кнопка "View" (если она есть) служит для просмотра ранее сыгранных партий. Это просто ещё один способ ознакомиться с игрой и нескучно провести время.

В общем, сайт меняется каждый день и, как я надеюсь, меняется в лучшую сторону, а всех присутствующих хочу поздравить <b><i>с наступающими праздниками: Новым Годом и Рождеством!</i></b>
</cut>

Десять игр от Dagaz

<a href="https://games.dtco.ru/">
<img align="center" src="https://habrastorage.org/webt/hn/ou/ai/hnouaidx8fjygagbo8tkh0wzphe.png" /></a>
Долго ли, коротко ли, но я развернул свой <a href="https://github.com/GlukKazan/DagazServer">сервер</a>. Теперь это не просто <a href="https://glukkazan.github.io/">коллекция игрушек</a>, в меру укомплектованная слабенькими ботами, а полноценная возможность игры с другими людьми по сети. Сразу скажу, что игры, в основном, тяготеют к традиционным, но есть и авторские, порой довольно экзотичные. Кстати, если по вашему мнению какой-то из игр не хватает - пишите мне, я постараюсь добавить.
<cut>
<spoiler title="Немного технических подробностей">
<a href="https://games.dtco.ru/">
<img align="center" src="https://habrastorage.org/webt/nk/h1/8-/nkh18-vxra9coskqs1cwo_x0gs4.png" /></a>
Сайт требует регистрации. Это не по злому умыслу, а просто по той причине, что игра по сети подразумевает наличие учётной записи на сервере. Если у вас её нет, создание не займёт много времени.

<a href="https://games.dtco.ru/reg">
<img align="center" src="https://habrastorage.org/webt/f6/gk/f2/f6gkf2ulajxwch7sdk08i7jfszy.png" /></a>
Как видите, здесь не требуется указывать чего-то конфиденциального. Просто логин и пароль для входа на сервер. И вообще, регистрация вас ни к чему не обязывает. Проект полностью открытый, бесплатный и таковым и останется. Если вы вдруг захотите указать свой EMail, чтобы я мог с вами связаться, то это можно сделать в личном профиле, уже после регистрации. Но можно и не указывать. Кстати, обещаю, что спамить по этому адресу или кому-то его передавать я не буду.

Интересное начинается после входа на сервер:

<img align="center" src="https://habrastorage.org/webt/5s/2j/n0/5s2jn0jrr2yuxu5yu-raa46kgnc.png" />
Интерфейс простенький и возможно будет меняться со временем. Новая игра запускается на вкладке "Launch". Можно выбрать саму игру (скорее раздел с похожими играми), её вариант и, в некоторых случаях, начальную расстановку фигур. Игрока, за которого вы собираетесь играть, тоже можно выбрать (пока на сайте только игры рассчитанные на двух игроков, но игры для большего количества участников тоже планируются).

Для некоторых игр, имеется возможность подключения бота. Это не так интересно как игра с человеком, но позволяет ознакомиться с игрой или быстро поиграть, при отсутствии потенциальных оппонентов. Если вы НЕ выбрали эту возможность и нажали на кнопку Launch, будет создана игровая сессия, ожидающая присоединения второго игрока. Разумеется, вы сразу попадёте в игру и сможете сделать ход (если играете за первого игрока). Кстати, запущенную игру можно как угодно перезапускать или заходить в неё позже - информация о выполненных ходах не потеряется.

Присоединиться к сессии созданной другим игроком можно на вкладке Join. После этого, начинается полноценная игра (а если оба игрока в сети, то еще и в реальном времени). Контроля времени на ход пока нет, но когда появится, опция будет настраиваться при запуске игры. Активные игровые сессии доступны на вкладке Watch. Кстати, сессии других игроков подсматривать не возбраняется.

<img align="center" src="https://habrastorage.org/webt/gj/49/qo/gj49qozualzu7ciwm8btpllzczi.png" />
Для удобства игроков сделана ещё одна вкладка - "Your turn". Здесь можно быстро найти сессии, ожидающие вашего хода. И ещё одно - следующие далее по тексту картинки кликабельные, но, поскольку сайт требует авторизации, первый клик приведёт на страничку с запросом логина и пароля. После авторизации, переход приведёт туда, куда надо.
</spoiler>
Теперь, после того как я рассказал вам о том как пользоваться сайтом, позвольте представить несколько игр, на мой взгляд, заслуживающих внимания. Итак:

<h2>10. Ставропольские шашки</h2>
<a href="https://games.dtco.ru/launch/22/48">
<img align="left" src="https://habrastorage.org/webt/mj/4y/no/mj4yno2epht0uc38z4zkwrynxm4.png" /></a>Эта игра выглядит как "<a href="https://ru.wikipedia.org/wiki/Русские_шашки">Русские шашки</a>" и, по большей части, ими и является. Шашки ходят на одну клетку вперёд, по диагонали. Бой вражеской шашки выполняется перепрыгиванием (тоже по диагонали) на следующую за ней пустую клетку. Бой обязателен и его надо продолжать пока есть такая возможность, но если имеется несколько возможностей взятия, можно выбирать любой из ходов, независимо от количества фигур взятых в итоге. В игре действует правило "<a href="https://ru.wikipedia.org/wiki/Турецкий_удар">Турецкого удара</a>" - взятые фигуры убираются с доски только по завершении хода. Дойдя до последней горизонтали, обычная шашка превращается в "летающую дамку", способную бить противника по диагонали, на любое расстояние, останавливаясь на любой свободной клетке, после перепрыгивания вражеской фигуры. Если шашка заходит на последнюю горизонталь в процессе боя, она превращается немедленно, продолжая бой уже в новом качестве. В общем, отличие у "Ставропольских шашек" всего одно, но важное. Вы можете ходить не только своими фигурами, но и фигурами противника. Тот, чьи фигуры останутся на доске не заблокированными, побеждает. Найти "<a href="https://games.dtco.ru/launch/22/48">Stavropol Checkers</a>" можно в разделе "<a href="https://games.dtco.ru/launch/22">Checkers</a>".

<h2>9. Белорусские шахматы</h2>
<a href="https://games.dtco.ru/launch/36/63">
<img align="right" src="https://habrastorage.org/webt/cx/zz/x8/cxzzx8suizi950fata2j-ropyn4.png" /></a>Здесь <a href="https://games.dtco.ru/launch/36/63/2">два</a> варианта расстановки фигур и тот что на картинке нравится мне больше. Сама игра представляет собой забавное сочетание "<a href="https://ru.wikipedia.org/wiki/Русские_шашки">Русских шашек</a>" и "<a href="https://ru.wikipedia.org/wiki/Шахматы">Шахмат</a>". Что в игре интересного? Например, вы можете атаковать короля противника "из укрытия" - шашкой или дамкой, после длинной цепочки взятий. Или поставить <a href="https://ru.wikipedia.org/wiki/Мат_(шахматы)">мат</a> королём, подойдя к королю противника вплотную. Этот, казалось бы, странный казус напрямую вытекает из правил игры. Дело в том, что если игрок имеет возможность боя шашкой или дамкой, он обязан ими ходить, даже если его король находится под <a href="https://ru.wikipedia.org/wiki/Шах_(шахматы)">шахом</a>. Это означает, что если в такой момент напасть на короля, защититься он не сможет (разве что какой-то из шашечных фигур). Нападать можно любой фигурой, в том числе и королём. В самом деле, атаковать короля в ответ никто не сможет, главное не ставить его под удар шашки или дамки. Подробнее об игре можно почитать <a href="http://belarus.fmjd.org/modules/smartsection/item.php?com_mode=flat&com_order=1&itemid=212">здесь</a>. А найти её можно в разделе "<a href="https://games.dtco.ru/launch/36/63">Cheskers</a>".

<h2>8. Столбовые шашки</h2>
<a href="https://games.dtco.ru/launch/24/35">
<img align="left" src="https://habrastorage.org/webt/vw/e7/-e/vwe7-elj1jcntqnvua8ojgkec1i.png" /></a>Эта <a href="https://ru.wikipedia.org/wiki/Столбовые_шашки">игра</a> - сама история, во всяком случае, известна она с 1875 года. В основе правил вновь "<a href="https://ru.wikipedia.org/wiki/Русские_шашки">Русские шашки</a>", но, в этот раз, изменение правил ещё интереснее. Дело в том, что взятые фигуры доску не покидают, а берутся "в плен" под побившую их фигуру. Соответственно, из плена их можно освободить, побив верхнюю фигуру. Знаменитый гроссмейстер, <a href="https://ru.wikipedia.org/wiki/Ласкер,_Эмануил">Эмануил Ласкер</a> высоко оценил эту игру, но, поскольку сам предпочитал <a href="https://ru.wikipedia.org/wiki/Английские_шашки">шашки английские</a>, придумал <a href="https://games.dtco.ru/launch/24/36">другую</a>, более респектабельную и без столь любимых русскому человеку дальнобойных дамок. Многие русские шашисты считают, что за столбовыми шашками будущее. Под эти игры выделен специальный раздел сайта, который называется "<a href="https://games.dtco.ru/launch/24/35">Column Checkers</a>".

<h2>7. Мельница</h2>
<a href="https://games.dtco.ru/launch/35/49">
<img align="right" src="https://habrastorage.org/webt/gw/av/bd/gwavbd1w_4sbpzo89w2lplzm0lg.png" /></a>Устали от шашек? Тогда "<a href="https://ru.wikipedia.org/wiki/Мельница_(игра)">Мельница</a>" - ваш выбор! Эта игра состоит в глубоком родстве с "<a href="https://ru.wikipedia.org/wiki/Крестики-нолики">Крестиками-ноликами</a>". Начинается она с пустой доски, на которую игроки, по очереди, ставят свои камни. Цель этих действий - построить "мельницу", ряд из трёх камней по одной из отмеченных линий. Если это удалось, игрок имеет право снять с доски один из камней противника. Приоритет отдаётся камням не входящим во вражеские "мельницы". После того как каждый из игроков выставил на доску по 9 своих камней, камни разрешается перемещать на пустой соседний пункт по отмеченным линиям. Цель та же - "смолоть" камни противника. Камни становятся "летающими", когда у игрока их остаётся не больше трёх. Летающие камни разрешено перемещать на любое свободное поле доски, впрочем, это, как правило, не спасает. Мельничных игр очень много - разные доски, разный набор камней. На сайте для них выделен раздел "<a href="https://games.dtco.ru/launch/35">Morris</a>".

<h2>6. Platform Chess</h2>
<a href="https://games.dtco.ru/launch/30/99">
<img align="left" src="https://habrastorage.org/webt/cy/kl/ix/cyklixmratjnmnbew5shgzrht6s.png" /></a>Эту забавную игру-трансформер <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=5">Robert Price</a> придумал в 2001 году. Все фигуры располагаются на платформах 2x2 клетки. Платформы своего цвета можно перемещать вместе с фигурами также, как это делается в "<a href="https://ru.wikipedia.org/wiki/Игра_в_15">пятнашках</a>". В остальном, игра полностью аналогична <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматам</a>. Начальный прыжок пешки, <a href="https://ru.wikipedia.org/wiki/Взятие_на_проходе">взятие на проходе</a>, <a href="https://ru.wikipedia.org/wiki/Рокировка">рокировки</a> - всё это работает, но, в дополнение к этому, можно перемещать по несколько фигур сразу или убирать платформу с того места, на которое фигура собирается сходить. Я взял на себя смелость и сделал небольшое <a href="https://games.dtco.ru/launch/30/99/2">дополнение</a>, в котором часть пешек заменяется бомбами. Бомбы перемещаются также как пешки, но не могут брать фигуры противника. Зато, они могут подрывать платформы, вместе с находящимися на них фигурами. В игру встроен защитный механизм, запрещающий подрыв на платформах со своими фигурами. Найти обе игры можно в разделе "<a href="https://games.dtco.ru/launch/30/99">Chess</a>".

<h2>5. Chess Go</h2>
<a href="https://games.dtco.ru/launch/23/86">
<img align="right" src="https://habrastorage.org/webt/g5/vu/a_/g5vua_f2jil6gd0gausqdzxlnia.png" /></a>А вот это уже моя разработка. Игра начинается как <a href="https://ru.wikipedia.org/wiki/Го">Го</a> на доске 9x9, но в какой-то момент, на доску вводятся фигуры, ставить которые можно только вместо камней своего цвета. Вторжение фигур на доску начинается с <a href="https://ru.wikipedia.org/wiki/Сянци#Король_(Генерал)">генерала</a> (противник должен разместить на доске своего генерала следующим ходом). После этого, можно добавлять на доску другие фигуры или новые камни, в любом порядке. Цель игры - захват вражеского генерала, но сделать это можно только по правилам Го, то есть, лишив <a href="https://ru.wikipedia.org/wiki/Терминология_го">дамэ</a> группу, в которой он находится. Схема перемещения фигур берёт за основу правила <a href="https://ru.wikipedia.org/wiki/Сянци">Сянци</a>, за тем исключением, что завершать ход на фигурах противника запрещено, а камни (без фигур на них) рассматриваются как пустое пространство. Если ход завершается на камне, фигура меняется с ним местами. Генерал может перемещаться только по камням своего цвета (и, как следствие, не может покинуть свою группу). <a href="https://ru.wikipedia.org/wiki/Сянци#Советник">Советник</a> также перемещается по камням, превращая при этом вражеские камни в свои. Найти игру можно в разделе "<a href="https://games.dtco.ru/launch/23/86">XiangQi</a>".

<h2>4. LuzhanQi</h2>
<a href="https://games.dtco.ru/launch/27/21">
<img align="left" src="https://habrastorage.org/webt/a4/ww/-a/a4ww-a0faz72acqkrxsz0j5afic.png" /></a>Китайская <a href="https://skyruk.livejournal.com/428408.html">игра</a>, похожая на <a href="https://ru.wikipedia.org/wiki/Стратего">Стратего</a>, но более интересная в тактическом плане. Это игра со скрытой информацией. Вы не знаете расположение фигур противника, пока не вступите с ними в бой. В отличии от Стратего, на доске есть убежища, защищающие фигуры от нападения и железные дороги, по которым можно перемещаться на любое расстояние по прямой. Флаг размещается в одном из двух штабов. Фигуры бьют друг друга, в соответствии с их силой (при равенстве сил, с доски убираются обе фигуры). Самая сильная фигура - фельдмаршал, самая слабая - инженер. Инженер может обезвреживать мины (остальные фигуры на них подрываются). Также в игре есть "одноразовые" гранаты, уничтожающие любую фигуру. Найти игру можно в разделе "<a href="https://games.dtco.ru/launch/27/21">Stratego</a>".

<h2>3. Dark XiangQi</h2>
<a href="https://games.dtco.ru/launch/23/12">
<img align="right" src="https://habrastorage.org/webt/lk/lg/yo/lklgyoe0zlodktmdk2l8winy_ga.png" /></a>Ещё одна модная игра, на основе "<a href="https://ru.wikipedia.org/wiki/Сянци">Китайских шахмат</a>". Все фигуры, кроме генералов, в начале игры перевёрнуты. Первый ход выполняется по <a href="https://ru.wikipedia.org/wiki/Сянци">правилам</a>, в соответствии с начальным расположением фигуры. После этого, фигура переворачивается и далее ходит уже в соответствии со своим номиналом. Интересным следствием из этого является то, что слоны могут переходить через "реку" на территорию противника, а советники вполне способны покидать замок. Также как и предыдущая, это игра со скрытой информацией. Найти её можно в разделе "<a href="https://games.dtco.ru/launch/23/12">XiangQi</a>".

<h2>2. BanQi</h2>
<a href="https://games.dtco.ru/launch/33/40">
<img align="left" src="https://habrastorage.org/webt/83/9w/o2/839wo2536tkqzzzvg2ijk6thce8.png" /></a>Ещё одна <a href="https://en.wikipedia.org/wiki/Banqi">игра</a>, похожая на предыдущую. Все фигуры, в начале игры, перевёрнуты. Первый игрок, открывая любую фигуру, определяет цвет, которым будет играть. Далее игроки, по очереди, либо открывают фигуры, либо ходят фигурами своего цвета. Перемещаться разрешено только по вертикали или горизонтали и, для большинства фигур, только на одну клетку. Исключение делается для пушек (в тайваньском варианте игры). Эти фигуры ходят по правилам <a href="https://ru.wikipedia.org/wiki/Сянци">XiangQi</a>, то есть, перепрыгивая через одну фигуру и приземляясь на следующей, пропуская любое число пустых полей. Бой осуществляется в соответствии с рангом фигур и различается в тайваньской и китайской версиях. Все игры семейства вынесены в раздел "<a href="https://games.dtco.ru/launch/33">BanQi</a>" на сервере.

<h2>1. Dark Chess</h2>
<a href="https://games.dtco.ru/launch/30/64">
<img align="right" src="https://habrastorage.org/webt/kd/k5/gs/kdk5gsa915apdl7k3owzfnmks_q.png" /></a>Подводя итог обзора, хочу представить ещё одну игру со скрытой информацией. Это обычные <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>, но видите вы лишь те поля, до которых могут добраться ваши фигуры (в случае с <a href="https://ru.wikipedia.org/wiki/Пешка">пешками</a>, это как поля располагающиеся впереди по диагонали, так и лежащие прямо по курсу). Помимо этого, игра даёт подсказку об уязвимости ваших собственных фигур. Если фигура отображается как полупрозрачная - противник её не видит. В противном случае, вам стоит задуматься о её защите. В общем, те люди, которые устали от обычных шахмат, могут получить новые впечатления, попробовав поиграть "на ощупь". Разумеется, ваш противник будет находиться в том же положении. Игру можно найти в разделе "<a href="https://games.dtco.ru/launch/30/64">Chess</a>".

Вот и подошёл к концу наш мини-рейтинг. Как и все рейтинги, он получился субъективным. Я написал о тех играх, которые нравятся мне. Возможно, вам удастся найти на моём сервере ту игру, которая нравится вам. С другой стороны, может оказаться так, что такой игры там не найдётся вовсе. В таком случае, напишите мне и я постараюсь её добавить.
</cut>

DagazServer: Как всё устроено

По всей видимости, я не самый правильный фронтедщик. Большую часть сознательной жизни я занимаюсь базами данных и немного бакендом. Любовь к настольным играм - вот что заставило меня связаться с web-разработкой. Новый, совершенно незнакомый мне язык программирования - JavaScript, я изучал по ходу дела. Допускаю, что многое из того что я делал, способно ужаснуть опытных web-разработчиков, но я стараюсь стать лучше. Этот текст не для тех, кто привык во всём следовать раз и навсегда написанным инструкциям. Но если вы любите экспериментировать, докапываться до каждой мелочи, открывать новое для себя, добро пожаловать под сень моего леса.

<img align="center" src="https://habrastorage.org/webt/a7/gv/zy/a7gvzynraneaz6j531jgz_widai.jpeg" />
<cut>
<spoiler title="С чего всё началось">
Фаза активного увлечения настольными играми началась для меня со знакомства с <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. То что на компьютере можно играть в игры - новостью не было. Оригинальность этого проекта заключалась в использовании ZRF - Lisp-оподобного языка, предназначенного для быстрого описания <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">разнообразных игр</a>. К сожалению, я быстро осознал, что хотя простые игры делаются на ZRF просто, игры чуть сложнее быстро выливаются в тысячи строк малопонятного кода. Для примера, в ZRF нет самой обычной арифметики. В результате, целочисленные значения приходится собирать из битовых флагов.

<spoiler title="И выглядит это как-то так">
<source lang="lisp">
(define not-0?
  (or (flag? $1-08)
      (flag? $1-04)
      (flag? $1-02)
      (flag? $1-01)
  )
)

(define inc
   (if (flag? $1-01)
       (set-flag $1-01 false)
       (if (flag? $1-02)
           (set-flag $1-02 false)
           (if (flag? $1-04)
               (set-flag $1-04 false)
               (if (flag? $1-08)
                   (set-flag $1-08 false)
                else
                   (set-flag $1-08 true)
               )
            else
               (set-flag $1-04 true)
           )
        else
           (set-flag $1-02 true)
       )
    else
       (set-flag $1-01 true)
   )
)

(define dec
   (if (not-flag? $1-01)
       (set-flag $1-01 true)
       (if (not-flag? $1-02)
           (set-flag $1-02 true)
           (if (not-flag? $1-04)
               (set-flag $1-04 true)
               (if (not-flag? $1-08)
                   (set-flag $1-08 true)
                else
                   (set-flag $1-08 false)
               )
            else
               (set-flag $1-04 false)
           )
        else
           (set-flag $1-02 false)
       )
    else
       (set-flag $1-01 false)
   )
)

(define sum
   (while (not-0? $2)
       (inc $1)
       (dec $2)
   )
)
</source>
</spoiler>
В <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a> - библиотеке разработанной Грегом Шмидтом, складывать числа было можно, но в качестве метаязыка использовался диалект <a href="https://ru.wikipedia.org/wiki/Форт_(язык_программирования)">Forth</a>-а, что не делало программы более понятными. Само решение представляло собой, в некотором роде, хак использующий API, предназначенное для подключения к Zillions ботов. Кроме того, Axiom никак не решала фатальный недостаток Zillions - игры продолжали запускаться только под Windows и только на платной платформе с закрытым исходным кодом.

Знакомство с проектом <a href="http://hgm.nubati.net/jocly/jocly-master/examples/browser/control.html">Jocly</a> подсказало мне возможное решение этой проблемы. Действительно, игра написанная на JavaScript могла запускаться в любом современном браузере, в том числе на мобильных платформах. С этого момента началась работа над <a href="https://github.com/GlukKazan/Dagaz">Dagaz</a>. Что-то я подсмотрел в <a href="https://github.com/mi-g/jocly">Jocly</a>, а что-то у <a href="http://zanefisher.github.io/nine-tile-cyvasse/">Зейна Фишера</a>. Также как Zillions, Dagaz использует ZRF (это позволяет разрабатывать прототипы новых игр очень быстро), но не напрямую (что оказалось невозможным из-за недостаточной производительности), а после компиляции специальной <a href="https://github.com/GlukKazan/Dagaz/tree/master/utils/z2j">утилитой</a>.

<spoiler title="Вот это">
<source lang="lisp">
(define checker-shift (
   $1 (verify empty?)
   (if (in-zone? promotion)
      (add King)
    else
      add
   )
))

(define checker-jump (
   $1 (verify enemy?) 
   capture 
   $1 (verify empty?)
   (if (in-zone? promotion)
       (add-partial King continue-type)
    else
       (add-partial jump-type)
   )
))

(define king-shift (
   $1 (while empty?
       add $1
   )
))

(define king-jump (
   $1 (while empty?  $1)
   (verify enemy?)
   $1 (while empty?
       mark
       (while empty? 
          (opposite $1)
       ) 
       capture
       back
       (add-partial continue-type) $1
   )
))

(define king-continue (
   $1 (while empty? 
       $1 (verify not-last-from?)
   )
   (verify enemy?) 
   $1 (while empty?
       mark
       (while empty? 
          (opposite $1)
       ) 
       capture
       back
       (add-partial continue-type) $1
   )
))

(game
  (title "Russian Checkers")

  (players White Black)
  (turn-order White Black)
  (move-priorities jump-type normal-type)

  (board
     (image "images/8x8.bmp")
     (grid
         (start-rectangle 2 2 52 52)
         (dimensions
           ("a/b/c/d/e/f/g/h" (50 0)) ; files
           ("8/7/6/5/4/3/2/1" (0 50)) ; ranks
         )
         (directions (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1))
     )
     (symmetry Black (nw se) (se nw) (ne sw) (sw ne))
     (zone (name promotion) (players White)
           (positions b8 d8 f8 h8)
     )
     (zone (name promotion) (players Black)
           (positions a1 c1 e1 g1)
     )
  )

  (piece
     (name Man)
     (image White "images/wman.bmp"
            Black "images/bman.bmp")
     (moves
         (move-type jump-type)
         (checker-jump nw) (checker-jump ne) (checker-jump sw) (checker-jump se)
         (move-type normal-type)
         (checker-shift nw) (checker-shift ne)
     )
  )
  (piece
     (name King)
     (image White "images/wdamone.bmp"
            Black "images/bdamone.bmp")
     (moves
         (move-type jump-type)
         (king-jump nw) (king-jump ne) (king-jump sw) (king-jump se)
         (move-type continue-type)
         (king-continue nw) (king-continue ne) 
         (king-continue sw) (king-continue se)
         (move-type normal-type)
         (king-shift nw) (king-shift ne) (king-shift sw) (king-shift se)
     )
  )

  (board-setup
    (White (Man a1 c1 e1 g1  b2 d2 f2 h2  a3 c3 e3 g3) )
    (Black (Man b8 d8 f8 h8  a7 c7 e7 g7  b6 d6 f6 h6) )
  )
)
</source>
</spoiler><spoiler title="превращается в это">
<source lang="javascript">
ZRF = {
    JUMP:          0,
    IF:            1,
    FORK:          2,
    FUNCTION:      3,
    IN_ZONE:       4,
    FLAG:          5,
    SET_FLAG:      6,
    POS_FLAG:      7,
    SET_POS_FLAG:  8,
    ATTR:          9,
    SET_ATTR:      10,
    PROMOTE:       11,
    MODE:          12,
    ON_BOARD_DIR:  13,
    ON_BOARD_POS:  14,
    PARAM:         15,
    LITERAL:       16,
    VERIFY:        20
};

Dagaz.Model.BuildDesign = function(design) {
    design.checkVersion("z2j", "2");
    design.checkVersion("animate-captures", "false");
    design.checkVersion("smart-moves", "true");
    design.checkVersion("show-hints", "false");
    design.checkVersion("show-blink", "true");
    design.checkVersion("deferred-captures", "true");
    design.checkVersion("advisor-wait", "5");

    design.addDirection("ne");
    design.addDirection("se");
    design.addDirection("sw");
    design.addDirection("nw");

    design.addPlayer("White", [2, 3, 0, 1]);
    design.addPlayer("Black", [2, 3, 0, 1]);

    design.addPosition("a8", [0, 9, 0, 0]);
    design.addPosition("b8", [0, 9, 7, 0]);
    design.addPosition("c8", [0, 9, 7, 0]);
    design.addPosition("d8", [0, 9, 7, 0]);
    design.addPosition("e8", [0, 9, 7, 0]);
    design.addPosition("f8", [0, 9, 7, 0]);
    design.addPosition("g8", [0, 9, 7, 0]);
    design.addPosition("h8", [0, 0, 7, 0]);
    design.addPosition("a7", [-7, 9, 0, 0]);
    design.addPosition("b7", [-7, 9, 7, -9]);
    design.addPosition("c7", [-7, 9, 7, -9]);
    design.addPosition("d7", [-7, 9, 7, -9]);
    design.addPosition("e7", [-7, 9, 7, -9]);
    design.addPosition("f7", [-7, 9, 7, -9]);
    design.addPosition("g7", [-7, 9, 7, -9]);
    design.addPosition("h7", [0, 0, 7, -9]);
    design.addPosition("a6", [-7, 9, 0, 0]);
    design.addPosition("b6", [-7, 9, 7, -9]);
    design.addPosition("c6", [-7, 9, 7, -9]);
    design.addPosition("d6", [-7, 9, 7, -9]);
    design.addPosition("e6", [-7, 9, 7, -9]);
    design.addPosition("f6", [-7, 9, 7, -9]);
    design.addPosition("g6", [-7, 9, 7, -9]);
    design.addPosition("h6", [0, 0, 7, -9]);
    design.addPosition("a5", [-7, 9, 0, 0]);
    design.addPosition("b5", [-7, 9, 7, -9]);
    design.addPosition("c5", [-7, 9, 7, -9]);
    design.addPosition("d5", [-7, 9, 7, -9]);
    design.addPosition("e5", [-7, 9, 7, -9]);
    design.addPosition("f5", [-7, 9, 7, -9]);
    design.addPosition("g5", [-7, 9, 7, -9]);
    design.addPosition("h5", [0, 0, 7, -9]);
    design.addPosition("a4", [-7, 9, 0, 0]);
    design.addPosition("b4", [-7, 9, 7, -9]);
    design.addPosition("c4", [-7, 9, 7, -9]);
    design.addPosition("d4", [-7, 9, 7, -9]);
    design.addPosition("e4", [-7, 9, 7, -9]);
    design.addPosition("f4", [-7, 9, 7, -9]);
    design.addPosition("g4", [-7, 9, 7, -9]);
    design.addPosition("h4", [0, 0, 7, -9]);
    design.addPosition("a3", [-7, 9, 0, 0]);
    design.addPosition("b3", [-7, 9, 7, -9]);
    design.addPosition("c3", [-7, 9, 7, -9]);
    design.addPosition("d3", [-7, 9, 7, -9]);
    design.addPosition("e3", [-7, 9, 7, -9]);
    design.addPosition("f3", [-7, 9, 7, -9]);
    design.addPosition("g3", [-7, 9, 7, -9]);
    design.addPosition("h3", [0, 0, 7, -9]);
    design.addPosition("a2", [-7, 9, 0, 0]);
    design.addPosition("b2", [-7, 9, 7, -9]);
    design.addPosition("c2", [-7, 9, 7, -9]);
    design.addPosition("d2", [-7, 9, 7, -9]);
    design.addPosition("e2", [-7, 9, 7, -9]);
    design.addPosition("f2", [-7, 9, 7, -9]);
    design.addPosition("g2", [-7, 9, 7, -9]);
    design.addPosition("h2", [0, 0, 7, -9]);
    design.addPosition("a1", [-7, 0, 0, 0]);
    design.addPosition("b1", [-7, 0, 0, -9]);
    design.addPosition("c1", [-7, 0, 0, -9]);
    design.addPosition("d1", [-7, 0, 0, -9]);
    design.addPosition("e1", [-7, 0, 0, -9]);
    design.addPosition("f1", [-7, 0, 0, -9]);
    design.addPosition("g1", [-7, 0, 0, -9]);
    design.addPosition("h1", [0, 0, 0, -9]);

    design.addZone("promotion", 1, [1, 3, 5, 7]);
    design.addZone("promotion", 2, [56, 58, 60, 62]);
    design.addZone("best", 1, [26, 21]);
    design.addZone("best", 2, [37, 42]);

    design.addCommand(0, ZRF.FUNCTION,	24);	// from
    design.addCommand(0, ZRF.PARAM,	0);	// $1
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.FUNCTION,	26);	// capture
    design.addCommand(0, ZRF.PARAM,	1);	// $2
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.IN_ZONE,	0);	// promotion
    design.addCommand(0, ZRF.FUNCTION,	0);	// not
    design.addCommand(0, ZRF.IF,	5);
    design.addCommand(0, ZRF.PROMOTE,	1);	// King
    design.addCommand(0, ZRF.MODE,	2);	// continue-type
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.JUMP,	3);
    design.addCommand(0, ZRF.MODE,	0);	// jump-type
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.FUNCTION,	28);	// end

    design.addCommand(1, ZRF.FUNCTION,	24);	// from
    design.addCommand(1, ZRF.PARAM,	0);	// $1
    design.addCommand(1, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(1, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.IN_ZONE,	0);	// promotion
    design.addCommand(1, ZRF.FUNCTION,	0);	// not
    design.addCommand(1, ZRF.IF,	4);
    design.addCommand(1, ZRF.PROMOTE,	1);	// King
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.JUMP,	2);
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.FUNCTION,	28);	// end

    design.addCommand(2, ZRF.FUNCTION,	24);	// from
    design.addCommand(2, ZRF.PARAM,	0);	// $1
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(2, ZRF.FUNCTION,	0);	// not
    design.addCommand(2, ZRF.IF,	4);
    design.addCommand(2, ZRF.PARAM,	1);	// $2
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.JUMP,	-5);
    design.addCommand(2, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(2, ZRF.FUNCTION,	20);	// verify
    design.addCommand(2, ZRF.PARAM,	2);	// $3
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(2, ZRF.FUNCTION,	0);	// not
    design.addCommand(2, ZRF.IF,	18);
    design.addCommand(2, ZRF.FUNCTION,	6);	// mark
    design.addCommand(2, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(2, ZRF.FUNCTION,	0);	// not
    design.addCommand(2, ZRF.IF,	5);
    design.addCommand(2, ZRF.PARAM,	3);	// $4
    design.addCommand(2, ZRF.FUNCTION,	23);	// opposite
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.JUMP,	-6);
    design.addCommand(2, ZRF.FUNCTION,	26);	// capture
    design.addCommand(2, ZRF.FUNCTION,	7);	// back
    design.addCommand(2, ZRF.FORK,	4);
    design.addCommand(2, ZRF.MODE,	2);	// continue-type
    design.addCommand(2, ZRF.FUNCTION,	25);	// to
    design.addCommand(2, ZRF.FUNCTION,	28);	// end
    design.addCommand(2, ZRF.PARAM,	4);	// $5
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.JUMP,	-19);
    design.addCommand(2, ZRF.FUNCTION,	28);	// end

    design.addCommand(3, ZRF.FUNCTION,	24);	// from
    design.addCommand(3, ZRF.PARAM,	0);	// $1
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.IF,	7);
    design.addCommand(3, ZRF.PARAM,	1);	// $2
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.FUNCTION,	4);	// last-from?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.FUNCTION,	20);	// verify
    design.addCommand(3, ZRF.JUMP,	-8);
    design.addCommand(3, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(3, ZRF.FUNCTION,	20);	// verify
    design.addCommand(3, ZRF.PARAM,	2);	// $3
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.IF,	18);
    design.addCommand(3, ZRF.FUNCTION,	6);	// mark
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.IF,	5);
    design.addCommand(3, ZRF.PARAM,	3);	// $4
    design.addCommand(3, ZRF.FUNCTION,	23);	// opposite
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.JUMP,	-6);
    design.addCommand(3, ZRF.FUNCTION,	26);	// capture
    design.addCommand(3, ZRF.FUNCTION,	7);	// back
    design.addCommand(3, ZRF.FORK,	4);
    design.addCommand(3, ZRF.MODE,	2);	// continue-type
    design.addCommand(3, ZRF.FUNCTION,	25);	// to
    design.addCommand(3, ZRF.FUNCTION,	28);	// end
    design.addCommand(3, ZRF.PARAM,	4);	// $5
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.JUMP,	-19);
    design.addCommand(3, ZRF.FUNCTION,	28);	// end

    design.addCommand(4, ZRF.FUNCTION,	24);	// from
    design.addCommand(4, ZRF.PARAM,	0);	// $1
    design.addCommand(4, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(4, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(4, ZRF.FUNCTION,	0);	// not
    design.addCommand(4, ZRF.IF,	7);
    design.addCommand(4, ZRF.FORK,	3);
    design.addCommand(4, ZRF.FUNCTION,	25);	// to
    design.addCommand(4, ZRF.FUNCTION,	28);	// end
    design.addCommand(4, ZRF.PARAM,	1);	// $2
    design.addCommand(4, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(4, ZRF.JUMP,	-8);
    design.addCommand(4, ZRF.FUNCTION,	28);	// end

    design.addPriority(0);			// jump-type
    design.addPriority(1);			// normal-type

    design.addPiece("Man", 0, 20);
    design.addMove(0, 0, [3, 3], 0);
    design.addMove(0, 0, [0, 0], 0);
    design.addMove(0, 0, [2, 2], 0);
    design.addMove(0, 0, [1, 1], 0);
    design.addMove(0, 1, [3], 1);
    design.addMove(0, 1, [0], 1);

    design.addPiece("King", 1, 100);
    design.addMove(1, 2, [3, 3, 3, 3, 3], 0, 10);
    design.addMove(1, 2, [0, 0, 0, 0, 0], 0, 10);
    design.addMove(1, 2, [2, 2, 2, 2, 2], 0, 10);
    design.addMove(1, 2, [1, 1, 1, 1, 1], 0, 10);
    design.addMove(1, 3, [3, 3, 3, 3, 3], 2, 10);
    design.addMove(1, 3, [0, 0, 0, 0, 0], 2, 10);
    design.addMove(1, 3, [2, 2, 2, 2, 2], 2, 10);
    design.addMove(1, 3, [1, 1, 1, 1, 1], 2, 10);
    design.addMove(1, 4, [3, 3], 1, 10);
    design.addMove(1, 4, [0, 0], 1, 10);
    design.addMove(1, 4, [2, 2], 1, 10);
    design.addMove(1, 4, [1, 1], 1, 10);

    design.setup("White", "Man", 56);
    design.setup("White", "Man", 58);
    design.setup("White", "Man", 60);
    design.setup("White", "Man", 62);
    design.setup("White", "Man", 49);
    design.setup("White", "Man", 51);
    design.setup("White", "Man", 53);
    design.setup("White", "Man", 55);
    design.setup("White", "Man", 40);
    design.setup("White", "Man", 42);
    design.setup("White", "Man", 44);
    design.setup("White", "Man", 46);
    design.setup("Black", "Man", 1);
    design.setup("Black", "Man", 3);
    design.setup("Black", "Man", 5);
    design.setup("Black", "Man", 7);
    design.setup("Black", "Man", 8);
    design.setup("Black", "Man", 10);
    design.setup("Black", "Man", 12);
    design.setup("Black", "Man", 14);
    design.setup("Black", "Man", 17);
    design.setup("Black", "Man", 19);
    design.setup("Black", "Man", 21);
    design.setup("Black", "Man", 23);
}

Dagaz.View.configure = function(view) {
    view.defBoard("Board");
    view.defPiece("WhiteMan", "White Man");
    view.defPiece("BlackMan", "Black Man");
    view.defPiece("WhiteKing", "White King");
    view.defPiece("BlackKing", "Black King");
 
    view.defPosition("a8", 2, 2, 50, 50);
    view.defPosition("b8", 52, 2, 50, 50);
    view.defPosition("c8", 102, 2, 50, 50);
    view.defPosition("d8", 152, 2, 50, 50);
    view.defPosition("e8", 202, 2, 50, 50);
    view.defPosition("f8", 252, 2, 50, 50);
    view.defPosition("g8", 302, 2, 50, 50);
    view.defPosition("h8", 352, 2, 50, 50);
    view.defPosition("a7", 2, 52, 50, 50);
    view.defPosition("b7", 52, 52, 50, 50);
    view.defPosition("c7", 102, 52, 50, 50);
    view.defPosition("d7", 152, 52, 50, 50);
    view.defPosition("e7", 202, 52, 50, 50);
    view.defPosition("f7", 252, 52, 50, 50);
    view.defPosition("g7", 302, 52, 50, 50);
    view.defPosition("h7", 352, 52, 50, 50);
    view.defPosition("a6", 2, 102, 50, 50);
    view.defPosition("b6", 52, 102, 50, 50);
    view.defPosition("c6", 102, 102, 50, 50);
    view.defPosition("d6", 152, 102, 50, 50);
    view.defPosition("e6", 202, 102, 50, 50);
    view.defPosition("f6", 252, 102, 50, 50);
    view.defPosition("g6", 302, 102, 50, 50);
    view.defPosition("h6", 352, 102, 50, 50);
    view.defPosition("a5", 2, 152, 50, 50);
    view.defPosition("b5", 52, 152, 50, 50);
    view.defPosition("c5", 102, 152, 50, 50);
    view.defPosition("d5", 152, 152, 50, 50);
    view.defPosition("e5", 202, 152, 50, 50);
    view.defPosition("f5", 252, 152, 50, 50);
    view.defPosition("g5", 302, 152, 50, 50);
    view.defPosition("h5", 352, 152, 50, 50);
    view.defPosition("a4", 2, 202, 50, 50);
    view.defPosition("b4", 52, 202, 50, 50);
    view.defPosition("c4", 102, 202, 50, 50);
    view.defPosition("d4", 152, 202, 50, 50);
    view.defPosition("e4", 202, 202, 50, 50);
    view.defPosition("f4", 252, 202, 50, 50);
    view.defPosition("g4", 302, 202, 50, 50);
    view.defPosition("h4", 352, 202, 50, 50);
    view.defPosition("a3", 2, 252, 50, 50);
    view.defPosition("b3", 52, 252, 50, 50);
    view.defPosition("c3", 102, 252, 50, 50);
    view.defPosition("d3", 152, 252, 50, 50);
    view.defPosition("e3", 202, 252, 50, 50);
    view.defPosition("f3", 252, 252, 50, 50);
    view.defPosition("g3", 302, 252, 50, 50);
    view.defPosition("h3", 352, 252, 50, 50);
    view.defPosition("a2", 2, 302, 50, 50);
    view.defPosition("b2", 52, 302, 50, 50);
    view.defPosition("c2", 102, 302, 50, 50);
    view.defPosition("d2", 152, 302, 50, 50);
    view.defPosition("e2", 202, 302, 50, 50);
    view.defPosition("f2", 252, 302, 50, 50);
    view.defPosition("g2", 302, 302, 50, 50);
    view.defPosition("h2", 352, 302, 50, 50);
    view.defPosition("a1", 2, 352, 50, 50);
    view.defPosition("b1", 52, 352, 50, 50);
    view.defPosition("c1", 102, 352, 50, 50);
    view.defPosition("d1", 152, 352, 50, 50);
    view.defPosition("e1", 202, 352, 50, 50);
    view.defPosition("f1", 252, 352, 50, 50);
    view.defPosition("g1", 302, 352, 50, 50);
    view.defPosition("h1", 352, 352, 50, 50);
}
</source>
</spoiler>
Да, читать это труднее, зато работает гораздо быстрее. Например, навигация - перемещение по доске, сводится к обычному арифметическому сложению. Есть ещё один момент. Некоторые правила, относящиеся не к перемещению отдельных фигур, а к игре в целом, невероятно трудно выразить на языке ZRF. Я и не пытаюсь. Для этого в Dagaz есть расширения. Например, в "<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Русских шашках</a>", как и в большинстве других шашечных игр с "летающими" дамками, действует правило "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>" - взятые фигуры убираются с доски только по завершении хода.

<spoiler title="Вот как это делается при помощи расширения">
<source lang="javascript">
(function() {

Dagaz.Model.deferredStrike = true;

var checkVersion = Dagaz.Model.checkVersion;

Dagaz.Model.checkVersion = function(design, name, value) {
  if (name != "deferred-captures") {
     checkVersion(design, name, value);
  }
}

var CheckInvariants = Dagaz.Model.CheckInvariants;

Dagaz.Model.CheckInvariants = function(board) {
  _.chain(board.moves)
   .filter(function(move) {
        return move.actions.length > 0;
    })
   .each(function(move) {
        var mx = _.chain(move.actions)
         .map(function(action) {
              return action[3];
          }).max().value();
          var actions = [];
          _.each(move.actions, function(action) {
              var pn = action[3];
              if ((action[0] !== null) && (action[1] === null)) {
                  pn = mx;
              }
              actions.push([ action[0], action[1], action[2], pn ]);
          });
          move.actions = actions;
    });
  CheckInvariants(board);
}

})();
</source>
</spoiler>
После того как список ходов сгенерирован базовой логикой, закодированной ZRF-описанием игры, он передаётся подключенным расширениям, способным выполнять сложные проверки, запрещать отдельные ходы, обогащать их дополнительными действиями или изменять порядок выполняемых действий, как в случае с <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/deferred-captures.js">deferred-captures</a>, упомянутым выше. Такой гибридный подход серьёзным образом расширяет описательные возможности системы, без необходимости усложнения базового метаязыка ZRF.

Проект Dagaz постоянно развивается. Так, совсем недавно, мне удалось разработать принципиально новый <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/view/2d/2d-view-full.js">модуль</a> представления, предоставляющий функциональность недостижимую в рамках проекта ранее. Теперь canvas можно разделять на независимые регионы, отрисовавать перекрывающиеся всплывающие окна, выполнять прокрутку изображения, более гибко управлять анимацией перемещения фигур и пр. В комплект к новому представлению, пришлось разработать и новый <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-full.js">контроллер</a>, выгодно отличающийся от <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-v2.js">старого</a> большей читабельностью кода.

<spoiler title="Вот как выглядит описание игры в новом стиле">
<source lang="javascript">
ZRF = {
    JUMP:          0,
    IF:            1,
    FORK:          2,
    FUNCTION:      3,
    IN_ZONE:       4,
    FLAG:          5,
    SET_FLAG:      6,
    POS_FLAG:      7,
    SET_POS_FLAG:  8,
    ATTR:          9,
    SET_ATTR:      10,
    PROMOTE:       11,
    MODE:          12,
    ON_BOARD_DIR:  13,
    ON_BOARD_POS:  14,
    PARAM:         15,
    LITERAL:       16,
    VERIFY:        20
};

Dagaz.Model.BuildDesign = function(design) {

    design.checkVersion("z2j", "2");
    design.checkVersion("smart-moves", "false");
    design.checkVersion("show-blink", "false");
    design.checkVersion("show-hints", "false");
    design.checkVersion("show-captures", "false");
    design.checkVersion("dtc-extension", "extended");

    var g = design.addGrid();
    g.addScale("A/B/C/D/E/F/G/H"); g.addScale("8/7/6/5/4/3/2/1");
    g.addDirection("n",[ 0, -1]); g.addDirection("nw",[-1, -1]);
    g.addDirection("e",[ 1,  0]); g.addDirection("ne",[ 1, -1]);
    g.addDirection("w",[-1,  0]); g.addDirection("sw",[-1,  1]);
    g.addDirection("s",[ 0,  1]); g.addDirection("se",[ 1,  1]);
    design.addPlayer("White", [6, 7, 4, 5, 2, 3, 0, 1]);
    design.addPlayer("Black", [6, 5, 2, 7, 4, 1, 0, 3]);
    g.addPositions();
    design.addPosition(["RWP", "RWN", "RWB", "RWR", "RWQ", "RWK", "RBP", "RBN", "RBB", "RBR", "RBQ", "RBK", "UP", "DN"]);

    design.addZone("last-rank",  1, [0, 1, 2, 3, 4, 5, 6, 7]);
    design.addZone("last-rank",  2, [56, 57, 58, 59, 60, 61, 62, 63]);
    design.addZone("third-rank", 1, [40, 41, 42, 43, 44, 45, 46, 47]);
    design.addZone("third-rank", 2, [16, 17, 18, 19, 20, 21, 22, 23]);

    design.addCommand(0, ZRF.FUNCTION,	24);	// from
    design.addCommand(0, ZRF.PARAM,	0);	// $1
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.IN_ZONE,	1);	// third-rank
    design.addCommand(0, ZRF.FUNCTION,	0);	// not
    design.addCommand(0, ZRF.IF,	11);
    design.addCommand(0, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(0, ZRF.FUNCTION,	0);	// not
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.FORK,	3);
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.FUNCTION,	28);	// end
    design.addCommand(0, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.PARAM,	1);	// $2
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(0, ZRF.FUNCTION,	0);	// not
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.FUNCTION,	28);	// end

    design.addCommand(1, ZRF.FUNCTION,	24);	// from
    design.addCommand(1, ZRF.PARAM,	0);	// $1
    design.addCommand(1, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(1, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.FUNCTION,	28);	// end

    design.addCommand(2, ZRF.FUNCTION,	24);	// from
    design.addCommand(2, ZRF.PARAM,	0);	// $1
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(2, ZRF.FUNCTION,	20);	// verify
    design.addCommand(2, ZRF.FUNCTION,	5);	// last-to?
    design.addCommand(2, ZRF.FUNCTION,	20);	// verify
    design.addCommand(2, ZRF.LITERAL,	0);	// Pawn
    design.addCommand(2, ZRF.FUNCTION,	10);	// piece?
    design.addCommand(2, ZRF.FUNCTION,	20);	// verify
    design.addCommand(2, ZRF.FUNCTION,	26);	// capture
    design.addCommand(2, ZRF.PARAM,	1);	// $2
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.FUNCTION,	6);	// mark
    design.addCommand(2, ZRF.PARAM,	2);	// $3
    design.addCommand(2, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(2, ZRF.FUNCTION,	4);	// last-from?
    design.addCommand(2, ZRF.FUNCTION,	20);	// verify
    design.addCommand(2, ZRF.FUNCTION,	7);	// back
    design.addCommand(2, ZRF.FUNCTION,	25);	// to
    design.addCommand(2, ZRF.FUNCTION,	28);	// end

    design.addCommand(3, ZRF.FUNCTION,	24);	// from
    design.addCommand(3, ZRF.IN_ZONE,	0);	// last-rank
    design.addCommand(3, ZRF.FUNCTION,	20);	// verify
    design.addCommand(3, ZRF.PARAM,	0);	// $1
    design.addCommand(3, ZRF.FUNCTION,	21);	// position
    design.addCommand(3, ZRF.ON_BOARD_DIR,	7);	// name
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.IF,	9);
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.IF,	4);
    design.addCommand(3, ZRF.FORK,	3);
    design.addCommand(3, ZRF.FUNCTION,	25);	// to
    design.addCommand(3, ZRF.FUNCTION,	28);	// end
    design.addCommand(3, ZRF.PARAM,	1);	// $2
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.JUMP,	-10);
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.FUNCTION,	20);	// verify
    design.addCommand(3, ZRF.FUNCTION,	25);	// to
    design.addCommand(3, ZRF.FUNCTION,	28);	// end

    design.addCommand(4, ZRF.FUNCTION,	24);	// from
    design.addCommand(4, ZRF.PARAM,	0);	// $1
    design.addCommand(4, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(4, ZRF.PARAM,	1);	// $2
    design.addCommand(4, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(4, ZRF.FUNCTION,	25);	// to
    design.addCommand(4, ZRF.FUNCTION,	28);	// end

    design.addCommand(5, ZRF.FUNCTION,	24);	// from
    design.addCommand(5, ZRF.PARAM,	0);	// $1
    design.addCommand(5, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(5, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(5, ZRF.FUNCTION,	0);	// not
    design.addCommand(5, ZRF.IF,	7);
    design.addCommand(5, ZRF.FORK,	3);
    design.addCommand(5, ZRF.FUNCTION,	25);	// to
    design.addCommand(5, ZRF.FUNCTION,	28);	// end
    design.addCommand(5, ZRF.PARAM,	1);	// $2
    design.addCommand(5, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(5, ZRF.JUMP,	-8);
    design.addCommand(5, ZRF.FUNCTION,	25);	// to
    design.addCommand(5, ZRF.FUNCTION,	28);	// end

    design.addCommand(6, ZRF.FUNCTION,	24);	// from
    design.addCommand(6, ZRF.PARAM,	0);	// $1
    design.addCommand(6, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(6, ZRF.FUNCTION,	25);	// to
    design.addCommand(6, ZRF.FUNCTION,	28);	// end

    design.addCommand(7, ZRF.FUNCTION,	24);	// from
    design.addCommand(7, ZRF.PARAM,	0);	// $1
    design.addCommand(7, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(7, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(7, ZRF.FUNCTION,	20);	// verify
    design.addCommand(7, ZRF.PARAM,	1);	// $2
    design.addCommand(7, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(7, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(7, ZRF.FUNCTION,	20);	// verify
    design.addCommand(7, ZRF.FUNCTION,	25);	// to
    design.addCommand(7, ZRF.PARAM,	2);	// $3
    design.addCommand(7, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(7, ZRF.FUNCTION,	3);	// friend?
    design.addCommand(7, ZRF.FUNCTION,	20);	// verify
    design.addCommand(7, ZRF.LITERAL,	3);	// Rook
    design.addCommand(7, ZRF.FUNCTION,	10);	// piece?
    design.addCommand(7, ZRF.FUNCTION,	20);	// verify
    design.addCommand(7, ZRF.FUNCTION,	24);	// from
    design.addCommand(7, ZRF.PARAM,	3);	// $4
    design.addCommand(7, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(7, ZRF.PARAM,	4);	// $5
    design.addCommand(7, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(7, ZRF.FUNCTION,	25);	// to
    design.addCommand(7, ZRF.FUNCTION,	28);	// end

    design.addCommand(8, ZRF.FUNCTION,	24);	// from
    design.addCommand(8, ZRF.PARAM,	0);	// $1
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(8, ZRF.FUNCTION,	20);	// verify
    design.addCommand(8, ZRF.PARAM,	1);	// $2
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(8, ZRF.FUNCTION,	20);	// verify
    design.addCommand(8, ZRF.FUNCTION,	25);	// to
    design.addCommand(8, ZRF.PARAM,	2);	// $3
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(8, ZRF.FUNCTION,	20);	// verify
    design.addCommand(8, ZRF.PARAM,	3);	// $4
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.FUNCTION,	3);	// friend?
    design.addCommand(8, ZRF.FUNCTION,	20);	// verify
    design.addCommand(8, ZRF.LITERAL,	3);	// Rook
    design.addCommand(8, ZRF.FUNCTION,	10);	// piece?
    design.addCommand(8, ZRF.FUNCTION,	20);	// verify
    design.addCommand(8, ZRF.FUNCTION,	24);	// from
    design.addCommand(8, ZRF.PARAM,	4);	// $5
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.PARAM,	5);	// $6
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.PARAM,	6);	// $7
    design.addCommand(8, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(8, ZRF.FUNCTION,	25);	// to
    design.addCommand(8, ZRF.FUNCTION,	28);	// end

    design.addPiece("Pawn", 0);
    design.addMove(0, 0, [0, 0], 0);
    design.addMove(0, 1, [1], 0);
    design.addMove(0, 1, [3], 0);
    design.addMove(0, 2, [2, 0, 0], 0);
    design.addMove(0, 2, [4, 0, 0], 0);

    design.addPiece("Knight", 1);
    design.addMove(1, 4, [0, 1], 0);
    design.addMove(1, 4, [0, 3], 0);
    design.addMove(1, 4, [6, 5], 0);
    design.addMove(1, 4, [6, 7], 0);
    design.addMove(1, 4, [2, 3], 0);
    design.addMove(1, 4, [2, 7], 0);
    design.addMove(1, 4, [4, 1], 0);
    design.addMove(1, 4, [4, 5], 0);

    design.addPiece("Bishop", 2);
    design.addMove(2, 5, [1, 1], 0);
    design.addMove(2, 5, [3, 3], 0);
    design.addMove(2, 5, [5, 5], 0);
    design.addMove(2, 5, [7, 7], 0);

    design.addPiece("Rook", 3);
    design.addMove(3, 5, [0, 0], 0);
    design.addMove(3, 5, [2, 2], 0);
    design.addMove(3, 5, [4, 4], 0);
    design.addMove(3, 5, [6, 6], 0);

    design.addPiece("Queen", 4);
    design.addMove(4, 5, [0, 0], 0);
    design.addMove(4, 5, [1, 1], 0);
    design.addMove(4, 5, [2, 2], 0);
    design.addMove(4, 5, [3, 3], 0);
    design.addMove(4, 5, [4, 4], 0);
    design.addMove(4, 5, [5, 5], 0);
    design.addMove(4, 5, [6, 6], 0);
    design.addMove(4, 5, [7, 7], 0);

    design.addPiece("King", 5);
    design.addMove(5, 6, [0], 0);
    design.addMove(5, 6, [1], 0);
    design.addMove(5, 6, [2], 0);
    design.addMove(5, 6, [3], 0);
    design.addMove(5, 6, [4], 0);
    design.addMove(5, 6, [5], 0);
    design.addMove(5, 6, [6], 0);
    design.addMove(5, 6, [7], 0);
    design.addMove(5, 7, [2, 2, 2, 4, 4], 1);
    design.addMove(5, 8, [4, 4, 4, 4, 2, 2, 2], 1);

    design.addPiece("PawnR", 6);
    design.addPiece("KnightR", 7);
    design.addPiece("BishopR", 8);
    design.addPiece("RookR", 9);
    design.addPiece("QueenR", 10);
    design.addPiece("KingR", 11);

    design.setup("White", "Pawn", ["A2", "B2", "C2", "D2", "E2", "F2", "G2", "H2"]);
    design.setup("White", "Knight", ["B1", "G1"]);
    design.setup("White", "Bishop", ["C1", "F1"]);
    design.setup("White", "Rook", ["A1", "H1"]);
    design.setup("White", "Queen", ["D1"]);
    design.setup("White", "King", ["E1"]);
    design.setup("White", "PawnR", ["RWP"]);
    design.setup("White", "KnightR", ["RWN"]);
    design.setup("White", "BishopR", ["RWB"]);
    design.setup("White", "RookR", ["RWR"]);
    design.setup("White", "QueenR", ["RWQ"]);
    design.setup("White", "KingR", ["RWK"]);

    design.setup("Black", "Pawn", ["A7", "B7", "C7", "D7", "E7", "F7", "G7", "H7"]);
    design.setup("Black", "Knight", ["B8", "G8"]);
    design.setup("Black", "Bishop", ["C8", "F8"]);
    design.setup("Black", "Rook", ["A8", "H8"]);
    design.setup("Black", "Queen", ["D8"]);
    design.setup("Black", "King", ["E8"]);
    design.setup("Black", "PawnR", ["RBP"]);
    design.setup("Black", "KnightR", ["RBN"]);
    design.setup("Black", "BishopR", ["RBB"]);
    design.setup("Black", "RookR", ["RBR"]);
    design.setup("Black", "QueenR", ["RBQ"]);
    design.setup("Black", "KingR", ["RBK"]);
}

Dagaz.View.configure = function(view) {

    var b = view.root.addRegion(70, 0, 540, 540);
    b.addBoard("WhiteBoard", [0]);
    b.addBoard("BlackBoard", [1]);
    var g = b.addGrid(31, 31, 89, 89);
    g.addScale("A/B/C/D/E/F/G/H", 60, 0);
    g.addScale("8/7/6/5/4/3/2/1", 0, 60);
    g.addTurns(0, [0]);
    g.addTurns(1, [1]);

    var r = view.root.addRegion(630, 0, 120, 540);
    r.addBoard("rpw", [0]);
    r.addBoard("rpb", [1]);

    r.addPosition("RWP",  1,  41, 58, 58, [0]);
    r.addPosition("RWN",  1, 121, 58, 58, [0]);
    r.addPosition("RWB",  1, 201, 58, 58, [0]);
    r.addPosition("RWR",  1, 281, 58, 58, [0]);
    r.addPosition("RWQ",  1, 361, 58, 58, [0]);
    r.addPosition("RWK",  1, 441, 58, 58, [0]);
    r.addPosition("RBP", 61,  41, 58, 58, [0]);
    r.addPosition("RBN", 61, 121, 58, 58, [0]);
    r.addPosition("RBB", 61, 201, 58, 58, [0]);
    r.addPosition("RBR", 61, 281, 58, 58, [0]);
    r.addPosition("RBQ", 61, 361, 58, 58, [0]);
    r.addPosition("RBK", 61, 441, 58, 58, [0]);

    r.addPosition("RBP",  1,  41, 58, 58, [1]);
    r.addPosition("RBN",  1, 121, 58, 58, [1]);
    r.addPosition("RBB",  1, 201, 58, 58, [1]);
    r.addPosition("RBR",  1, 281, 58, 58, [1]);
    r.addPosition("RBQ",  1, 361, 58, 58, [1]);
    r.addPosition("RBK",  1, 441, 58, 58, [1]);
    r.addPosition("RWP", 61,  41, 58, 58, [1]);
    r.addPosition("RWN", 61, 121, 58, 58, [1]);
    r.addPosition("RWB", 61, 201, 58, 58, [1]);
    r.addPosition("RWR", 61, 281, 58, 58, [1]);
    r.addPosition("RWQ", 61, 361, 58, 58, [1]);
    r.addPosition("RWK", 61, 441, 58, 58, [1]);

    var d = view.root.addRegion(770, 0, 120, 540, true, undefined, Dagaz.Model.drawDivision, Dagaz.Controller.eventDivision);
    d.addBoard("div");
    d.addPosition("UP", 1, 1, 120, 30);
    d.addPosition("DN", 1, 510, 120, 30);

    view.addPiece(["WhitePawn", "WhiteKnight", "WhiteBishop", "WhiteRook", "WhiteQueen", "WhiteKing"], Dagaz.View.drawPiece);
    view.addPiece(["BlackPawn", "BlackKnight", "BlackBishop", "BlackRook", "BlackQueen", "BlackKing"], Dagaz.View.drawPiece);
    view.addPiece(["WhitePawnR", "BlackPawnR", "WhiteKnightR", "BlackKnightR", "WhiteBishopR", "BlackBishopR", "WhiteRookR", "BlackRookR", "WhiteQueenR", "BlackQueenR", "WhiteKingR", "BlackKingR"], Dagaz.View.drawRes);
    view.addPiece(["PawnWhite", "SmallPawnWhite", "KnightWhite", "SmallKnightWhite", "BishopWhite", "SmallBishopWhite", "RookWhite", "SmallRookWhite", "QueenWhite", "SmallQueenWhite", "KingWhite", "SmallKingWhite"]);
    view.addPiece(["PawnBlack", "SmallPawnBlack", "KnightBlack", "SmallKnightBlack", "BishopBlack", "SmallBishopBlack", "RookBlack", "SmallRookBlack", "QueenBlack", "SmallQueenBlack", "KingBlack", "SmallKingBlack"]);
    view.addPiece(["two", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "plus", "minus", "question"]);
    view.addPiece(["db", "dw", "ub", "uw"]);
}</source>
</spoiler>
Сама модель тоже меняется. Все эти длинные и непонятные столбцы команд стековой машины могут скоро уйти в прошлое.

<spoiler title="Описание игры станет более читаемым">
<source lang="javascript">
(function() {

var step = function(ctx, params) {
    if (ctx.go(params, 0) && !ctx.isFriend()) {
        ctx.end();
    }
}

var pawnShift = function(ctx, params) {
    if (ctx.go(params, 0) && ctx.isEmpty()) {
        if (ctx.inZone(0)) {
            ctx.promote(4);
        }    
        ctx.end();
    }
}

var pawnLeap = function(ctx, params) {
    if (ctx.go(params, 0) && ctx.isEnemy()) {
        if (ctx.inZone(0)) {
            ctx.promote(4);
        }    
        ctx.end();
    }
}

var pawnJump = function(ctx, params) {
    if (ctx.go(params, 0) && 
        ctx.isEmpty() && 
        ctx.inZone(1) && 
        ctx.go(params, 0) && 
        ctx.isEmpty()) {
        ctx.end();
    }
}

var enPassant = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEnemy() &&
        ctx.isPiece(0)) {
        ctx.capture();
        if (ctx.go(params, 1)) {
            ctx.put();
            if (ctx.go(params, 1) &&
                ctx.isLastFrom()) {
                ctx.end();
            }
        }
    }
}

var jump = function(ctx, params) {
    if (ctx.go(params, 0) && 
        ctx.go(params, 1) && 
       !ctx.isFriend()) {
        ctx.end();
    }
}

var slide = function(ctx, params) {
    while (ctx.go(params, 0)) {
        if (ctx.isFriend()) break;
        ctx.end();
        if (!ctx.isEmpty()) break;
    }
}

var O_O = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEmpty() &&
        ctx.go(params, 0) &&
        ctx.isEmpty()) {
        ctx.put();
        if (ctx.go(params, 0) &&
            ctx.isFriend() &&
            ctx.isPiece(1)) {
            ctx.take();
            if (ctx.go(params, 1) &&
                ctx.go(params, 1)) {
                ctx.end();
            }
        }
    }
}

var O_O_O = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEmpty() &&
        ctx.go(params, 0) &&
        ctx.isEmpty()) {
        ctx.put();
        if (ctx.go(params, 0) &&
            ctx.isEmpty() &&
            ctx.go(params, 0) &&
            ctx.isFriend() &&
            ctx.isPiece(1)) {
            ctx.take();
            if (ctx.go(params, 1) &&
                ctx.go(params, 1) &&
                ctx.go(params, 1)) {
                ctx.end();
            }
        }
    }
}

games.model.BuildDesign = function(design) {
    design.checkVersion("smart-moves", "false");

    design.addDirection("w");  // 0
    design.addDirection("e");  // 1
    design.addDirection("s");  // 2
    design.addDirection("ne"); // 3
    design.addDirection("n");  // 4
    design.addDirection("se"); // 5
    design.addDirection("sw"); // 6
    design.addDirection("nw"); // 7

    design.addPlayer("White", [1, 0, 4, 6, 2, 7, 3, 5]);
    design.addPlayer("Black", [0, 1, 4, 5, 2, 3, 7, 6]);

    design.addPosition("a8", [0, 1, 8, 0, 0, 9, 0, 0]);
    design.addPosition("b8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("c8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("d8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("e8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("f8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("g8", [-1, 1, 8, 0, 0, 9, 7, 0]);
    design.addPosition("h8", [-1, 0, 8, 0, 0, 0, 7, 0]);
    design.addPosition("a7", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g7", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h7", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a6", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g6", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h6", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a5", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g5", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h5", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a4", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g4", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h4", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a3", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g3", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h3", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a2", [0, 1, 8, -7, -8, 9, 0, 0]);
    design.addPosition("b2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("c2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("d2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("e2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("f2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("g2", [-1, 1, 8, -7, -8, 9, 7, -9]);
    design.addPosition("h2", [-1, 0, 8, 0, -8, 0, 7, -9]);
    design.addPosition("a1", [0, 1, 0, -7, -8, 0, 0, 0]);
    design.addPosition("b1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("c1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("d1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("e1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("f1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("g1", [-1, 1, 0, -7, -8, 0, 0, -9]);
    design.addPosition("h1", [-1, 0, 0, 0, -8, 0, 0, -9]);

    design.addZone("last-rank", 1, ["a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"]);
    design.addZone("last-rank", 2, ["a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1"]);
    design.addZone("third-rank", 1, ["a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3"]);
    design.addZone("third-rank", 2, ["a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6"]);

    design.addPiece("Pawn", 0, 2);
    design.addMove(0, pawnShift, [4], 0);
    design.addMove(0, pawnJump, [4], 0);
    design.addMove(0, pawnLeap, [7], 0);
    design.addMove(0, pawnLeap, [3], 0);
    design.addMove(0, enPassant, [1, 4], 0);
    design.addMove(0, enPassant, [0, 4], 0);

    design.addPiece("Rook", 1, 10);
    design.addMove(1, slide, [4], 0);
    design.addMove(1, slide, [2], 0);
    design.addMove(1, slide, [0], 0);
    design.addMove(1, slide, [1], 0);

    design.addPiece("Knight", 2, 6);
    design.addMove(2, jump, [4, 7], 0);
    design.addMove(2, jump, [4, 3], 0);
    design.addMove(2, jump, [2, 6], 0);
    design.addMove(2, jump, [2, 5], 0);
    design.addMove(2, jump, [0, 7], 0);
    design.addMove(2, jump, [0, 6], 0);
    design.addMove(2, jump, [1, 3], 0);
    design.addMove(2, jump, [1, 5], 0);

    design.addPiece("Bishop", 3, 6);
    design.addMove(3, slide, [7], 0);
    design.addMove(3, slide, [6], 0);
    design.addMove(3, slide, [3], 0);
    design.addMove(3, slide, [5], 0);

    design.addPiece("Queen", 4, 18);
    design.addMove(4, slide, [4], 0);
    design.addMove(4, slide, [2], 0);
    design.addMove(4, slide, [0], 0);
    design.addMove(4, slide, [1], 0);
    design.addMove(4, slide, [7], 0);
    design.addMove(4, slide, [6], 0);
    design.addMove(4, slide, [3], 0);
    design.addMove(4, slide, [5], 0);

    design.addPiece("King", 5, 1000);
    design.addMove(5, step, [4], 0);
    design.addMove(5, step, [2], 0);
    design.addMove(5, step, [0], 0);
    design.addMove(5, step, [1], 0);
    design.addMove(5, step, [7], 0);
    design.addMove(5, step, [6], 0);
    design.addMove(5, step, [3], 0);
    design.addMove(5, step, [5], 0);
    design.addMove(5, O_O, [1, 0], 1);
    design.addMove(5, O_O_O, [0, 1], 1);

    design.setup("White", "Pawn", ["a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2"]);
    design.setup("White", "Rook", ["a1", "h1"]);
    design.setup("White", "Knight", ["b1", "g1"]);
    design.setup("White", "Bishop", ["c1", "f1"]);
    design.setup("White", "Queen", ["d1"]);
    design.setup("White", "King", ["e1"]);
    design.setup("Black", "Pawn", ["a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7"]);
    design.setup("Black", "Rook", ["a8", "h8"]);
    design.setup("Black", "Knight", ["b8", "g8"]);
    design.setup("Black", "Bishop", ["c8", "f8"]);
    design.setup("Black", "Queen", ["d8"]);
    design.setup("Black", "King", ["e8"]);
}

})();</source>
</spoiler>
Более того, такой подход позволит полностью отказаться как от Z2J (утилиты преобразования ZRF в JavaScript), так и от самого ZRF. Описание игры можно будет писать руками, сразу на JavaScript. Всё это позволит разрабатывать более сложные игры, ещё быстрее чем раньше.
</spoiler>
У меня были <a href="https://glukkazan.github.io/">игры</a>. Много игр, но настольные игры, за очень редким исключением - это то, во что интересно играть с кем-то. В этом и заключалась проблема. Для некоторых игр мне удалось сделать ботов, но играли они слабо, а в том, что касается Шахмат или Го, я не питал никаких иллюзий по поводу того, что мне удастся разработать бота, играть с которым будет интересно. Отчасти, это связано с низкой производительностью разработанной мной универсальной модели, но по большей части, я просто не очень силён в разработке ботов для настольных игр.

Радикальным решением стала бы разработка сетевой версии Dagaz, при помощи которой пользователи смогли бы играть друг с другом через Internet, но это подразумевало платный хостинг с полноценным бакендом и базой данных. Поскольку речь шла о хобби-проекте, я был не готов вкладывать в это деньги.

<spoiler title="К счастью, появилась другая возможность">
Дело в том, что моё начальство уже давно в курсе моего увлечения настольными играми. Иногда я провожу внутренние митапы на эту и другие темы, а недавно мы <a href="https://habr.com/ru/post/514426/">организовали</a> небольшой, но самый настоящий турнир, по разработке ботов для игры в "<a href="https://glukkazan.github.io/go/atari-go.htm">Atari Go</a>" среди сотрудников компании. И вот, буквально на днях, отдел маркетинга выступил с предложением о разработке платформы для повышения лояльности среди клиентов компании. Для меня это выглядело как публикация в Интернете нескольких, отобранных отделом маркетинга, игр и генерация "бонусов", для получения скидок, при победах игроков. Разумеется, меня такое предложение очень порадовало.
</spoiler>
Так, волей-неволей, мне пришлось взяться за бакенд. Я выбрал <a href="https://nestjs.com/">Nest</a>. Во первых, давно хотел попробовать <a href="https://www.typescriptlang.org/">TypeScript</a>. Кроме того, все эти <a href="https://docs.nestjs.com/controllers">аннотации</a>, максимально похожи на тот кровавый энтерпрайз, к которому я привык. Под капотом у Nest-а всё тот же <a href="https://expressjs.com/ru/">Express</a>, но код записывается лаконичнее - это удобно. <a href="https://swagger.io/">Swagger</a> прикручивается к проекту при помощи <a href="https://docs.nestjs.com/openapi/introduction">нескольких строк</a> кода, а также всё новых и новых аннотаций. После этого, с REST API можно ознакамливаться <a href="http://games.dtco.ru/api/swagger/">так</a> или даже <a href="http://games.dtco.ru/api/swagger-json">так</a>.

Отдельно стоит рассказать о базе данных. Вообще, я из тех людей, кому гораздо проще сразу писать SQL запрос, чем разбираться в премудростях какой-нибудь ORM. Но для этого проекта я <a href="https://docs.nestjs.com/recipes/sql-typeorm">сделал исключение</a>. Просто потому что <a href="https://typeorm.io/#/">TypeORM</a> создаёт все задекларированные таблички автоматически, а мне остаётся просто создать на сервере пустую базу данных. Разумеется, я выбрал <a href="https://www.postgresql.org/download/">PostgreSQL</a>, но думаю, что переключиться на <a href="https://www.mysql.com/">MySQL</a>, при необходимости, будет не слишком сложно.

<spoiler title="Подробнее про базу данных">
Для меня, игровой сервер - это прежде всего база данных. В ней хранятся учётные данные пользователей, описания игр, данные по игровым сессиям, все выполненные игроками ходы, в общем, всё что нужно для организации игры по сети.

<img align="center" src="https://habrastorage.org/webt/f6/m_/fa/f6m_fa_ht3-supj1xj_1jai3tsu.png" />
Параметры подключения к серверу конфигурируются в файле <a href="https://github.com/GlukKazan/DagazServer/blob/master/ormconfig.json">ormconfig.json</a> в корне проекта. Помимо понятных вещей, типа логина и пароля, там определяется путь к каталогу, в котором описываются сущности базы данных (entities) и это именно то, за что мне нравится TypeORM. Дело в том, что мне нет необходимости писать SQL-скрипты для создания таблиц в базе данных. Достаточно создать по одному TypeScript-описанию на каждую таблицу.

<spoiler title="Например такому">
<source lang="javascript">
import { Entity, PrimaryGeneratedColumn, Column, Index, ManyToOne, JoinColumn, Check, Unique } from "typeorm";
import { users } from "./users";
import { game_sessions } from "./game_sessions";
import { game_results } from "./game_results";

@Entity()
@Unique(["session_id", "player_num"])
@Check(`"is_ai" in (0, 1)`)
export class user_games {
    @PrimaryGeneratedColumn()
    id: number;

    @Index()
    @Column({ nullable: false })
    user_id: number;
    @ManyToOne(type => users)
    @JoinColumn({ name: "user_id" })
    user: users;

    @Index()
    @Column({ nullable: false })
    session_id: number;
    @ManyToOne(type => game_sessions)
    @JoinColumn({ name: "session_id" })
    session: game_sessions;

    @Index()
    @Column({ nullable: true })
    result_id: number;
    @ManyToOne(type => game_results)
    @JoinColumn({ name: "result_id" })
    result: game_results;

    @Column({ nullable: true })
    score: number;

    @Column()
    player_num: number;

    @Column({ default: 0 })
    is_ai: number;

    @Column({ nullable: true })
    time_limit: number;
}</source>
</spoiler>
После этого, структура таблиц будет автоматически синхронизироваться с описанием сущностей, при каждом запуске сервера (если конечно флаг synchronize в ormconfig.json установлен в true). Возможности <a href="https://typeorm.io/#/entities">аннотаций</a> вполне достаточны для описания типа и размера столбцов, ограничений целостности, значений по умолчанию, в общем, всех необходимых деталей хранения данных.

Но структура таблиц - это только половина дела. Надо как-то заполнить справочники начальными значениями. Для этого, в TypeORM используются <a href="https://typeorm.io/#/migrations">миграции</a>. Миграция - это просто пара SQL-скриптов, используемых для наката и отката изменений в базе данных.

<spoiler title="Что-то в таком роде">
<source lang="javascript">
import {MigrationInterface, QueryRunner} from "typeorm";

export class init1592210976213 implements MigrationInterface {

    public async up(queryRunner: QueryRunner): Promise<any> {
        await queryRunner.query(`insert into contact_types(id, name) values(1, 'EMail')`);

        await queryRunner.query(`insert into token_types(id, name) values(1, 'Access')`);
        await queryRunner.query(`insert into token_types(id, name) values(2, 'Refresh')`);

        await queryRunner.query(`insert into game_results(id, name) values(1, 'Won')`);
        await queryRunner.query(`insert into game_results(id, name) values(2, 'Lose')`);
        await queryRunner.query(`insert into game_results(id, name) values(3, 'Draw')`);

        await queryRunner.query(`insert into users(is_admin, login, pass) values(1, 'root', 'root')`);
    }

    public async down(queryRunner: QueryRunner): Promise<any> {
        await queryRunner.query(`delete from users`);
        await queryRunner.query(`delete from game_statuses`);
        await queryRunner.query(`delete from game_results`);
        await queryRunner.query(`delete from token_types`);
        await queryRunner.query(`delete from contact_types`);
        await queryRunner.query(`delete from realms`);
    }
}</source>
</spoiler>
Выполняется миграция с консоли, после того как все таблицы созданы при первом запуске сервера. Поскольку в нашем проекте используется TypeScript, команда для запуска довольно заковыристая (и разумеется, предварительно должен быть установлен командный интерфейс TypeScript-а).

<source>
npm install -g ts-node
ts-node ./node_modules/typeorm/cli.js migration:run
</source>
Все выполненные миграции фиксируются в специальной табличке в базе данных (по умолчанию, она называется migrations) и при необходимости могут быть отменены командой 'typeorm migration:revert'.
</spoiler>
Следующая важная вещь из коробки - это <a href="https://docs.nestjs.com/techniques/authentication">аутентификация</a>. Для того чтобы не гонять логин и пароль в открытом виде в каждом запросе, используем <a href="https://ru.wikipedia.org/wiki/JSON_Web_Token">JWT</a>. С точки зрения Nest-а, проверка авторизации пользователя, при выполнении запроса, сводится к использованию <a href="https://github.com/GlukKazan/DagazServer/blob/master/src/auth/local.strategy.ts">той</a> или <a href="https://github.com/GlukKazan/DagazServer/blob/master/src/auth/jwt.strategy.ts">иной</a> стратегии (все детали выполняемых проверок, разумеется, вынесены в <a href="https://github.com/GlukKazan/DagazServer/blob/master/src/auth/auth.service.ts">сервис</a>). Сами стратегии обёрнуты в <a href="https://github.com/GlukKazan/DagazServer/blob/master/src/auth/local-auth.guard.ts">guard</a>-ы и могут использоваться вполне декларативно.

<source lang="javascript">
  @UseGuards(LocalAuthGuard)
  @Post('api/auth/login')
  async login(@Request() req) {
    const device: string = req.headers['x-forwarded-for'] || 
                           req.connection.remoteAddress;
    const r = await this.authService.login(req.user, device);
    return r;
  }
</source>
Здесь первая аннотация говорит о том, что для получения JWT используется базовая аутентификация. На выходе (если всё пойдёт успешно), получаем токен, который прикрепляем как <a href="https://tools.ietf.org/html/rfc6750">bearer</a> к запросам, использующим JWT-аутентификацию. Вторая аннотация определяет URL по которому должен выполняться POST-запрос и с этим связан один очень интересный момент.

<spoiler title="Суета вокруг роутинга">
Дело в том, что помимо бакенда, обычно бывает ещё и фронтенд. Например, на <a href="https://angular.io/">Angular</a>-е. В моём случае, это небольшая <a href="https://github.com/GlukKazan/ActivateBonus">страничка</a>, для активации операторами бонусов, особого интереса не представляющая. Важно здесь то, что фронтенд приложения умеют показывать различные странички, в зависимости от URL (это называется роутингом). То есть, у фронтенда роутинг свой, а у бакенда свой. Вопрос в том, как их подружить?

Проще всего, это делается в режиме отладки. Создаём <a href="https://github.com/GlukKazan/ActivateBonus/blob/main/proxy.conf.json">файл</a> с настройками, запускаем фронтенд командой 'ng serve --proxy-config proxy.conf.json' и отлаживаемся на здоровье (при условии, что бакенд тоже запущен, конечно). Все запросы, начинающиеся с префикса '/api' будут проксироваться на бакенд. Но держать два открытых TCP-порта в релизной сборке немного неудобно. Вот как это делается в Nest-е:

<spoiler title="main.ts">
<source lang="javascript">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from "@nestjs/platform-express";
import { join } from 'path';
import { NotFoundExceptionFilter } from './frontend.catch';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(
    AppModule,
  );

  app.useStaticAssets(join(__dirname, '/../public'), {prefix: '/'});
  app.setBaseViewsDir(join(__dirname, '/../public'));
  app.useGlobalFilters(new NotFoundExceptionFilter());

  app.enableCors();
  await app.listen(3000);
}
bootstrap();
</source>
</spoiler><spoiler title="frontend.catch.ts">
<source lang="javascript">
import { NotFoundException, Catch, ExceptionFilter, ArgumentsHost, HttpException } from "@nestjs/common";
import { resolve } from 'path';

@Catch(NotFoundException)
export class NotFoundExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    response.sendFile(resolve('public/index.html'));
  }
}</source>
</spoiler>
Для начала, учим бакенд отдавать статический контент. Корень сайта отображается на каталог public, то есть, файлы Nest будет искать именно там. Но что произойдёт, если файл найти не удастся? На этот случай, в проект добавлен перехватчик <a href="https://github.com/GlukKazan/DagazServer/blob/master/src/frontend.catch.ts">frontend.catch.ts</a>, пересылающий все непонятные запросы в 'public/index.html', то есть собранному фронтенду с сохранением URL. Это немножко трудно уложить в голове, но именно благодаря этому работает <a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a> Angular-а.
</spoiler>
Теперь, когда всё заработало, осталось разместить это на какой-то живой машине, доступной из Internet. Но перед этим, стоит озаботиться переходом от HTTP-протокола к HTTPS (очевидно, что передача логинов и паролей в открытом виде, при выполнении базовой аутентификации - это не самая удачная мысль). В принципе, Nest это тоже <a href="https://docs.nestjs.com/faq/multiple-servers">умеет</a>, но гораздо проще, в смысле администрирования, установить на тот же сервер proxy <a href="https://nginx.org/ru/">Nginx</a>. Конфигурация выглядит примерно вот так:

<source lang="nginx">
server {
	listen 80;
	listen 443 ssl;
        ssl_certificate /etc/nginx/ssl/certificate.crt;
        ssl_certificate_key /etc/nginx/ssl/private.key;
        ssl_verify_client off;
	
	server_name games.dtco.ru;
	location / {
		index index.html;
		proxy_pass http://localhost:3000/;
	}
}
</source>
<spoiler title="Здесь, правда, не обошлось без ложки дёгтя">
Для того чтобы сервер работал сам по себе, в Linux системах его желательно оформлять как сервис. В моём случае, это вылилось вот в такой вот dagaz.service файл:

<source>
[Unit]
Description=Dagaz Server
After=network-online.target

[Service]
Restart=on-failure
Type=simple
User=dagaz
WorkingDirectory=/home/dagaz/Downloads/DagazServer-master
ExecStart=/usr/bin/npm start

[Install]
WantedBy=multi-user.target
</source>
Замечаете неладное? Да-да, я запускаю его командой 'npm start', то есть, при каждом запуске собираю заново из TypeScript-а. Что меня заставило пойти на это? Начну издалека. В идеальном мире, мне следовало бы собрать сервер один раз и после этого запускать уже собранный. Примерно так:

<source>
nest build
cd build
node main.js
</source>
Но я использую TypeORM, чтобы работать с базой данных. Для начала, мне не удалось прикрутить ormconfig.json, из которого берутся настройки подключения к собранному серверу. Само по себе, это не беда. Есть другой способ для передачи настроек.

<spoiler title="database.provider.ts">
<source lang="javascript">
import { createConnection } from 'typeorm';
import { dbOptions } from '../app.config';

export const databaseProviders = [
  {
    provide: 'DATABASE_CONNECTION',
    useFactory: async () => await createConnection(
      dbOptions
    ),
  },
];</source>
</spoiler><spoiler title="app.config.ts">
<source lang="javascript">
import "reflect-metadata";
import { ConnectionOptions } from "typeorm";

export let dbOptions: ConnectionOptions = {
    type: "postgres",
    host: "127.0.0.1",
    port: 5433,
    username: "dagaz",
    password: "dagaz",
    database: "dagaz",
    migrationsTableName: "migrations",
    synchronize: false,
    logging: false,
    entities: [
        "src/entity/**/*.{ts,js}",
        "./entity/**/*.{ts,js}"
    ]
}</source>
</spoiler>
Здесь есть нюанс. В entities я передаю две строки (это пути, по которым TypeORM ищет описания сущностей базы данных). Первая используется в режиме отладки, а по второй поиск идёт уже в собранной версии. В принципе, в каждой из них можно было оставить по одному расширению, просто я хотел показать и эту возможность. Файл ormconfig.json, после выполненных изменений, конечно убираем, он больше не нужен.

Ещё один добрый совет. Устанавливайте synchronize в false всегда, если только не собираетесь изменять структуру таблиц в базе данных. По причинам, о которых скажу чуть позже, со сборкой я возился на немного устаревшей версии проекта. Этого вполне хватило, чтобы снести в базе данных "ненужные" с точки зрения TypeORM поля. После чего, всё естественно сломалось. Не повторяйте моих ошибок.

Собранная версия запускается заметно быстрее (поскольку не надо каждый раз пересобирать TypeScript), но увы, воспользоваться этим я не смог.

<spoiler title="Возникла ещё одна проблема">
<source>
C:\Users\User\dagaz-server>npm run build

> dagaz-server@0.0.1 prebuild C:\Users\User\dagaz-server
> rimraf dist


> dagaz-server@0.0.1 build C:\Users\User\dagaz-server
> tsc -p tsconfig.build.json

node_modules/@nestjs/swagger/dist/type-helpers/omit-type.helper.d.ts:2:90 - error TS1005: ',' expected.

2 export declare function OmitType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]): Type<Omit<T, typeof keys[number]>>;
                                                                                           ~

node_modules/@nestjs/swagger/dist/type-helpers/omit-type.helper.d.ts:2:91 - error TS1005: ',' expected.

2 export declare function OmitType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]): Type<Omit<T, typeof keys[number]>>;
                                                                                            ~

node_modules/@nestjs/swagger/dist/type-helpers/pick-type.helper.d.ts:2:90 - error TS1005: ',' expected.

2 export declare function PickType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]): Type<Pick<T, typeof keys[number]>>;
                                                                                           ~

node_modules/@nestjs/swagger/dist/type-helpers/pick-type.helper.d.ts:2:91 - error TS1005: ',' expected.

2 export declare function PickType<T, K extends keyof T>(classRef: Type<T>, keys: readonly K[]): Type<Pick<T, typeof keys[number]>>;

Found 4 errors.

npm ERR! code ELIFECYCLE
npm ERR! errno 2
npm ERR! dagaz-server@0.0.1 build: `tsc -p tsconfig.build.json`
npm ERR! Exit status 2
npm ERR!
npm ERR! Failed at the dagaz-server@0.0.1 build script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\User\AppData\Roaming\npm-cache\_logs\2020-10-21T09_33_58_253Z-debug.log</source>
</spoiler>
При попытке сборки, ошибки компиляции летят откуда-то из недр @nestjs/swagger. Обновление пакета и TypeScript-а до последних версий не помогло. Если кто-то знает, как с этим бороться, скажите мне, я заинтригован. А сборка, о которой я писал выше, отлаживалась на копии проекта с полностью вырезанным Swagger-ом (и немного устаревшей, да). В результате, я не захотел отказываться от Swagger-а и запускаю сервис командой 'npm start'.
</spoiler>
А что с играми? Если вы ещё не забыли, наша цель - связать имеющиеся игры с сервером (в рамках текущего проекта, чтобы получать от сервера сгенерированный бонус при выигрыше). В этом вполне может помочь <a href="https://jquery.com/">jQuery</a> (кстати, это одна из всего лишь трёх используемых мной сторонних библиотек, кроме неё я использую <a href="http://underscorejs.ru/">Underscore</a> и в некоторых случаях <a href="https://www.npmjs.com/package/seedrandom">Seedrandom</a>). Фактически, вся интеграция свелась к переписыванию всего одного <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/games/common-scripts/app-v2-net.js">модуля</a>.

<source  lang="javascript">
var SERVICE = "/api/";

var inProgress = false;
var auth = null;
...
var authorize = function() {
  if (auth !== null) return;
  inProgress = true;
  $.ajax({
     url: SERVICE + "auth/anonymous",
     type: "GET",
     dataType: "json",
     success: function(data) {
         auth = data.access_token;
         console.log('Auth: Succeed ' + auth);
         inProgress = false;
     },
     error: function() {
         Dagaz.Controller.app.state = STATE.STOP;
         alert('Auth: Error!');
     },
     statusCode: {
        401: function() {
             Dagaz.Controller.app.state = STATE.STOP;
             alert('Auth: Bad User!');
        },
        500: function() {
             Dagaz.Controller.app.state = STATE.STOP;
             alert('Auth: Internal Error!');
        }
     }
  });
}
...
App.prototype.exec = function() {
  this.view.configure();
  ...
  this.view.draw(this.canvas);
  if (inProgress) return;
  authorize();
  ...
}
</source>
<spoiler title="В этом месте произошёл второй непонятный мне момент">
Сразу после запуска, каждая игра выполняет несколько REST-запросов с JWT-аутентификацией к серверу. Проблема выглядела как "плавающий" сбой одного из таких запросов (в результате которого игра аварийно завершалась). Чтобы понять что происходит, пришлось собрать пакеты, летающие между Nginx-ом и Nest-ом.

<source>
tcpdump -vv -i any -s 4906 /var/log/dagaz.pcap
</source>
Вот <a href="https://games.dtco.ru/log/dagaz.pcap">что</a> получилось в итоге:

<img align="center" src="https://habrastorage.org/webt/cr/gj/yz/crgjyz3bdsh4y3bf2iotmelqequ.png" />
Запросы передаваемые через IPv4 обрабатывались нормально, а передаваемые через IPv6 - отбрасывались с ошибкой авторизации (403). Я облазил исходники Nest-а, но так и не понял, почему это происходит (если у кого-то есть мысли на этот счёт - буду рад выслушать). В результате, IPv6 на Loopback-е пришлось отключить:

<spoiler title="sysctl.conf">
<source>
net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
net.ipv6.conf.lo.disable_ipv6=1
</source>
</spoiler>
и всё заработало.
</spoiler>
Конечно, только этим дело не ограничивалось. Одним из требований отдела маркетинга была возможность запуска игр на мобильных устройствах. В этом, мне помог @jonic (за что я очень ему благодарен). Было совершенно необходимо <a href="https://github.com/GlukKazan/DagazServer/blob/master/public/games/autofit.js">уметь масштабировать</a> canvas, на котором происходит вся игра, по размерам экрана мобильного телефона или планшета. При этом, соотношение сторон должно было сохраняться, а в том случае если ширина canvas-а значительно превосходит высоту было крайне желательно попросить пользователя повернуть устройство должным образом.

<a href="https://games.dtco.ru/games/filler.html">
<img align="center" src="https://habrastorage.org/webt/ku/fl/nk/kuflnkyqtw22zwwiwvofoltlihk.png" /></a>
Второй задачей стала интеграция отобранных отделом маркетинга игр в единое меню, с кратким описанием игр, страничками побед и поражений и навигацией между всеми этими страничками. Поскольку задача поддержания всего этого зоопарка в актуальном состоянии, сама по себе, способна свести с ума, Кирилл приспособил <a href="https://gulpjs.com/">Gulp</a> для автоматизированной <a href="https://github.com/GlukKazan/DagazServer/blob/master/gulpfile.js">сборки</a> этой части сайта. Вот как всё выглядит в результате:

<a href="http://games.dtco.ru/games/index.html">
<img align="center" src="https://habrastorage.org/webt/wq/6n/lx/wq6nlxyzc7buxmnnvmik_j3emp8.png" /></a>
Вот так, при помощи Nest-а, jQuery, Nginx-а и небольшой доли везения нам удалось развернуть в Internet-е игровой сервер. Кому стало интересно, заходите ещё.

<oembed>https://www.youtube.com/watch?v=qp1snun58A8</oembed>
</cut>

Как мы турнир провели

<img align="left" src="https://habrastorage.org/webt/dy/3d/gn/dy3dgnhaftcendytv0j1gd8uabm.png" /><b><i>Потому что совместный труд, для моей пользы 
- он объединяет.

Матроскин

Бросая в воду камешки, смотри на круги, ими образуемые; иначе такое бросание будет пустою забавою.

Козьма Прутков "Мысли и афоризмы".</i></b>

Недавно, в прошлую пятницу, мы решили слегка разнообразить свои будни, проведя программистский турнир. Повестка определилась не сразу. Были мысли про аналитическую обработку данных, машинное обучение, но в конце концов, остановились на настольных играх. Нам хотелось ввести в мероприятие элемент соревнования, а что, как не игры, позволяет легко это сделать?
<cut>
<img align="center" src="https://habrastorage.org/webt/si/7b/xs/si7bxsw0koq-iavdzv6ou6qdars.jpeg" />
Итак, коллектив, желающий принять участие в соревновании, в наличии был, с призовым фондом тоже разобрались - осталось определиться с игрой. Я предложил "Атари Го" и на то у меня были самые веские основания.

<spoiler title="Что вообще такое, это ''Атари Го''?">
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> - это абстрактная логическая игра, распространённая в Китае, Японии и Корее. Для игры используется прямоугольная доска, расчерченная вертикальными и горизонтальными линиями. Фигуры (камни), которыми играют противники, ставятся на пересечения линий (пункты). Стандартный размер доски - 19x19. В игре участвуют два игрока, один из которых получает чёрные камни, другой белые. Игрок с чёрными камнями начинает игру.

В начале игры доска пуста. Игроки, по очереди, ставят камни своего цвета на пустые пункты доски. Свободные пункты, граничащие с камнем по линиям, называются "дамэ". Поставленные на доску камни не перемещаются, но их можно убрать с доски, полностью окружив (лишив дамэ). Камни одного цвета, расположенные по соседству, составляют группу. Группа может быть снята с доски только целиком, после заполнения всех её дамэ:

<img src="https://habrastorage.org/webt/gj/or/hj/gjorhj9xn0kcpybrmkp7ftymbto.png" />

В Го запрещены самоубийственные ходы. Нельзя ставить камень на доску, лишая свою группу последнего дамэ. Но это правило не касается того случая, когда своим ходом мы берём камни противника. Поскольку взятые камни соседствуют с камнем поставленным на доску, таким ходом мы не убиваем свою группу, а увеличиваем количество её дамэ:

<img src="https://habrastorage.org/webt/aj/nh/-r/ajnh-rczi2mibzor3kjgzlir5bi.png" />

Есть еще одно правило (<a href="https://ru.wikipedia.org/wiki/Правило_ко">Ко</a>), запрещающее повторение на доске предыдущей позиции, но для нас оно не очень важно. Дело в том, что "Атари Го" продолжается лишь до первого взятия. Игрок, первым захвативший хотя бы один из камней противника, побеждает. Поскольку камни на доске не могут двигаться, очевидно, что повторение позиции может быть связано только с захватом камней. Таким образом, в "Атари Го", ситуация Ко возникнуть не может, поскольку после первого же взятия игра будет завершена.

"Атари Го" - игра детская, используемая для обучения учеников основам захвата камней в Го. Стандартный размер доски для неё - 9x9 линий. Для наших целей эта игра наиболее пригодна. Дело в том, что Го - очень сложная игра. В первую очередь, по той причине, что её цель - окружение наибольшей территории, связана с захватом камней лишь опосредованно. "Атари Го" более прямолинейна. Писать ботов для этой игры гораздо проще!
</spoiler>
<ul>
	<li>Го - хорошо изученная и очень популярная игра с интересной игровой механикой</li>
	<li>Разработка ботов для Го - сложное занятие, но "Атари Го" существенно проще</li>
	<li>Партии в "Атари Го" зрелищны и динамичны, а сама игра не подвержена "<a href="https://ru.wikipedia.org/wiki/Ничейная_смерть">ничейной смерти</a>"</li>
	<li>В разработке ботов, для этой игры, могут применяться как <a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">минимаксные алгоритмы</a>, так и метод "<a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a>"</li>
	<li>По всей видимости, не существует общедоступных реализаций ботов для этой игры, которыми можно было бы воспользоваться в условиях острого дефицита времени </li>
</ul>
Относительно последнего пункта предвижу возражения. Да, действительно, ботов для Го пишется много и найти доступную реализацию совсем не проблема, но "Атари Го" - это другая игра. Потеря отдельных камней в Го не рассматривается как катастрофа - цели в игре совсем другие. В "Атари Го", потеря даже одного камня - это немедленное поражение.

Поскольку мы не хотели связывать участников каким-то одним языком программирования, было решено разработать Web-сервис, предоставляющий <a href="https://ru.wikipedia.org/wiki/REST">REST API</a>, для регистрации ходов участников турнира. Впоследствии, эта идея полностью себя оправдала. Помимо Java, в качестве языков разработки, участники соревнования использовали C++, Kotlin и даже Lua. Чтобы исключить возможное влияние различной производительности компьютеров, на которых планировался запуск ботов, были закуплены и первоначально протестированы два однотипных комплекта <a href="https://a.aliexpress.com/_eL785B">мини ПК</a>, на которых была установлена ОС Ubuntu Linux 20-ой версии.

<img align="center" src="https://habrastorage.org/webt/ro/dk/aq/rodkaqiuf34ntxhqfb6hroohdga.jpeg" />

Сервис, фиксирующий ход партий, был разработан на <a href="https://nodejs.org/en/">Node.js</a> с использованием фреймворка <a href="https://nestjs.com/">Nest</a>, но это была только половина дела. Дело в том, что сервер задумывался как универсальное решение, не зависящее от конкретики каких либо из игр. Его задача - фиксация в БД ходов игроков и контроль времени, но он не проверяет на корректность сами ходы. Проверка корректности ходов, а также определение победителя - задача <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-net.js">Арбитра</a>, небольшого JavaScript-приложения, подключающегося к серверу с использованием библиотеки <a href="https://jquery.com/">jQuery</a>.

<spoiler title="Больше технических деталей">
Многопользовательский игровой сервер - это прежде всего, база данных. В качестве СУБД мы использовали PostgreSQL. Схема данных проектировалась "на вырост" и, на текущий момент, выглядит следующим образом:

<img align="center" src="https://habrastorage.org/webt/_6/1q/tm/_61qtmha7srjzvy3b3qtmojgrzy.png" />
Часть относящаяся к user-ам и token-ам, я думаю понятна (сервер использует <a href="https://ru.wikipedia.org/wiki/JSON_Web_Token">JWT</a>-авторизацию). Список поддерживаемых игр хранится в таблице games (только "Атари Го" на момент начала турнира). На каждую партию создаётся запись в game_sessions. Игроки, участвующие в партии (для некоторых игр их может быть больше двух) фиксируются в таблице user_games. Сами ходы сохраняются в game_moves.

<spoiler title="Сервер предоставляет следующее API">
<source lang="javascript">
{
   "openapi":"3.0.0",
   "info":{
      "title":"Dagaz Server",
      "description":"Dagaz Server API description",
      "version":"0.0.1",
      "contact":{

      }
   },
   "tags":[
      {
         "name":"dagaz",
         "description":""
      }
   ],
   "servers":[

   ],
   "components":{
      "schemas":{
         "User":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "is_admin":{
                  "type":"number"
               },
               "name":{
                  "type":"string"
               },
               "username":{
                  "type":"string"
               },
               "password":{
                  "type":"string"
               },
               "email":{
                  "type":"string"
               },
               "created":{
                  "format":"date-time",
                  "type":"string"
               },
               "deleted":{
                  "format":"date-time",
                  "type":"string"
               },
               "last_actived":{
                  "format":"date-time",
                  "type":"string"
               }
            },
            "required":[
               "id",
               "name",
               "username",
               "created",
               "last_actived"
            ]
         },
         "Pref":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "user_id":{
                  "type":"number"
               },
               "game_id":{
                  "type":"number"
               },
               "created":{
                  "format":"date-time",
                  "type":"string"
               }
            },
            "required":[
               "game_id"
            ]
         },
         "Sess":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "status":{
                  "type":"number"
               },
               "game_id":{
                  "type":"number"
               },
               "game":{
                  "type":"string"
               },
               "filename":{
                  "type":"string"
               },
               "created":{
                  "format":"date-time",
                  "type":"string"
               },
               "creator":{
                  "type":"string"
               },
               "changed":{
                  "format":"date-time",
                  "type":"string"
               },
               "closed":{
                  "format":"date-time",
                  "type":"string"
               },
               "players_total":{
                  "type":"number"
               },
               "winner":{
                  "type":"number"
               },
               "loser":{
                  "type":"number"
               },
               "score":{
                  "type":"number"
               },
               "last_setup":{
                  "type":"string"
               }
            },
            "required":[
               "game_id"
            ]
         },
         "Challenge":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "session_id":{
                  "type":"number"
               },
               "user_id":{
                  "type":"number"
               },
               "user":{
                  "type":"string"
               },
               "player_num":{
                  "type":"number"
               }
            },
            "required":[
               "session_id"
            ]
         },
         "Join":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "user_id":{
                  "type":"number"
               },
               "user":{
                  "type":"string"
               },
               "session_id":{
                  "type":"number"
               },
               "player_num":{
                  "type":"number"
               },
               "is_ai":{
                  "type":"number"
               }
            },
            "required":[
               "session_id"
            ]
         },
         "Move":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "session_id":{
                  "type":"number"
               },
               "user_id":{
                  "type":"number"
               },
               "turn_num":{
                  "type":"number"
               },
               "move_str":{
                  "type":"string"
               },
               "setup_str":{
                  "type":"string"
               },
               "note":{
                  "type":"string"
               },
               "time_delta":{
                  "type":"number"
               },
               "time_limit":{
                  "type":"number"
               },
               "additional_time":{
                  "type":"number"
               }
            },
            "required":[
               "session_id",
               "user_id",
               "move_str"
            ]
         },
         "Result":{
            "type":"object",
            "properties":{
               "id":{
                  "type":"number"
               },
               "session_id":{
                  "type":"number"
               },
               "user_id":{
                  "type":"number"
               },
               "result_id":{
                  "type":"number"
               },
               "score":{
                  "type":"number"
               }
            },
            "required":[
               "session_id",
               "result_id"
            ]
         }
      }
   },
   "paths":{
      "/api/auth/login":{
         "post":{
            "operationId":"AppController_login",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/User"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               }
            },
            "security":[
               {
                  "basic":[

                  ]
               }
            ]
         }
      },
      "/api/auth/refresh":{
         "get":{
            "operationId":"AppController_refresh",
            "parameters":[

            ],
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               }
            },
            "security":[
               {
                  "basic":[

                  ]
               }
            ]
         }
      },
      "/api/users":{
         "get":{
            "operationId":"UsersController_findAll",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         },
         "post":{
            "operationId":"UsersController_update",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/User"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/users/{id}":{
         "get":{
            "operationId":"UsersController_findUsers",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         },
         "delete":{
            "operationId":"UsersController_delete",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/preferences":{
         "get":{
            "operationId":"PreferencesController_findAll",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         },
         "post":{
            "operationId":"PreferencesController_create",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Pref"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/preferences/{id}":{
         "delete":{
            "operationId":"PreferencesController_delete",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/session":{
         "get":{
            "operationId":"SessionController_findAll",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         },
         "post":{
            "operationId":"SessionController_create",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Sess"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/session/{id}":{
         "get":{
            "operationId":"SessionController_getSession",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/session/close":{
         "post":{
            "operationId":"SessionController_close",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Sess"
                        }
                     }
                  }
               }
            },
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/challenge":{
         "get":{
            "operationId":"ChallengeController_findAll",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         },
         "post":{
            "operationId":"ChallengeController_create",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Challenge"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/challenge/{id}":{
         "delete":{
            "operationId":"ChallengeController_delete",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/join/{id}":{
         "get":{
            "operationId":"JoinController_findJoined",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/join":{
         "post":{
            "operationId":"JoinController_join",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Join"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/move/all/{id}":{
         "get":{
            "operationId":"MoveController_getMoves",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/move/unconfirmed/{id}":{
         "get":{
            "operationId":"MoveController_getUnconfirmedMove",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/move/confirmed/{id}":{
         "get":{
            "operationId":"MoveController_getConfirmedMove",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/move":{
         "post":{
            "operationId":"MoveController_update",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Move"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/move/confirm":{
         "post":{
            "operationId":"MoveController_confirm",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Move"
                        }
                     }
                  }
               }
            },
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "403":{
                  "description":"Forbidden."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/result/{id}":{
         "get":{
            "operationId":"ResultController_getMoves",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/result":{
         "post":{
            "operationId":"ResultController_join",
            "parameters":[

            ],
            "requestBody":{
               "required":true,
               "content":{
                  "application/json":{
                     "schema":{
                        "type":"array",
                        "items":{
                           "$ref":"#/components/schemas/Result"
                        }
                     }
                  }
               }
            },
            "responses":{
               "201":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "404":{
                  "description":"Not Found."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      },
      "/api/game":{
         "get":{
            "operationId":"GameController_allGames",
            "parameters":[

            ],
            "responses":{
               "200":{
                  "description":"Successfully."
               },
               "401":{
                  "description":"Unauthorized."
               },
               "500":{
                  "description":"Internal Server error."
               }
            },
            "security":[
               {
                  "bearer":[

                  ]
               }
            ]
         }
      }
   }
}</source>
</spoiler>
Прежде всего, один из игроков создаёт игровую сессию (POST api/session), формирует вызов противнику (POST api/challenge) и выполняет первый ход (POST api/move). Второй игрок получает вызов (GET api/challenge) и присоединяется к сессии (POST api/join). Далее, каждый из игроков, в цикле, получает ход противника (GET api/move/confirmed/:id, здесь id - идентификатор сессии) и выполняет собственный ход (POST api/move).

Как я уже писал выше, сервер не проверяет корректность выполняемых ходов, но он учитывает время, затраченное на каждый ход. В соответствии с регламентом <a href="https://en.wikipedia.org/wiki/Time_control#Byo-yomi">баёми</a>, каждому из игроков выделяется основное время (games.main_time), по истечении которого даётся дополнительное время (games.additional_time), на выполнение каждого хода. Учитывается период времени от момента получения хода противника (или создания игровой сессии), до момента формирования собственного хода. Это довольно мягкая система контроля времени. Даже исчерпав основное время, игрок не проиграет, если укладывается в дополнительное время, при выполнении каждого хода.

Корректность ходов игроков (в соответствии с правилами игры), а также победителя определяет Арбитр - специальное приложение, подключающееся к серверу с правами администратора. Его задача - получение не подтверждённых ходов игроков, их проверка и формирование подтверждения (setup_str), позволяющего восстановить позицию, на момент завершения хода (это может понадобиться, например, при перезапуске Арбитра, без завершения партии). Также, Арбитр выполняет проверку исчерпания лимита времени и условия завершения игры (взятие хотя бы одного из камней). Дополнительно, эта программа осуществляет визуализацию хода игры (скриншоты в статье сделаны с её помощью).
</spoiler>
Разработка ботов, даже для "Атари Го" - дело сложное. Трёх суток выделенных конкурсантам на подготовку, оказалось достаточно только для того, чтобы боты просто заработали. Кроме того, мини-ПК, на которых проводился конкурс, оказались существенно менее производительными, чем рабочие места, на которых выполнялась отладка. Всё это привело к тому, что боты, в ходе турнира, не блистали особым интеллектом, но забавные моменты всё же случались.

<img align="center" src="https://habrastorage.org/webt/lc/zk/nj/lczknj1ipaefqfykcdnugh_s2vm.png" />
Это пример финальной позиции в одной из турнирных партий. Борьба ботов была интересная и ожесточённая. В конце-концов, белые попытались поймать противника в <a href="https://www.sente.ru/2007/08/sityo/">ситё</a>, но не заметили, что следующим ходом чёрные поставили их в положение <a href="http://go-igo.ru/dictionary-go/atari.html">атари</a>. Бот белых допустил ошибку, пытаясь продолжить "лестницу". Чёрные немедленно этим воспользовались - взяли камень и завершили игру.

<spoiler title="Всё это хорошо иллюстрирует характер ошибок, допущенных участниками турнира">
Одной из главных сложностей игры Го является то, что оценка материала в ней, практически, не имеет никакого смысла. Важно не то, сколько камней стоит на доске, а то, как они расположены. Существуют позиции требующие немедленной реакции игрока:

<img src="https://habrastorage.org/webt/az/wm/6_/azwm6_3oxwapxay8mp5xfapuwyw.png" />

Это ситуация "<a href="http://go-igo.ru/dictionary-go/atari.html">атари</a>" - угроза взятия камня. Если мы играем в "Атари Го", вне зависимости от очерёдности хода, игрок должен ответить в пункт "E6", над чёрным камнем. Белые, при этом, побеждают, а чёрные - защищаются от немедленного поражения, "удлиняя" камень, попавший в ловушку. При обнаружении на доске "атари", игрок должен отвечать немедленно, без каких либо предварительных расчётов. Существуют и более коварные позиции.

<img src="https://habrastorage.org/webt/8x/2-/qc/8x2-qcnqx9myit2q2-j_m0smy2e.png" />

Здесь, слева направо, представлены: угроза двойного "<a href="http://go-igo.ru/dictionary-go/atari.html">атари</a>", угроза "<a href="http://go-igo.ru/dictionary-go/geta.html">гэта</a>" и угроза "<a href="https://www.sente.ru/2007/08/sityo/">ситё</a>". Во всех трёх случаях, белые должны немедленно реагировать, вполне определённым образом, чтобы избежать поражения. Чёрные, в свою очередь, могут поймать белых в ловушку, на своём ходе. Сказанное не отменяет необходимости просмотра ходов в глубину, но ходы, связанные с обработкой этих ситуаций, должны рассматриваться в первую очередь.

<spoiler title="Это больше похоже на распознавание образов, чем на задачу оптимизации">
В своей <a href="https://glukkazan.github.io/go/atari-go.htm">реализации</a> бота для "Атари Го", я постарался собрать наиболее важные <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/go-family/data/atari.dat">паттерны</a>, требующие специальной обработки. В человекочитаемом виде, это выглядит следующим образом:

<source lang="javascript">
1000    ; Двойное атари
-----
?????
??B??
?B.??
?????
?????
</source>
Пункт, в который выполняется рассматриваемый ход, расположен в центре квадрата 5x5. Ходу присваивается некоторая стоимость, используемая для его оценки, а окружение описывается специальными символами (например, "В" означает камень противника с двумя дамэ). Разумеется, описание в такой нотации неудобно использовать в программе. Кроме того, было бы неплохо покрутить эту позицию на 90, 180 и 270 градусов, а если она не симметрична ещё и поотражать относительно осей. Набирать все такие позиции вручную неразумно. Лучше выполнить черновую работу <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/go-family/data/pattern.pl">скриптом</a>.

<source lang="javascript">
Dagaz.AI.Patterns.push({re: /.{7}B.{3}B0.{12}/, price: 1000});
Dagaz.AI.Patterns.push({re: /.{11}B0.{4}B.{7}/, price: 1000});
Dagaz.AI.Patterns.push({re: /.{12}0B.{3}B.{7}/, price: 1000});
Dagaz.AI.Patterns.push({re: /.{7}B.{4}0B.{11}/, price: 1000});
</source>
На выходе получаем регулярные выражения, описывающие все интересующие нас позиции. Сама предварительная оценка хода выполняется <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/go-family/atari-go-goal.js">здесь</a>, в функции heuristic. Дополнительно, выполняется ещё несколько проверок. Например, в "Атари Го", ходы в отдалении от своих или чужих камней не имеют большого смысла, а ходы на первую и вторую линию, как правило, очень опасны.
</spoiler>
В силу нехватки времени, выделенного на разработку ботов, а также в связи со слабым знанием игры, ни один из участников не обрабатывал подобные ситуации специальным образом. Речь не идёт о сложных формах, боты не всегда корректно определяли даже ситуацию простого "атари".
</spoiler>
Тем не менее, отборочный этап турнира, в рамках которого каждый из участников сыграл со всеми претендентами по две партии (белыми и чёрными), прошёл отлично и по количеству побед мы определили двух финалистов. 

<img align="center" src="https://habrastorage.org/webt/bf/8o/d_/bf8od_fvc6xcqlf2c-biy5v5278.png" />

Далее, игры продолжались до трёх побед, с чередованием очерёдности первого хода. Победив с итоговым счётом 3:1, довольный (и три ночи не спавший) победитель забрал свой приз:

<img align="center" src="https://habrastorage.org/webt/u-/wf/zn/u-wfznaa7dahqxyjpmmhvxp165i.png" />
Поаплодируем ему!
</cut>

Сплетая дизайн

<a href="https://glukkazan.github.io/control/filler.htm"><img align="left" src="https://habrastorage.org/webt/ra/fz/qh/rafzqhfcqpwnbk1a6o4yidcxvxy.png" /></a><b><i>Три кольца - премудрым эльфам 
- для добра их гордого.
Семь колец - пещерным гномам 
- для труда их горного.
Девять - людям Средиземья...

Джон Рональд Руэл Толкин</i></b>

Работая над <a href="https://glukkazan.github.io/">играми</a>, я уделяю большое внимание дизайну. Речь идёт не о красивой картинке, хотя и она конечно имеет значение. Прежде всего, для меня важны удобные игровые механики. Игра должна приносить удовольствие. Когда в <a href="https://glukkazan.github.io/elimination/mine-sweeper-16x16.htm">Сапёре</a> при клике на пустое поле автоматически открываются все поля, не соседствующие с минами - это удобно. Известный всем <a href="https://glukkazan.github.io/arrange/klondike.htm">пасьянс</a> также можно значительно улучшить, просто избавив пользователя от необходимости выполнения лишних действий. Но сегодня я хочу рассказать о другой игре. Той самой, которая изображена на <abbr title="Картинке для привлечения внимания">КДПВ</abbr> (как обычно, все картинки в статье кликабельные).
<cut>
Оригинальная игра Filler <a href="https://ru.wikipedia.org/wiki/Filler">была разработана</a> компанией Gamos в далёком 1990 году и запускалась под управлением MS DOS. С тех пор было выпущено немало её клонов, работающих на всех мыслимых и немыслимых платформах. В какой-то момент я тоже решил "быть в тренде" и разработать свою версию этой игры. Ладно-ладно, я просто хотел проверить, как Dagaz справится с таким количеством изменяемых фигур на доске.

<a href="https://glukkazan.github.io/control/filler.htm">
<img align="center" src="https://habrastorage.org/webt/kn/rx/a3/knrxa3to3lobmzhadvtpaszxd3g.png" /></a>
Суть дела довольно проста - всё игровое поле случайным образом заполнено квадратами шести различных цветов (наблюдательные читатели могут заметить, что от первоначальных ромбов я отказался). Левый нижний и правый верхний угол принадлежат игрокам. Выполняя ход, каждый из игроков может выбрать цвет, граничащий с его областью. Вся территория игрока перекрашивается, присоединяя граничащие области того же цвета. Цель игры - захватить большую территорию. Может получиться так, что один из игроков лишится возможных ходов ещё до того, как вся ничейная территория будет распределена. Ну что же, в таком случае игрок терпит досрочное поражение.

На картинке можно заметить два важных элемента пользовательского интерфейса. Двухцветная полоска сверху призвана избавить игроков от утомительных расчётов в уме того, чья территория больше. Можно было бы отобразить точные значения захваченной территории, но я стараюсь не применять числовые обозначения там, где без них можно обойтись. Что касается панели внизу, то именно с её помощью игрок выполняет свой ход. Помимо текущего, на ней отображаются лишь те цвета, которые разрешается выбрать по правилам игры. Ввод с клавиатуры также поддерживается. Можно не утруждать себя тыканьем мышью по экрану, а ограничиться нажатием всего одной клавиши с выбранной цифрой.

<spoiler title="И то и другое - примеры повторного использования кода в Dagaz">
Управление игрой с клавиатуры мне понадобилось когда я разрабатывал <a href="https://glukkazan.github.io/sokoban/sokoban-01.htm">Sokoban</a> (тоже <a href="https://ru.wikipedia.org/wiki/Sokoban">клон</a>, да). Клавиатурные стрелки в этой игре обеспечивают более естественное управление чем мышь. Надо сказать, что это был первый момент, когда пришлось писать разный код для различных браузеров. Пока всё ограничивалось тыканьем мыши по экрану и рисованием на канвасе, код оставался вполне себе браузерно-независимый.

<a href="https://glukkazan.github.io/sokoban/sokoban-01.htm">
<img align="center" src="https://habrastorage.org/webt/wf/ix/he/wfixhe8kbsb7ievk57skpegw5y8.png" /></a>
Что касается панели с отображением распределения очков - это довольно востребованный элемент. Впервые он понадобился, когда я работал над чудесной игрой из <a href="https://ru.wikipedia.org/wiki/%D0%91%D1%80%D1%83%D0%BD%D0%B5%D0%B9">Брунея</a> под названием "<a href="https://en.wikipedia.org/wiki/Pasang_(game)">Пасанг</a>".

<a href="https://glukkazan.github.io/pasang/pasang-01.htm">
<img align="center" src="https://habrastorage.org/webt/og/zc/75/ogzc75nhbcwqz62ptwie_psrbi0.png" /></a>
Я пошёл навстречу пожеланием играющих и сделал полоску с отображением очков потолще.
</spoiler>
Разумеется, первое, о чём меня попросили благодарные пользователи - это уменьшение размеров игрового поля (игра на доске 80x40 довольно занимательна, но крайне продолжительна по времени). Я же, в свою очередь, решил добавить в игру тактического разнообразия. Базовая идея игры Filler гениальна, но нет ничего такого, что нельзя было бы сделать ещё лучше. В первую очередь я подумал о стенах. С их помощью можно строить лабиринты!

<a href="https://glukkazan.github.io/control/filler-40x20.htm?selector=8">
<img align="center" src="https://habrastorage.org/webt/cr/nb/e5/crnbe5ltmw47cjrlmjejscl_zt4.png" /></a>
Менее очевидная идея - области игрового поля, заполненные одним из обычных цветов, но... не случайным образом. В первую очередь - это, конечно, приз для более расторопного игрока. Тот, кто первым доберётся до обширной области одного цвета, получит значительное преимущество в очках. Но есть и другое, не менее важное применение. Протяжённые однородные области позволяют практически мгновенно перемещаться по доске, захватывая территории более эффективно, а также отрезая противника от перспективных направлений.

<a href="https://glukkazan.github.io/control/filler-40x20.htm?selector=4">
<img align="center" src="https://habrastorage.org/webt/hb/d1/di/hbd1dimsykf-yfkafx0s3mvgr2i.png" /></a>
Далее, мне не нравилось то, что территорию, захваченную одним из игроков, нельзя вернуть в игру, чтобы впоследствии перераспределить иным образом. Я добавил в игру "тьму", распространяющуюся по доске при каждом ходе. Стены ограничивают её движение, но никакие цветные области препятствием для неё не являются. Разумеется, без каких либо сдерживающих факторов тьма просто распространилась бы по доске, раздавив обоих игроков. Требовались какие-то предохранители.

<a href="https://glukkazan.github.io/control/filler-40x20.htm?selector=6">
<img align="center" src="https://habrastorage.org/webt/oz/uo/st/ozuosto3jew9-fun_wiv8ienp4a.png" /></a>
Специальные поля с жёлтыми "искрами" позволяют "подорвать" соприкасающуюся с ними тьму, заполнив захваченную ей область случайно распределёнными цветами. Граничащие с этой областью клетки также "подрывается", что позволяет разрушать стены. Голубые "искры" позволяют остановить тьму, "заморозив" фронт её распространения. Это своего рода универсальный предохранитель. Для "заморозки" ему не обязательно граничить с тьмой. Оба типа детонаторов срабатывают как при достижении их игроками, так и в тех случаях, когда тьма до них добирается первой.

<spoiler title="Кстати, о взрывах">
Тема изменяемой геометрии доски очень привлекательна в компьютерных реализациях настольных игр. Одновременное перемещение нескольких фигур способно внести радикальные изменения в расстановку фигур на доске. Но платформа, на которой перемещаются фигуры, также является фигурой. Само собой, в голову приходят различные идеи для выведения из игры фигур целыми платформами. Именно таким образом в "<a href="https://glukkazan.github.io/checkmate/platform-chess.htm">Платформенных шахматах</a>", придуманных Робертом Прайсом в 2001 году, появились бомбы.

<a href="https://glukkazan.github.io/control/filler-40x20.htm?selector=7">
<img align="center" src="https://habrastorage.org/webt/of/2y/dl/of2ydls0rbdjtho23fszwa_6lgm.png" /></a>
По сути, это те же самые пешки, у которых я отобрал возможность атакующего хода. Дойдя до последней линии, они также ни во что не превращаются. Для чего они нужны? Такая фигура способна уничтожить всю платформу целиком, вместе с находящимися на ней фигурами. Также, я добавил предохранительный механизм, запрещающий взрыв при наличии на платформе других дружественных фигур. Автор игры всецело одобрил моё нововведение.
</spoiler>
Детонаторы можно использовать и сами по себе, динамически строя "лабиринт" в зависимости от действий игроков. Дело в том, что заморозка на самом деле действует не на фронт распространение тьмы, как я сказал раньше, а на все клетки, изменяющие своё состояние при выполнении хода. То есть, если игрок выбрал цвет граничащий с заморозкой, все присоединённые им на этом ходу квадраты превратятся в стены. Это очень коварное препятствие, способное запереть игрока полностью. Жёлтые "искры" куда менее опасны.

<a href="https://glukkazan.github.io/control/filler-40x20.htm?selector=7">
<img align="center" src="https://habrastorage.org/webt/wh/2x/id/wh2xidyxyqku93mzsubcg9yoal4.png" /></a>
Ну что же, я очевидно не первый, из тех кто решил разработать ещё один клон замечательной игры Filler. Будем надеяться, что и не последний. Больше игр, товарищи! Хороших и разных.
</cut>

Dagaz: История с персистентностью

<img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png" /><b><i>Любая достаточно развитая технология неотличима от магии.
Артур Кларк
&nbsp;
— Я больше не хочу быть сравнением... Сделайте меня метафорой.
Чайна Мьевиль</i></b>

Работа над большим <a href="https://glukkazan.github.io/">проектом</a> похожа на <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D1%80%D0%BE%D0%B8%D0%B4%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">метроидванию</a>. Решая частные проблемы, мы открываем новые возможности. Со временем, эти возможности крепнут, соединяются с другими возможностями и это позволяет решать застарелые, куда более важные и сложные проблемы новым, совершенно неожиданным способом. У меня есть хороший пример на эту тему. И я хочу о нём рассказать.
<cut>
Модуль <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/common-setup.js">common-setup</a> задумывался как простое средство отладки. Часто, бывает очень полезно иметь возможность вернуться к какой-то конкретной позиции, чтобы локализовать проблему. Но такая расстановка фигур возникает в игре мимолётно, а её восстановление стоит немалых трудов. Мне было необходимо средство, автоматизирующее этот процесс, и я его сделал. В самом деле, я легко могу закодировать любую позицию, описав расположение фигур на доске:

<blockquote>?setup=0c3;0a2;0c2;0d2;1a1;4b1;5c1;1d1;-1a4;4b4;5c4;1d4;0a3;0d3;0b2;;&turn=0</blockquote>
Затем, я могу добавить эти параметры в url, чтобы воспроизвести позицию. Этим и занимается common-setup. Модуль сохраняет описание всех промежуточных позиций в лог и даёт возможность воспроизвести их. Это не очень совершенный механизм. Например, такое описание ничего нам не даёт, если мы не знаем к какой игре оно относится. Имеются и другие недостатки,о которых я скажу позже. Сейчас, пришло время познакомиться со следующим участником нашего рассказа.

<a href="https://glukkazan.github.io/light-off/hex-light-off-01.htm">
<img align="center" src="https://habrastorage.org/webt/7_/i1/dz/7_i1dzv7lp6sajcawqmldwx4hma.png" /></a>
Опция progressive-levels пришла из <a href="http://www.zillions-of-games.com/">Zillions of Games</a> и я долгое время не понимал, зачем она нужна. Попробуйте погасить все лампочки (это просто) и вам станет понятно о чём я говорю. После победы игрока, progressive-levels просматривает текущий url, и если находит в нём число, увеличивает его на единичку. На самом деле, это замечательное средство вовлечения игрока, но этим его возможности не ограничиваются. Есть игры, состоящие из нескольких раундов. Закончив один, игроки, по определённым правилам, перераспределяют фигуры и начинают играть снова.

<a href="https://glukkazan.github.io/breakthrough/kamisado.htm">
<img align="center" src="https://habrastorage.org/webt/iy/bi/ff/iybiff0rupuwcijge_z8b0fimiw.png" /></a>
Такой подход очень часто практикуется в африканских <a href="https://ru.wikipedia.org/wiki/Манкала">манкалах</a>. В <a href="https://glukkazan.github.io/mancala/ohvalhu.htm">Овалху</a>, например, игра не просто начинается снова. Игроки используют захваченные в предыдущем раунде зёрна для первоначального наполнения своих лунок. Лунки, заполнить которые не удалось, считаются выбывшими из игры, использовать их нельзя. Фактически, в каждом раунде играется новая игра, на новой доске. Только когда проигравший в очередном раунде игрок не может заполнить хотя бы одну лунку, признаётся его окончательное поражение.

<spoiler title="Эту возможность можно понимать гораздо шире">
<a href="https://glukkazan.github.io/sliding-puzzles/washington_1.htm">
<img align="center" src="https://habrastorage.org/webt/o_/aj/lp/o_ajlpvgnzcglfojk3vd-rhwozy.png" /></a>
Для решения этой головоломки, квадратную плашку требуется последовательно провести через все четыре угла игрового поля. Это хороший пример игры разделённой на раунды и для common-setup здесь также найдётся работа. Дело в том, что при переходе от одного раунда к другому, необходимо сохранять взаимное расположение частей, чтобы создать иллюзию непрерывного решения. Можно пойти ещё дальше, сделав сами переходы между раундами менее заметными.

<a href="https://glukkazan.github.io/checkers/magyar-dama.htm?setup=+4;0:3;+13;0:3+1;+13;0:3+1;+13;0:3+1;+12;0:3+2;+12;0:3+1;+10;0:3+3;+11;0:3+2;+24;1:2;+13;1:2;+15;1:1=21;+14;1:1;+13;1:1=11;1:1=22;+13;1:1=2222;+12;1:1;+35;&turn=1">
<img align="center" src="https://habrastorage.org/webt/gk/hf/ye/gkhfyel6ybgkumfd5x_foxluhny.png" /></a>
Просто перенесите отмеченные тайлы наверх и посмотрите, что произойдёт. Подобные "бездосковые" игры большая редкость, но сама концепция может создать определённые сложности. Строго говоря, в "<a href="https://glukkazan.github.io/checkers/magyar-dama.htm">Magyar Dama</a>" такая возможность не особенно необходима (надо постараться, чтобы доске действительно потребовалось "ползать"), но в <a href="https://www.youtube.com/watch?v=ySamvjzZsPo">Hive</a>, например, она была бы очень востребована. При переходе от одного раунда к другому, можно не просто запоминать расположение фигур, но и изменять его, перемещая все фигуры, например, ближе к центру рабочей области.

<a href="https://glukkazan.github.io/elimination/apocalypse.htm">
<img align="center" src="https://habrastorage.org/webt/ss/0s/uo/ss0suora_d8v2vavrw7kz8wehlw.png" /></a>
Концепция многораундной игры может быть полезна при разработке разнообразных <a href="https://ru.wikipedia.org/wiki/Roguelike">рогаликов</a> (иллюстрация выше показывает возможность одновременного перемещения фигур, но это лишь один элемент из множества важных составных частей roguelike-игр). Переход от одного раунда к другому может выполнять генерацию "комнат", на основании seed, используемого для генерации мира. Конечно, здесь также будет полезна возможность завершения раунда игры с различным результатом (чтобы различать выход из комнаты с различных сторон). Сейчас возможных итогов всего три (победа, проигрыш и ничья), но существуют игры в которых их должно быть больше.

<a href="https://glukkazan.github.io/elimination/rithmomachia.htm">
<img align="center" src="https://habrastorage.org/webt/lt/ea/11/ltea11ctmcw6ymezanbr_ygakfi.png" /></a>
Я пока не сделал этого, но по <a href="https://habr.com/ru/post/234587/">правилам</a>, <a href="https://en.wikipedia.org/wiki/Rithmomachy">Ритмомахию</a> можно завершать различным способом. И эта игра не исключение. В бурятском "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Шатар</a>", например, итог игры существенно различается, в зависимости от того, каким из способов был заматован король.
</spoiler>
Следующий шаг был сделан практически случайно. В моих играх есть звук. Он мне очень нравится, но наверняка на свете есть люди, которых он раздражает. Именно для них была предусмотрена возможность его отключения. Казалось бы, это работало неплохо, но настройки никуда не сохранялись и после каждого обновления страницы звук приходилось отключать снова (и это раздражало ещё больше). Меня попросили как-то исправить эту проблему и первым пришедшим мне в голову решением были <a href="https://ru.wikipedia.org/wiki/Cookie">cookie</a> (первое решение не всегда бывает удачным). 

<spoiler title="Вот как это выглядело">
<source lang="javascript">
Dagaz.Controller.sound = function() {
    if (Dagaz.Controller.soundOff) {
        sound.innerHTML = "no Sound";
        Dagaz.Controller.soundOff = false;
        document.cookie = "dagaz.sound=on";
    } else {
        sound.innerHTML = "Sound";
        Dagaz.Controller.soundOff = true;
        document.cookie = "dagaz.sound=off";
    }
}
</source></spoiler>
Мне не хотелось мусорить, поэтому cookie были короткоживущими, до закрытия окна браузера. А потом я подумал: "а почему бы не научить common-setup сохраняться в cookie тоже"? Пришлось устанавливать параметр <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8">max-age</a>, но это того стоило. Во первых, состояние игры теперь сохранялось при случайном закрытии окна. В качестве бонуса, переключение режима игры с ботом "AI/no AI" также не сбрасывало игру. Это было здорово!

<spoiler title="Конечно, пришлось предусмотреть ещё кое что">
Во первых, любое завершение игры должно было сбрасывать сохранение, в противном случае, последний ход повторялся бы снова и снова, до момента устаревания cookie (и это вряд ли кого нибудь бы порадовало). Для досрочного завершения игры я добавил ссылку "New game", очищающую сохранение и обновляющую страницу. Но это была меньшая из проблем. Помните я говорил, что результат работы common-setup мало полезен в отрыве от информации о том, к какой игре он относится? А cookie для сохранения был общим для всех игр (опять же, чтобы не мусорить лишнего).

<spoiler title="Пришлось делать что-то в таком вот роде">
<source lang="javascript">
var getName = function() {
  var str = window.location.pathname.toString();
  var result = str.match(/\/([^.\/]+)\./);
  if (result) {
      return result[1].replace("-board", "").replace("-ai", "");
  } else {
      return str;
  }
}

var badName = function(str) {
  var result = str.match(/[?&]game=([^&*]*)/);
  if (result) {
      return result[1] != getName();
  } else {
      return true;
  }
}

var getCookie = function() {
  var str = document.cookie;
  var result = str.match(/dagaz\.(setup=[^*]*)/);
  if (result) {
      var r = decodeURIComponent(result[1]);
      if (badName(r)) return "";
      return "?" + r;
  } else {
      return "";
  }
}

var getSetup = function() {
  var str = window.location.search.toString();
  var result = str.match(/[?&]setup=([^&]*)/);
  if (result) {
      return result[1];
  } else {
      str = getCookie();
      result = str.match(/[?&]setup=([^&]*)/);
      if (result) {
          return result[1];
      } else {
          return "";
      }
  }
}

Dagaz.Model.getSetup = function(design, board) {
  var str = "";
  ...
  str = str + ";&turn=" + board.turn;
  if (Dagaz.Controller.persistense == "setup") {
      var s = str + "&game=" + getName() + "*";
      var maxage = getMaxage();
      if (maxage) {
        document.cookie = "dagaz.setup=" + encodeURIComponent(s) + "; max-age=" + maxage;
      } else {
        document.cookie = "dagaz.setup=" + encodeURIComponent(s);
      }
  }
  return "?setup=" + str;
}
</source></spoiler>
Кроме того, далеко не все игры можно описать исключительно расстановкой фигур на доске. В тех играх, где счёт идёт на очки (таких как <a href="https://glukkazan.github.io/pasang/pasang-01.htm">Pasang</a> или <a href="https://glukkazan.github.io/checkmate/chaturaji.htm">Chaturanji</a>) доска, сама по себе, хранит глобальные значения, а в играх с выставлением фигур из резерва (<a href="https://glukkazan.github.io/morris/nine-man-morris.htm">Morris</a>, <a href="https://glukkazan.github.io/arrange/bolotoudou.htm">Bolotoudou</a>) пришлось научить common-setup сохранять счётчики фигур, ещё не выставленных на доску. Да что там говорить, самая первая его версия не умела сохранять даже очерёдность хода!

<a href="https://glukkazan.github.io/checkmate/shatranj-1.htm">
<img align="center" src="https://habrastorage.org/webt/nw/xp/p1/nwxpp1i7qo0aevfux5rr_kqaaim.png" /></a>
В некоторых играх имеется несколько вариантов начальной расстановки фигур. В <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандже</a> фигуры расставляются согласно <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%B8%D1%8F">табиям</a> (в противном случае, дебюты в этой игре были бы чрезмерно утомительными). В других играх, таких как <a href="https://glukkazan.github.io/races/stratego.htm">Stratego</a> и <a href="https://glukkazan.github.io/races/luzhanqi.htm">Luzhanqi</a>, подобным образом расставляется лишь часть фигур (остальные фигуры бота размещаются случайным образом). Само по себе это не проблема (common-setup, в любом случае, запоминает расстановку всех фигур), но некоторые игры идут дальше...

<a href="https://glukkazan.github.io/custodian/reversi.htm">
<img align="center" src="https://habrastorage.org/webt/0y/hp/yd/0yhpyduqu2mgx4glqonulbwmrlw.png" /></a>
Здесь имеется несколько, выбираемых случайным образом, вариантов самого игрового поля и если не предпринимать никаких мер, common-setup может попытаться восстановить расстановку фигур, сохранённую для другой доски. Самих вариантов может быть немного (в <a href="https://glukkazan.github.io/elimination/mana.htm">Mana</a>, например, их всего два), но в зависимости от выбора какого либо из них, игра может изменяться очень существенно. 

К счастью, существует <a href="https://github.com/davidbau/seedrandom/blob/released/seedrandom.js">библиотека</a>, помогающая решить эту проблему. В самом деле, прежде чем вызывать random, мы можем cгенерировать seed и, сохранив его в какой нибудь переменной, использовать для инициализации генератора, перед получением последующих псевдо-случайных значений. В дальнейшем, seed можно сохранить в cookie, вместе с описанием позиции, чтобы при восстановлении игры, можно было восстановить и доску, на которой она происходит.
</spoiler>
К сожалению, есть игры, для которых метод сохранения состояния модулем common-setup не подходит. В упомянутом выше <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a>, возможность выполнения хода (для всех ходов кроме самого первого) зависит от того, на каком поле был завершён предыдущий ход. Существуют игры и с ещё более сложной механикой:

<a href="https://glukkazan.github.io/morris/morabaraba.htm">
<img align="center" src="https://habrastorage.org/webt/pc/ah/yo/pcahyosk3fotjxjnlmmafvjw5jk.png" /></a>
В <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельнице</a>, помимо обычных ходов имеются бонусные - если игрок выстроил три своих фигуры в ряд, он имеет право убрать с доски одну фигуру противника. Помимо этого, правилами запрещается выстраивать одну и ту же тройку два раза подряд. Всё это означает, что для корректной работы игры необходимо сохранять историю предыдущих ходов. К счастью, такая возможность имеется.

Модуль <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">session-manager</a> сохраняет историю игры, позволяя игроку возвращаться на один или несколько ходов назад, возможно выполняя другой ход. Также, с этим механизмом связана опция "advisor", подсказывающая игроку возможный ход, при игре с ботом. Ретроспективно, идея сохранения истории игры в cookie кажется очевидной, но пришёл я к ней не сразу.

<spoiler title="Сначала появилась игра по переписке">
Проект Dagaz имеет богатую историю. В каком-то смысле, он является идейным продолжением "<a href="http://www.zillions-of-games.com/">Zillions of Games</a>", разработанной в далёком 1998 году. С 2003 года Zillions не развивается, но новые игры продолжают появляться, во многом благодаря деятельности одного человека. Ed van Zon взял на себя общение с фанатами и публикацию новых игр на сайте. Помимо этого он развивает и собственный проект под названием "<a href="http://mindsports.nl/">MindSports</a>", посвящённый популяризации традиционных настольных игр.

<a href="http://mindsports.nl/index.php/dagaz">
<img align="center" src="https://habrastorage.org/webt/eu/in/mr/euinmrgfa_ur3e13hx3tjnhokdc.png" /></a>
Эта страничка на MindSports посвящена Dagaz и появилась она не случайно. Ed уже довольно давно разрабатывает настольные игры, но первоначально их интерактивность обеспечивалась <a href="https://ru.wikipedia.org/wiki/Java-%D0%B0%D0%BF%D0%BF%D0%BB%D0%B5%D1%82">Java-апплетами</a>, пользоваться которыми, в последнее время, стало несколько неудобно. Некоторое время назад, Ed принял решение о переводе своего сайта на Dagaz, попросив меня выполнить некоторые доработки.

Прежде всего, требовалось обеспечить сохранение истории игры на сервере, для того, чтобы игроки могли играть друг с другом, по переписке. Здесь следует отметить, что Dagaz, сам по себе, не содержит какого-то backend-а, ограничиваясь выполнением JavaScript-кода в браузере. Ed предложил доработать session-manager, чтобы обеспечить возможность сериализации истории игры. Первоначально, я отнёсся к идее скептически, поскольку это означало, что перед выполнением каждого хода в браузере игрока, каждый раз, должна была проигрываться вся партия, до сохранённой позиции (без отображения на экране, разумеется), но практика показала, что подход вполне работоспособен.

В качестве формата хранения я выбрал <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a> поскольку, как уже говорил, session-manager хранит дерево состояний, а SGF это поддерживает. В результате, в каждую игру с сессионной персистентностью пришлось тащить <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/utils/sgf-parser.js">парсер</a>, но это не очень большая проблема, учитывая то, что SGF используется в проекте и в других целях (для хранения дебютных библиотек, например). В результате всего этого, на MindSports, в настоящий момент, имеется уже более 80 игр и головоломок на движке Dagaz и в большую из них часть можно играть по переписке.
</spoiler>
Следующий шаг был довольно очевиден - я стал сохранять <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>-описание партий в cookie, а потом мне подсказали, что это не очень современно и я перенёс всё в <a href="https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage">localStorage</a> (это упростило код и решило некоторые проблемы с отладкой в Google Chrome). В этом месте у читателя может возникнуть вопрос. У меня имеются два механизма одинакового назначения, и один из них более совершенен чем другой. Почему бы не перевести <b>все</b> игры на сессионную персистентность? К сожалению, всё не так просто. 

Есть целые семейства игр, для которых сохранение сессий неприменимо:

<ol>
	<li>Все игры со случайной расстановкой фигур или случайным выбором игрового поля (<a href="https://glukkazan.github.io/checkmate/shatranj-1.htm">Shatranj</a>, <a href="https://glukkazan.github.io/checkmate/sittuyin.htm">Sittuyin</a>, <a href="https://glukkazan.github.io/xiangqi/janggi.htm">Janggi</a>, <a href="https://glukkazan.github.io/races/stratego.htm">Stratego</a>, <a href="https://glukkazan.github.io/races/luzhanqi.htm">Luzhanqi</a>, <a href="https://glukkazan.github.io/xiangqi/banqi-chinese.htm">Banqi</a> и много других)</li>
	<li>Игры с костями, для которых использование session-manager имеет мало смысла (<a href="https://glukkazan.github.io/races/ur.htm">Ur</a>, <a href="https://glukkazan.github.io/races/puluc.htm">Puluc</a>, <a href="https://glukkazan.github.io/races/shen.htm">Shen</a>, <a href="https://glukkazan.github.io/races/backgammon.htm">Backgammon</a>, <a href="https://glukkazan.github.io/checkmate/chaturaji.htm">Chaturaji</a> и другие)</li>
	<li>Многораундовые игры (<a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a>, <a href="https://glukkazan.github.io/sliding-puzzles/washington_1.htm">Washington</a>, <a href="https://glukkazan.github.io/mancala/ohvalhu.htm">Ohvalhu</a>)</li>
	<li>Наконец, есть игры, в которых персистентность session-manager-а не может использоваться, по соображениям производительности (как ни странно, в <a href="https://glukkazan.github.io/checkers-like/fanorona.htm">Fanorona</a>, при всей её кажущейся простоте, в самом начале игры, имеется огромное количество возможных дебютов, связанное со спецификой выполнения взятия в этой игре)</li>
</ol>
В общем, у меня есть два механизма, предназначенные, в общем-то, для одного и того же. И это замечательно, потому что я могу выбирать, какой из них применить.
</cut>

Dagaz: Сумма технологий

<img align="left" src="https://habrastorage.org/webt/it/hf/a5/ithfa5igeohyiayejgri7s5tcey.png" /><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, технологии интересуют  меня,  так  сказать,  по  необходимости: потому что всякая цивилизация включает и то, к чему общество стремилось, и то, чего никто не замышлял. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Порой,  и  довольно  часто,  путь  технологии открывал случай: искали же когда-то философский камень,  а  нашли  фарфор.</i>&nbsp;
&nbsp;
Станислав Лем.</i></b>

С самого начала работы над <a href="https://glukkazan.github.io/">проектом</a>, было понятно, что качественный AI мне жизненно необходим! Самому с собой играть скучно, а модуль для игры по сети - он неизвестно когда ещё будет. Я пытался писать ботов сам, но все они работали либо плохо, либо плохо и медленно. В конце концов, я устал заниматься этой самодеятельностью и нашёл шахматного <a href="http://omerkel.github.io/Garbochess-JS/oliver/">бота</a>, качество игры которого меня вполне устраивало. Но тут возникла проблема. Мне-то были нужны не только Шахматы. Тому, как я с этим боролся, и посвящена эта статья.
<cut>
Если вы посмотрите на исходный код <a href="https://github.com/glinscott/Garbochess-JS/blob/master/js/garbochess.js">Garbochess-JS</a> (кстати, на <abbr title="Картинка для привлечения внимания">КДПВ</abbr> фотография <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%B1%D0%BE,_%D0%93%D1%80%D0%B5%D1%82%D0%B0">Греты Гарбо</a>, знаменитой актрисы, в честь которой проект получил своё название), то сможете заметить, что красота исходного кода - это последнее из того, что интересовало его автора. В тексте присутствуют глобальные переменные и прочие милые мелочи, добросовестно портированные из первоначального <a href="https://github.com/glinscott/Garbochess-3/tree/master/GarboChess3">проекта</a>. 

Для меня, самой большой проблемой стало то, что сам алгоритм никак не отделён от исключительно шахматной специфики, такой как оценка позиции, эвристики и прочее. Уже только по этой причине, код пришлось полностью переписывать. Это была большая работа (и она всё ещё продолжается до сих пор), но сегодня уже есть некоторые успехи, которыми я могу поделиться.

<a href="https://glukkazan.github.io/checkmate/platform-chess.htm">
<img align="center" src="https://habrastorage.org/webt/-b/pu/a_/-bpua_octpkv3-rkwy4eebl1azg.png" /></a>
<spoiler title="Немного о производительности">
Этот бот всё ещё слишком требователен к ресурсам. Я работаю над этим, но пока что, он и на компьютерах довольно задумчив, а на телефонах тормозит просто безобразно. Для меня это всё равно большой прогресс, поскольку он играет так, как мог бы играть человек. Все предыдущие мои попытки были весьма далеки от этого.

Качество игры сильно зависит от того, какое количество позиций бот успеет рассмотреть за отведённое время (поэтому, на более быстрых компьютерах он будет играть заметно лучше). Количеством миллисекунд, отведённых на "размышление", можно управлять <a href="https://glukkazan.github.io/checkmate/platform-chess.htm?ai=1000">через url</a>, но здесь есть некоторая гранулярность, особенно заметная на медленных устройствах. Фактическое время поиска хода всегда будет больше заданного. 

Не стоит устанавливать маленькие значения. Бот будет играть глупо. Я предупредил.
</spoiler>
Можно заметить, что хотя эта игра (которую придумал Robert Price в 2001 году) похожа на <a href="https://ru.wikipedia.org/wiki/Шахматы">Шахматы</a>, оригинальный Garbochess с ней вряд ли бы справился. Это хорошая иллюстрация той задачи, что передо мной стояла. Мне следовало отделить <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/ab-ai-v5.js">алгоритм</a> поиска наилучшего хода, от всего <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/chess-ai.js">того</a>, что специфично для конкретных игр. Для того, чтобы можно было использовать его в разных играх, разумеется. Для чего же ещё?

Конечно, начинал я с чего-то куда менее сложного (но уже на этом этапе возникли первые трудности). Пешки здесь двигаются по обычным правилам (но без прыжка первым ходом и <a href="https://ru.wikipedia.org/wiki/Взятие_на_проходе">взятия на проходе</a>). Превращение любой фигуры завершает игру. Отсутствие возможности хода означает поражение.

<a href="https://glukkazan.github.io/breakthrough/pawn-wars-5x5.htm">
<img align="center" src="https://habrastorage.org/webt/un/qg/pi/unqgpi7ygj24c3l50atyultko9e.png" /></a>
Трудности, разумеется, возникли в связи с тем, что Garbochess нацелен исключительно на шахматы. Когда король находится под <a href="https://ru.wikipedia.org/wiki/Мат_(шахматы)">матом</a> или <a href="https://ru.wikipedia.org/wiki/Пат">патом</a>, процесс поиска хода завершается естественным образом. Остаётся только проверить, под <a href="https://ru.wikipedia.org/wiki/Шах_(шахматы)">шахом</a> ли король, для определения результата завершения игры. В "Войне пешек" есть и другое завершение, связанное с превращением одной из фигур. 

Бот, в этих случаях, бодро продолжал перебор вариантов, несмотря на то, что игра уже закончилась. Я довольно легко победил это, запретив дальнейшую генерацию ходов, после достижения цели игры. Другим отличием явилось то, что отсутствие возможности хода, в этой игре - это всегда поражение. В игре просто нет королей, незачем проверять, под шахом ли они. С этим удалось справиться ещё легче. Следующими на очереди были крупные формы.

<a href="https://glukkazan.github.io/checkmate/dunsanys-chess.htm">
<img align="center" src="https://habrastorage.org/webt/b0/ud/oo/b0udoorjf5ejijatjq6y5qkee8w.png" /></a>
<spoiler title="Здесь стоит сделать небольшое теоретическое отступление">
Я хочу рассказать о том, как работает <a href="https://www.chessprogramming.org/Garbochess">Garbochess</a>. Всё основано на минимаксном алгоритме с "<a href="https://ru.wikipedia.org/wiki/Альфа-бета-отсечение">альфа-бета-отсечением</a>". В связи с этим, есть одна проблема - чтобы всё это работало, мы должны заранее знать, до какого уровня глубины будем опускаться. Предсказать это число, при условии ограничения на продолжительность поиска хода, довольно проблематично. 

Либо мы выберем слишком маленькую глубину, неэффективно израсходовав выделенное время, либо опустимся слишком глубоко, потратим много времени и найдём, в результате, скорее всего, далеко не самый лучший ход. Чтобы победить эту проблему, было придумано <a href="https://www.chessprogramming.org/Iterative_Deepening">итеративное углубление</a>. Глубина поиска последовательно инкрементируется, начиная с единички и до тех пор, пока хватает времени.

Это работает, но для того чтобы не повторять одни и те же вычисления (очень дорогостоящие, кстати) снова и снова, необходимо использовать <a href="https://www.chessprogramming.org/Transposition_Table">таблицу транспозиций</a>. А поскольку это подразумевает поиск конкретной позиции в памяти по какому-то компактному ключу, без <a href="https://www.chessprogramming.org/Zobrist_Hashing">Зобрист-хэша</a> тоже не обойтись! Я к тому, что в Garbochess всё взаимосвязано. Убери что-то одно и остальное просто не будет работать!
</spoiler>
В этом месте, начались проблемы с производительностью. Дело в том, что нельзя просто опуститься до какого-то уровня и оценить там позицию! Может получиться так, например, что мы завершим поиск, на взятии ферзём пешки, не обратив внимания на то, что следующим ходом ферзь может быть взят, с далеко не лучшим для нас итогом размена. Перед тем как что-то оценивать, необходимо "проигрывать" до конца все форсированные ходы, к которым относятся любые взятия, а также любые ходы в тех ситуациях, когда король находится под шахом.

В этом и заключалась проблема. Дело в том, что все проверки на выделенное время выполнялись в той части кода, которая про "альфа-бета отсечение", а не в той, что про доигрывание. Есть такие игры, в которых такое доигрывание способно принимать чудовищно разветвлённые формы. Там выполнение программы и умирало. При этом нельзя было просто добавить проверку на время в "доигрывание", потому что в результате, там бы всё и закончилось, возможно не дойдя до действительно хороших ходов. Пришлось это дело как-то ограничивать (с потерей качества игры, само собой).

<spoiler title="Другая причина зависаний крылась в том, что моя модель оказалась очень медленной">
Раз в десять, примерно, медленнее модели шахматной игры, используемой Garbochess. Само собой, за универсальность надо платить, но не такой же ценой! Когда я начинал работу над проектом, я довольно плохо знал JavaScript и принял не очень удачное решение, использовать стековую машину, для генерации разрешённых правилами ходов.

<spoiler title="То есть, описание Шахмат выглядит как-то так">
<source lang="javascript">
Dagaz.Model.BuildDesign = function(design) {
    design.addDirection("w");  // 0
    design.addDirection("e");  // 1
    design.addDirection("s");  // 2
    design.addDirection("ne"); // 3
    design.addDirection("n");  // 4
    design.addDirection("se"); // 5
    design.addDirection("sw"); // 6
    design.addDirection("nw"); // 7

    design.addPlayer("White", [1, 0, 4, 6, 2, 7, 3, 5]);
    design.addPlayer("Black", [0, 1, 4, 5, 2, 3, 7, 6]);

    design.addPosition("a8", [0, 1, 8, 0, 0, 9, 0, 0]);
    ...
    design.addPosition("h1", [-1, 0, 0, 0, -8, 0, 0, -9]);
    ...
    design.addCommand(0, ZRF.FUNCTION,	24);	// from
    design.addCommand(0, ZRF.PARAM,	0);	// $1
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.IN_ZONE,	0);	// last-rank
    design.addCommand(0, ZRF.FUNCTION,	0);	// not
    design.addCommand(0, ZRF.IF,	4);
    design.addCommand(0, ZRF.PROMOTE,	4);	// Queen
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.JUMP,	2);
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.FUNCTION,	28);	// end

    design.addCommand(1, ZRF.FUNCTION,	24);	// from
    design.addCommand(1, ZRF.PARAM,	0);	// $1
    design.addCommand(1, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(1, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.IN_ZONE,	1);	// third-rank
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.PARAM,	1);	// $2
    design.addCommand(1, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(1, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.FUNCTION,	28);	// end
    ...
    design.addPiece("Pawn", 0, 800);
    design.addMove(0, 0, [4], 1);
    design.addMove(0, 1, [4, 4], 1);
    design.addMove(0, 2, [7], 1);
    design.addMove(0, 2, [3], 1);
    design.addMove(0, 3, [1, 4, 4], 1);
    design.addMove(0, 3, [0, 4, 4], 1);
    ...
    design.setup("White", "Pawn", 48);
    ...
    design.setup("Black", "King", 4);
}
</source></spoiler>
<spoiler title="А должно бы выглядеть следующим образом">
<source lang="javascript">
var step = function(ctx, params) {
    if (ctx.go(params, 0) && !ctx.isFriend()) {
        ctx.end();
    }
}

var pawnShift = function(ctx, params) {
    if (ctx.go(params, 0) && ctx.isEmpty()) {
        if (ctx.inZone(0)) {
            ctx.promote(4);
        }    
        ctx.end();
    }
}

var pawnLeap = function(ctx, params) {
    if (ctx.go(params, 0) && ctx.isEnemy()) {
        if (ctx.inZone(0)) {
            ctx.promote(4);
        }    
        ctx.end();
    }
}

var pawnJump = function(ctx, params) {
    if (ctx.go(params, 0) && 
        ctx.isEmpty() && 
        ctx.inZone(1) && 
        ctx.go(params, 0) && 
        ctx.isEmpty()) {
        ctx.end();
    }
}

var enPassant = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEnemy() &&
        ctx.isPiece(0)) {
        ctx.capture();
        if (ctx.go(params, 1)) {
            ctx.put();
            if (ctx.go(params, 1) &&
                ctx.isLastFrom()) {
                ctx.end();
            }
        }
    }
}

var jump = function(ctx, params) {
    if (ctx.go(params, 0) && 
        ctx.go(params, 1) && 
       !ctx.isFriend()) {
        ctx.end();
    }
}

var slide = function(ctx, params) {
    while (ctx.go(params, 0)) {
        if (ctx.isFriend()) break;
        ctx.end();
        if (!ctx.isEmpty()) break;
    }
}

var O_O = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEmpty() &&
        ctx.go(params, 0) &&
        ctx.isEmpty()) {
        ctx.put();
        if (ctx.go(params, 0) &&
            ctx.isFriend() &&
            ctx.isPiece(1)) {
            ctx.take();
            if (ctx.go(params, 1) &&
                ctx.go(params, 1)) {
                ctx.end();
            }
        }
    }
}

var O_O_O = function(ctx, params) {
    if (ctx.go(params, 0) &&
        ctx.isEmpty() &&
        ctx.go(params, 0) &&
        ctx.isEmpty()) {
        ctx.put();
        if (ctx.go(params, 0) &&
            ctx.isEmpty() &&
            ctx.go(params, 0) &&
            ctx.isFriend() &&
            ctx.isPiece(1)) {
            ctx.take();
            if (ctx.go(params, 1) &&
                ctx.go(params, 1) &&
                ctx.go(params, 1)) {
                ctx.end();
            }
        }
    }
}

games.model.BuildDesign = function(design) {
    design.addDirection("w");  // 0
    design.addDirection("e");  // 1
    design.addDirection("s");  // 2
    design.addDirection("ne"); // 3
    design.addDirection("n");  // 4
    design.addDirection("se"); // 5
    design.addDirection("sw"); // 6
    design.addDirection("nw"); // 7

    design.addPlayer("White", [1, 0, 4, 6, 2, 7, 3, 5]);
    design.addPlayer("Black", [0, 1, 4, 5, 2, 3, 7, 6]);

    design.addPosition("a8", [0, 1, 8, 0, 0, 9, 0, 0]);
    ...
    design.addPosition("h1", [-1, 0, 0, 0, -8, 0, 0, -9]);
    ...
    design.addPiece("Pawn", 0, 2);
    design.addMove(0, pawnShift, [4], 0);
    design.addMove(0, pawnJump, [4], 0);
    design.addMove(0, pawnLeap, [7], 0);
    design.addMove(0, pawnLeap, [3], 0);
    design.addMove(0, enPassant, [1, 4], 0);
    design.addMove(0, enPassant, [0, 4], 0);
    ...
    design.setup("White", "Pawn", ["a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2"]);
    design.setup("White", "Rook", ["a1", "h1"]);
    design.setup("White", "Knight", ["b1", "g1"]);
    design.setup("White", "Bishop", ["c1", "f1"]);
    design.setup("White", "Queen", ["d1"]);
    design.setup("White", "King", ["e1"]);
    design.setup("Black", "Pawn", ["a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7"]);
    design.setup("Black", "Rook", ["a8", "h8"]);
    design.setup("Black", "Knight", ["b8", "g8"]);
    design.setup("Black", "Bishop", ["c8", "f8"]);
    design.setup("Black", "Queen", ["d8"]);
    design.setup("Black", "King", ["e8"]);
}
</source></spoiler>
Кстати, и для человека это удобнее! К сожалению, чтобы реализовать такую красоту, мне придётся всё переписывать. Так что, это дело следующей версии, но должно стать заметно быстрее. Генерация списка ходов, сейчас, это самое узкое место. Очень дорогая операция!

Одним из следствий такой разницы в производительностях оказалось то, что проверка на завершение отведённого времени выполнялась слишком редко. Один раз за 128 итераций. За это время, на телефоне, алгоритм успевал задумываться примерно на минуту. На десктопе дело обстояло лучше, но тоже не слишком радужно. В общем, пришлось сделать эти проверки более частыми (конечно, это не спасает от того, что на телефонах бот будет играть очень тупо).
</spoiler>
Стоит отметить, что далеко не всегда вопрос производительности стоит остро. Есть игры, играть в которые людям объективно сложно. Использование в таких играх алгоритмов не упускающих ни единой возможности приводит к совершенно убойным результатам:

<a href="https://glukkazan.github.io/mancala/mini-mancala.htm">
<img align="center" src="https://habrastorage.org/webt/3c/pr/fd/3cprfdtb6poyqttqgk9biipojxe.png" /></a>
Берём все шарики в одной из двух лунок на своей стороне и сеем по одному в следующие лунки, против часовой стрелки. У кого первого кончились все шарики - тот и проиграл. Ирония заключается в том, что если первый игрок всё делает правильно - он (в большинстве случаев) выигрывает. В вычислительном плане, это очень простая игра, но человеку играть в неё сложно. Можно привести и менее экстремальные примеры:

<a href="https://glukkazan.github.io/xiangqi/mini-xiangqi.htm">
<img align="center" src="https://habrastorage.org/webt/cu/wr/xo/cuwrxolrdcdbvvqgcwsns_lbffe.png" /></a>
А вот <a href="https://glukkazan.github.io/xiangqi/dark-mini-xiangqi.htm">так</a> ещё интереснее! Впрочем, в этой игре, человек уже довольно легко побеждает. Если знает <a href="https://ru.wikipedia.org/wiki/Сянци">правила</a> и не зевает, конечно. Вообще, в шахматном мире, довольно много различных мини-игр. И с ними текущая реализация бота уже вполне справляется.

<spoiler title="У нового бота есть и недостатки, конечно">
Например, я пока не придумал, как его рандомизировать. В одной и той же позиции (при одинаковых настройках) бот будет всегда делать один и тот же ход. Это плохо, конечно. Я немного экспериментировал с этим, но пока любые попытки рандомизации ухудшают качество игры. Наиболее перспективной выглядит предварительная случайная сортировка списка ходов на первом уровне. Но пока здесь рано говорить о каких-то успехах.

Кстати, порядок просмотра узлов очень важен! Альфа-бета-отсечение работает гораздо лучше, если просматривать ходы в порядке от лучших к худшим. Сложность заключается в том, что по самому ходу бывает трудно судить о том, насколько он хорош. Разумеется, на эту тему была придумана куча эвристик. 

Прежде всего, начинать следует с лучшего хода предыдущей итерации. Далее, имеет смысл рассматривать ходы, берущие только что походившую фигуру (желательно, наименее ценными фигурами). Затем следуют взятия, но не все, а только с выгодным разменом (как его определить - это тоже та ещё задача). В отношении "тихих" ходов очень помогает "<a href="https://www.chessprogramming.org/Killer_Heuristic">эвристика убийцы</a>" (здесь пришлось научиться использовать Зобрист для хэширования ходов, а не только позиций). Потом всё остальное, завершая невыгодными разменами.
</spoiler>
Но, в целом, я вполне доволен полученными (промежуточными) результатами. Здесь есть ещё над чем поработать. Пока, я подключил далеко не все оптимизации Garbochess. Да и вопрос <a href="https://www.chessprogramming.org/Evaluation">оценки позиции</a> - это тема для отдельного большого разговора. Всё это - плоды продолжительного коллективного труда многих и многих умных людей. Я очень благодарен всем им за эту работу. Сам бы я до многого из всего этого не додумался.

Dagaz: A new Beginning

<img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png" /><b><i>It runs south and circles north, circling, circling to run with its wind
And according to its circuits the wind returns;
All the rivers run into the sea — and the sea does not overflow,
To the place where the rivers run, — There they continue to run;

<a href="https://www.biblegateway.com/passage/?search=Ecclesiastes+1">The book of Ecclesiastes</a></i></b>

In 1998, a completely unique, for its time, application was developed that allows you to reduce the process of developing an abstract board game (or puzzle) to a small text description language, vaguely reminiscent of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>.  This project was called <a href="http://www.zillions-of-games.com/">Zillions of Games</a>.  It created a furor among fans of board games.  Currently, over 2,000 applications have been created using this technology.
<cut>
It quickly became clear that ZoG has many drawbacks.  I already <a href="https://habr.com/ru/post/221779/">wrote</a> about this in Habr and I will not repeat myself.  Let me just say that the developers did not take into account the features of a huge number of existing games and some important options were hard-coded, so that their change became extremely problematic.  Greg Schmidt, in 2007, tried to rectify the situation by releasing the <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a>, but its tight integration with ZoG does not permit solving all the problems.

Project <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf">Ludi</a> pointed out new frontiers, using the universal game “engine” and <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithms</a> to automate the process of development of new board games.  Unfortunately, this approach was initially envisaged as a deliberate simplification of the game mechanics and of the level of the AI employed.  Discussion of the goals of this project is beyond the scope of this article, but some of its technical solutions, no doubt, served as the starting point for my own development.

My goal is the development of a more versatile and user-friendly “engine” for the creation of abstract board games.  For almost a year I have been studying the possibility of ZoG and Axiom and learned a great deal about their limitations.  I think I can solve their problems by creating a more universal and cross-platform solution.  On the progress of work on this project I shall report.

<h2>Openness and modularity</h2>
Perhaps the main drawback of ZoG is its closure.  The product was assembled “once and forever” under one single platform — Windows.  Were it open-source code, one could try to port it under Linux, Android, iOS …  Another problem is its monolithicness.

In ZoG there are the beginnings of modularity, allowing for connection to the games DLL, including custom implementations of the AI.  Axiom goes a little further, allowing you to run applications in the mode autoplay, without using the ZoG kernel.  Notwithstanding the serious limitation of this solution (supporting applications only for two players), this example demonstrates how modularity would be helpful!  The opportunity to organize a game with two bots (using different AI settings) and to collect statistics on a large number of games can not be overestimated.  But how much better it would be if the product has been fully modular!

<ul>
	<li>Move generation module</li>
	<li>Move execution module</li>
	<li>Control module</li>
	<li>AI module</li>
	<li>Visualization module</li>
</ul>
All work describing the games is to be performed by the move generation module.  This is the “heart” of the project.  Transfer of all tasks not connected with this function to other modules will make it as simple as possible.  You can improve this module, without looking at AI issues and user interaction.  You can completely change the format of the description of games or add support for the descriptions in the format of ZoG, Axiom and Ludi.  Modularity is the basis of flexibility of the solution!

The move execution module is the custodian of the game state.  Information on the current game state is transferred to all other modules on demand.  For reasons which I will give below, execution progress must pass through the generation module, whose task is the formation of a command in terms of module execution.  Also, the task of the move generation module is the primary configuration of the game space, based on the description of the game.

The control module is, in fact, the application itself.  It asks the move generation module for a list of possible moves and changes the game state, passing the selected move to the move execution module.  The control module can be connected to play one or more AI bots.  As many as you need (and possibly different)!  The type of control unit is determined by the division of tasks.  This may be autoplay to collect game statistics, game server (it can control several state stores, leading a large number of gaming sessions) or individual applications for playing offline.

The ability to connect different implementations of AI will improve the quality of the game.  It is understood that the modules for the game of chess and Go should use different approaches.  Games with incomplete information and games using random data also require an individual approach.  Universal implementation of AI will be equally bad play all the games!  Modular connection AI will allow to compare the “strength” of the algorithms, including a game mode “to each other.”  Since the AI architecture is separated from the storage state of the game, one instance of the gaming bot can support an unlimited number of gaming sessions simultaneously.

Visualization of game process may also be varied.  The first thing that comes to mind are 2D and 3D implementations.  The platform for which the application is being developed, is also important.  Less obvious is that visualization may be an important part of the game!  For example, in the game <a href="https://glukkazan.github.io/elimination/surakarta.htm">Surakarta</a>, taking pieces will be completely non-obvious in the absence of proper animation of moves.

<a href="https://glukkazan.github.io/elimination/surakarta.htm">
<img align="center" src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"/></a>
In general, modularity seems a good idea for such a project, and open source code will enable everyone who wishes to participate in the project.  At the present time, I do not set myself commercial purposes, but I think that, if desired, I will find a way to make money without closing the source code.

<h2>The game space</h2>
Before starting the show, you need to set the stage.  The board is not just a place where the pieces are arrayed.  Beside that, the direction of movement of the pieces can be determined (in fact, the connections between the board positions) play areas (e.g., areas for conversion of pieces) forbidden fields, etc.  Here is how the definition of the chess board looks in the ZoG-realization:

<spoiler title="Defining the board in ZoG">
<source lang="lisp">
(define Board-Definitions
  (image "images\Chess\SHaag\Chess8x8.bmp" "images\Chess\Chess8x8.bmp")
  (grid
     (start-rectangle 5 5 53 53)
     (dimensions
         ("a/b/c/d/e/f/g/h" (49 0)) ; files
         ("8/7/6/5/4/3/2/1" (0 49)) ; ranks
     )
     (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0)
                 (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1)
     )
  )
  (symmetry Black (n s)(s n) (nw sw)(sw nw) (ne se)(se ne))
  (zone
     (name promotion-zone)
     (players White)
     (positions a8 b8 c8 d8 e8 f8 g8 h8)
  )
  (zone
     (name promotion-zone)
     (players Black)
     (positions a1 b1 c1 d1 e1 f1 g1 h1)
  )
  (zone
     (name third-rank)
     (players White)
     (positions a3 b3 c3 d3 e3 f3 g3 h3)
  )
  (zone
     (name third-rank)
     (players Black)
     (positions a6 b6 c6 d6 e6 f6 g6 h6)
  )
)</source></spoiler>
You may notice that besides the game settings, here are the settings associated with the visualization.  I am firmly convinced that these settings do not belong here.  In implementing a visualization module, multiple settings can be used and different settings may be required.  Moreover, simulation games can work without any visualization module at all (like autoplay in Axiom).  Indeed, since Axiom is used to visualize ZoG, the definition does not contain anything superfluous:

<spoiler title="Defining the board in Axiom">
<source lang="perl">

{board
    8 8 {grid}
board}

{directions
    -1  0  {direction} n
     1  0  {direction} s
     0  1  {direction} e
     0 -1  {direction} w
    -1 -1  {direction} nw
     1 -1  {direction} sw
    -1  1  {direction} ne
     1  1  {direction} se
directions}

{symmetries
    Black {symmetry} n s
    Black {symmetry} nw sw
    Black {symmetry} ne se
symmetries}
</source></spoiler>
Unfortunately, Axiom also does not have a way to determe game zones (the location of game zones must be determined manually in the code).  This is not Axiom's only simplification.  Definition of the board in this project can not contain more than one grid and this grid must be two-dimensional.  The board, thus defined, is a one-dimensional array, but for the convenience of the programmer, synonyms are defined for each of the spaces as follows:

<img align="center" src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"/>
Compared with the more flexible scheme of grid definition in ZoG, these restrictions are quite uncomfortable (especially given the fact that the imposed naming scheme used these fields for the very purpose of visualization).  Fortunately, it is possible to define a board of arbitrary shape.  Both Axiom and ZoG provide an opportunity to identify element-wise each position on the board along with the ability to determine the links between arbitrary pairs of positions.  Using this approach, we can define a board of any topology.  Its only drawback is the extreme verbosity and complexity of the description.

In addition to the location of the pieces on the board and in the reserve, the system should have the ability to store attributes for individual pieces and for the spaces on the board.  A good example of the need to use the attributes of a rule of “<a href="https://en.wikipedia.org/wiki/Castling">castling</a>” in <a href="https://en.wikipedia.org/wiki/Chess">chess</a>.  This is a difficult move, which includes simultaneous movement of the king and a rook, allowed, provided that neither of these pieces have moved before performing this move.  An attribute could be used to store a Boolean tag showing whether the piece has ever moved.  Field attributes can also find some interesting applications.

It should be noted that attributes are not just variables but part of the game state.  An attribute value may be changed by the execution of a turn (including by the AI module) and should be available for all subsequent turns, but not for turns performed in another branch of the game.  Currently, ZoG supports storing boolean attributes of pieces.  Axiom storage attributes are not supported, but you can add to the definition of the board a description of variables and arrays.  These variables can be used, such as counters of the quantity of captured pieces:

<source lang="perl">
{board
    5 18 {grid}
    {variable} WhitePieces
    {variable} BlackPieces
board}</source>
Yet another limitation of ZoG and of Axiom is the rule that each position of the board can contain no more than one piece.  If any piece completes a move to a position occupied by another piece, the piece previously occupying the position is automatically considered to be “eaten”.  This rule goes well with the “chess” principle of taking pieces and serves to simplify description of this game, but complicates the implementation of games such as “<a href="http://www.iggamecenter.com/info/en/bashni.html">bashni checkers</a>” and “<a href="http://www.iggamecenter.com/info/en/tavreli.html">tavreli</a>”.

<img align="center" src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"/>

In these games, pieces can be arranged in “columns”.  Such a “column” can be moved all together, as a single piece.  After some reflection, I decided that it was better not to abandon the automatic implementation of the “Chess” capture, but to improve mechanisms for moving groups of pieces.  Indeed, for the implementation of the “pillars”, you can always add to board another dimension (this is especially easy, as long as the visualization module is separated from the move generating module and from the AI, then you can use any logic whatsoever for rendering the three-dimensional board into its two-dimensional visualization).  An additional argument in favor of this decision was that “high-stacked” movement of pieces is not the only type of group travel.  For example, in “<a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf">Pentago</a>” board fragments can be rotated together with the pieces mounted thereon.

<img align="center" src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"/>
Summarizing, I can say that, for my game framework, I decided to take all the best that has been thought up in ZoG, Axiom, and Ludi, and add whatever, in my opinion, they lack.

<h2>Move generation</h2>
Move generation is akin to <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming">non-deterministic programming</a>.  The task of the move generator is providing, upon request, a list of all possible moves from the current position.  Which move from this list will be selected by a player or AI is not its function.  Let's see how the generation of moves is done in ZoG.  As an example, we take the move generation macro for a long-range piece (a queen or bishop).  This is how it is used in determining moves for these pieces:

<source lang="lisp">
(piece
      (name Bishop)
      (image White "images\Chess\SHaag\wbishop.bmp" "images\Chess\wbishop.bmp"
             Black "images\Chess\SHaag\bbishop.bmp" "images\Chess\bbishop.bmp")
      (moves
         (slide ne)
         (slide nw)
         (slide se)
         (slide sw)
      )
)</source>
As a parameter, a macro is passed the direction of movement on the board.  If you do not consider the possibility of installing new pieces on the board, the generation of a move looks simple.  For each of the pieces on the board, all possible moves according to the rules are calculated.  Then the magic begins…

Each of the definitions can add to the list a number of possible moves!  Adding a move to the list is done with the command add (at the same time positioning each moving piece on the board).  I already <a href="https://habr.com/ru/post/221779/">wrote</a> about how this architectural solution is extremely poor.  The command for the formation of the move should be separated from the commands that manipulate pieces (as was done in Axiom).  Let's see how the macro works:

<source lang="lisp">
(define slide
 (  $1
    (while empty?
        add
        $1
    )
    (verify not-friend?)
    add
))</source>

First, the displacement is performed by one cell, in the given direction, then in a cycle the space reached is checked for the absence of the pieces on it, a move is formed, and the arrangement proceeds to another cell in the same direction.  If you stop here, the piece can “slide” through empty cells, but how can you take enemy pieces?

Very simple!  Having run the command verify, the verication that the field is not occupied by a friendly piece, we form another add command, completing the move.  If on this cell was located an enemy piece, it will be taken automatically (as on one space of the board, at one time, you cannot have more than one piece).  If the piece was friendly, the calculation of the move will abort with the command verify (violation of the conditions specified in this command immediately terminates the calculation of the current move).

n both ZoG and Axiom one can move only one's own pieces (or rather, moving the opponent's pieces is possible, but only if specified in the mode of calculation of a move of one of one's own pieces).  I find this an extremely inconvenient restriction, because there are many games in which you can directly move the opponent's piece (in “<a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm">Stavropol Checkers</a>”, for example).  It would be more consistent to perform the move calculation for all pieces, regardless of their affiliation.  In the macro that determines the move, one would need only to add one check to allow moving only one's own pieces:

<source lang="lisp">
(define slide
 (  (verify friend?)
    $1
    (while empty?
        add
        $1
    )
    (verify not-friend?)
    add
))</source>

Important is the ability to perform a move consisting of several “partial” moves.  In implementations of drafts, this ability is used to perform “chain” captures:

<source lang="lisp">
(define checker-jump
    ($1 (verify enemy?)
        capture
        $1
        (verify empty?)
        (if (not-in-zone? promotion-zone)
            (add-partial jumptype)
         else
            (add-partial King jumptype)
        )
    )
)</source>

The partial move command is formed with add-partial (for this command, as well as for the command add, there is a variation of the move, with “transformation” of the pieces).  Such a move is always part of a larger, “composite” move.  As a rule, for subsequent moves, a “mode” is set, which the continuation should implement.  So in checkers, a capture can continue only with following captures but not with a “soft” (non-capturing) move.

<spoiler title="Note">
In ZoG, implementation of partial moves is poor.  Trying to execute the add-partial command in a cycle causes an error.  As a result, the capture performed by a checker king can be realized only in the following very awkward manner:

<source lang="lisp">
(define king-jump-1
    ($1 (while empty?
            $1
        )
        (verify enemy?)
        capture
        $1
        (verify empty?)
        (add-partial jumptype)
    )
)

(define king-jump-2
    ($1 (while empty?
            $1
        )
        (verify enemy?)
        capture
        $1
        (verify empty?)
        $1
        (verify empty?)
        (add-partial jumptype)
    )
)</source>
And so on, until king-jump-7!  Let me remind you that in most varieties of checkers with a “long-range” king, the king, after each capture, can stop on any space of a continuous chain of empty spaces following the captured piece.  There is, incidentally, one variant of this game in which the “chain” capture rule is formulated differently.  That is just what I like about checkers - everyone can find a variant to one's liking.
</spoiler>
Such a system of description of the rules is very flexible, but sometimes more complex logic is required.  For example, if the piecee, during “partial” progress should not re-pass through a previously traversed field, it is logical to use the flags associated with positions on the board.  Having visited a space, we set a flag, so subsequently not to go to this space again:

<source lang="lisp">
(verify (not-position-flag? my-flag))
(set-position-flag my-flag true)</source>
In addition to “positional” flags, in ZoG you can use global flags.  These capabilities should not be confused with the attributes of pieces.  Unlike the latter, these are not part of the game state.  Unfortunately, both attributes of pieces and flags in ZoG can only be boolean (in Axiom attributes are not even supported).  This limitation makes it difficult to perform operations associated with the various types of counting.  For example, in <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2233">this</a> little puzzle, I had to use for “counting” pieces, caught in a “fork”, a pair of boolean flags (the exact number I did not need, as long as the pieces were more than one).

Another thing to fix is the lack of a clear “life cycle” in the execution of the move.  All flags are automatically reset before starting the move, but it would be easier to identify clearly the initialization phase.  In my opinion, in the calculation of the move, there should occur the following phases:

<ol>
	<li>Initialization of variables and checking preconditions for the composite move</li>
	<li>Initialization of variables and checking preconditions for the partial move</li>
	<li>Generation of the partial move</li>
	<li>Checking postconditions of the partial move</li>
	<li>Generating, completing, and checking postconditions of the composite move</li>
	<li>Checking for the termination conditions of the game</li>
</ol>
The group of steps from the second to the fourth, in the full composite move, may be repeated many times.  The idea of pre- and post-conditions, which I call invariants, I took from the project Ludi.  I tell you more about the use of invariants later.

<h2>On the importance of notation</h2>
Generation of all possible moves from the position is only half of the story.  To control the game state requires a compact presentation of the generated moves.  In ZoG, for this purpose, ZSG-notation is used.  Here is an account of a possible beginning of a chess game in this form:

<source lang="perl">
1.  Pawn e2 - e4
1.  Pawn e7 - e5
2.  Knight g1 - f3
2.  Knight b8 - c6
3.  Bishop f1 - c4
3.  Knight g8 - f6
4.  King e1 - g1 Rook h1 - f1 @ f1 0 0 @ g1 0 0
4.  Pawn d7 - d5
5.  Pawn e4 x d5
5.  Knight f6 x d5</source>
This script is close to the usual <a href="https://en.wikipedia.org/wiki/Chess_notation">chess notation</a> and generally user friendly.  Only white's fourth move may cause some confusion.  So in ZSG it looks like <a href="https://en.wikipedia.org/wiki/Castling">castling</a>.  The part of the description of the move before the '@' character is quite clear; it is the simultaneous movement of the rook and the king, but what follows?  Thus, in ZSG, it looks like a reset of attributes of the pieces is required in order to prevent the possibility of repeated castling.

<spoiler title="Note">
ZoG uses its ZSG-notation particularly in order to show the course of the game in a form understandable to the player.  On the right of the board, a «Moves List» sub-window may be open.  This list can be used to navigate through the recorded game.  This list is not very convenient, because a branching tree view of alternative games is not supported.  The part of the recorded turns associated with changes in attributes of pieces, is not displayed to the user.
</spoiler>
The recording of a move in ZSG-notation should contain full information sufficient to correctly change the game state.  If information about a change of attributes is lost, in a game according to such a record, a move could be incorrectly repeated (for example, the player would have the opportunity to re-execute the castling).  Unfortunately, in DLL-extensions (such as Axiom), extended information can not be transmitted.

Working with DLL-extensions, ZoG is forced to make a quite cunning manipulation when positioning to a selected move (for example, when you roll back a move).  From [each] previous position [working from the beginning of the game], all possible moves are generated, and then, within that list, one must search for a move with the [corresponding] ZSG representation.  The [side effects of each] generated move is are applied to [each successive] game state, as it is possible to perform side-effects not reflected in the move's ZSG-representation.

The situation is aggravated by the fact that the only way to get to the game state at the time of a move in the past, is the consistent application of all the moves from the beginning of the game, to the initial state of the board.  In really <a href="https://habr.com/ru/post/234587/">complex cases</a>, this kind of navigation does not occur quickly.  Another disadvantage of ZSG-notation can be illustrated by the recording of the following move in the game of <a href="https://en.wikipedia.org/wiki/Go_(game)">Go</a>:

<source lang="perl">
1.  White Stone G19 x A19 x B19 x C19 x D19 x E19 x F19</source>
Here, in the position G19, a white stone is placed that captures a group of black stones.  Since all the pieces involved in the performance of the placement must be mentioned in the ZSG-performance, the record of the turn may seem very long (in Go, one drop may capture up to 360 stones).  To what this may lead, I wrote <a href="https://habr.com/ru/post/235483/">earlier</a>.  The buffer size allocated for recording the ZoG move, may not be enough.  Moreover, if for some reason the order of removal of stones changes (in the process of development of the game it happens), an attempt to apply a move, from an old order of captures, will fail.

Fortunately, there is a simple way to deal with all these problems.  Let's look at how to define moves of pieces in ZRF:

<source lang="lisp">
(piece
     (name Pawn)
     (image White "images\Chess\SHaag\wpawn.bmp" "images\Chess\wpawn.bmp"
            Black "images\Chess\SHaag\bpawn.bmp" "images\Chess\bpawn.bmp")
     (moves
        (Pawn-capture nw)
        (Pawn-capture ne)
        (Pawn-move)
        (En-Passant e)
        (En-Passant w)
     )
)</source>
Names of moves, defined in ZoG macros, are inaccessible as a generator of moves.  But what prevents us from giving up on macros and making descriptions of the moves with their names?  Here's how the record would look for a chess game:

<source lang="perl">
1.  e2 - e4  Pawn-move
1.  e7 - e5  Pawn-move
2.  g1 - f3  leap2 n nw
2.  b8 - c6  leap2 n ne
3.  f1 - c4  slide nw
3.  g8 - f6  leap2 n nw
4.  e1 - g1  O-O
4.  d7 - d5  Pawn-move
5.  e4 x d5  Pawn-capture nw
5.  f6 x d5  leap2 w nw
</source>
<spoiler title="Note">
Astute readers may notice that in the moves for “black” I used directions not appropriate to the actual directions on the chessboard.  This is connected with the fact that “symmetries” are defined for black:

<source lang="lisp">
(symmetry Black (n s)(s n) (nw sw)(sw nw) (ne se)(se ne))</source>
Roughly speaking, then, what for white is “north”, for black is “south”, and vice versa.
</spoiler>
The benefits of such a record is not obvious, but it has one important advantage.  All moves are described in a uniform manner and these descriptions do not contain anything extra (the names of descriptions of moves, of course, could be made more “descriptive”).  In the description of castling one managed to get rid of both the changes of attributes and of the description of the rook move (this description is no longer dependent on the implementation details of the move).  An even clearer usefulness of such records exists in the case of the game of Go:

<source lang="perl">
1.  G19  drop-to-empty  White Stone</source>
And that's it!  If the opponent's stones are taken in accordance with the rules of the game, there is no need to list them all in the move description.  It is sufficient to indicate the initial and final space of displacement (possibly with a sign to take), the name of the executing move and the line of parameters passed to it.  Of course, in order to perform a move according to this description, for decoding, it is necessary to access the move generation module, but ZoG does so!

Another possibility, which one should support, appears in the functionality of “partial” moves.  Here is an example from “<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Russian checkers</a>”:

<source lang="perl">
1.             Checker g3 - f4
1.             Checker f6 - g5
2.             Checker e3 - d4
2.  partial 2  Checker g5 - e3 = XChecker on f4
2.             Checker e3 - c5 = XChecker on d4 x d4 x f4
</source>
Here the blacks, on their second move, take two pieces on d4 and f4.  A preliminary “transformation” of these pieces to XChecker is a feature of this implementation and serves to prevent the re-taking of “defeated” pieces on the same move.  The phrase “partial 2” describes the beginning of “composite” course, which consists of two “partial” moves.  This form of description is inconvenient, because at the time of generation of the first move, the length of the sequence of “partial” moves may not be known.  Here's how this description will look in a new format:

<source lang="perl">
1.     g3 - f4  checker-shift nw
1.     f6 - g5  checker-shift ne
2.     e3 - d4  checker-shift nw
2.  +  g5 - e3  checker-jump  nw
2.  +  e3 - c5  checker-jump  sw
2.  +
</source>
Implementation details related to the “transformation” of pieces are irrelevant.  The capture of pieces is also not specified, as in checkers, capture occurs as a “side effect” of the piece's move and not according to the “principle of chess.”  Partial progress will be encoded with the symbol “+” at the beginning of the line.  A lone “+” indicates the completion of a “composite move” (in fact, this is the usual “partial” move, containing a missing move, an empty string).

Thus, using named rules for the implementation of moves, one has managed to create a universal notation, fully satisfying our requirements.  Of course, it has nothing to do with either the standard chess or with any other notation, but it just so happens that the conventional notation for chess, checkers and other games, too, have nothing to do with each other.  The visualization module can always convert the move record into a more familiar form accepted for a particular game.  Conversion can also be into some universal form, like <a href="https://en.wikipedia.org/wiki/Smart_Game_Format">SGF (Smart Game Format)</a>.

<h2>The life cycle of the game</h2>
In addition to information about placing pieces on the board, the sequence of turns is a compnent part of the game state, a variable in the game process.  In the simplest (and most common) case, for storing this information one bit will suffice, but ZoG provides a few more opportunities to implement more complex cases.  Here is how a description of a sequence of moves could look for the game <a href="http://www.iggamecenter.com/info/en/splut.html">Splut!</a>:

<source lang="lisp">
(players South West North East)
(turn-order
    South
    West West
    repeat
    North North North
    East East East
    South South South
    West West West
)</source>
In this game, each player makes three moves at a time, but if you were to give the first player the opportunity to make three moves from the initial position, he would be able to destroy one of the opponent's pieces, which would give him a significant advantage.  For this reason, the first player should make only one move (it gives an opportunity to prepare to attack an opposing player, but not attack him), the second — two moves (this is also not enough to attack an opposing player), after which each player always makes three moves.

<img align="center" src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"/>
The label repeat indicates the beginning of a cyclically repeating sequence of moves.  If it does not appear, the entire description is repeated cyclicly.  ZoG does not allow the use of the label repeat more than once.  Another important feature is the specification of the turn order.  Here's how a description of the sequence of turns for a game in which each player performs two turns (the first move - moving pieces, the second - capturing opponent's pieces) might look:

<source lang="lisp">
(players White Black)
(turn-order
    (White normal-move)
    (White capture-move)
    (Black normal-move)
    (Black capture-move)
)</source>
There is one more capability associated with the description of moving someone else's pieces, but it is very inconvenient to use.  The problem is that such a description has no alternative.  If the description states that the move should be done by an enemy piece, the player must perform this move!  In ZoG it is impossible to describe a choice of moving his own or someone else's piece.  If such an capability is needed in a game (such as in “<a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm">Stavropol Checkers</a>”), it is necessary to make all the pieces neutral (creating for this purpose a player who does not participate in the game) and determine for all players the opportunity to move a neutral piece.  I have said above that it is much easier by default to allow all players the ability to move any pieces (their own as well as their opponent's) adding the necessary checks in the move generation algorithms.

As you can see, the range of options provided by ZoG for description of the sequence of turns is extremely limited.  Axiom also fails to add new features, because it (usually) runs over ZoG.  Ludi, in this respect, is even poorer.  In order to maximize unification of the rules of the game (required for the possibility of using generic algorithms), in this project, all descriptive capabilities have been deliberately simplified, which has brought about an elimination of whole layers of games.

<img align="center" src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"/>
"<a href="https://en.wikipedia.org/wiki/Bao_(game)">Bao Swahili</a>” is a good example of a game with a complex life cycle.  In this game, the are two phases with rules for move execution which differ significantly.  At the beginning of the game, part of the stones is “in the hand” of each player.  While there are still stones “in hand”, stones are put into wells, one stone at a time.  When the stones “in hand” run out, the second phase of the game begins, with the distribution of inserted stones.  One cannot say that this game can not be described in ZRF (the description language of ZoG), but because of the limitations of ZoG, this implementation would be extremely confusing (which certainly is not best for the quality of AI work).  Let's see how the description of such a game would look in an “ideal world”:

<source lang="lisp">
(players South North)
(turn-order
    (turn-order
        (South p-i-move)
        (North p-i-move)
    )
    (label phase-ii)
    (turn-order
        (South p-ii-move)
        (North p-ii-move)
    )
)</source>
Here, each turn-order list determines its repeating sequence of moves (distinguishing itself by mode of move execution).  The keyword label defines a label to which a transition can be made during the generation of the latest move.  You may notice that here we proceed from the implicit assumption that such a transition always occurs after the move of the second player (otherwise it would violate the sequence of moves).  How to make the transition to the next phase at an arbitrary time?

<source lang="lisp">
(players South North)
(turn-order
    (turn-order
        (South p-i-move)
        (North p-i-move)
    )
    (turn-order
        (labels - phase-ii)
        (South p-ii-move)
        (labels phase-ii -)
        (North p-ii-move)
    )
)</source>
Here, labels are carried in the loop body and comprise two names.  Label names in the labels lists appear in the order of transfer of players in the list of players.  The name used for the transition is determined by which player made the last move.  If this was the North, it will transition to the first label, otherwise, to the second.  If any of the names in the labels will not be used, the corresponding position can be filled by a dash.

<img align="center" src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"/>
An important aspect in the management of alternating moves, is the ability to perform a repeated turn.  In games of the <a href="https://en.wikipedia.org/wiki/Tables_(board_game)">Tables family</a>, such as <a href="https://en.wikipedia.org/wiki/Tables_(board_game)#History">Nard</a>, <a href="https://glukkazan.github.io/races/backgammon.htm">Backgammon</a>, or <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2262">Ur</a>, for example, the ability to perform repeated turns is an important element of game tactics.  In ZoG one can use passing a turn to emulate this feature, but this approach significantly complicates the description of the game (especially with more players).  It would be much more logical to use a label for repeating a turn:

<source lang="lisp">
(players South North)
(turn-order
    (label repeat)
    South
    (label repeat)
    North
)</source>
The game having jumped to the label repeat, the player will again play his turn (the label closest to the current position in the list of turns will take effect).  I like the approach of <a href="https://en.wikipedia.org/wiki/Perl">Perl</a> in its implicit definitions.  Implicit generation of control structures can significantly simplify game description.  Inasmuch as repeated moves can be used in many games, the labels repeat, anticipating possible repetion of any turn can be implicit:

<source lang="lisp">

(players South North)
(turn-order
    South
    North
)</source>
Moreover, since the sequence of turns is fully consistent with the written order of players in the players construct, you can automatically generate the entire turn-order phrase:

<source lang="lisp">
(players South North)</source>
The easier the description is to write, the better.

<h2>Breakable invariant</h2>
The main thing that I do not like in ZoG can be expressed with one word - checkmated.  At first glance, it's just a condition (very common in games of the <a href="https://en.wikipedia.org/wiki/Checkmate">chess family</a>) linking the end of the game with the formation a mate situation.  Alas, on closer examination, the simplicity shows itself to be deceptive.  Use of this keyword means not only the performance, after each move, of a check for the completion of the game, but also imposes upon the player certain “behavior”.

<oembed>https://youtu.be/OR74gUlfQNY</oembed>
From the usual <a href="https://en.wikipedia.org/wiki/Shogi">Shogi</a>, this game differs only in the number of players.  Unfortunately, this difference is enough to make the job of determining checkmate (and everything associated with this “magic” word) incorrect.  Verifying being in check is performed only with relation to one of the players.  As a result, the king may come to be under attack, and be eaten [by a combination of opponents' turns even when not left in “check”]!  That this is not optimal will be reflected in the work of the AI.

If this problem seems insignificant, it is worth remembering coalitions are usually formed in four-player games “pair against pair”.  In the case of the formation of coalitions, we must consider that pieces friendly to the king do not threaten him!  So, for example, two friendly Kings may well reside on neighboring spaces of the board.

<img align="center" src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"/>
It becomes more complicated than ever if a player may have several kings.  In “<a href="http://history.chess.free.fr/tamerlane-full.htm">Tamerlane chess</a>”, the royal pawn turns into a prince (actually, a second king).  If this happens, you can win only by capturing the first king (either of the two), and mating the second.  In this game, you can get even a third king, double spending on the transformation of the “pawn of pawns”!  The expressive capabilities of “checkmated” are not enough to adequately describe this situation.

Another difficulty may be the very process of giving mate.  So in Mongolian chess (<a href="https://en.wikipedia.org/wiki/Shatar">Shatar</a>), the result of attempted mate depends on the order in which the pieces execute sequential “check”.  The result can prove to be either win or a draw (such as mate by a pawn), or even a defeat (horse mate forbidden, but you can give check).  Slightly less exotic, in this regard, is Japanese Shogi.  In this game, it is forbidden to give mate with a dropped pawn, but you can give check with a dropped pawn and give check mate with a moved pawn.

<spoiler title="Note">
There is one more important point worth mentioning.  In some games, such as Rhythmomagic, there can be several different ways to end the game.  The most obvious way to win, involving the destruction of the opponent's pieces, is also the least preferred.  For more significant victory, one must arrange one's pieces on enemy territory in a certain pattern.

One should distinguish between the types of victories (and defeats and draws) at the level of game description, since the type of game ending may matter to the player.  In addition, it should be possible to assign numerical priorities to the various game endings.  Upon simultaneous fulfillment several completion conditions, the one that has the highest priority should count.
</spoiler>
Obviously, one must separate the logic of verification of game end from the test for the king's having fallen into check, which is an <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)">invariable rule</a> that is checked after each turn.  Violation of the rule makes it impossible to perform the move (the move is removed from the list of available moves).  So a (simplified) test for a King's being in check might look like this for “Tamerlane chess”:

<source lang="lisp">
(verify
    (or
        (> (count (pieces my? (is-piece? King))) 1)
        (= (count (pieces my? (is-piece? King) is-attacked?)) 0)
    )
)</source>
It is important to understand that this test should be carried out only for one's own kings (I used the predicate my?, because the predicate friend?, with support for coalitions, will be satisfied not only for one's own pieces, but also for the pieces of all friendly players).  Acceptable (and desirable, [if there are multiple friendly kings]) is the situation in which the enemy king falls under check, after a move, but by one's own king.  This situation should be impossible [unless there are multiple friendly kings]!  Having provided support for checking such rules, checking for the completion of the game by checkmate becomes trivial.  If there are no possible moves and the [only] king is in check, the game is over [if that king belongs to the last surviving player of the second last surviving coalition]:

<source lang="lisp">
(loss-condition
    (and
        (= (count moves) 0)
        (= (count (pieces my? (is-piece? King)) 1)
        (> (count (pieces my? (is-piece? King) is-attacked?)) 0)
    )
)</source>
The ability to determine invariants will be useful in other games, such as in <a href="https://glukkazan.github.io/checkers/international-checkers.htm">checkers</a>.  The greatest difficulty in the implementation of games of this family, is linked to the implementation of the “majority rule”.  In almost all drafts games, capturing is compulsory.  Also, in most games of this family, there is a characteristic completion of “chain captures” in a single turn.  The checker, having captured, continues to take other pieces, if possible.  In most games, the player is required to carry out chain captures to the end, but there are exceptions to this rule, for example, <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">Fanorona</a>.

<a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">
<img align="center" src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"/></a>
Using the mechanism of partial moves, implementating a “chain capture” is quite simple.  Difficulties arise when, in addition, one imposes a condition under which, of all the possible options, one must choose a chain in which a maximal number of pieces are captured.  In ZoG this logic must be implemented from scratch at the level of “hardcoding”:

<source lang="lisp">
(option "maximal captures" true)</source>
This setting is suitable for “<a href="https://glukkazan.github.io/checkers/international-checkers.htm">International checkers</a>”, but in the “<a href="https://glukkazan.github.io/checkers/italian-checkers.htm">Italian checkers</a>” the majority rule is formulated differently.  In this version of the game, if there are several options for the same number of captures, you must select an option which captures the larger number of transformed checkers (kings).  The developers of ZoG have provided this.  You enter the following setting:

<source lang="lisp">
(option "maximal captures" 2)</source>
In this setting, one counts not only the number of pieces captured, but also their type.  Unfortunately, not everything can be foreseen.  Here's how the “majority rule” is formulated in “old French checkers”:

<blockquote><i>If by a series of captures it is possible to capture the same number of checkers with a simple man or with a king, the player must use the king.  However, if the number of checkers is the same in both cases, but in one there is an enemy king (or there are more), the player must choose this option, even if the capturing is then done using the simple checker, and not using the king.</i></blockquote>
Of course, at the present time, almost no one plays this version of checkers, but its very existence clearly demonstrates the shortcomings of “hardcoded” implementation.  Using the mechanism of invariants allows for all possible options for the “majority rule” in a universal manner.  For the “<a href="http://www.checkerschest.com/checkers-games/french-checkers.htm">old French checkers</a>” implementation would be as follows:

<source lang="lisp">
(verify
    (>= capturing-count max-capturing-count)
)
(if (> capturing-count max-capturing-count)
    (let max-capturing-count capturing-count)
    (let max-capturing-sum capturing-sum)
    (let max-attacking-value attacking-value)
)
(verify
    (>= capturing-sum max-capturing-sum)
)
(if (> capturing-sum max-capturing-sum)
    (let max-capturing-sum capturing-sum)
    (let max-attacking-value attacking-value)
)
(verify
    (>= attacking-value max-attacking-value)
)
(let max-attacking-value attacking-value)
</source>
Here, we assume that the rules for capture generation correctly fill [the following] local variables:

<ul>
	<li><b>capturing-count</b>	— total pieces captured</li>
	<li><b>capturing-sum</b>	— number of kings captured</li>
	<li><b>attacking-value</b>	— value of piece capturing</li>
</ul>
Associated with each of these variables is a value-accumulator, stored in a variable with the prefix max.  The three checks are executed serially.  Violation of any of the verify conditions immediately interrupts the generation of the next turn option (the capture is not stored in the list of possible turns).  Since the checks performed are associated with variable values, it is not sufficient [to test only the current new capture option].  Each test generates a “bendable rule” associated with the generated capture [which may revise the accumulated maximum value].  After each change in any accumulator, all associated rules must be checked again [for every option in the list].  If any of the conditions are breached for a previously generated option, that option must be removed from the list of possible turn options.

<h2>Conclusion</h2>
This is translation of my article of 2014 year. Since then, I have rethought a lot and the <a href="https://glukkazan.github.io/">Dagaz project</a> has become a reality, but I did not change almost anything in the text. This article was translated by my friend <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=505">Howard McCay</a> and I am grateful to him for the work done.
</cut>

Dagaz: Эпизоды (часть 2)

<img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png" /><b><i>— Один слон, одна колесница, пятеро пехотинцев и трое всадников составляют ПАТТИ, утроенное ПАТТИ составляет СЕНАМУКХУ, ... 
а десять АНИКИНИ составляют АКШАУХИНИ, и это есть самая крупная войсковая единица…
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Генри Лайон Олди "Гроза в безначалье"</i></b>

В прошлой <a href="https://habr.com/ru/post/459456/">статье</a> я рассказывал о шашках и это не случайно. Шашечные игры, с их составными ходами, послужили основой <a href="https://glukkazan.github.io/">проекта</a>, составили его костяк. До сих пор, шашки подкидывают мне сюрпризы. Например, буквально на днях, мне довелось <a href="https://www.facebook.com/groups/228184761151081/permalink/466609280641960/">исправлять</a> застарелый баг, связанный с опцией отложенного взятия. И вообще, как я уже говорил, шашечные игры сильно недооценены. Но одними лишь шашками дело не ограничивается...
<cut>
<h2>Шахматы</h2>
<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> не кажутся нам какой-то необычной игрой, но это всё просто потому что мы к ним очень сильно привыкли. Взять, у примеру, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">пешку</a>. Если вдуматься, это очень необычная фигура. Единственная в шахматах, которая бьёт не так как ходит. А правило <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a> и вовсе сложно считать чем-то очевидным (да-да, знаю, так сложилось исторически). Но не будем о банальном. Пешка умеет превращаться в другие фигуры! Причём, в отличии от большинства других <a href="https://glukkazan.github.io/checkmate/chess.svg">традиционных шахматных игр</a>, выбор не ограничивается максимум двумя вариантами.

<a href="https://glukkazan.github.io/checkmate/baby-chess.htm">
<img align="center" src="https://habrastorage.org/webt/rx/rb/b8/rxrbb87dmkynfbn6kmeeiyofvom.png" /></a>
Под это дело, мне пришлось научиться рисовать графические диалоги, прямо на canvas-е. До этого момента, пешки превращались только в ферзей, что было несколько неудобно в тех <a href="https://glukkazan.github.io/checkmate/demi-chess.htm">играх</a>, где ферзи отсутствуют. А есть ведь ещё и <a href="https://glukkazan.github.io/checkmate/balbo-chess.htm">такие</a>, в которых доступный ассортимент фигур зависит от поля на котором превращение происходит!

<a href="https://glukkazan.github.io/checkers-like/dablot-child.htm">
<img align="center" src="https://habrastorage.org/webt/hi/uv/jp/hiuvjpe7knaex1m8gevn_jrgt4c.png" /></a>
Другим важным моментом является наличие в игре "королевских" фигур. Разумеется, это не шахматное изобретение. Главные фигуры присутствуют во множестве старинных игр. <a href="https://glukkazan.github.io/checkers-like/dablot-prejjesne.htm">Dablot</a>, <a href="https://glukkazan.github.io/checkers/italian-damone.htm">Damone</a>, <a href="https://glukkazan.github.io/checkers/altai-shatra.htm">Altai Shatra</a> - во всех этих играх "короля" можно заманить в ловушку, завершив, тем самым, игру досрочно. Особенно пикантны игры, в которых в королей могут превращаться фигуры рядовые. В "<a href="https://glukkazan.github.io/checkers/cheskers.htm">Шашматах</a>", например, у игрока есть выбор: получить, в результате превращения, более сильную фигуру или обезопасить себя, создав "запасного" короля.

Во всех этих играх, игрок проигрывает потеряв все королевские фигуры. Так, если на доске присутствуют "принц" и "король", для победы необходимо захватить их обоих. Такое понимание "правила внезапной смерти" характерно для древних игр, таких как <a href="https://glukkazan.github.io/checkmate/chaturanga.htm">Чатуранга</a>, но уже в <a href="https://glukkazan.github.io/checkmate/shatranj.htm">Шатрандже</a> шахматная мысль идёт дальше. Теперь короля атаковать нельзя - это фигура неприкосновенная, но и игрок не имеет право оставлять свою главную фигуру под ударом! Если же избежать угрозы королевской фигуре невозможно - игра заканчивается. Так появляются понятия <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мата</a>.

<spoiler title="Строго говоря, не во всех шахматных играх дело обстоит таким образом">
Главной проблемой <a href="https://glukkazan.github.io/shogi/chu-shogi.htm">действительно</a> <a href="https://glukkazan.github.io/shogi/tenjiku-shogi-board.htm">больших</a> <a href="https://glukkazan.github.io/shogi/makadaidaishogi-board.htm">шахматных</a> <a href="https://glukkazan.github.io/shogi/ko-shogi-kanji-board.htm">игр</a> является наличие в игре нескольких королей. В особо запущенных случаях, дело осложняется ещё и вычурными правилами завершения игры. Так например, в "<a href="https://en.wikipedia.org/wiki/Ko_shogi#Game_end">Ko Shogi</a>" победу приносит взятие фигур "General" и "Middle troop" либо "General" и "Banner". При этом, "Middle troop" может превратиться в "Governor" (а <a href="https://en.wikipedia.org/wiki/Ko_shogi#Promotion">правила превращения</a> в "Ko Shogi" - это отдельная большая тема), которого, в этом случае, также необходимо взять. Всё это дьявольски осложняет понятия шаха и мата. Гораздо проще разрешить брать королевские фигуры, разбираясь с возникшей ситуацией по ходу дела. Другим фактором, ломающим идею, является игра более чем двух игроков.

<a href="https://glukkazan.github.io/shogi/yonin-shogi.htm">
<img align="center" src="https://habrastorage.org/webt/t3/51/sl/t351slzygjviyba6u_9q_tmv-qm.png" /></a>
Здесь понятие шаха (как угрозы королю) становится ещё более абстрактным. В самом деле, если южный игрок атаковал короля западного игрока, последнему совершенно необязательно предпринимать что-то по этому поводу, поскольку до того как Юг снова получит право хода, Север и Восток могут ситуацию значительно скорректировать. Кроме того, в <a href="https://en.wikipedia.org/wiki/Yonin_shogi">Yonin Shogi</a> действует <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8#%D0%A5%D0%BE%D0%B4%D1%8B">правило сброса</a>, а королей также как и другие фигуры, разрешается забирать в свой резерв. Разумеется, для того чтобы продолжать игру, игрок должен держать на доске (а не в резерве) хотя бы одного из своих королей (можно и больше, но смысла нет), а чтобы победить, он должен собрать под своим началом королей всех четырёх армий.
</spoiler>
Но даже если рассматривать лишь те игры, в которых правила "шаха" и "мата" действуют, всё оказывается не так просто. Прежде всего, полная проверка на всевозможные угрозы королю оказывается довольно затратной. Учитывая то, что атаки, в общем случае, не обязательно могут быть только шахматными (в "<a href="https://glukkazan.github.io/checkmate/belarusian-chess.htm">Белорусских шахматах</a>", например, можно атаковать короля шашечными фигурами, а приоритет во взятии шашечными фигурами позволяет поставить <a href="http://www.gambiter.ru/checkers/item/276-chess-checkers.html">мат королём</a>) было бы заманчиво выполнять генерацию всех допустимых ходов с последующей проверкой угроз королю. На практике, это работает слишком медленно. Приходится <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/chess-invariant.js">дублировать</a> схему перемещения фигур, чтобы проверять возможные угрозы без генерации списка ходов.

С самой проверкой на "мат" тоже были сложности. Очень продолжительное время, условием поражения я считал отсутствие возможного хода (с учётом запретов из за короля под шахом, разумеется). В общем-то это не так уж и неверно, учитывая то, что в большинстве игр (в том числе и шахматных) так оно и есть. Но <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82">не в Шахматах</a>! К счастью, в версии 1.2.7 я придумал как поправить ситуацию без ущерба производительности и теперь пат определяется корректно. Кстати, та же проверка на возможные угрозы используется и ботами (что сильно улучшает качество их игры), но всё равно, AI в <a href="https://glukkazan.github.io/checkmate/chess.htm">Шахматах</a> отвратительный (<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/data/chess.txt">дебютная библиотека</a> помогает незначительно). Тут уж грешить я могу только на самого себя. Всё таки, качественный шахматный AI - это не моё.

<a href="https://glukkazan.github.io/checkmate/gravity-chess.htm">
<img align="center" src="https://habrastorage.org/webt/9l/w_/5l/9lw_5lyzw5txvlssdgvi3gby4ps.png" /></a>
Всё это не отменяет того факта, что в шахматных играх есть на что заморочиться. Эта игра, конечно, в большой степени шутка (да и нет у меня уверенности, что удалось исправить все ошибки в её реализации), но в похожую по духу "<a href="https://glukkazan.github.io/checkmate/momentum-chess.htm">Momentum Chess</a>" вполне можно серьёзно поиграть. С самой трактовкой мата также возможны варианты. Например, король может быть <a href="https://glukkazan.github.io/checkmate/neutral-king.htm">общим</a> или в игре может быть фигура, которая <a href="https://glukkazan.github.io/checkmate/anti-king.htm">должна</a> постоянно находиться под шахом (есть её, при этом, нельзя). В общем, шахматы - это весело.

Что ещё можно извлечь из этой игры? В Шахматах есть презабавнейший ход, при выполнении которого, двигаются две фигуры одновременно. Конечно, я говорю о <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировке</a>. Для моего проекта эта концепция столь же важна как и составной ход, позаимствованный из шашечных игр. Существует масса игр в которых её можно применить. <a href="https://glukkazan.github.io/checkers/dameo.htm">Dameo</a>, <a href="https://glukkazan.github.io/elimination/abalone.htm">Abalone</a>, <a href="https://glukkazan.github.io/breakthrough/ordo.htm">Ordo</a> - во всех этих играх, фигуры двигаются одновременно. Но можно пойти ещё дальше!

<a href="https://glukkazan.github.io/elimination/apocalypse.htm">
<img align="center" src="https://habrastorage.org/webt/kv/at/nl/kvatnlnq0o0_n_qyotorgcyijwi.gif" /></a>
Согласен, это довольно далеко от первоначальной концепции рокировки, но зачем себя ограничивать? Надо выжимать из заложенных концепций всё, по максимуму.
</cut>

Dagaz: Конец одиночества

<img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png" /><b><i>Счастье для всех, даром
и пусть никто не уйдёт обиженный!&nbsp;
&nbsp;
А. и Б. Стругацкие "Пикник на обочине"</i></b>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

Боты, как бы хорошо они не играли, плохая замена живым игрокам. Если бот играет слабо - это не интересно. Если сильно - это обидно и снова не интересно. Баланс соблюсти чертовски трудно (тем более, что для каждого игрока он индивидуальный). Я уже давно собирался реализовать сетевую игру, но всё упиралось в необходимость содержания собственного сервера. К счастью, решение пришло с неожиданной стороны.
<cut>
Ed van Zon - это человек, с которым я общаюсь довольно давно. Так получилось, что именно он подхватил падающее знамя <a href="http://www.zillions-of-games.com">Zillions</a>, когда разработчики (Jeff Mallett и Mark Lefler) внезапно потеряли интерес к развитию проекта. Так что, все <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">эти игры</a> опубликованы на сайте его силами. А ещё, он и <a href="https://en.wikipedia.org/wiki/Christian_Freeling">Christian Freeling</a> занимаются поддержкой и развитием собственного сайта (само собой, тоже про настольные игры):

<a href="http://mindsports.nl/">
<img align="center" src="https://habrastorage.org/webt/5v/8c/ma/5v8cmafs1-f3ezgmwqwwpztojxg.png" /></a>
Но всё это была присказка. Сказка начинается с того, что на этом сайте есть нора (вернее, <a href="http://mindsports.nl/index.php/the-pit">яма</a>, но суть не в этом), в которой живые игроки могут играть по переписке. Вернее могли, до тех пор пока технология Java-апплетов не стала считаться устаревшей. В последнее же время, поскольку их использование простыми смертными стало затруднительным, Эд задумался о более современных решениях. И тут подвернулся я, вместе со своим <a href="https://glukkazan.github.io/">проектом</a>.

<a href="http://mindsports.nl/index.php/dagaz">
<img align="center" src="https://habrastorage.org/webt/dt/vt/as/dtvtaski8pti0uleyrv3kogaep8.png" /></a>
После очень небольшого обучающего тура, с моей стороны, Эд, в течение буквально пары месяцев, настрогал три десятка новых игр на движке Dagaz и выложил их на сайте. Напомню, что <a href="https://glukkazan.github.io/LICENSE.txt">MIT-лицензия</a> (как и я сам), такие действия всячески поддерживает.

<spoiler title="Была, впрочем, одна проблема">
Подразумевалось, что во все эти игры игроки смогут играть между собой, а не только с ботами, Dagaz же, в его первоначальной реализации, такой возможности не предусматривал. Пришлось быстренько что-то придумывать. К счастью, у меня уже был <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">session-manager</a>, позволявший откатывать ошибочно сделанные ходы. В качестве бонуса, он сохранял историю игры в оперативной памяти и этим решено было воспользоваться.

<spoiler title="Сохранение">
<source lang="javascript">
SessionManager.prototype.save = function() {
  if (_.isUndefined(this.current) || _.isUndefined(this.current.board)) return null;
  var states = [];
  var board  = this.current.board;
  while (board.parent !== null) {
      states.push(board);
      board = board.parent;
  }
  var r = "(";
  while (states.length > 0) {
      var board = states.pop();
      r = r + ";" + Dagaz.Model.playerToString(board.parent.player);
      r = r + "[" + Dagaz.Model.moveToString(board.move) + "]";
  }
  r = r + ")";
  return r;
}
</source></spoiler>
<spoiler title="и загрузка">
<source lang="javascript">
SessionManager.prototype.load = function(sgf) {
  var res = Dagaz.Model.parseSgf(sgf);
  this.states = [];
  delete this.current;
  var board = Dagaz.Model.getInitBoard();
  this.addState(Dagaz.Model.createMove(), board);
  for (var i = 0; i < res.length; i++) {
       var p = res[i].name;
       if (p != Dagaz.Model.playerToString(board.player)) return false;
       if (res[i].arg.length != 1) return false;
       var move = this.locateMove(board, res[i].arg[0]);
       if (move === null) return false;
       board = board.apply(move);
       this.addState(move, board);
  }
  this.controller.setBoard(board);
  return true;
}
</source></spoiler>
Уложились всего в несколько десятков строк (сам парсер <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF-формата</a> я конечно не считаю, желающие могут посмотреть его <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/utils/sgf-parser.js">здесь</a>). К слову сказать, и сам SGF и session-manager поддерживают работу с деревом, а не просто с историей игры, но для наших текущих целей это не требовалось. 
</spoiler>
В качестве первой игры от Dagaz, с возможностью игры по сети, хотелось выбрать что-то оригинальное (тем более, что <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашки</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> и <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> у Эда уже были). Выбор пал на <a href="https://www.chessvariants.com/rules/turnover">Turnover</a>. Эту игру, во многом похожую на Шахматы, совсем недавно придумал Lúcio José Patrocínio Filho.

<a href="http://mindsports.nl/index.php/dagaz/822-turnover-ai">
<img align="center" src="https://habrastorage.org/webt/er/id/8p/erid8pbh2iggr2qsvwk8mqorauu.png" /></a>
Фигуры здесь сборные. Самое большое кольцо ходит как <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">шахматная пешка</a>, среднее - как <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">слон</a>, а сердцевина представляет из себя <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">ладью</a>. Комбинация из ладьи и слона даёт <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D1%80%D0%B7%D1%8C">ферзя</a> (что вполне логично), а два кольца - <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шахматного коня</a>. Все три части вместе образуют замок - главную фигуру, которую необходимо защищать. Здесь стоит сказать, что перемещается всегда всего одна, самая внешняя часть. Таким образом, внешнее кольцо замка, в любой момент, может переместиться ходом пешки (в том числе, прыжком через поле), но замок, при этом, будет разрушен.

<spoiler title="Здесь есть ещё одна, пока не решённая, проблема">
Потеряв последний замок, игрок проигрывает. На самом деле, потерять все замки игрок не может, поскольку в игре действуют правила <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мата</a>. Замки запрещено оставлять под ударом, но только при условии, что <b>все</b> они атакованы. Кроме того, интригу в игру добавляет то, что новые фигуры (и замки тоже) могут создаваться из составных частей по ходу дела (в том числе, из материала противника). Всё это делает проверку на шах и мат очень сложной задачей и вот пример, с которым она пока не справляется:

<img align="center" src="https://habrastorage.org/webt/hd/km/r8/hdkmr8ygjgcckvjzafaya9hgpzc.png" />
На самом деле, здесь нет мата, но это довольно сложно. Поле D1 атаковано слоном на E2 и это последний замок. Золотые могут построить второй замок, сходив ладьёй с C3 на C4, но это поле тоже атаковано! Фокус заключается в том, что оба поля атакует одна и та же фигура, а она не может съесть оба замка одним ходом! Lúcio обнаружил эту ошибку совсем недавно и это то, над чем я буду работать в ближайшее время.
</spoiler>
<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">Рокировок</a> и <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a> в игре нет, да и вообще, Turnover не очень похож на Шахматы. Королей в игре много, но они не могут двигаться (во всяком случае, без разрушения), а кони и ферзи "одноразовые", поскольку перемещаясь, внешнее кольцо разрушает фигуру. На мой взгляд, игра выглядит довольно интересной, хотя и совершенно не исследованной. Поиграть можно вот здесь:

<a href="http://mindsports.nl/index.php/players-section">
<img align="center" src="https://habrastorage.org/webt/w6/k0/lw/w6k0lwlpbbrmxh43wkpbax0rkag.png" /></a>
Для игры по сети, разумеется потребуется зарегистрироваться (игра то ведь по переписке) и послать кому нибудь "Challenge". Если хотите <a href="http://mindsports.nl/index.php/dagaz/822-turnover-ai">поиграть с ботом</a> (или просто <a href="http://mindsports.nl/index.php/dagaz/821-turnover">подвигать по доске фигуры</a>), никакой регистрации не требуется. Впрочем, при таком режиме, игра мало чем будет отличаться от опубликованной на <a href="https://glukkazan.github.io/checkmate/turnover.htm">GitHub-е</a>. Также, не требуется регистрация для наблюдения за текущими или ранее сыгранными партиями. 

<spoiler title="В качестве бонуса">
В Dagaz поддерживается ещё один режим игры:

<a href="https://glukkazan.github.io/checkmate/dark-turnover.htm">
<img src="https://habrastorage.org/webt/mq/oh/z-/mqohz-pohdjs0ss3imljgn2_cgc.png" /></a>
Так что, желающие могут попробовать поиграть вслепую (в этот раз, только против бота).
</spoiler>
Учёт побед/поражений для Turnover пока не ведётся, но здесь всё в ваших руках. Если игра будет популярна, Эд обещал прикрутить к ней рейтинг. Ну и напоследок небольшой опрос, на тему дальнейшего развития проекта:
</cut>

Dagaz: Эпизоды (часть 1)

<img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png" /><b><i>Мы расшатали ваши умственные фильтры,  и  в  результате появился ответ. Метод сработал, он будет действенным всегда. Все,  что необходимо сделать - это избавиться от лишнего груза предрассудков...

Раймонд Джоунс "<a href="http://lib.ru/INOFANT/DZHOUNS/noise.txt">Уровень шума</a>"</i></b>

<a href="https://glukkazan.github.io/">Dagaz</a> появился не на пустом месте. Я всегда увлекался настольными играми и головоломками, а программированием занимаюсь сколько себя помню, но мысль о некоем "универсальном" движке просто не могла бы прийти мне в голову. К самой этой идее я относился скептически. Пока не увидел <a href="http://www.zillions-of-games.com/">Zillions</a>. К сожалению, продукт, на тот момент, уже не развивался, исходный код был недоступен, да и вообще, программа работала только под Windows. Спустя некоторое время, я решил взяться за открытый проект.
<cut>
Как я уже сказал, никаких исходных кодов у меня не было, но немного "<a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">пощупав</a>" Zillions, я уловил его главную идею - максимальное повторное использование прикладного кода, позволяющее использовать одни и те же конструкции в различных, казалось бы совершенно не похожих друг на друга случаях. Всё дело было в правильно подобранных usecase-ах. И я составил <a href="https://github.com/GlukKazan/Dagaz/blob/master/doc/games.txt">план</a>.

<h2>Шашки</h2>
Это важное, но крайне недооценённое семейство игр заложило первый камень в фундамент проекта. Все "шашечные" игры похожи друг на друга и различаются лишь в деталях. С точки зрения игрового дизайна, все они объединяются тремя главными идеями:

<ul>
	<li>Шашечным взятием</li>
        <li>Приоритетом взятия</li>
        <li>Составным ходом</li>
</ul>
Первый пункт особых вопросов не вызывает, но если разработка ориентирована на шахматные игры, может оказаться неожиданностью. Далеко не во всех играх, взятие происходит на том же поле, где фигура завершает движение. С приоритетными ходами всё немного интереснее. В шашках, это правило позволяет строить сложную комбинационную игру, заманивая противника в ловушки, работающие по принципу "отдать меньше - забрать больше".

<oembed>https://www.youtube.com/watch?v=zMpxcNG2UDQ</oembed>
Разумеется, механизм приоритетных ходов был реализован в Zillions (и перекочевал оттуда в Dagaz). Без него практически все шашечные игры (безусловно входящие в "джентельменский набор" настольных игр обязательных к реализации) просто не могли бы работать правильно. Здесь всё дело в деталях. Посмотрим, как этот механизм был реализован:

<spoiler title="В Zillions">
<source lang="lisp">
(move-priorities jump-type normal-type)
...
(define checker-shift (
   $1 (verify empty?) ; Двигаемся вперёд и проверяем что поле пусто
   add                ; Завершаем ход
))

(define checker-jump (
   $1 (verify enemy?) ; Двигаемся вперёд и проверяем что там вражеская фигура
   capture            ; Берём её (вызов capture необходим - взятие не шахматное)
   $1 (verify empty?) ; Двигаемся в том же направлении и проверяем что поле пусто
   add                ; Завершаем ход
))
...
(piece
   (name Man)
   (image White "images/stapeldammen/white.bmp"
          Red "images/stapeldammen/red.bmp")
   (moves
       (move-type jump-type)
       (checker-jump nw) (checker-jump ne) (checker-jump sw) (checker-jump se)
       (move-type normal-type)
       (checker-shift nw) (checker-shift ne)
   )
)
</source></spoiler>
Это практически полное описание простейшей шашечной игры. В <a href="https://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> введено понятие режимов хода (<b>move-type</b>), а конструкция <b>move-priorities</b> позволяет сказать, что при наличии ходов более приоритетных (взятий), менее приоритетные (тихие ходы) рассматриваться не должны. Уровней приоритета может быть определено и больше двух, в этом плане, конструкция достаточно универсальна, но работая над играми в Dagaz, я столкнулся с некоторыми ограничениями этого механизма.

<a href="https://glukkazan.github.io/checkers/cheskers.htm">
<img align="center" src="https://habrastorage.org/webt/y6/6-/7r/y66-7rt1ejot9yb-ppoq-wmk98u.png" /></a>
В этой <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BC%D0%B0%D1%82%D1%8B">игре</a>, придуманной Соломоном Голомбом, помимо шашек, присутствуют и шахматные фигуры. Сложность заключается в том, что взятие, оставаясь приоритетным для шашечных фигур, не является таковым для фигур шахматных (в противном случае их было бы слишком легко заманить в ловушку и съесть). Наивное определение приоритетов при помощи ключевого слова <b>move-priorities</b>, в этой игре, работать не будет.

В самом деле, если не включать взятия шахматными фигурами в состав приоритетных ходов, при наличии возможности взятия как шашечной фигурой так и шахматной, мы не сможем сходить шахматной фигурой, поскольку шашечное взятие приоритетно. Если же считать шахматные взятия столь же приоритетными, мы будем обязаны брать шахматными фигурами всегда, когда предоставится такая возможность. И то и другое противоречит правилам игры.

В Zillions эта проблема практически не решается. И это было главной причиной, по которой я задумался о введении в Dagaz механизма JavaScript-расширений. Идея, сама по себе, довольно простая: поскольку некоторые игровые механики довольно сложно выразить в ZRF, почему бы не ввести фазу пост-обработки ходов? Модуль расширения, в этом случае, просматривает весь список сгенерированных ходов целиком и может принимать решения об отбраковке тех или иных ходов. Вот как это <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/cheskers-invariant.js">выглядит</a> для "<a href="https://glukkazan.github.io/checkers/cheskers.htm">Шашмат</a>":

<spoiler title="Простой и компактный код">
<source lang="javascript">
var CheckInvariants = Dagaz.Model.CheckInvariants;

Dagaz.Model.CheckInvariants = function(board) {
  var design = Dagaz.Model.design;
  var types  = [];
  types.push(design.getPieceType("Bishop")); 
  types.push(design.getPieceType("Camel"));
  var isPriority = false;
  _.each(board.moves, function(move) {
      if (isCapturing(board, move)) {
          if (_.indexOf(types, getType(board, move)) < 0) isPriority = true;
      }
  });
  if (isPriority) {
     _.each(board.moves, function(move) {
          if (!isCapturing(board, move)) {
              move.failed = true;
          }
     });
  }
  CheckInvariants(board);
}
</source></spoiler>
В дальнейшем, идея расширений развивалась и цвела пышным цветом. Я получил удобный и мощный механизм для кодирования многих игр, реализация которых на чистом ZRF была бы крайне проблематична, но означает ли это, что определение приоритетов в стиле ZRF устарело? Разумеется нет! Во первых, написать одну строку на ZRF проще чем полсотни на JavaScript, но, что более важно, "жёсткие" приоритеты в стиле ZRF работают таким образом, что низко-приоритетные ходы даже не генерируются! Это важно, с точки зрения производительности. Генерация ходов в Dagaz - очень дорогая операция.

<spoiler title="Еще одна игра со сложными приоритетами">
<a href="https://glukkazan.github.io/checkers-like/dablot-prejjesne.htm">
<img align="center" src="https://habrastorage.org/webt/_w/zj/lj/_wzjljuhqpa3qmnfnousdrlkxhq.png" /></a>
<a href="https://en.wikipedia.org/wiki/Dablot_Prejjesne">Dablot</a> - игра чем-то похожая на "<a href="https://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Итальянские шашки</a>", но более древняя. Помимо обычных фигур, в ней есть "принцы" и "короли" и младшие фигуры не имеют права бить старших. Но сложность не в этом. Для королей (а в некоторых разновидностях игры и для принцев тоже) взятие не является обязательным! Здесь возникает та же проблема, что и с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BC%D0%B0%D1%82%D1%8B">Шашматами</a>. Если мы объявим взятия королём приоритетными, то грубо нарушим правила игры, в противном же случае, мы не сможем бить королём при возможности альтернативного боя простой фигурой. Только механизм расширений Dagaz решает эту проблему.

Кстати, с "Итальянскими шашками" всё не так просто. Во многих разновидностях шашек существует правило гласящее, что игрок обязан брать максимальное количество фигур. То есть, не просто не может прервать цепочку взятий, а обязан выбрать тот путь, фигур на котором он возьмёт больше! По причинам, о которых я расскажу ниже, это правило не могло быть реализовано в Zillions в универсальном виде и разработчики были вынуждены его захардкодить. В итальянских шашках "правило большинства" звучит ещё сложнее: "бить нужно максимально возможное количество шашек соперника, а при равных вариантах боя нужно бить максимальное количество дамок".
</spoiler>
Составные ходы - вторая важная составляющая шашечных игр. Настолько важная, что <a href="https://github.com/GlukKazan/Dagaz/blob/master/tests/checkers-test.js">тест</a> на правильность взятия в "<a href="https://glukkazan.github.io/checkers/turkish-dama.htm">Турецких шашках</a>" я периодически запускаю до сих пор. Пару раз, когда я ломал модель очередными изменениями, это действительно помогало. 

<spoiler title="Ходы - составные и частичные">
<spoiler title="Посмотрим, как в ZRF реализованы составные ходы">
<source lang="lisp">
(define checker-shift (
   $1 (verify empty?)
   (if (in-zone? promotion)
      (add King)
    else
      add
   )
))

(define checker-jump (
   $1 (verify enemy?) 
   capture 
   $1 (verify empty?)
   (if (in-zone? promotion)
       (add King)
    else
       (add-partial jump-type)
   )
))

(define king-shift (
   $1 (verify empty?)
   add
))

(define king-jump (
   $1 (verify enemy?) 
   capture 
   $1 (verify empty?)
   (add-partial jump-type)
))
</source></spoiler>
Вот так вот всё просто. Команда <b>add-partial</b> говорит, что ход можно продолжить (той же фигурой, это важно) если есть ещё ходы с указанным режимом. Иными словами: "фигура должна продолжать взятие, пока есть такая возможность". Вроде бы, всё замечательно, но есть один нюанс. Zillions рассматривает каждое такое взятие как отдельный "частичный" ход. Посмотрим, к чему это может привести.

<a href="https://glukkazan.github.io/elimination/mana.htm">
<img align="center" src="https://habrastorage.org/webt/pr/ff/mu/prffmuzpuk9wv7gks7do1h6djuq.png" /></a>
В этой <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2462">игре</a>, количество "шажков", выполняемых фигурой, определяется значком, на котором она стоит. Сейчас ход белых и ходит Damyo (фигура обозначенная красной бусинкой). В Zillions, выполнив два частичных хода, она легко может зайти в левый верхний угол, из которого уже не сможет сделать последний оставшийся ход (назад возвращаться нельзя). Брать фигуру противника на втором частичном ходу также запрещено. В Zillions нет никакой возможности, для того чтобы запретить последовательность ходов, заводящую в тупик.

В Dagaz - всё по другому! Последовательность частичных ходов <b>всегда</b> собирается в полный составной ход. Ход, который не удаётся завершить, попросту не соберётся! Это более ресурсозатратный подход, в результате чего генерация списка ходов в Dagaz - очень дорогая операция. Но и плюсы у него весомые. Например бот получает весь составной ход целиком и не должен просматривать позицию вперёд, выполняя оставшиеся частичные ходы.

Ещё более важно, что такой подход предоставляет возможность рассматривать весь список условно-допустимых ходов, выполняя более сложные проверки и запрещать одни ходы в зависимости от наличия других. Например "правило большинства", о котором я упоминал выше, в Dagaz реализуется совершенно <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/maximal-captures.js">элементарно</a>. Причём, и для "Итальянских шашек" тоже. Разработчики Zillions "решили" известную им проблему для шашечных игр, захардкодив опцию "<b>maximal captures</b>", но существует огромное количество игр с другими сложными проверками, о которых они, на тот момент, не имели ни малейшего представления!
</spoiler>
В процессе работы над новыми играми, концепция составного хода также развивалась. <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">Fanorona</a> и <a href="https://glukkazan.github.io/pasang/pasang-01.htm">Pasang</a> подсказали интересную игровую механику, в рамках которой группа снимаемых с доски фигур должна выбираться игроком, выполняющим ход:

<a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">
<img align="center" src="https://habrastorage.org/webt/w2/zr/xf/w2zrxfku5fs-aklwv3983gcfk4w.gif" /></a>
Также, <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Fanorona</a> - одна из тех редких игр, в которых игрок имеет право прерывать цепочку взятий. Первое взятие в ней обязательно, последующие, в рамках того же хода - на усмотрение игрока. В Dagaz эта опция (<b>pass-partial</b>) реализована ходом фигуры "на месте". Здесь могут быть missclick-и это, по всей видимости, не очень удобно, но с введением в проект <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">session-manager</a>-а, ошибочные ходы стало возможно откатывать.

Дальнейшим развитием темы стали "стреляющие" ходы. Впервые я сделал их в <a href="https://glukkazan.github.io/races/hanga-roa-board.htm">Hanga Roa</a> и <a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">Ko Shogi</a>, но, как выяснилось позже, сделал неправильно! Ошибочная реализация не работала под управлением ботов (а поскольку никаких ботов для обеих этих игр у меня нет до сих пор, не удивительно, что я ничего не заметил). Много позже, когда я делал "<a href="https://glukkazan.github.io/stalemate/amazons.htm">Амазонок</a>", мне удалось локализовать проблему и исправить её. Своего расцвета эта идея достигла в <a href="https://glukkazan.github.io/breakthrough/chessball.htm">игре</a>, придуманной одним из наших соотечественников в далёком 1957 году.

<a href="https://glukkazan.github.io/breakthrough/chessball.htm">
<img align="center" src="https://habrastorage.org/webt/7z/nv/k8/7znvk8vjkevscqukwkvl7qepw88.png" /></a>
Есть ещё одна проблема, связанная с реализацией составных ходов в Dagaz. Дело в том, что список допустимых ходов, из конкретного игрового состояния, формируется сразу - весь целиком. В Zillions, с её частичными ходами, это не очень критично, но в Dagaz, если фигура получит возможность "кружить на месте", фаза генерации хода никогда не будет завершена (очевидно, что исправить эту проблему расширениями невозможно, потому что до них дело просто не доходит). Вот одна из игр, для которых это важно:

<a href="https://glukkazan.github.io/races/super-chinese-checkers.htm">
<img align="center" src="https://habrastorage.org/webt/jl/sl/n6/jlsln6ekdv4c_y8g4w2cdxtfjzm.png" /></a>
Здесь фигуры с доски не убираются и одну и ту же фигуру можно перепрыгивать много раз подряд. Очевидным решением является запрет на посещение одного и того же поля дважды за ход, но мне пришлось основательно влезть в ядро, чтобы реализовать такую проверку. Это немножко напоминало реализацию опции "<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/deferred-captures.js">отложенного взятия</a>", но поскольку "<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Русские шашки</a>" я делал гораздо раньше, то и проблем с ней было намного меньше. 

<spoiler title="К сожалению, есть игры, в которых даже такие проверки не спасают">
В правилах <a href="https://glukkazan.github.io/checkers/stapeldammen.htm">Stapeldammen</a> (это такая разновидность "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовых шашек</a>" явно указывается, что одну и ту же фигуру можно бить по нескольку раз за ход. Фигура, выполняющая ход, возвращается на одни и те же позиции по нескольку раз и продолжает бой, пока во вражеских столбиках есть фигуры. Составные ходы Dagaz не могут справиться с этой проблемой. Логика боя "Столбовых шашек" слишком сложна для ядра, а до расширений дело не дойдёт, поскольку поскольку генерация хода зацикливается. Разумеется, выход есть:

<a href="https://glukkazan.github.io/checkers/stapeldammen.htm?setup=+42;0:2=22;;0:2=22;+16;0:2=22;;0:2=22;;0:2;+5;0:1;+2;0:1;+20;&turn=0">
<img align="center" src="https://habrastorage.org/webt/wq/dw/r0/wqdwr0nl6vz3bentua8vpdiml18.png" /></a>
В Dagaz нет частичных ходов, но мы можем их сэмулировать, пропуская очередной ход противником (тот же подход используется в <a href="https://glukkazan.github.io/mancala/hawalis.htm">манкалах</a>). И как раз эта логика легко реализуется <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/stapeldammen-restrictions.js">расширением</a>. Просто запрещаем все ходы, при определённых условиях, а опция <b>pass-turn=forced</b> автоматически генерирует пустой ход. Вот ещё одна <a href="http://www.iggamecenter.com/info/en/pilare.html">игра</a> с подобной эмуляцией.

<a href="https://glukkazan.github.io/stalemate/pilare-board.htm">
<img align="center" src="https://habrastorage.org/webt/l3/qg/ze/l3qgzeou6mpibm80fzejdzk5qp8.png" /></a>
Искусственное разделение составных ходов на частичные не очень хорошо для AI ботов, но иногда, просто не остаётся другого выхода.
</spoiler>
В общем, концепция составных ходов живёт и развивается. Совсем недавно, мне пришлось сделать ещё одну новую опцию (<b>complete-partial</b>) для одной древнеегипетской <a href="https://glukkazan.github.io/races/shen.htm">игры</a>.

<oembed>https://www.youtube.com/watch?v=ceBXdXL-aXE</oembed>
Помимо автоматического завершения перемещения фигур по стрелочкам, в ней есть и другие интересные технические решения. Но об этом как-нибудь в другой раз.

Dagaz: Ошибки

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>Дело помощи утопающим - &nbsp;
дело рук самих утопающих.

И.Ильф и Е.Петров.</b></i>
&nbsp;
&nbsp;
Ошибки ошибкам рознь. Работая над <a href="https://glukkazan.github.io/">проектом</a>, я веду свой личный <a href="https://github.com/GlukKazan/Dagaz/blob/master/doc/bugs.txt">рейтинг ошибок</a>. Что-то исправляется совсем легко, при первом запуске, что-то намертво прибито гвоздями к архитектуре и потому отравляет жизнь годами. Некоторые ошибки просто вымораживают. Когда их исправляешь - чувствуешь, что живешь. Я люблю такие ошибки.
<cut>
Всё время писать одинаковые игры было бы не интересно. К счастью, игры разные. Некоторые игры более разные чем другие. Честно говоря, я и берусь-то за них, в основном, из-за уникальности их игровых механик. Для меня такие игры - своего рода вызов.

<a href="https://glukkazan.github.io/races/hanga-roa-board.htm">
<img src="https://habrastorage.org/webt/eq/d5/yw/eqd5ywsfv9aewsdcsfkr8g3nip0.png" align="center"/></a>
<spoiler title="Hanga Roa">
Эта <a href="https://www.chessvariants.com/other.dir/hanga_roa/hanga_roa.html">игра</a> ломает стереотипы и рвёт шаблоны. Не обманывайтесь поверхностным сходством с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматами</a>. На Шахматы она совершенно не похожа. Цель игры - провести своего "Короля" (<b>Moai</b>) к противоположному краю доски. Вот только, сам по себе, <b>Moai</b> ходить по доске не умеет. Эта фигура ходит только "по камушкам" (строго своего цвета), перемещаясь на одну соседнюю клетку в любом из восьми направлений (использованный камень с доски убирается). Шаги можно повторять, пока есть такая возможность.

<b>MataToa</b> (на доске она похожа на пешку) также перемещается на один шаг, в любом из восьми направлений и может разрушать вражеские "дороги", забирая камни чужого цвета (по пустым полям она, разумеется, также перемещаться может). В остальном, "шахматное взятие" в игре не используется, фигуры с доски убираются совсем по другому. Для снятия с доски фигуры, её необходимо окружить своими камнями таким образом, чтобы она не могла двигаться (очевидно, что поймать <b>MataToa</b>, таким образом, невозможно). Если удалось окружить <b>Moai</b> - игра на этом и заканчивается. С <b>Ariki</b>, последней оставшейся фигурой, дело обстоит по другому.

<b>Ariki</b> - фигура строитель (на доске изображена как ладья), которая бросает те самые "камушки" на доску. Ход выполняется следующим образом: фигура перемещается на любое расстояние по любому из восьми направлений (как шахматный ферзь, только без боя), после чего, производит два "выстрела". Камни также летят на любое расстояние, в любом из восьми направлений. Если удаётся завалить камнями вражескую <b>Ariki</b>, она снимается с доски, но не навсегда. Игрок, которому она принадлежит, может поставить её на доску снова, в один из последующих ходов, но только на первую горизонталь. Пожалуй, это самая удивительная шахматная механика, из тех что я видел.
</spoiler>
Всё дело в этих самых "стреляющих" фигурах. Сам по себе "выстрел" кодируется довольно просто, но для того, чтобы появилась возможность "стрелять" два раза подряд, пришлось залезть в <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/zrf-model.js">ядро</a>. Дело в том, что ещё со времён с <a href="http://www.zillions-of-games.com/">Zillions</a>, такая последовательность действий трактуется как составной ход, то есть последовательность частичных ходов, выполняемых <b>одной</b> фигурой, а "выстрел" - это, по сути, перемещение той же фигуры на <b>другую</b> позицию. Не на ту, с которой должен выполняться следующий частичный ход (второй "выстрел"). С этим пришлось повозиться.

Поскольку я пока не придумал, как реализовать бота для этой игры, то сделал её в режиме "интеллектуальной доски", контролирующей соблюдение правил, но без игрового AI. Это сыграло со мной злую шутку. Ошибка совершенно никак не проявлялась при ручном управлении фигурами, но стала очевидна, как только я начал делать бота для "<a href="https://glukkazan.github.io/stalemate/amazons.htm">Амазонок</a>".

<spoiler title="Строго говоря есть ещё одна игра  с похожей механикой">
<a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">
<img src="https://habrastorage.org/webt/-f/gz/cw/-fgzcw_nk0bw0iwstzpzaryq2kg.png"  align="center"/></a>
Но для <a href="https://en.wikipedia.org/wiki/Ko_shogi">неё</a> я бота тоже не делал. Думаю, вы понимаете почему.
</spoiler>
В случае с "Амазонками" я нашёл <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/stalemate/amazons-extension.js">обходной путь</a> и не стал лазать в ядро, но для Hanga Roa такое решение не подходило. Поскольку бота для игры всё равно не было, я забросил это дело в долгий ящик (и оно продолжало грызть меня изнутри). Так бы и продолжалось, если бы, работая над "<a href="https://habr.com/ru/post/276329/">Квантовым Моррисом</a>", я не наткнулся на такое вот паскудство:

<a href="https://glukkazan.github.io/arrange/quantum-morris.htm">
<img src="https://habrastorage.org/webt/wy/lq/j-/wylqj-7e3uc4ucfjpagbqrc5-ac.png"  align="center"/></a>
Проблема усугублялась тем, что ошибка, по всей видимости, проявлялась в зависимости от фаз Луны. Это (а также ряд других случаев) наглядно показало, что пришло время для переписывания кода анимации перемещения фигур, с которого проект практически начинался. Поймите меня правильно, я не ринулся переписывать <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/view/2d/2d-view-v2.js">view</a> сразу. Я убеждал себя в том, что это необходимо, ещё около месяца. И в конце концов, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/view/2d/2d-view-v4.js">убедил</a>. Код стал проще и понятнее. Попутно, стали более очевидны и другие ошибки, мучившие меня долгое время.

<a href="https://glukkazan.github.io/checkers-like/fanorona-debug.htm?setup=0:2+18;0:1;+1;0:1;0:2;0:1;0:2;0:1+18;&turn=1">
<img src="https://habrastorage.org/webt/lv/av/fk/lvavfkeuk7bqtlmfleyjz6ge6yg.png"  align="center"/></a>
Картинка кликабельна. Полюбуйтесь, как чёрный шарик, завершив ход, превращается в белый (хотя и совсем не должен этого делать). Со старым view он оставался чёрным и ошибка была не так очевидна. На view фигура оставалась чёрной, но управлять ей игрок более не мог (поскольку, в model то она была белой) и это бесило. Строго говоря, это ошибка модели, но к ней (как и к утилите конвертации ZRF-кода в JavaScript) уже и так накопилось много вопросов.

По хорошему, там всё надо переписывать, но я к этому пока морально не готов. Поэтому, я сделал очередной "<a href="https://github.com/GlukKazan/GlukKazan.github.io/commit/085ec9d99ef18bcee0b6323c82ee6d239411a923">быстрый фикс</a>" и в <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">Фанорону</a>, теперь, можно играть нормально, без сопутствующих чудес. В "<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Русские шашки</a>", кстати, тоже. Там был баг, связанный с реализацией правила "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">турецкого удара</a>", неожиданно легко исправленная <a href="https://github.com/GlukKazan/Dagaz/commit/69b71322cb87011a367b5768850f99f8eeff0650">этим</a> простым фиксом. Так я работаю над ошибками. Так я делаю проект лучше.
</cut>

Dagaz: Подробности

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>В "пи" цифр не пересчитать,
"е" - бесконечно столь же.
А если их с конца писать, какое будет больше?

Мартин Гарднер "Крестики-нолики"</i></b>

Для этой статьи, я хотел выбрать другой эпиграф, но счёл его излишне пафосным. Очередной <a href="https://glukkazan.github.io/index.html">релиз</a> вновь затянулся. За это время, я успел сменить работу! Работа на новом месте отнимает уйму сил, но я продолжаю находить время для своего маленького увлечения. И надо сказать, то, с чем мне приходится сталкиваться в процессе, становится всё сложнее и сложнее. Я расскажу вам об этом. Я хотел начать с другого эпиграфа, но этот тоже неплох.
<cut>
В этот раз, случились новые <a href="https://glukkazan.github.io/mancala/mancala.svg">манкалы</a> и "<a href="https://skyruk.livejournal.com/tag/%D0%B8%D0%B3%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D1%8B">игры-переходы</a>" (это <a href="https://glukkazan.github.io/races/halma-10x10.htm">Хальма</a> и её родственники). Своего рода гонки, в которых надо занять своими фигурами дом противника, раньше него. Фигуры (и свои и чужие) можно перепрыгивать (как в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашках</a>), но никаких взятий нет. Да что я вам объясняю? Наверняка, многие из вас в детстве играли в "<a href="https://glukkazan.github.io/races/halma-8x8.htm">Уголки</a>".

<a href="https://glukkazan.github.io/races/halma-8x8.htm">
<img align="center" src="https://habrastorage.org/webt/m-/tt/uh/m-ttuhd2zzavfm0siq5e0z2hz2q.png" /></a>
На первый взгляд, игра выглядит простой, но проблемы начались уже на уровне ядра. Помните, я <a href="https://habr.com/post/335228/">рассказывал</a> о составных ходах? По многим причинам, их удобнее представлять именно составными - в виде единого целого, а не в виде последовательности частичных ходов. Это более удобно для AI, да и с точки зрения дизайна, существуют игры, описание которых в форме составных ходов выглядит гораздо естественнее. Но есть одна проблема. 

В шашках, при выполнении составного хода, фигуры убираются с доски (возможно по завершении хода). В Уголках - можно прыгать через свои или противника фигуры до бесконечности. Буквально. И никакие расширения здесь не спасают, поскольку всё зацикливается не доходя до них, в ядре, ещё на этапе генерации списка ходов. Пришлось изменять эту логику, реализуя там опцию (<b>detect-loops</b>), о которой вполне стоило бы подумать заранее.

<spoiler title="С ботом всё тоже вышло непросто">
Главная проблема, с этим семейством игр, заключается в том, что не так-то легко подобрать оценочную функцию, адекватно представляющую ситуацию на доске. Поскольку целью игры является достижение "дома" противника, можно оценивать суммарное расстояние от всех фигур до целевых полей (<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D1%85_%D0%BA%D0%B2%D0%B0%D1%80%D1%82%D0%B0%D0%BB%D0%BE%D0%B2">манхэттенское</a> или <a href="https://ru.wikipedia.org/wiki/%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0">евклидово</a> - без разницы), но в Хальме, при удачном стечении обстоятельств, фигуры могут пропрыгать всю доску одним ходом, так что такая оценка мало что даёт.

С целевыми полями тоже не всё ясно. Нельзя направлять все фигуры на одно и то же поле. Первая фигура, которая до него доберётся тут же его и займёт. Идеально было бы определять оптимальные целевые поля для каждой из фигур и двигаться к ним, но это сложно, в вычислительном плане. Кроме того, ситуация на доске с каждым ходом меняется. В общем, я решил не заглядывать далеко вперёд и ограничиться чисто <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/heuristic-ai.js">эвристическим алгоритмом</a>.

<spoiler title="С такой вот оценкой качества хода">
<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  var t = getTargets(design, board, board.player);
  var m = getMove(move);
  var r = 1;
  if (m !== null) {
      if (!design.inZone(0, board.player, m.start)) {
          if (_.indexOf(t.first, m.end) >= 0) {
              r = 1000 + getDistance(t.first, m.start) - getDistance(t.first, m.end);
          }
          if (_.indexOf(t.goal, m.end) >= 0) {
              r = 700 + getDistance(t.first, m.start) - getDistance(t.first, m.end);
          }
          if ((r == 1) && (_.indexOf(t.second, m.end) >= 0)) {
              r = 500 - getDistance(t.second, m.end);
          }
      }
      if (r == 1) {
          if (design.inZone(2, board.player, m.end) && !design.inZone(2, board.player, m.start)) {
              r = 300;
          }
      }
      if (bestFound(design, board, 300)) return -1;
      if (r == 1) {
          var goals = getGoals(design, board, board.player);
          if (!_.isUndefined(goals[m.start])) {
              var goal = goals[m.start];
              if (m.next == goal.next) {
                  r = 100 + distance(goal.end, m.start) - distance(goal.end, m.end);
              }
          }
      }
      if (notBest(design, board, r)) return -1;
      var b = board.apply(move);
      if (isRestricted(design, b, board.player)) return -1;
  }
  return r;
}
</source></spoiler>
Не идеальное решение, но для начала вполне рабочее. Если бот видит ход, которым можно "пропрыгать" в "дом" противника, он выбирает его. В противном случае - постепенно уменьшает расстояние до цели, стараясь избегать заторов. Самая печальная ситуация может случиться если один игрок (случайно или умышленно) оставит свою фигуру в "доме", а другой - "запрёт" её двойным рядом своих фигур.

<spoiler title="Конечно, вероятность такой ситуации довольно низка">
Благодаря правилу, предложенному Сидни Сэксоном - изобретателем и коллекционером игр из Нью Йорка. Его предложение заключается в следующем: если фигура имеет возможность покинуть свой "дом", прыжком через фигуру противника или цепочкой прыжков, начинающейся с такого хода - она обязана это сделать. Я опробовал различные варианты правил, исключающих возможность запирания фигур в их собственном "доме" и нашёл правило Сидни Сэксона наиболее удачным. После выхода из своего "дома", фигура более не может в него возвращаться (хотя и имеет право проходить через него, в процессе выполнения хода).
</spoiler>
На всякий случай, я запрещаю ходы "запирающие" противника (при отсутствии просмотра на много ходов вперёд, можно позволить себе довольно сложные эвристики), устанавливая им отрицательные оценки, но не менее опасна для бота и ситуация "запирания" пустых целевых полей (особенно это заметно в <a href="https://glukkazan.github.io/races/halma-10x10.htm">классической Хальме</a>, с её чисто ортогональными ходами). В общем, этому боту есть куда расти.

В играх, где фигуры разрешается брать, всё ещё более усложняется. И таких игр много! Пожалуй, наиболее известной из них является "<a href="https://glukkazan.github.io/checkers-like/camelot.htm">Камелот</a>", придуманный Джорджем Паркером в 1930 году. Но лично мне куда больше нравится гораздо менее известная игра, построенная на основе той же механики.

<a href="https://glukkazan.github.io/checkers-like/suff.htm">
<img align="center" src="https://habrastorage.org/webt/bs/te/h2/bsteh2xmgo5irtwzrp38xqrqb04.png" /></a>
Эта <a href="https://glukkazan.github.io/checkers-like/suff.htm">игра</a> - сама история! В далёком 1908 году, Суфражистки придумали её для продвижения своих политических взглядов. Здесь есть всё: Палата общин, <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%B1%D0%B5%D1%80%D1%82-%D1%85%D0%BE%D0%BB%D0%BB">Альберт-холл</a>, городская тюрьма и больница. Женщины-<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%84%D1%80%D0%B0%D0%B6%D0%B8%D1%81%D1%82%D0%BA%D0%B8">суфражистки</a> сражаются с полисменами. Их цель - провести 6 своих человек в Палату общин. В свой штаб - Альберт-холл они заходить не могут. Перемещаются фигуры в любом направлении. Также допускаются прыжки через дружеские и вражеские фигуры. 

Серия прыжков, при этом, может быть сколь угодно длинной. Если дело происходит на "арене", вражеские фигуры, при прыжке через них, срубаются и отправляются в тюрьму или больницу. Обычные фигуры рубят только по диагонали, крупные (констебли и лидеры суфражисток) - в любом направлении. Когда в тюрьме и больнице набирается по 6 фигур, их можно "обменять", снова введя в игру. Таким образом, фигуры, как в "<a href="https://glukkazan.github.io/shogi/shogi-board.htm">Сёги</a>" или "<a href="https://glukkazan.github.io/checkers/column-checkers.htm">Столбовых шашках</a>", никогда не покидают игру.
</spoiler>
Вообще, весь этот релиз как раз на тему подобных опций. Например, я наконец-то осилил правильное превращение фигур в <a href="https://glukkazan.github.io/checkmate/chess.htm">Шахматах</a> (до сих пор, все пешки превращались только в ферзей, что вообще говоря, неправильно). Я не стал сильно с этим заморачиваться и отрисовал диалог выбора прямо на канвасе. Получилось неплохо (ещё бы руки дошли сделать так, чтобы они мат от пата отличали, так было бы вообще замечательно).

<a href="https://glukkazan.github.io/checkmate/gardner-chess.htm">
<img align="center" src="https://habrastorage.org/webt/rx/rb/b8/rxrbb87dmkynfbn6kmeeiyofvom.png" /></a>
Другая "ядерная" доработка была связана с улучшением пользовательского интерфейса и имеет свою предысторию. В проекте уже довольно давно существует <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/common-setup-v2.js">механизм</a>, позволяющий кодировать текущую позицию, передавая её через URL. С учётом того, что описания всех состояний игры, в этом формате, записываются в лог, он неплохо помогает в отладке. Вот только пользователю, знать ничего не знающему про лог браузера, пользы от него мало.

<spoiler title="Нет-нет, это не вся польза!">
Существует целый ряд игр, игровой процесс которых состоит из множества (возможно разнородных) этапов. В качестве примера, можно привести популярную игру 2008-го года - <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a>. Каждый этап этой игры (до прохождения одной из фигур на последнюю горизонталь) относительно короткий, но по его завершении, игра продолжается. Игроки, по оговоренным правилам, вновь расставляют свои фигуры на первой линии и снова пытаются достичь последней горизонтали раньше противника (фигура, принесшая победу в предыдущем этапе получает новые способности).

<a href="https://glukkazan.github.io/breakthrough/kamisado.htm">
<img align="center" src="https://habrastorage.org/webt/ls/wj/5s/lswj5shz5vuu-59qxhcpffe9zt8.png" /></a>
Именно этот аспект игры автоматизирует опция "<b>progressive-levels</b>", выполняющая автоматический переход к следующему этапу игры, при победе одного из игроков. А поскольку начальная расстановка фигур от одного этапа к другому различается, она вычисляется модулем <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/common-setup-v2.js">common-setup</a> и передаётся в следующий этап игры через <a href="https://ru.wikipedia.org/wiki/URL">URL</a>.

<a href="https://glukkazan.github.io/custodian/reversi.htm">
<img align="center" src="https://habrastorage.org/webt/tg/ul/oq/tguloquzmgj5yqcq0mnfmofica0.png" /></a>
Рука об руку с этой возможностью идёт другой способ, позволяющий разнообразить начальную расстановку фигур. Опция "<b>selector</b>" позволяет кодировать несколько начальных расстановок (и даже конфигураций доски), в рамках одного <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/other-games/reversi.js">JS-файла</a>. Обновите начальную страницу <a href="https://glukkazan.github.io/custodian/reversi.htm">Reversi</a> и вы поймёте, что я имею в виду.
</spoiler>
Новый подключаемый <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">модуль</a> призван решить проблему. Конструктивно - это обычное дерево, в котором сохраняются все игровые состояния, фигурировавшие когда либо в игровой сессии (а поскольку это дерево, в перспективе, всю историю игры можно будет выгружать в <a href="https://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>-файл). Пользователь имеет возможность "листать" эти состояния, используя кнопки, появляющиеся вверху экрана.

<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">
<img align="center" src="https://habrastorage.org/webt/c6/wf/ee/c6wfeeqzbvrho5kcmsdxq9mhu1i.png" /></a>
Это действительно удобно, но из двух стрелочек, занимающих место наверху, можно извлечь ещё больше пользы. Именно этим и занимается опция "<b>advisor-mode</b>". Если пользователь думает дольше заданного времени, бот, с которым он играет, рассчитывает ход за него и помещает новое игровое состояние в "session-manager". Предложенный ход можно принять, просто нажав кнопку "вперёд". А если ход не понравится, то его всегда можно откатить.

Много радости, в процессе разработки, принёс звук (казалось бы, чего уж проще). Первая <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/sound-manager.js">реализация</a> оказалась слишком наивной. Не знаю с чем это связано, но где-то посредине игры, звук просто переставал проигрываться, без каких либо сообщений в логе. Это проявлялось во всех имеющихся у меня браузерах, пока я не стал кэшировать созданные объекты Sound в памяти. Но тут пришла другая беда.

Если звук проигрывался продолжительный, а бот соображал достаточно быстро (как в <a href="https://glukkazan.github.io/mancala/ohojichi-2x6.htm">манкалах</a>, например), то звук его хода просто "проглатывался", что выглядело крайне неприятно. Здесь шаманить пришлось долго и дело кончилось <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/sound-manager-v2.js">костылями</a>. При установленном флаге "clonable", я всё таки создаю несколько экземпляров Sound, по одному на каждого игрока (пусть и проигрывают они один и тот же звук). Конечно, это никак не помогло с IE, отказывавшимся (очевидно, по религиозным соображениям) иметь дело как с "wav", так и с "ogg" файлами. Этот браузер, у меня, работает бесшумно!

В остальном, релиз прошёл без приключений. Компанию "<a href="https://glukkazan.github.io/races/halma.htm">Хальме</a>" и <a href="https://glukkazan.github.io/mancala/mancala.svg">манкалам</a> составили пара <a href="https://glukkazan.github.io/checkmate/anti-king.htm">игр</a> <a href="https://glukkazan.github.io/checkmate/neutral-king.htm">шахматных</a>, а <a href="https://glukkazan.github.io/shogi/rocket-shogi.htm">также</a> <a href="https://glukkazan.github.io/shogi/leshogi.htm">великое</a> <a href="https://glukkazan.github.io/shogi/ikusa-shogi.htm">множество</a> <a href="https://glukkazan.github.io/shogi/treasure-shogi.htm">вариаций</a> <a href="https://glukkazan.github.io/shogi/hex-kyoto-shogi.htm">Сёги</a>, вычитанных мной в очередном номере "<a href="http://www.tavolando.net/FdA.html">Il fogliaccio degli astratti</a>" и ещё одна простенькая <a href="https://glukkazan.github.io/stalemate/rhombic-chess-variant.htm">игра</a> от китайских товарищей. Ах да, вот ещё что:

<a href="https://glukkazan.github.io/elimination/find-pair.htm">
<img align="center" src="https://habrastorage.org/webt/ey/um/s3/eyums30t7t3genww75fy3yhxlcq.png" /></a>
Просто небольшой тренажёр кратковременной памяти. Надо открывать одинаковые пары (дама с дамой, король с королём и т.п.) одинакового цвета. За это даются очки и на всё про всё 200 кликов. Поскольку к очкам начисляются бонусы (за чередование красной и чёрной масти, например), можно посоревноваться с друзьями на предмет того, у кого память лучше. Дерзайте!

<b><i>И всех с Наступающим Новым Годом!</i></b>
</cut>

Dagaz: Из тумана

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Все это плутни королевы Маб.
Она в конюшнях гривы заплетает
И волосы сбивает колтуном...

Вильям Шекспир</i></b>

Это был долгий <a href="https://glukkazan.github.io/">релиз</a>, но и сделано было немало. Появился <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/session-manager.js">session-manager</a>, позволяющий откатывать ошибочно сделанные ходы. Кое где добавилось звуковое оформление. А ещё, я придумал прикольный <a href="https://glukkazan.github.io/custodian/reversi.htm">способ</a>, позволяющий затолкнуть несколько альтернативных вариантов начальной расстановки в одну игру. И самое главное - я наконец добрался до игр с неполной информацией.
<cut>
Объясню, о чём идёт речь. В привычных нам настольных играх, таких как <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> или <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашки</a>, игроки, в любой момент игры, обладают полной информацией о расположении фигур (своих и противника), правилах их перемещения, целях игры и т.п. Такие игры довольно хорошо изучены и относятся к категории "<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%D1%81_%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B9_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B5%D0%B9">игр с полной информацией</a>". Теперь, представьте себе, что часть этой информации может быть скрыта от игрока.

<a href="https://glukkazan.github.io/shogi/dark-yonin-shogi.htm">
<img align="center" src="https://habrastorage.org/webt/1h/hd/xl/1hhdxlqk7btnosi-jpow5azj-xy.png" /></a>
"Туман войны" - прекрасная иллюстрация темы. По правилам "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B_%D0%B2%D1%82%D1%91%D0%BC%D0%BD%D1%83%D1%8E">Шахмат втёмную</a>", игроки могут видеть не все фигуры противника, а только те, которые размещены на полях, до которых можно добраться одним ходом любой из своих фигур. Я внёс в это правило два дополнения:

<ol>
	<li>Разумеется, игрок всегда видит <b>свои</b> фигуры, но по тому как они отображаются - в нормальном виде или полупрозрачном, он может судить о том, видит ли их противник.</li>
	<li>Исключительно в декоративных целях, я разместил "облака" на тех областях, которые невидимы в настоящий момент.</li>
</ol>
Освоив общий <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/chess/dark-chess-view.js">принцип</a>, я немного увлёкся и наделал огромное количество игр с "туманом войны". Помимо собственно <a href="https://glukkazan.github.io/checkmate/dark-chess.htm">Шахмат</a>, у меня имеются "тёмные" варианты для <a href="https://glukkazan.github.io/xiangqi/dark-xiangqi.htm">Сянцы</a>, <a href="https://glukkazan.github.io/xiangqi/dark-janggi.htm">Чанги</a>, <a href="https://glukkazan.github.io/checkmate/dark-shatranj-1.htm">Шатранджа</a>, <a href="https://glukkazan.github.io/checkmate/dark-sittuyin.htm">Ситтуйина</a> и многих других игр. Есть даже "<a href="https://glukkazan.github.io/elimination/dark-cannon.htm">Пушки втёмную</a>"! Все эти игры объединяет одно: 

<spoiler title="Компьютер жульничает!">
Я даже не пытался вносить изменения в алгоритмы работы ботов для этих игр, поскольку сделал ставку на то, что неравные условия хотя бы частично компенсируют крайне слабую их игру, по сравнению с человеком. Как я уже <a href="https://habr.com/post/353116/">писал</a> ранее, разработка качественного AI для настольных игр является очень непростой задачей. Разумеется, у правил есть исключения. Даже при очень слабой игре бота, человеку будет сложно играть в незнакомую <a href="https://glukkazan.github.io/xiangqi/passive-chess.htm">игру</a>, буквально напичканную ловушками. Что уж говорить о её "тёмном" <a href="https://glukkazan.github.io/xiangqi/dark-passive-chess.htm">варианте</a>
</spoiler>
Однако, в целом, это не очень правильный подход. Хочется видеть бота, умеющего обходиться ровно теми данными, которые имеются у его противника - человека. Почему это важно? Всё очень просто - по тому как играет бот, иногда бывает очень легко догадаться о том, имеет ли он доступ к скрытой информации (подглядывает) или нет. И разумеется, человеку гораздо интереснее играть с тем ботом, который <b>не</b> подглядывает (с другим человеком играть ещё интереснее, но это отдельная история).

И здесь стоит подобрать игру, немножко отличную от Шахмат (поскольку заниматься разработкой "честного" бота играющего в Шахматы "втёмную" я не готов). Таких игр довольно много и нельзя сказать, что они проще чем Шахматы или Шашки. Они просто другие и требуют индивидуального подхода.

<spoiler title="Например">
Есть одна детская игра, с разработкой бота для которой я пока не справился. Называется она "Джунгли" или <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D1%83%D0%BD%D0%B3%D0%BB%D0%B8_(%D0%BD%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0)">Dou Shou Qi</a>. Цель игры - проникновение на вражескую территорию. У каждого из игроков есть "логово" - центральное поле на первой линии. Если в логово войдёт любая из фигур противника - он победил (своими фигурами занимать логово нельзя).

<a href="https://glukkazan.github.io/breakthrough/jungle-board.htm">
<img align="center" src="https://habrastorage.org/webt/l_/rz/cb/l_rzcbk0dmvj5ul8m1e4wdefrny.png" /></a>
Фигуры упорядочены по старшинству. Слон бьёт все фигуры, далее следуют: Лев, Тигр, Леопард, Собака, Волк, Кошка и Крыса. Крыса может бить только слона и другую крысу, кроме того, это единственная фигура, способная перемещаться в воде (в середине доски расположены два водоёма). Тигр и лев могут воду перепрыгивать, но только в том случае, если путь по воде не перекрывает крыса. За исключением прыжков, все фигуры движутся одинаково - на одно соседнее поле по вертикали или горизонтали. Логово окружено ловушками. Фигура в ловушке уязвима для <b>любой</b> фигуры противника.

Как можно видеть, правила довольно простые. Что мешает разработать бота для этой игры? Прежде всего - тихоходность фигур. При наличии угроз, я могу оценить выгоду разменов, но большую часть игры фигуры просто бегают друг за другом на довольно протяжённые расстояния. Я не могу позволить себе просмотр партии на большое число ходов вперёд (из за ограничений на продолжительность расчёта хода), в результате чего размены выпадают за "горизонт" просмотра и все ходы становятся для меня равноценными.
</spoiler>
Для начала, я решил остановиться на <a href="https://en.wikipedia.org/wiki/Banqi">BanQi</a> - китайских "Слепых шахматах". Это весьма оригинальная игра со скрытой информацией, родственная "Джунглям". Для меня важно, что наработки, в связи с созданием бота для этой игры, могут быть использованы и в других играх, таких как <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D1%83%D0%BD%D0%B3%D0%BB%D0%B8_(%D0%BD%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0)">Dou Shou Qi</a>, <a href="https://en.wikipedia.org/wiki/Luzhanqi">Luzhan Qi</a>, <a href="https://en.wikipedia.org/wiki/Stratego">Stratego</a> или даже (возможно) <a href="https://en.wikipedia.org/wiki/Tafl_games">Tafl</a>.

<oembed>https://www.youtube.com/watch?v=bG11at_PKxA</oembed>
Расскажу о правилах. Игра протекает на половине доски для "Китайских шахмат" (<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8">Xiang Qi</a>), при этом, оригинальная разметка доски не играет никакой роли. Фигуры размещаются внутри клеток (как в традиционных), а не на пересечениях линий (как в китайских шахматах). В начале игры, все фигуры тщательно перемешиваются и размещаются на доске лицевой стороной вниз (поскольку  традиционные фигуры Сянцы представляют собой этакие бочонки, а их количество совпадает с количеством полей на половине доски, с этим не возникает трудностей). 

Далее игроки чередуют свои ходы. Выполняя ход, игрок может перевернуть любую из закрытых фигур, либо переместить ранее открытую фигуру своего цвета. Цвета игроков определяются самым первым ходом. Если первой открыта чёрная фигура, открывший её игрок будет играть чёрными. Все фигуры в игре ходят одинаково (за исключением "Пушки" в тайваньском варианте, о которой я скажу позже) - на одну соседнюю клетку по вертикали или горизонтали. Возможность взятия определяется порядком старшинства фигур:

<b>Генерал > Советник > Слон > Повозка > Конь > Пушка > Солдат</b>

Старшие фигуры бьют младших или равных им, за одним исключением: солдат бьёт генерала (своего рода "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C,_%D0%BD%D0%BE%D0%B6%D0%BD%D0%B8%D1%86%D1%8B,_%D0%B1%D1%83%D0%BC%D0%B0%D0%B3%D0%B0">Камень-Ножницы-Бумага</a>"). Осталось сказать пару слов о тайваньском BanQi:

<ol>
	<li>В отличии от китайского варианта, в тайваньском BanQi генерал <b>не</b> может бить солдата.</li>
	<li>Пушка перемещается по правилам <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8#Пушка">XiangQi</a>, то есть на любое число полей по ортогонали тихим ходом (как колесница) или бьёт любую фигуру противника, с прыжком через "лафет", при выполнении атакующего хода.</li>
</ol>
Есть ещё гонконгский вариант, но он практически ничем не отличается от китайского, за исключением того, что изменён порядок старшинства фигур. Я решил сосредоточиться на тайваньском варианте правил, как на наиболее интересном, в тактическом плане.

<spoiler title="На что стоит обратить внимание при разработке бота?">
Во первых, игра выглядит очень простой, но таковой не является. Даже если не рассматривать нюансы, связанные с тайваньскими пушками, стоимость фигур контринтуитивна. Хотя "Советник" может побить меньшее количество фигур чем "Генерал", именно он является главным действующим лицом в игре. Во первых, советников у игрока два. Кроме того, каждого советника превосходит по силе всего один вражеский генерал, в то время как генерала могут атаковать целых пять солдат! По той же причине, стоимость солдата, в игре, выше стоимости генерала. В конце концов, он может побить самую сильную фигуру! Второе важное соображение подсказывает одна из "кентерберийских" головоломок Генри Дьюдени.

<a href="https://glukkazan.github.io/checkmate/catch-pigs.htm">
<img align="center" src="https://habrastorage.org/webt/v9/jd/ax/v9jdaxvmdjxuvp-gw6sr9h7_i8a.png" /></a>
Это скорее задача-шутка, чем полноценная головоломка. Все фигуры могут ходить на одно соседнее поле по вертикали или горизонтали. Белые ходят первыми, при этом, и белые и чёрные всегда делают по два хода (разными фигурами)! В этих условиях, левый шут никогда не сможет поймать левого осла, а правый - правого (можете проверить это самостоятельно). Разумеется, правый шут может поймать левого осла без всякого труда. Всё дело в чётности!

Эта задачка натолкнула меня на некоторые мысли. Во первых, задача бота, в таких играх как BanQi или DouShouQi - это, прежде всего, поиск кратчайшего пути. От каждой из активных фигур (своей или противника) необходимо построить цепочки ходов ко всем возможным целям (в том числе и к своим фигурам, для расчёта возможных разменов). После этого, цепочки необходимо оценить и здесь возможны следующие варианты.

<ol>
	<li>Атакующая фигура бьёт атакуемую - выгодная (бонусная) цепочка оцениваемая стоимостью атакуемой фигуры (за вычетом стоимости атакующей, если последняя находится под защитой), с учётом длины цепочки.</li>
	<li>Атакующая фигура бьётся атакуемой - не выгодная (штрафная) цепочка, оцениваемая стоимостью атакующей фигуры.</li>
	<li>Фигуры бьют друг друга (например равны) - здесь всё зависит от чётности, выгодны нечётные цепочки, а чётные должны рассматриваться как штрафные (если бы других фигур на поле не было, чётность полностью определяла бы итог игры).</li>
</ol>
Разумеется, всё не так просто. Как минимум, следует помнить о специфичном ходе пушек в тайваньском BanQi (Что касается "Джунглей", то там особых случаев ещё больше), но это то, с чего можно начать. Имея полный набор оцененных цепочек, можно оценивать ходы. Стоимость хода должна складываться из стоимостей цепочек (как бонусных так и штрафных), длину которых он уменьшает.
</spoiler>
Прежде всего, важно понимать, что эффективно использовать <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0-%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">минимаксные</a> алгоритмы здесь вряд ли удастся. Ходы, вскрывающие ранее скрытые фигуры, слишком радикально изменяют оценку позиции. Не имея информации о скрытых фигурах, практически невозможно просматривать позицию на много ходов вперёд. Но нет худа без добра, зато мы можем использовать гораздо более сложные (в вычислительном плане) эвристики для оценки самих ходов!

Бот, оценивающий ходы по их эвристике, у меня уже <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/heuristic-ai-v3.js">есть</a> (понадобился для одной забавной <a href="https://glukkazan.github.io/pasang/pasang-01.htm">игры</a>). Это очень простой алгоритм. Все ходы отсортировываются по убыванию эвристики (ходы с отрицательным значением эвристики вообще отбрасываются), после чего просматриваются по порядку. Если очередной ход ведёт в позицию из которого нет ответа противника, ведущего к немедленной победе, бот считает его наилучшим. Используя этот алгоритм можно не заморачиваться оценкой позиции, но над <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/xiangqi/banqi-invariant.js">эвристикой</a> придётся попотеть.

<spoiler title="Прежде всего, строим цепочки">
<source lang="javascript">
var getChains = function(design, board) {
  var player = board.getValue(board.player);
  if (player === null) return [];
  if (_.isUndefined(board.chains)) {
      board.chains = [];
      var pieces   = getGoals(design, board);
      var targets  = getTargets(design, board, pieces);
      _.each(pieces.positions, function(pos) {
          var goals = pieces; var f = true;
          var piece = board.getPiece(pos);
          if (piece === null) return;
          if (!chinese && (piece.type == 12)) {
              goals = targets;
              f = false;
          }
          var group  = [ pos ];
          var level  = [];
          level[pos] = 0;
          for (var i = 0; i < group.length; i++) {
              if (_.indexOf(goals.positions, group[i]) >= 0) {
                   // Строим цепочку...

              }
              if ((i > 0) && (board.getPiece(group[i]) !== null)) continue;
              _.each(design.allDirections(), function(dir) {
                   p = design.navigate(board.player, group[i], dir);
                   while (p !== null) {
                        if (_.indexOf(group, p) >= 0) break;
                        group.push(p);
                        level[p] = level[ group[i] ] + 1;
                        if (f || (board.getPiece(p) !== null)) break;
                        p = design.navigate(board.player, p, dir);
                   }
              });
          }
      });
  }
  return board.chains;
}
</source></spoiler>
Разумеется, я кэширую все промежуточные данные в игровом состоянии, чтобы не считать их по нескольку раз. Кроме того, здесь используется один трюк, весьма полезный при расчёте связных областей. Я выполняю итерации по массиву <b>group</b>, подкладывая в него дополнительные элементы внутри цикла, по мере необходимости. Все сложности связаны с пушками. Для них целями цепочек считаются не сами фигуры, а поля, с которых последние могут быть атакованы.

<spoiler title="Оцениваются цепочки ровно так, как я и говорил">
<source lang="javascript">
var getChainPrice = function(design, board, attacker, attacking, len) {
  var player = board.getValue(board.player);
  if ((player === null) || (attacker == null) || (attacking === null)) return 0;
  if (attacker.player == attacking.player) return 0;
  var isAttacking = isAttacker(design, attacker.type, attacking.type);
  var isAttacked  = isAttacker(design, attacking.type, attacker.type);
  if (!chinese && (attacker.type == 12)) {
      isAttacking = true;
      isAttacked  = (attacking.type == attacker.type) && (len == 1);
  }
  var price = 0;
  var f = (len % 2 == 0);
  if (attacker.player != player) f = !f;
  if (isAttacking) {
      if (isAttacked) {
          price = f ? (len - design.price[attacker.type]) : (design.price[attacking.type] - len);
      } else {
          price = design.price[attacking.type] - len;
          if (f) price = (price / 2) | 0;
      }
  } else {
      if (isAttacked) {
          price = len - design.price[attacker.type];
      }
  }
  return price;
}
</source></spoiler>
... в зависимости от длины и чётности цепочки, а также с учётом стоимостей атакующей и атакуемой фигур. Но это только половина дела! необходимо оценить каждый из возможных ходов, используя построенные цепочки. Я ввожу ещё одну промежуточную структуру - пожелания, чтобы агрегировать имеющиеся данные. Оценка хода складывается из оценок пожеланий, которым он удовлетворяет:

<spoiler title="Как-то вот так">
<source lang="javascript">
var addWish = function(board, comment, price, src, dst) {
  if (_.isUndefined(board.wish[src])) {
      board.wish[src] = [];
  }
  if (_.isUndefined(dst)) dst = src;
  if (_.isUndefined(board.wish[src][dst])) {
      board.wish[src][dst] = price;
  } else {
      board.wish[src][dst] += price;
  }
}

var getWish = function(design, board) {
  if (_.isUndefined(board.wish)) {      
  ...
  }
  return board.wish;
}

Dagaz.AI.heuristic = function(ai, design, board, move) {
  var wish = getWish(design, board);
  if (move.isSimpleMove() &&
      !_.isUndefined(wish[ move.actions[0][0][0] ]) &&
      !_.isUndefined(wish[ move.actions[0][0][0] ][ move.actions[0][1][0] ])) {
      return wish[ move.actions[0][0][0] ][ move.actions[0][1][0] ];
  }
  return 0;
}
</source></spoiler>
Что касается самой функции <b>getWish</b>, то здесь начинается магия (и это то место, где я скорее всего напахал и не один раз). Прежде всего, я разделяю оценку ходов на основе открытой информации и ввод в игру новых фигур. Это не совсем правильно, но пока я просто не знаю как согласовать столь разнородные оценки. Если на основе открытой информации никаких пожеланий сформировано не было, бот пытается открывать новые фигуры (здесь тоже есть некоторые трюки).

<ol>
	<li>Если открыта вражеская пушка, окружённая закрытыми фигурами, имеет смысл открыть одну из фигур рядом с ней, поскольку велика вероятность, что она сможет атаковать пушку, а пушка побить её, в любом случае, не сможет.</li>
	<li>Если открыта фигура отличная от пушки, можно попробовать вскрыть фигуру, расположенную через "лафет" от неё, поскольку есть вероятность, что это окажется пушка.</li>
	<li>При наличии атакующей цепочки со стороны противника, можно вскрыть одну из фигур, по соседству с цепочкой, чтобы перехватить атаку.</li>
	<li>Если защитить фигуру не получается, можно открыть фигуру рядом с ней, попытавшись свести ситуацию к размену.</li>
</ol>
<spoiler title="Разумеется, вероятность открытия той или иной фигуры полезно оценивать">
<source lang="javascript">
var getShadow = function(design, board) {
  var player = board.getValue(board.player);
  if (player === null) return [];
  if (_.isUndefined(board.shadow)) {
      board.shadow = [];
      _.each(design.allPositions(), function(pos) {
           var piece = board.getPiece(pos);
           if ((piece !== null) && (piece.type < 7)) {
               var value = piece.type + 7;
               if (piece.player != player) {
                   value = -value;
               }
               board.shadow.push(value);
           }
      });
  }
  return board.shadow;
}

var isFriend = function(design, x) {
  return x > 0;
}

var isPiece = function(design, x, y) {
  return x == y;
}

var isAttacker = function(design, x, enemy) {
  if (x < 0) return false;
  if ((x == 13) && (enemy == 7)) return true;
  if (!chinese && (x == 7) && (enemy == 13)) return false;
  if (!chinese && (x == 12)) return false;
  return x <= enemy;
}

var isDefender = function(design, x, enemy, friend) {
  if (!isAttacker(design, x, enemy)) return false;
  return design.price[friend] <= design.price[enemy];
}

var estimate = function(design, board, p, y, z) {
  var shadow = getShadow(design, board);
  if (shadow.length == 0) return 0;
  var r = 0;
  _.each(shadow, function(x) {
      if (p(design, x, y, z)) r++;
  });
  return (100 * r) / shadow.length;
}
</source></spoiler>
Игрок может оценивать вероятности, ведя учёт фигур, выбывших из игры. В принципе, то же самое может делать и бот, но есть более простой способ - просмотреть <b>все</b> ещё не открытые фигуры скопом и на основе собранной информации оценивать вероятность открытия желаемой. При этом, не гарантируется успешность выбранного хода, но если вероятность благоприятного исхода низка, ход не будет выбираться вообще.

<spoiler title="В принципе, подход себя оправдал, но ещё есть над чем поработать">
Пока не очень хорошо получаются защитные ходы. Некоторые фигуры отважно идут навстречу более сильному врагу, вместо того чтобы от него убегать (хотя убегать в их случае, как правило, уже бесполезно). Также, есть сложности с координацией действий различных фигур (это может быть полезно, для того чтобы "загнать" остатки фигур противника). Сам подход выглядит очень перспективным, но над эвристиками ещё предстоит подумать.

Эвристики на основе "цепочек" ходов могут быть полезны не только в BanQi, но и во многих других играх, с преобладанием "тихоходных" фигур (если и не в качестве определяющего критерия, то для предварительной оценки качества ходов в более сложных алгоритмах, по крайней мере). Особенно востребован этот подход в тех играх, для которых применение минимаксных алгоритмов затруднено или вообще невозможно (таких как <a href="https://en.wikipedia.org/wiki/Yonin_shogi">Yonin Shogi</a>, например).

<img align="center" src="https://habrastorage.org/webt/k_/x3/dq/k_x3dqvxu3swinw7qkgmvo__6km.png" />
Разумеется, я собираюсь продолжить работу над играми с неполной информацией. На рисунке изображена филиппинская "<a href="https://en.wikipedia.org/wiki/Game_of_the_Generals">Игра генералов</a>", пока ещё не готовая. Это самая простая игра из большого семейства, включающего в себя такие игры как <a href="https://en.wikipedia.org/wiki/Luzhanqi">LuzhanQi</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%BE">Stratego</a>. И конечно, я всё ещё рассчитываю сделать работающего бота для "<a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D1%83%D0%BD%D0%B3%D0%BB%D0%B8_(%D0%BD%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0)">Джунглей</a>"!
</spoiler>
А для тех, кто меня всё ещё читает, могу предложить ещё одну забавную игру-головоломку со скрытой информацией:

<a href="https://glukkazan.github.io/elimination/fox-hunting.htm">
<img align="center" src="https://habrastorage.org/webt/bm/aa/4p/bmaa4p2ctbqb_9k_oz1wjoulx9c.png" /></a>
Я играл в неё в детстве, на программируемом калькуляторе, называется "Охота на лис". На поле случайным образом спрятаны 8 лис, которых надо найти "методом тыка". При выборе пустой области, отображается суммарное количество лис по всем восьми направлениям. Проиграть невозможно, но можно посоревноваться на минимальное количество кликов. И если будете играть в наушниках, убавьте звук. Возможно, я перестарался со звуковыми эффектами.
</cut>

Dagaz: Орда

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Мильоны — вас. Нас — тьмы, и тьмы, и тьмы.
Попробуйте, сразитесь с нами!
Да, скифы — мы! Да, азиаты — мы...
&nbsp;
Александр Блок "<a href="http://slova.org.ru/blok/skify/">Скифы</a>"</i></b>

В предыдущей <a href="https://habr.com/post/358870/">статье</a> я много рассказывал о своих находках в области дизайна и пользовательского интерфейса настольных игр, но тот рассказ пришлось прервать, можно сказать на середине, отчасти по причине большого объёма статьи, отчасти просто потому, что в тот момент я не был готов продолжать его дальше. С тех пор многое изменилось. Новые интересные задачки были решены, а породившие их (не менее интересные) игры были добавлены в <a href="https://glukkazan.github.io/">релиз</a>. Об этом я и хочу рассказать сегодня.
<cut>
<oembed>https://www.youtube.com/watch?v=nWSawKsdTlQ&t=12s</oembed>
Если кто помнит, речь шла об игре "<a href="https://glukkazan.github.io/elimination/abalone.htm">Абалон</a>", разработанной Мишелем Лале и Лораном Леви в 1988 году. Суть её в выталкивании за пределы поля шаров противника. Два шара могут толкать один, а три шара - пару шаров другого цвета. Игрок может перемещать свои шары по доске, как по одному, так и группами, по два или три шара (при этом, три шара должны составлять "ряд"). Что мешало мне сделать эту игру в прошлый раз?

Очевидно, не само групповое перемещение. Одновременное перемещение нескольких фигур, в рамках одного хода, есть даже в <a href="https://glukkazan.github.io/checkmate/chess.htm">Шахматах</a> (<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>). А головоломки "<a href="https://glukkazan.github.io/sliding-puzzles/hughe.htm">Sliding puzzles</a>" просто таки построены на том, чтобы такое перемещение происходило синхронно и плавно. Давайте посмотрим на одну игру, разработанную Робертом Эбботом в 1975 году:

<a href="https://glukkazan.github.io/breakthrough/epaminondas-8x8.htm">
<img align="center" src="https://habrastorage.org/webt/kv/fp/d-/kvfpd-kf--0kt2sproxmbidswpi.png" /></a>
Это похоже на "Абалон". Разница лишь в том, что "ряд" не "выталкивает" фигуру противника с её места, а просто убирает с доски, используя "шахматное" взятие. Победа присуждается тому из игроков, кто сумел провести на последний ряд доски своих фигур больше, чем это удалось сделать его противнику, на тот же момент. Вся игра построена на перемещении "рядов". Добиться победы ходами лишь одиночных фигур вряд ли удастся. Вот как выглядит простой "толкающий" ход.

<spoiler title="ZRF">
<source lang="lisp">
(define push-1 (
  $1 (verify friend?)
  (while friend?
      cascade 
      $1
  )
  (verify not-friend?)
  add
))
</source></spoiler>
Всё дело в волшебном слове <b>cascade</b> - оно заставляет интерпретатор "отпустить" перемещаемую фигуру на текущее поле, взяв оттуда "в руку" другую фигуру (свою или противника - не важно) и продолжить движение, уже с новой фигурой "в руке". За один ход такую операцию можно производить многократно, перемещая, таким образом, неограниченное количество фигур одновременно. Такие (и чуть более сложные) кейсы встречаются и в других играх - "<a href="https://glukkazan.github.io/elimination/cannon.htm">Пушках</a>", "<a href="https://glukkazan.github.io/checkers/dameo.htm">Дамео</a>", "<a href="https://glukkazan.github.io/stalemate/lewthwaite-7x7.htm">Игре Леутуэйта</a>", ...

<a href="https://glukkazan.github.io/elimination/abalone-alien-attack.htm">
<img align="center" src="https://habrastorage.org/webt/ts/cz/0-/tscz0-t_xblqjzzxeolgpa-7cjm.gif" /></a>
С точки зрения пользовательского интерфейса, "толкающие" ходы также реализуются довольно тривиально. Привычная метка целевого поля (зелёненький кружок) появляется на фигуре. Если (по правилам игры) мы можем эту фигуру съесть - едим (шахматное взятие), в противном случае - толкаем. Можно проталкивать ряд и более чем на одно поле вперёд (как в игре Epaminondas). Конечно, кодирование такого хода будет чуть более сложным:

<spoiler title="ZRF">
<source lang="lisp">
(define push-2 (
  $1 (verify friend?)
  (while friend?
      mark
      $1 (verify not-enemy?)
      to back cascade
      $1
  )
  $1 (verify not-friend?)
  add
))
</source></spoiler>
Ключевое слово <b>to</b> (и парное ему <b>from</b>) действует совместно с <b>cascade</b>. Оно означает, что фигуру "из руки" надо поставить на доску уже сейчас, а новую фигуру "взять в руку" чуть погодя, после навигации на другое поле. В общем, "толкающие" ходы - это просто, но в Абалон есть и другая разновидность группового перемещения:

<a href="https://glukkazan.github.io/elimination/abalone.htm">
<img align="center" src="https://habrastorage.org/webt/ta/hn/js/tahnjsqbpx_m2hmguohqdiannb4.gif" /></a>
Я называю их "поперечными" ходами. С точки зрения ZRF-кодирования, в них нет ничего сложного. Проблема именно в пользовательском интерфейсе. Как "сказать" программе о том, что игрок хочет переместить не один шар, а группу, если и тот и другой ход разрешены правилами? Я использую всё тот же "blink", так пригодившийся мне в шашках, для пометки "текущей" фигуры. Только теперь "текущих" фигур в наборе несколько.

Клик по "свободной" фигуре добавляет её в группу в том случае, если существует ход, в котором задействованы все добавленные в группу фигуры (ещё проще не отпускать кнопку, выделяя всю группу одним движением мыши). Если таких ходов нет, просто создаётся новая группа, пока состоящая из одной фигуры. Зелёные круги всегда показываются для последней добавленной фигуры (это, возможно, не очень очевидно, но привыкнуть можно). Повторный клик по любой "блинкающей" фигуре немедленно сбрасывает всю группу.

<spoiler title="Кстати">
Зелёные круги вовсе не обязательно будут появляться просто при наличии "блинкающих" фигур. В некоторых случаях, возможна ситуация, в которой все выбранные фигуры входят в какой-то допустимый ход, но при этом не существует допустимого хода, ограничивающегося перемещением лишь этих выбранных фигур. Звучит немного запутанно, но вот вам иллюстрация:

<a href="https://glukkazan.github.io/breakthrough/taacoca.htm">
<img align="center" src="https://habrastorage.org/webt/d_/3h/me/d_3hmeibopemfxnzcfpmwmvztty.gif" /></a>
В этой <a href="http://www.iggamecenter.com/info/ru/taacoca.html">игре</a> допускаются одновременные ходы только лишь групп из трёх фигур (если фигур осталось меньше, двигаться должны все). Все выбранные фигуры двигаются на один шаг и в одном и том же направлении. Взятие шахматное, свои фигуры мешают перемещению. Для победы, необходимо провести хотя бы одну из своих фигур на последнюю линию, в лагерь противника.

Сама игра, на мой взгляд, не очень интересна, но, с точки зрения кодинга - это настоящее безумие. Любая попытка "честной" генерации всех возможных ходов групп из трёх фигур приводит к комбинаторному взрыву. Приходится хитрить (благо Dagaz это позволяет). Для начала, генерируем все допустимые ходы одиночных фигур. Это просто:

<source lang="lisp">
(define step (
  $1 add
))
</source>
Пока можно даже не проверять возможный бой собственной фигуры, всё это потом! Просто идём во все стороны, куда только возможно. Далее, включаем "<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/breakthrough/taacoca-extension.js">магию</a>". Просто комбинируем все возможные сочетания трёх ходов различных фигур в одном направлении, строя декартово произведение. После этого, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/breakthrough/taacoca-invariant.js">отбрасываем</a> ходы, натыкающиеся на собственные фигуры.

Почему бы не отбросить их сразу? По очень простой причине - фигура имеет право двигаться на занятое поле, если оно освобождается в рамках того же группового хода, а на момент генерации "элементарных" ходов, информация о составе перемещаемых групп отсутствует! Вот за что я так люблю этот проект. Он, время от времени, подкидывает такие вот интересные задачки!
</spoiler>
Перемещение не обязательно должно происходить всего на одно поле, как в Abalone. В игре <a href="https://glukkazan.github.io/breakthrough/ordo.htm">Ordo</a> (и в особенности в <a href="https://glukkazan.github.io/breakthrough/ordo-x.htm">Ordo X</a>), придуманной Дитером Штейном в 2009 году, группы фигур могут перемещаться и на гораздо более дальние расстояния. Единственное условие - фигуры своего цвета, по завершении хода, не должны разделяться (это такой же инвариант игры как и необходимость ухода королём из под угрозы в Шахматах). Побеждает игрок первым добравшийся до последней линии доски.

<a href="https://glukkazan.github.io/breakthrough/ordo-x.htm">
<img align="center" src="https://habrastorage.org/webt/e9/es/o2/e9eso2wtosdaokcmbftoppjdwqq.gif" /></a>
В этой игре есть и продольные и поперечные ходы "рядов" фигур любого размера и на любую дистанцию (в пределах доски, конечно). Шаблонов, применяемых для генерации ходов, так много, что обработка <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/breakthrough/ordo.zrf">ZRF-файла</a>, разработанным мной <a href="https://github.com/GlukKazan/Dagaz/tree/master/utils/z2j">конвертером</a>, занимает более 5 минут (большинство игр обрабатываются за секунды)! Можно было бы предположить, что это приведёт к проблемам на этапе генерации ходов, но это не так. Подавляющая часть ходов отсекается <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/breakthrough/ordo-extension.js">инвариантом</a> игры.

<spoiler title="Здесь подвернулась ещё одна мозголомная задачка">
Дело в том, что разработанный мной механизм поочерёдного выделения фигур, для выполнения группового хода, вообще говоря, несовместим с интерфейсом "толкающих" ходов, реализуемым старыми версиями контроллера. Это просто - для выполнения "толкающего" хода, необходимо выделить фигуру, имеющую возможность сходить на поле, пока что занятое другой фигурой перемещаемой группы. Но мы не можем отобразить её целевое поле, поскольку формирование группы не завершено, а ход одиночной фигуры на занятое поле, скорее всего, запрещён правилами игры.

В общем, если всё делать "по правилам", надо поочерёдно кликнуть по всем фигурам перемещаемой группы и только после этого интерфейс отобразит целевые поля для последней добавленной фигуры. Даже в Абалоне, с его группами максимум из трёх фигур это несколько утомительно, а в Ордо - вообще немыслимо! Пришлось придумывать специальный метод, автоматически "расширяющий" группу при обнаружении описанных выше конфликтов.

<spoiler title="Вот как он выглядит для Abalone">
<source lang="javascript">
Dagaz.Model.closure = function(board, move, group) {
  var r = [];
  _.each(group, function(pos) {
      r.push(pos);
  });
  for (var i = 0; i < r.length; i++) {
      var pos = r[i];
      _.each(move.actions, function(a) {
          if ((a[0] !== null) && (a[1] !== null) && (a[0][0] == pos)) {
              var p = a[1][0];
              var piece = board.getPiece(p);
              if ((piece !== null) && (piece.player == board.player) && 
                  (_.indexOf(r, p) < 0)) {
                  r.push(p);
              }
          }
      });
  }
  return r;
}
</source></spoiler>
Но в Ордо допустимы длинные "толкающие" ходы и этот алгоритм не работает! Не беда - все функции, определённые в Dagaz.Model, можно переопределять.

<spoiler title="Таким вот образом">
<source lang="javascript">
Dagaz.Model.closure = function(board, move, group) {
  var design = board.game.design;
  var r = [];
  _.each(group, function(pos) {
      r.push(pos);
  });
  for (var i = 0; i < r.length; i++) {
      var pos = r[i];
      _.each(move.actions, function(a) {
          if ((a[0] !== null) && (a[1] !== null) && (a[0][0] == pos)) {
               var target = a[1][0];
               var x   = Dagaz.Model.getX(pos);
               var y   = Dagaz.Model.getY(pos);
               var dx  = sign(Dagaz.Model.getX(target) - x);
               var dy  = sign(Dagaz.Model.getY(target) - y);
               var dir = design.findDirection(pos, pos + (dy * Dagaz.Model.WIDTH) + dx);
               if (dir !== null) {
                   while ((pos !== null) && (pos != target)) {
                       var piece = board.getPiece(pos);
                       if ((piece === null) || (piece.player != board.player)) break;
                       if (_.indexOf(r, pos) < 0) {
                           r.push(pos);
                       }
                       pos = design.navigate(board.player, pos, dir);
                   }
               }
          }
      });
  }
  return r;
}
</source></spoiler>
Проще всего эта перегрузка выглядит для <a href="http://www.iggamecenter.com/info/ru/taacoca.html">Такоки</a>. Поскольку в ней "толкающих" ходов нет (всегда необходимо явно выделять все фигуры входящие в группу), достаточно заблокировать эту функциональность, то есть, просто не расширять группу:

<source lang="javascript">
Dagaz.Model.closure = function(board, move, group) {
  return group;
}
</source>
Извиняюсь за такое никому ничего не говорящее имя функции. Просто не смог придумать лучшего названия для выполняемого действия.
</spoiler>
<a href="https://glukkazan.github.io/elimination/gess-board.htm">
<img align="center" src="https://habrastorage.org/webt/w0/ao/0l/w0ao0ly48ozfetiaojn5ilq9wum.png" /></a>
В этой <a href="https://en.wikipedia.org/wiki/Gess">игре</a> также реализовано групповое перемещение, но его механика совершенно иная! Здесь фигуры передвигаются группами 3x3, причём, частью перемещаемого "паттерна" являются и пустые поля группы тоже. Наличие фигур на одном из восьми внешних полей показывает направления, в которых можно перемещаться, а заполненность центрального поля определяет, можно ли двигать "паттерн" на произвольное или лишь на короткое расстояние, не более 3 шагов. Для победы, необходимо разрушить "кольцо" противника - аналог королевской фигуры (это пустое поле, со всех сторон окружённое восемью заполненными). Приходится быть очень осторожным, чтобы не разрушить и своё кольцо тоже. 

<a href="https://glukkazan.github.io/elimination/gess-board.htm">GESS</a> оказался настоящим кошмаром, как с точки зрения "<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/other-games/gess-extension.js">магии</a>", так и в плане самого <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/other-games/gess.js">прототипа</a> - скелета игры. Достаточно лишь сказать, что доска (20x20, с учётом ряда полей за границей доски) состоит из двух слоёв. Весь верхний слой полностью заполнен невидимыми фигурами, управляющими перемещением. Передвижения камней, составляющих "паттерны" игроков - всего лишь побочные эффекты этих ходов. К сожалению, я пока не справился с разработкой бота для этой игры.

<oembed>https://www.youtube.com/watch?v=hBuolYNV1Oo</oembed>
В завершение статьи, хочу познакомить вас с ещё кое чем, не имеющим непосредственного отношения к теме группового перемещения фигур. Эту <a href="https://glukkazan.github.io/checkers/magyar-dama.htm">игру</a> меня попросил сделать один из подписчиков моей <a href="https://www.facebook.com/DagazGames/">странички</a> проекта - Sultan Ratrout. В общем-то, это обычные <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">столбовые шашки</a> на гексагональной доске. Даже без дамок. Революционность концепции в другом! Само поле игры - трансформируемое! Наслаждайтесь.

<b><i>А я отправляюсь в отпуск...</i></b>
</cut>

Сага опций

<a href="http://kalevala.onegaborg.eu/"><img align="left" src="https://habrastorage.org/webt/pw/kh/6z/pwkh6z-xc1coitp894f8kg1cxrw.png" /></a><b><i>Чтоб я вновь устроил Сампо,
Сделал короб многострунный,
Вновь пустил на небо месяц,
Солнцу снова дал свободу...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Калевала"</i></b>

Настольные игры выглядит очень привлекательно для начинающих разработчиков. Здесь нет необходимости в построении фотореалистичных изображений и применении сложных шейдеров (хотя никто не запрещает <a href="https://habr.com/post/359356/">этим заниматься</a>). Даже использование 3D, в подавляющем большинстве игр, вовсе не обязательно. Сложность настольных игр сосредоточена на не визуальных составляющих. Пользовательский интерфейс выглядит простым и до предела примитивным.

Вот только... он таковым не является! Сегодня я хочу рассказать о своём опыте в разработке дизайна пользовательского интерфейса настольных игр, накопленном более чем за год работы.
<cut text="Осторожно, анимированные картинки ...">
Моё серьёзное увлечение настольными играми началось с момента знакомства с <a href="http://www.zillions-of-games.com/index.html">Zillions of Games</a>. Я уже много писал об этом уникальном продукте, позволяющем мастерить компьютерные настольные игры, буквально "на коленке". Напомню лишь, что именно эта программа послужила прототипом <a href="https://github.com/GlukKazan/Dagaz/">Dagaz</a> - свободного и бесплатного продукта, разработкой которого я занимаюсь в настоящее время.

Я многому научился у ZoG и этот <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">опыт</a> послужил надёжным фундаментом для моей собственной разработки. Очень многое в ZoG мне не нравилось и именно это побудило меня к работе. Кое что было переделано, но в основе продолжают лежать концепции Zillions of Games. Например, такие как:

<spoiler title="Опции">
Это просто настройки, изменяющие те или иные аспекты "поведения" ядра Zillions of Games. Некоторые из них чисто декоративные (например, используя опцию "animate captures", можно отключить "улетание" взятых фигур вверх, зачем-то работающее по умолчанию), но часть из этих настроек важна настолько, что без них корректная работа многих игр была бы невозможна. Перечислю наиболее важные из них:

<ul>
	<li><b>"pass turn"</b> - Это можно изменить, но в большинстве игр участвуют по двое игроков, ходы которых чередуются. Выполнение хода является обязательным и его невозможность приводит к немедленному завершению игры (не обязательно к поражению). Не все игры таковы. Например, в <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> игрок имеет право "пасовать", пропуская ход, что является важным аспектом правил игры. Во многих играх, таких как <a href="https://glukkazan.github.io/custodian/reversi.htm">Reversi</a>, игрок обязан пропустить ход, если не имеет возможности сходить по правилам. Опция "pass turn" управляет этой возможностью.</li>
	<li><b>"pass partial"</b> - Более сложная вариация предыдущей опции предназначенная для игр с составными (частичными, в терминологии ZoG) ходами. По умолчанию, начав цепочку взятий (в таких играх как <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашки</a>), игрок обязан завершить её до конца (то есть, продолжать брать фигуры, пока есть такая возможность). Обычно, это правило сочетается с приоритетом взятия (игрок обязан брать фигуру противника, если есть такая возможность). Мне известна единственная традиционная <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">игра</a>, взятие в которой обязательно при том, что цепочку взятий можно прерывать. Без опции "pass partial", реализовать её в Zillions корректно было бы невозможно.</li>
	<li><b>"maximal captures"</b> - Это хитрая опция! Само по себе то, что мы обязаны до конца продолжать цепочку взятий, вовсе не заставляет нас брать максимальное количество фигур! Выполняя очередное взятие, мы можем "свернуть не туда" и завершить цепочку по более короткой ветви. Опция "maximal captures" не даст нам этого сделать. Без неё, возникли бы проблемы с реализацией "<a href="https://glukkazan.github.io/checkers/international-checkers.htm">Международных шашек</a>"!</li>
	<li><b>"recycle captures"</b> - В Zillions of Games довольно сложно реализованы drop-ходы (добавление новых фигур на доску). В частности, для всех фигур, участвующих в таких ходах, должны быть указаны специальные счётчики, учитывающие количество фигур этого типа "за пределами" доски (это делается при помощи ключевого слова "off"). Опция "recycle captures" возвращает взятые фигуры в соответствующие им off-счётчики, в результате чего их можно помещать на доску повторно. Это редко используемая опция, но когда она действительно нужна - без неё не обойтись.</li>
	<li><b>"include off-pieces"</b> - Ещё одна опция, связанная off-счётчиками. Результат некоторых игр определяется подсчётом количества фигур, находящихся у игроков, но в играх с drop-ходами, такими как <a href="https://glukkazan.github.io/custodian/seega.htm">Seega</a>, необходимо подсчитывать и те фигуры, которые ещё не выставлены на доску! Опция служит именно для этого.</li>
</ul>
Я думаю, вы уловили мысль. Большинство игр можно реализовать без всего перечисленного, но если требуется что-то особенное - приходится подключать опции. Для Zillions of Games это хардкод! Причём, даже в большей степени чем вы думаете. Например, опция "pass turn", помимо всем понятных <b>false</b> и <b>true</b> включает в себя "<b>forced</b>", а "maximal captures", для "<a href="https://glukkazan.github.io/checkers/italian-checkers.htm">Итальянских шашек</a>", так и вовсе, включается значением "<b>2</b>" (в этой игре, дамки считаются "более равными", чем все остальные).

В Dagaz, я расширил механизм опций. Конечно, в тех случаях, когда можно обойтись глобальными флагами, я так и делаю, но "maximal-captures", например, кодирует очень сложное поведение, связанное с подсчётом фигур. Эта опция реализована <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/maximal-captures.js">расширением</a> игры. Более того, тот же подход позволил мне реализовать новые опции, спрятав, например, в "<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/deferred-captures.js">deferred-captures</a>" сложную логику "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>", в Zillions традиционно кодируемую крайне непростым образом.
</spoiler>
<img align="center" src="https://habrastorage.org/webt/a1/x1/zc/a1x1zcyuwggbqqwa91vp-h8jk1s.gif" />
Как я уже писал выше, пользовательский интерфейс ZoG выглядит очень простым. Указываем мышью, какую фигуру собираемся перетащить (при этом, подсвечиваются те поля, на которые можно переместиться), после чего перетаскиваем фигуру на новое поле. Здесь есть два момента, которые мне не нравятся. Первый связан с мобильными устройствами, на которых Dagaz, худо-бедно, работает, а Zillions of Games нет.

На сенсорных экранах, указатель мыши успешно заменяется пальцем. Но это означает, что пока мы на что-то нажимаем, этот самый палец загораживает добрую половину экрана. В результате, разглядеть подсветку полей становится затруднительно. Когда палец отрывается от экрана, подсветка исчезает. Это кажется очевидным, но поскольку я, в основном, отлаживал Dagaz на десктопе, то далеко не сразу догадался, до чего же дьявольски неудобно приходится пользователям мобильных устройств.

<a href="https://glukkazan.github.io/elimination/elehunt-easy-board.htm">
<img align="center" src="https://habrastorage.org/webt/ob/9t/xi/ob9txikmogl6pnh2lsqlwgcoovi.png" /></a>
Второй момент связан с "перетаскиванием" фигур по экрану. Дело в том, что далеко не во всех играх фигура состоит из одного "куска". В такой ситуации, "Drag & Drop" всё портит. На Zillions of Games <a href="https://glukkazan.github.io/index.html#sliding">подобные игры</a> выглядят просто ужасно. Это главная причина, по которой я отказался от перетаскивания. В Dagaz, нажатие на фигуру включает "подсветку" целевых полей, а последующее нажатие на целевое поле запускает перемещение. Для мобильных устройств, это вдвойне хорошо,  поскольку второе нажатие является своего рода "подтверждением" - пока оно не выполнено, можно отказаться от хода, выбрав другую фигуру.

<spoiler title="Кстати">
С этим механизмом связана ещё одна довольно спорная опция, включенная в Zillions of Games по умолчанию - "<b>smart moves</b>". Суть её довольно проста - если вы выбираете фигуру, для которой имеется единственный допустимый ход, то этот ход выполняется немедленно, без всякого "перетаскивания" по доске. То же работает для целевых полей, на которые ведёт единственный допустимый, в текущей ситуации, ход. Это может здорово сэкономить время, но если вы играете в сложную, малознакомую игру, скорее всего, только приведёт к проблемам. Тем не менее, в разнообразных <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%BA%D0%B0%D0%BB%D0%B0">манкалах</a> такая настройка попросту незаменима.

<a href="https://glukkazan.github.io/mancala/toguz-kumalak.htm">
<img align="center" src="https://habrastorage.org/webt/xi/ue/sw/xiueswst30e63adcd5cazmc6fvw.png" /></a>
В Dagaz я разделил "smart-moves" на две настройки: "from", используемую во всех манкалах и головоломках с движущимися кусками и "to", для которой нашлись применения в "<a href="https://glukkazan.github.io/sokoban/sokoban-01.htm">Сокобане</a>" и ещё <a href="https://glukkazan.github.io/renju/gomoku-knights.htm">одной игре</a>. Разумеется, значение "true" включит обе настройки сразу, но вряд ли имеет смысл это делать в подавляющем большинстве игр. Специально для "Сокобана" я сделал ещё и альтернативный <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sokoban/keyboard.js">модуль</a>, позволяющий управлять игрой при помощи стрелок компьютерной клавиатуры.
</spoiler>
<a href="https://glukkazan.github.io/checkmate/platform-chess-board.htm">
<img align="center" src="https://habrastorage.org/webt/qd/pa/us/qdpaussfcwvvgyi05_jpoojnusy.png" /></a>
Завершая разговор о наследии Zillions of Games, хочется рассказать о ещё одном важном механизме. Обратите внимание на жёлтые прямоугольники на картинке. Именно они определяют, какая фигура будет выбрана, при нажатии мышью. В этом и заключается проблема. Если фигуры расположены в два (и более) слоя, регион, расположенный выше, всегда будет перехватывать нажатие мышью, независимо от того, есть в нём фигура или нет. По пальцам невозможно пересчитать, сколько раз мне это мешало! Разумеется, в Dagaz это исправлено.

<a href="https://glukkazan.github.io/races/hanoi-5.htm">
<img align="center" src="https://habrastorage.org/webt/-e/qs/dy/-eqsdyrbyfhylr3dianfmskxpjg.gif" /></a>
В некоторых играх ("<a href="https://glukkazan.github.io/control/gala.htm">Фермерских шахматах</a>", например) очень важно, чтобы анимация перемещения фигур выполнялась по определённой траектории. Перенос фигур "по прямой" может существенно затруднить понимание правил игры. Здесь возможны различные подходы, но я исходил из того, что модель должна "знать" только начальную и конечную позиции перемещения. Всё остальное находится в ведении представления игры. В конфигурации представления определяются "вектора", связывающие отдельные позиции, а его задача, получив пару позиций от модели - автоматически построить последовательность связывающих их "векторов", для анимации перемещения.

<spoiler title="Анимация перемещения фигур в ''Ханойских башнях''">
<source lang="javascript">
view.addVector(Dagaz.Model.stringToPos("a1"), Dagaz.Model.stringToPos("a6"));
view.addVector(Dagaz.Model.stringToPos("a2"), Dagaz.Model.stringToPos("a6"));
view.addVector(Dagaz.Model.stringToPos("a3"), Dagaz.Model.stringToPos("a6"));
view.addVector(Dagaz.Model.stringToPos("a4"), Dagaz.Model.stringToPos("a6"));
view.addVector(Dagaz.Model.stringToPos("a5"), Dagaz.Model.stringToPos("a6"));
...
</source></spoiler>
<a href="https://glukkazan.github.io/custodian/brandubh.htm">
<img align="center" src="https://habrastorage.org/webt/jj/_a/jm/jj_ajmkid0_zpythpyk28brxwwk.png" /></a>
Часто бывает полезно иметь возможность дать игроку визуальную подсказку о целях игры. Иногда (как на рисунке выше), доска сама по себе является подсказкой, но если этого недостаточно (как в <a href="https://glukkazan.github.io/sliding-puzzles/mothers.htm">головоломках</a> с движущимися кусками, например), поможет ещё одна, унаследованная от Zillions, "декоративная" опция. Если "<b>highlight-goals</b>" активирована, при наведении на фигуру указателя мыши, будут подсвечены те позиции, на которые её следует провести.

Продолжая тему визуальных "подсказок" игроку, стоит рассказать о ещё одной новой опции Dagaz. В играх со сложными составными ходами очень легко "потеряться", забыв (или не поняв), что фигура ещё не завершила свой ход полностью. Реализуя настройку "show-blink", я решил не перегружать дизайн новыми цветовыми пометками, а использовать анимацию, для выделения фигуры, выполняющей ход.

<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">
<img align="center" src="https://habrastorage.org/webt/4h/pg/se/4hpgsezni8dh1gngpbzm0bzkugy.gif" /></a>
Это решение может показаться избыточным, но здесь важно понимать, что реализуя эту опцию, я ориентировался, в основном, вовсе не на шашки. Существует множество гораздо более сложных игр с составными ходами, например таких как "<a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">Ko Shogi</a>" или "<a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">Tenjiku Shogi</a>". Даже хорошо зная правила, на таких досках очень легко "заблудиться". А есть и такие <a href="https://glukkazan.github.io/races/hanga-roa-board.htm">игры</a>, дизайн составного хода которых непривычен совершенно:

<a href="https://glukkazan.github.io/races/hanga-roa-board.htm">
<img align="center" src="https://habrastorage.org/webt/fa/by/rj/fabyrja5kjgjun63xshsunydosq.gif" /></a>
Тесно связан с этой темой и вопрос индикации взятия фигур. Если взятие в игре шахматное или игра всем знакома (как шашки, например) - особых проблем нет, но даже в Шахматах забираемая фигура <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">не всегда</a> располагается на том поле, где завершается ход. А если игра <a href="https://glukkazan.github.io/custodian/gwyddbwyll.htm">менее знакома</a>, индикация потенциальных взятий становится жизненно важной. Более того, в некоторых играх должна предоставляться возможность <b>выбора</b> группы захватываемых фигур:

<a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">
<img align="center" src="https://habrastorage.org/webt/w2/zr/xf/w2zrxfku5fs-aklwv3983gcfk4w.gif" /></a>
В мадагаскарской <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанороне</a>, существует два типа хода со взятием: в первом случае, фигура (или группа фигур) забирается приближением к ней, во втором - отступлением. В игре возможны ситуации, в которых игрок должен выбрать, каким образом осуществляется захват. Всё ещё более осложняется тем, что этот захват может быть встроен в цепочку составного хода. Также, возможность выбора захватываемых фигур востребована в играх с "бонусным" взятием, таких как "<a href="https://glukkazan.github.io/morris/windmill.htm">Мельница</a>", "<a href="https://glukkazan.github.io/checkers-like/yote.htm">Йотай</a>" или "<a href="https://glukkazan.github.io/arrange/bolotoudou.htm">Болотуду</a>".

Как и в случае с "show-blink", я решил не перегружать интерфейс цветовыми пометками, а отображать потенциальные взятия полупрозрачными фигурами. Аналогичным образом показываются drop-ходы. Фигура, добавляемая на доску drop-ходом, отображается в полупрозрачном виде при прохождении указателя мыши над соответствующей позицией (к сожалению, такая индикация не работает на мобильных устройствах).

<a href="https://glukkazan.github.io/checkers-like/bagh-chal.htm">
<img align="center" src="https://habrastorage.org/webt/1g/je/lv/1gjelvuw8ll-_061wacqbolt36q.png" /></a>
В некоторых случаях, правилами игры drop-ходы разрешены не во все позиции. Если разрешённых для хода позиций немного, для того, чтобы не вводить игрока в заблуждение, имеет смысл отобразить на доске все допустимые ходы. Это хорошо работает в таких играх как <a href="https://glukkazan.github.io/custodian/reversi.htm">Reversi</a> и <a href="https://glukkazan.github.io/renju/renju.htm">Renju</a>, с её дебютным регламентом:

<a href="https://glukkazan.github.io/renju/renju.htm">
<img align="center" src="https://habrastorage.org/webt/p6/d_/st/p6d_stk4akgsnowffa-isgajvxi.gif" /></a>
Очень часто, запрещённых ходов гораздо меньше чем разрешённых (это относится к <a href="https://renju.su/pravila/vvedenie-v-pravila-rendzyu-foly/">фолам в Рендзю</a>, например). Запрещённые позиции необходимо помечать, чтобы не вводить игрока в заблуждение. Я не стал придумывать ничего нового и использовал известное многим игрокам обозначение "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE">Ко</a>".

<img align="center" src="https://habrastorage.org/webt/6v/dt/xz/6vdtxzp6nlklgc6pxqlnwdsvgm4.png" />
В <a href="https://glukkazan.github.io/renju/renju.htm">Renju</a>, <a href="https://glukkazan.github.io/arrange/ningxia-fangqi-board.htm">Fangqi</a> и <a href="https://glukkazan.github.io/renju/ninuki-renju.htm">подобным</a> <a href="https://glukkazan.github.io/arrange/xinjiang-fangqi-board.htm">им</a> играх таких квадратиков на доске может быть больше одного. Также имеется некоторая сложность, связанная с перемещением фигур. В играх семейства "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельница</a>", может действовать правило, запрещающее построение одного и того же ряда два раза подряд. При этом, не вполне правильно помечать только пустое поле, достраивающее ряд, поскольку ход в эту позицию может быть допустим, если он ведёт к построению <b>другого</b> ряда. В этом случае, имеет смысл помечать все фигуры, составляющие форму:

<a href="https://glukkazan.github.io/morris/windmill.htm">
<img align="center" src="https://habrastorage.org/webt/lc/gw/pr/lcgwpr-iptzqjbf_3rdditky430.gif" /></a>
Вот такая у меня получилась "<a href="https://glukkazan.github.io/morris/windmill.htm">Мельница</a>". <a href="https://glukkazan.github.io/morris/nine-man-morris.htm">В</a> <a href="https://glukkazan.github.io/morris/morabaraba.htm">ассортименте</a>. А ещё пара <a href="https://glukkazan.github.io/arrange/ningxia-fangqi-board.htm">похожих</a> <a href="https://glukkazan.github.io/arrange/xinjiang-fangqi-board.htm">игр</a> от китайских товарищей и, конечно же, "<a href="https://glukkazan.github.io/arrange/bolotoudou.htm">Болотуду</a>". Разумеется, это не конец истории. Например, я очень хочу сделать вот <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D0%B0%D0%BB%D0%BE%D0%BD_(%D0%B8%D0%B3%D1%80%D0%B0)">эту</a> игру. Правда, одними только опциями здесь дело уже не ограничится.
</cut>

Dagaz: Ищем таланты

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Делай с нами, 
делай, как мы, 
делай лучше нас!

Телепередача 80-ых</i></b>

Должен признаться, я не очень хорош в разработке ботов. Уверен, есть люди, умеющие это делать гораздо лучше меня. И я бы очень хотел, чтобы такие люди присоединились к <a href="https://glukkazan.github.io/">проекту</a>. В плане материального поощрения, предложить я могу немногое. Dagaz был задуман как бесплатная и общедоступная альтернатива <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Сам я <a href="https://github.com/GlukKazan/Dagaz/blob/master/LICENSE.txt">не против</a> его коммерческого использования, просто пока не придумал, как это можно сделать.

Проект, безусловно, продолжит развиваться и останется бесплатным (в своей основе). Любого человека, внесшего свой вклад в его развитие я буду считать своим другом и соавтором. Разумеется, указание авторства, для всех модулей, в разработке которых эти люди приняли участие, будет обязательным. Кроме того, я готов оказать любую посильную техническую помощь по проекту. Например, я могу рассказать о том, как разрабатывать игровых ботов.
<cut>
Прежде всего, стоит заметить, что далеко не для всех игр вопрос разработки ботов стоит остро. В случае головоломок, бот, умеющий находить решение - скорее роскошь, чем жизненная необходимость. Кроме того, существуют игры, в силу объективных причин, гораздо более сложные для человека, чем для компьютера. В полной мере это относится к различным <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%BA%D0%B0%D0%BB%D0%B0">манкалам</a>.

<a href="https://glukkazan.github.io/mancala/oware.htm">
<img align="center" src="https://habrastorage.org/webt/qi/z1/ln/qiz1lnlnc1ozddwvwrrwflmyaue.png" /></a>
Победить у компьютера в такой игре тяжело. И это не потому, что вы не умеете в неё играть! Я знаю человека, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">который умеет</a>. Так вот, победил он далеко не с первой попытки и с очень небольшим перевесом. И это при том, что в ней используется далеко не самый удачный <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/maxmin-ai-v2.js">бот</a>, гораздо более скромно проявляющий себя в <a href="https://glukkazan.github.io/shogi/mini-shogi.htm">других играх</a>. Манкалы словно бы специально созданы для компьютеров! Но дело не только в них.

<a href="https://glukkazan.github.io/elimination/fox-and-geese-british.htm">
<img align="center" src="https://habrastorage.org/webt/fg/gm/g0/fggmg0kr1urxyhydfdfg0ybb4hs.png" /></a>
Здесь бот ещё <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/aggressive-ai.js">проще</a>, но сама <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%B0_%D0%B8_%D0%B3%D1%83%D1%81%D0%B8">игра</a> ассиметрична. Задача "лисы" (есть всё, что только возможно) гораздо проще задачи "гусей" (зажать "лису", лишив её хода) и за "лису" играет компьютер. Если кому-то удастся у него выиграть, сообщите. Потому что мне это пока не удалось. Сам процесс вроде понятен, но постоянно упускаешь из виду какую нибудь "мелочь". 

<oembed>https://www.youtube.com/watch?v=6ZeUV8cH8sI</oembed>
Также, имеются игры, с которыми боты вполне справляются, хотя могли бы играть гораздо лучше. <a href="https://glukkazan.github.io/custodian/reversi.htm">Reversi</a> - отличный тому пример. Уверен, человеку, хорошо играющему в эту игру, справиться с ботом будет не трудно, но для меня, например, это непосильная задача. Увы, с большей частью наиболее популярных игр мои боты не справляются совершенно. Вот список тех из них, для которых эта проблема наиболее актуальна:

<ol>
	<li>Шашки - в первую очередь "<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Русские</a>", "<a href="https://glukkazan.github.io/checkers/international-checkers.htm">Международные</a>" и "<a href="https://glukkazan.github.io/checkers/frisian-checkers.htm">Фризские</a>". Боты с ними, в принципе, работают, но играют на уровне очень слабого новичка. Также очень интересны "<a href="https://glukkazan.github.io/checkers/turkish-dama.htm">Турецкие шашки</a>", здесь боты играют ещё хуже. Самого пристального внимания заслуживают "<a href="https://glukkazan.github.io/checkers/column-checkers.htm">Столбовые шашки</a>" и "<a href="https://glukkazan.github.io/checkers/laska.htm">Ласка</a>". Это действительно сложные и очень интересные игры!</li>
	<li><a href="https://glukkazan.github.io/checkmate/chess.htm">Шахматы</a> и всё что на них <a href="https://glukkazan.github.io/checkmate/chess.svg">похоже</a>. В эти игры, все мои боты играют совершенно отвратительно. То же относится к "<a href="https://glukkazan.github.io/xiangqi/xiangqi.svg">Китайским</a>" и, в ещё большей степени, "<a href="https://glukkazan.github.io/shogi/shogi.svg">Японским</a>" шахматам. Здесь, я не говорю о "<a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">больших</a> <a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">играх</a>", разработка ботов для которых довольно специфична и в которые мало кто играет (я знаю таких людей). В первую очередь, для меня интересны наиболее популярные варианты. <a href="https://glukkazan.github.io/checkers/cheskers.htm">Шашматы</a> также в приоритете. Их вообще стоит вынести в отдельную категорию, поскольку они взяли всё самое сложное "из обоих миров". В первую очередь, меня интересуют "<a href="https://glukkazan.github.io/checkmate/belarusian-chess.htm">Белорусские шахматы</a>" и "<a href="https://glukkazan.github.io/checkers/shatra-board.htm">Алтайская шатра</a>". Любители совсем уж хардкорной экзотики могут опробовать свои силы на "<a href="https://glukkazan.github.io/checkmate/platform-chess.htm">Платформенных шахматах</a>".</li>
	<li>Постановочные игры, прежде всего "<a href="https://glukkazan.github.io/renju/renju-board.htm">Рендзю</a>" и "<a href="https://glukkazan.github.io/go/go-19x19-board.htm">Го</a>". Это очень свежая тема, в том смысле, что я вот только что к ним приступил. Вообще, игры со сбросом фигур на доску (наравне с манкалами) - тема текущей итерации проекта, так что таких игр совсем скоро будет больше. И уже сейчас понятно, что некоторые из них (Го например) требуют особого подхода при разработке AI. А ведь есть и ещё более <a href="https://glukkazan.github.io/go/three-color-go-board.htm">замороченные игры</a>.</li>
	<li>В эту категорию попадают игры самые разнообразные. Здесь и детские "<a href="https://glukkazan.github.io/breakthrough/jungle-board.htm">Джунгли</a>" и французский "<a href="https://glukkazan.github.io/custodian/agon-board.htm">Агон</a>" XVIII-го века. Игры <a href="https://glukkazan.github.io/custodian/alea-evangeli-board.htm">большие</a> и <a href="https://glukkazan.github.io/breakthrough/epaminondas-8x8.htm">поменьше</a>. Игры совершенно <a href="https://glukkazan.github.io/races/hanga-roa-board.htm">безумные</a>. Всех их объединяет одно. Я не имею ни малейшего представления о том, как подступиться к разработке их AI. И, разумеется, я буду просто счастлив, если кто-то поможет довести до ума AI для моего "<a href="https://glukkazan.github.io/elimination/spock-board.htm">Спока</a>".</li>
</ol>
Так каким же образом можно написать своего бота? В качестве самого первого шага, стоит скачать содержимое <a href="https://github.com/GlukKazan/Dagaz">этого</a> или <a href="https://github.com/GlukKazan/GlukKazan.github.io">этого</a> репозитория к себе на компьютер (без чего писать, а тем более отлаживать, что либо будет тяжело). Хотя второй из перечисленных репозиториев является, по сути, релизным, никакой обфускации или минификации он, на текущий момент, не использует. Все приложения устроены предельно просто. Из html-файла последовательно загружаются несколько js-скриптов.

<spoiler title="Примерно вот так">
<source lang="xml">
<!DOCTYPE html>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Turkish Dama</title>
</head>
<body>

<img id="Board" style="display:none" src="images/turkish.png">
<img id="WhiteMan" style="display:none" src="images/wman.png">
<img id="BlackMan" style="display:none" src="images/bman.png">
<img id="WhiteKing" style="display:none" src="images/wdamone.png">
<img id="BlackKing" style="display:none" src="images/bdamone.png">

<table id="Table" style="margin:auto; font-family:sans-serif; font-size:14px">
<tr><td>Traditional - Turkish <a href="turkish-dama-board.htm">no AI</a></td></tr>
	<tr style="height:548px; vertical-align:top">
		<td id="CanvasCell" style="width:548px">
			<canvas id="Canvas" width="548" height="548" style="cursor:default">Broken canvas...</canvas>
		</td>
		<td style="width:300px;">
			<div id="ScrollDiv" style="height:510px; overflow:auto">
				<img id="GlyphImage" />
				<p id="HelpText"></p>
				<p id="GameSession"></p>
			</div>
		</td>
	</tr>
	<tr>
		<td>
			<div style="height:100px; width:500px; margin-left:auto; margin-right:auto">
				<table>
					<tr id="PieceInfo" style="display:none">
						<td>
							<img id="PieceInfoImage" />
						</td>
						<td id="PieceInfoText"></td>
					</tr>
				</table>
			</div>
		</td>
	</tr>
</table>

<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="../common-scripts/dagaz.js"></script>
<script src="../common-scripts/zrf-model.js"></script>
<script src="../common-scripts/zobrist.js"></script>
<script src="../common-scripts/common-setup.js"></script>
<script src="../common-scripts/2d-view-v2.js"></script>
<script src="../common-scripts/move-list-v2.js"></script>
<script src="../common-scripts/maxmin-ai-v2.js"></script>
<script src="../common-scripts/sgf-parser.js"></script>
<script src="data/turkish.js"></script>
<script src="../common-scripts/sgf-ai.js"></script>
<script src="scripts/maximal-captures.js"></script>
<script src="scripts/turkish-dama.js"></script>
<script src="../common-scripts/app-v2.js"></script>

<script src="../common-scripts/analytics.js"></script>

</body>
</html>
</source></spoiler>
Можно заметить, что из числа сторонних библиотек, я использую только очень для меня удобную <a href="http://underscorejs.ru/">Underscore</a> (я не настаиваю на её использовании). Все скрипты ботов содержат в своём имени "-ai". Именно они нам сейчас и интересны. Но прежде чем двигаться дальше, стоит немного рассказать о том:

<spoiler title="Что такое дизайн игры?">
Прежде всего, Dagaz отделяет дизайн игры (ZrfDesign) от её состояния (ZrfBoard). Дизайн определяет топологию доски и правила перемещения фигур, а состояние - то какие фигуры и где находятся, в данный конкретный момент. Объект ZrfDesign создаётся один раз на всю игру, объектов ZrfBoard может создаваться (в том числе, для нужд ботов) неограниченное количество. В начале игры, дизайн инициализируется вызовом функции <b>Dagaz.Model.BuildDesign</b>:

<spoiler title="turkish-dama.js">
<source lang="javascript">
Dagaz.Model.BuildDesign = function(design) {
    design.checkVersion("z2j", "2");
    design.checkVersion("zrf", "2.0");
    design.checkVersion("animate-captures", "false");
    design.checkVersion("smart-moves", "true");
    design.checkVersion("maximal-captures", "true");

    design.addDirection("w");
    design.addDirection("e");
    design.addDirection("s");
    design.addDirection("n");

    design.addPlayer("White", [1, 0, 3, 2]);
    design.addPlayer("Black", [0, 1, 3, 2]);

    design.addPosition("a8", [0, 1, 8, 0]);
    design.addPosition("b8", [-1, 1, 8, 0]);
    ...
    design.addPosition("h1", [-1, 0, 0, -8]);

    design.addZone("promotion", 1, [0, 1, 2, 3, 4, 5, 6, 7]);
    design.addZone("promotion", 2, [56, 57, 58, 59, 60, 61, 62, 63]);

    design.addCommand(0, ZRF.FUNCTION,	24);	// from
    design.addCommand(0, ZRF.PARAM,	0);	// $1
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	2);	// enemy?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.FUNCTION,	26);	// capture
    design.addCommand(0, ZRF.PARAM,	1);	// $2
    design.addCommand(0, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(0, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(0, ZRF.FUNCTION,	20);	// verify
    design.addCommand(0, ZRF.IN_ZONE,	0);	// promotion
    design.addCommand(0, ZRF.IF,	4);
    design.addCommand(0, ZRF.MODE,	0);	// jump-type
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.JUMP,	3);
    design.addCommand(0, ZRF.PROMOTE,	1);	// King
    design.addCommand(0, ZRF.FUNCTION,	25);	// to
    design.addCommand(0, ZRF.FUNCTION,	28);	// end

    ...
    design.addPriority(0);			// jump-type
    design.addPriority(1);			// normal-type

    design.addPiece("Man", 0, 1);
    design.addMove(0, 0, [3, 3], 0);
    design.addMove(0, 0, [0, 0], 0);
    design.addMove(0, 0, [1, 1], 0);
    design.addMove(0, 1, [3], 1);
    design.addMove(0, 1, [0], 1);
    design.addMove(0, 1, [1], 1);

    ...
    design.setup("White", "Man", 48);
    design.setup("White", "Man", 49);
    ...
}
</source></spoiler>
Весь этот код генерируется из <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/turkish-dama.zrf">zrf</a>-файла автоматически и трогать его не надо. На что здесь стоит обратить внимание? Вызовы <b>addPlayer</b> определяют игроков и, в простейшем случае, очерёдность их ходов (на второй аргумент функции пока отвлекаться не будем). Функция <b>addPosition</b> определяет единичную позицию на доске, а <b>addDirection</b> - направление. В самом конце, вызовами <b>setup</b> задаётся начальная расстановка фигур.

Позиции и направления - это просто два линейных массива, индексируемых с нуля. Таким образом, положение фигуры на доске всегда определяется целым не отрицательным числом. Такое числовое значение, в любой момент, можно превратить в имя позиции, используя функцию <b>Dagaz.Model.posToString</b>. Обратное преобразование выполняет <b>Dagaz.Model.stringToPos</b>.

С направлениями немного сложнее. Также как и позиции, они кодируются целыми не отрицательными числами (в соответствии с порядком вызова <b>addDirection</b> при конфигурировании дизайна игры). Получить код направления из имени можно использовав метод <b>getDirection</b> объекта design. Метод <b>allDirections</b> позволяет получить массив всех доступных направлений (для получения списка всех позиций имеется аналогичный метод <b>allPositions</b>). Но что такое само направление?

Помните второй аргумент <b>addPosition</b>? Фактически, это массив смещений внутри линейного списка всех позиций, по одному для каждого направления. Если соответствующее значение равно нулю, двигаться в указанном направлении из этой позиции запрещено (нет такого направления). Сама навигация осуществляется следующим методом:

<source lang="javascript">
ZrfDesign.prototype.navigate = function(player, pos, dir) {
  if (!_.isUndefined(this.players[player])) {
      dir = this.players[player][dir];
  }
  if (this.positions[pos][dir] != 0) {
      return + pos + this.positions[pos][dir];
  } else {
      return null;
  }
}
</source>
Как видите, достаточно просто прибавить смещение к индексу позиции или вернуть null, если такое перемещение запрещено. Все перемещения должны формулироваться в "системе координат" первого игрока. Это означает, что например в Шахматах, чёрные пешки, также как и белые движутся "на север". За правильную перекодировку направлений отвечает второй аргумент метода <b>addPlayer</b>.

Осталось рассказать об игровых зонах. Это просто списки "особых" позиций на доске, определяемые методом <b>addZone</b>. Зоны индивидуальны для каждого игрока. Это означает, что одна и та же (по имени) зона, для разных игроков, может содержать различные позиции. Для проверки нахождения позиции в заданной зоне используется метод <b>inZone</b>. Все определения перечисленных функций можно найти в исходном тексте модуля <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/zrf-model.js">zrf-model.js</a>
</spoiler>
Таким образом, у нас есть дизайн, не изменяемый в процессе игры, и набор игровых состояний, кодирующих расстановку фигур, на момент начала каждого хода, но возникает законный вопрос:

<spoiler title="Как изменять игровое состояние?">
Вообще говоря, никак, потому что изменять его непосредственно вы никогда не должны! Конечно, в <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/zrf-model.js">zrf-model</a> имеется метод <b>setPiece</b>, позволяющий поместить фигуру на доску, но вызывать его напрямую не надо! Игровое состояние иммутабельно. Новое состояние создаётся из старого применением к нему хода (объекта типа ZrfMove), методом <b>apply</b>.

Откуда берутся эти самые ходы? Они генерируются самим игровым состоянием при вызове метода <b>generate</b>. При этом, дизайн и расширения игры следят за тем, чтобы в список сформированных ходов попали только ходы, допустимые правилами игры! Также как и игровое состояние, ходы не должны изменяться разработчиком бота непосредственно, но можно в любой момент, выполнить генерацию допустимых ходов, получить новое состояние игры, применив ход и, разумеется, <b>читать</b> любую информацию, содержащуюся в этих объектах.

Итак, чем нас может порадовать ZrfBoard? Прежде всего, мы всегда можем узнать, чей сейчас ход, обратившись к члену <b>player</b> (в отличии от позиций и направлений, игроки в Dagaz индексируются начиная с единицы). Целочисленный член <b>zSign</b> содержит значение <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">zobrist-хэша</a> идентифицирующее расстановку фигур. Метод <b>getPiece</b> позволяет получить фигуру, находящуюся по указанной позиции (принимается числовой индекс). Если метод возвращает null, значит опрашиваемая позиция пуста.

Сама фигура (ZrfPiece) содержит два члена: <b>type</b> - тип фигуры (числовое значение индексируемое с нуля) и владельца - <b>player</b>. Кроме того, объекты ZrfPiece могут содержать значения атрибутов (индексируемые числовыми ключами). Метод <b>getValue</b> позволяет получить такое значение, указав индекс. Как обычно, null означает отсутствие искомого значения. Допускается хранение значений как строкового, так и числового типов.

Осталось разобраться с ходами (ZrfMove). Это самая сложная часть. Во многих играх, таких как Шахматы и Шашки, допускаются "сложные" ходы, включающие в себя одновременное перемещение нескольких фигур, последовательное взятие фигур, одну за другой и т.п. Поскольку ход переводит игру из одного непротиворечивого состояние в другое, все эти действия кодируются в рамках <b>одного</b> хода и применяются атомарно (всё или ничего).

Последовательность всех выполняемых действий содержится в массиве <b>actions</b>. Каждое элементарное действие представляет собой четырёхэлементный массив, содержащий следующие элементы:

0 - <b>Массив</b> начальных позиций перемещения
1 - <b>Массив</b> конечных позиций перемещения
2 - <b>Массив</b> фигур (объектов типа ZrfPiece) помещаемых на доску
3 - Целое <b>число</b>, содержащее номер частичного хода, в рамках составного

Каждый из перечисленных массивов, обычно состоит из одного элемента. Массивы большего размера используются редко, для недетерминированных ходов, применяемых в некоторых играх. Номер частичного хода определяет очерёдность выполнения действий. Если для двух действий это значение одинаково, они выполняются одновременно. В противном случае, первым выполняется действие с меньшим номером частичного хода. Используются три разновидности действий:

<ol>
	<li>Взятие фигуры - нулевой элемент заполнен, первый элемент содержит null</li>
	<li>Сброс (добавление фигуры на доску) - нулевой элемент равен null, заполнены первый и второй элементы</li>
	<li>Перемещение - заполнены нулевой и первый элементы, также может быть заполнен второй элемент (если фигура превращается в процессе выполнения хода)</li>
</ol>
Метод <b>toString</b> позволяет получить текстовое описание (нотацию) хода. Иногда это  здорово помогает в процессе отладки.
</spoiler>
Вся игра представляет собой, по сути, повторяющийся цикл, состоящий из генерации допустимых ходов и последующего применения их к игровому состоянию. Итерации повторяются (с чередованием ходов игроков, заданным правилами игры) до тех пор, пока не произойдёт одно из следующих событий.

<ol>
	<li>Список ходов, сгенерированных одним из игроков, оказывается пуст (в зависимости от игры, это может расцениваться как поражение, ничья или даже победа игрока)</li>
	<li>Функция <b>Dagaz.Model.checkGoals</b> возвращает значение, отличное от null</li>
</ol>
Второй пункт позволяет запрограммировать корректное завершение для практически любой игры.

<spoiler title="Вот, например, как это выглядит для Reversi">
<source lang="javascript">
var isValid = function(design, board, player, pos) {
  for (var dir = 0; dir < design.dirs.length; dir++) {
       var p = design.navigate(player, pos, dir);
       if (p === null) continue;
       var piece = board.getPiece(p);
       if ((piece === null) || (piece.player == player)) continue;
       while (p !== null) {
           p = design.navigate(player, p, dir);
           if (p !== null) {
               piece = board.getPiece(p);
               if (piece === null) break;
               if (piece.player == player) return true;
           }
       }
  }
  return false;
}

var checkGoals = Dagaz.Model.checkGoals;

Dagaz.Model.checkGoals = function(design, board, player) {
  var fc = 0; var ec = 0;
  var positions = [];
  _.each(design.allPositions(), function(pos) {
      var piece = board.getPiece(pos);
      if (piece === null) {
          positions.push(pos);
      } else {
          if (piece.player == player) {
              fc++;
          } else {
              ec++;
          }
      }
  });
  var f = true;
  _.each(positions, function(pos) {
      if (f) {
          if (isValid(design, board, player, pos)) f = false;
          if (isValid(design, board, design.nextPlayer(player), pos)) f = false;
      }
  });
  if (f) {
      if (fc == ec) return 0;
      if (fc > ec) {
          return 1;
      } else {
          return -1;
      }
  }
  return checkGoals(design, board, player);
}
</source>
Обратите внимание на функцию <b>isValid</b>. При помощи неё, определяется наличие разрешённых правилами игры ходов и только в том случае, если ни один из игроков не может сделать такой ход, определяется победитель (просто тот игрок, у которого больше фигур на доске).</spoiler>
Функция <b>checkGoals</b> - неотъемлемая часть дизайна игры. На момент разработки бота, она уже определена и вполне достаточно просто уметь её вызывать, для корректного определения позиций, завершающих игру. Функция может быть вызвана для любого игрового состояния и принимает три аргумента: дизайн игры, текущее состояние игры и идентификатор игрока, с точки зрения которого оценивается позиция. Результат вызова интерпретируется следующим образом:

<b>1</b> - победа игрока <b>player</b>
<b>-1</b> - поражение игрока <b>player</b>
<b>0</b> - ничья
<b>null</b> - не терминальная позиция (игра может быть продолжена)

Ещё одна важная вещь, о которой необходимо знать, до того как приступать к разработке каких либо ботов - это оценочная функция. Я уже довольно подробно <a href="https://habrahabr.ru/post/349516/">писал</a> об этом раньше, но ещё раз повторюсь. Задачей оценочной функции является числовая оценка позиции, с точки зрения одного из игроков (чем больше значение - тем лучше позиция).

<spoiler title="Вот как она может выглядеть">
<source lang="javascript">
Dagaz.AI.eval = function(design, params, board, player) {
  var r = 0;
  _.each(design.allPositions(), function(pos) {
      var piece = board.getPiece(pos);
      if (piece !== null) {
          var v = design.price[piece.type];
          if (piece.player != player) {
              v = -v;
          }
          r += v;
      }
  });
  return r;
}
</source></spoiler>
Обычно (но не обязательно) оценка позиции, с точки зрения одного из игроков, совпадает с оценкой той же позиции его противником, взятой с противоположным знаком. Без соблюдения этого условия не будут работать, например, <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0-%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">минимаксные алгоритмы</a>. Существуют игры (например те, в которых участвует <a href="https://glukkazan.github.io/shogi/yonin-shogi.htm">более двух игроков</a>), в которых соблюсти это условие не представляется возможным. Также, есть игры, в которых использование минимакса затруднительно, по другим причинам (например, сложная очерёдность передачи хода).

<a href="https://glukkazan.github.io/stalemate/virus-wars.htm">
<img align="center" src="https://habrastorage.org/webt/5r/cr/cb/5rcrcbn0roz8k3ussmkwnaouucc.png" /></a>
В этих случаях, на первый план выходят эвристики (при использовании минимакса они тоже очень полезны, поскольку позволяют предварительно отсортировать возможные ходы по их потенциальной "силе"). В отличии от оценочной функции, эвристика оценивает сам ход, а не позицию на доске после его выполнения. Эвристика может быть как очень <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/other-games/virus-wars-extension.js">сложной</a>, так и максимально простой.

<spoiler title="Такой, например">
<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  return move.actions.length;
}
</source>
В тибетской игре "<a href="https://glukkazan.github.io/custodian/ming-mang-small.htm">Минг-Манг</a>", чем больше мы берём фигур противника за ход, тем лучше. Поскольку ход в "Минг-Манг" состоит из перемещения своей фигуры и произвольного количества взятий, для того, чтобы получить хорошую эвристику, достаточно просто оценить количество элементов в массиве <b>move.actions</b> (о структуре хода в Dagaz я рассказывал выше).
</spoiler>
Далеко не для всех игр построить качественную оценочную функцию бывает легко. В особенно сложных случаях хорошо помогают "маленькие хитрости". Про "покрытие", очень полезное в играх шахматного типа, я уже писал <a href="https://habrahabr.ru/post/349516/">ранее</a>. Другой возможностью является хранение вспомогательных значений в атрибутах фигур.

<a href="https://glukkazan.github.io/renju/renju.htm">
<img align="center" src="https://habrastorage.org/webt/i1/x1/sx/i1x1sxuzdnqmtwml8plwwpbgcak.png" /></a>
В "<a href="https://www.gambler.ru/%D0%A0%D1%8D%D0%BD%D0%B4%D0%B7%D1%8E">Рендзю</a>" наиболее важным аспектом является наличие на доске "троек" и "четвёрок", ориентированных по четырём различным направлениям. Эта информация используется не только AI, но и для выявления ситуаций всевозможных "фолов" (длинных рядов и "вилок"), запрещённых для первого игрока, а также для определения завершения игры (5 камней "в ряд"). Между тем, поиск таких конфигураций на доске - задача довольно таки ресурсоёмкая.

С другой стороны, если мы уже храним счётчики с длинами рядов, для всех ранее поставленных на доску камней, задача обновления этих счётчиков, при добавлении нового камня, становится <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/renju-family/renju-extension.js">тривиальной</a>. Чуть более сложен (но вполне <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/go-family/go-extension.js">реализуем</a>) подсчёт количества "<a href="http://go-igo.ru/dictionary-go/dame.html">дамэ</a>" для групп камней, в играх семейства "<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>". В любом случае, гораздо проще хранить эти значения, чем вычислять снова и снова, каждый раз, когда они понадобятся. Конечно, эти мелочи, сами по себе, не превратят бота в <a href="https://ru.wikipedia.org/wiki/AlphaGo">AlphaGo</a>, но могут сделать его разработку гораздо более комфортной.

Вот мы и подошли к разговору о ботах. Задача бота, в Dagaz - выбор наилучшего (в каком-то смысле) хода из списка всех допустимых ходов, сгенерированных игровым состоянием. Вот как выглядит самый простой бот:

<spoiler title="random-ai.js">
<source lang="javascript">
(function() {

function RandomAi(params) {
  this.params = params;
  if (_.isUndefined(this.params.rand)) {
      this.params.rand = _.random;
  }
}

var findBot = Dagaz.AI.findBot;

Dagaz.AI.findBot = function(type, params, parent) {
  if ((type == "random") || (type == "solver")) {
      return new RandomAi(params);
  } else {
      return findBot(type, params, parent);
  }
}

RandomAi.prototype.setContext = function(ctx, board) {
  ctx.board  = board;
}

RandomAi.prototype.getMove = function(ctx) {
  var moves = Dagaz.AI.generate(ctx, ctx.board);
  if (moves.length == 0) {      
      return { done: true, ai: "nothing" };
  }
  if (moves.length == 1) {
      return { done: true, move: moves[0], ai: "once" };
  }
  var ix = this.params.rand(0, moves.length - 1);
  return {
      done: true,
      move: moves[ix],
      ai:   "random"
  };
}

})();</source>
Да-да, просто выбор случайного хода из всех доступных. Кстати, не надо думать, что это совершенно бесполезный бот. У него есть свои, очень важные, применения.
</spoiler>
Уже по этому листингу можно понять следующее:

<ol>
	<li>Любой бот должен "встроиться" в цепочку вызовов <b>Dagaz.AI.findBot</b> (для того, чтобы <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-v2.js">контроллер</a> смог его найти. Поиск бота осуществляется по его типу. Основных типов три: <b>"opening"</b>, <b>"common"</b> и <b>"random"</b>. Найденные боты также выстраиваются "в цепочку". Это делается для того, чтобы первым наилучший ход искал бот, предназначенный для дебютов (<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/sgf-ai-v2.js">sgf-ai</a>, например), вслед за ним отрабатывал главный бот (<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/maxmin-ai-v2.js">maxmin-ai</a>, в большинстве случаев), а уж если он ничего не нашёл (счёл все ходы слишком плохими), в игру включался <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/random-ai.js">random-ai</a>, просто чтобы сходить хотя бы как нибудь. Для решения головоломок используется специальный тип бота "<b>solver</b>".</li>
	<li>Для каждого игрока, с которым работает бот, создаётся свой "контекст" (это делается для того, чтобы один бот мог обслуживать одновременно несколько различных игроков). Внутри контекста можно хранить любые данные, разделяемые между последовательными обращениями к боту (например, дерево состояний игры). Перед запросом у бота "наилучшего" хода, контроллер передаёт боту текущее состояние игры (вызовом метода <b>setContext</b>).</li>
	<li>Ход у бота запрашивается методом <b>getMove</b>. Метод возвращает хэш, содержащий поле <b>move</b> (искомый ход). Также, если бот завершил поиск хода, он должен передать <b>true</b> в поле <b>done</b> возвращаемого хэша. В настоящее время эта функциональность не используется, но подразумевается, что контроллер может запросить у бота ход несколько раз подряд. В случае, если бот не успел найти наилучший ход за отведённое время, он может вернуть лучший ход из уже рассмотренных, но не устанавливать поле <b>done</b>, чтобы контроллер продолжил опрос.</li>
</ol>
Посмотрим на чуть более сложный бот:

<spoiler title="heuristic-ai.js">
<source lang="javascript">
(function() {

Dagaz.AI.NOISE_FACTOR = 10;

function Ai(params, parent) {
  this.params = params;
  this.parent = parent;
  if (_.isUndefined(this.params.NOISE_FACTOR)) {
      this.params.NOISE_FACTOR = Dagaz.AI.NOISE_FACTOR;
  }
}

var findBot = Dagaz.AI.findBot;

Dagaz.AI.findBot = function(type, params, parent) {
  if ((type == "heuristic") || (type == "common") || (type == "1") || (type == "2")) {
      return new Ai(params, parent);
  } else {
      return findBot(type, params, parent);
  }
}

Ai.prototype.setContext = function(ctx, board) {
  if (this.parent) {
      this.parent.setContext(ctx, board);
  }
  ctx.board     = board;
  ctx.timestamp = Date.now();
}

Ai.prototype.getMove = function(ctx) {
  ctx.board.moves = Dagaz.AI.generate(ctx, ctx.board);
  if (ctx.board.moves.length == 0) {
      return { done: true, ai: "nothing" };
  }
  var nodes = _.chain(ctx.board.moves)
     .map(function(m) {
          return {
             move:   m,
             weight: Dagaz.AI.heuristic(this, ctx.design, ctx.board, m)
          };
      }, this)
     .filter(function(n) {
          return n.weight >= 0;
      }).value();
  if (this.params.NOISE_FACTOR > 1) {
      _.each(nodes, function(n) {
         n.weight *= this.params.NOISE_FACTOR;
         n.weight += _.random(0, this.params.NOISE_FACTOR - 1);
      }, this);
  }
  if (nodes.length > 0) {
      nodes = _.sortBy(nodes, function(n) {
           return -n.weight;
      });
      return {
           done: true,
           move: nodes[0].move,
           time: Date.now() - ctx.timestamp,
           ai:  "heuristic"
      };
  }
  if (this.parent) {
      return this.parent.getMove(ctx);
  }
}

})();
</source></spoiler>
Это не столько "искусственный интеллект", сколько "искусственные инстинкты". Просто выбор хода с максимальной эвристикой, без какого бы ты ни было использования оценочной функции. Этот бот быстр и прозрачен в отладке, но на этом его достоинства заканчиваются. Глубину его интеллекта вы можете оценить по текущему уровню игры "<a href="https://glukkazan.github.io/renju/renju.htm">Рендзю</a>", "<a href="https://glukkazan.github.io/stalemate/virus-wars.htm">Войны вирусов</a>" и особенно "<a href="https://glukkazan.github.io/go/atari-go.htm">Атари Го</a>". В идеале, хотелось бы добиться нормальной работы чего нибудь вроде <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/ab-ai-v3.js">этого</a> (моя реализация минимакса с альфа-бета отсечением пока что, увы, не работающая).

Говоря об отладке ботов, стоит отметить, что дело это кропотливое, нудное и к особому веселью не располагающее. Любой инструмент облегчающий этот процесс безусловно стоит использовать. В первую очередь это касается модуля <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/common-setup-v2.js">common-setup</a>. Достаточно добавить его в список загружаемых скриптов и в логе (как включить лог в браузере, думаю объяснять не надо), после выполнения каждого хода, начнут появляться записи примерно такого вида:

<source>
Setup: ?setup=+19;0:1=4;+2;0:1=4;+5;0:2=3;+7;0:1=2;0:2=5;+7;0:2=5;+29; 
</source>
Добавив эту запись к адресной строки браузера (вот <a href="https://glukkazan.github.io/go/atari-go-board.htm?setup=+19;0:1=4;+2;0:1=4;+5;0:2=3;+7;0:1=2;0:2=5;+7;0:2=5;+29;">так</a>) можно воссоздать соответствующую позицию немедленно, без нудного воспроизведения предшествующих ходов. А при некоторой сноровке, можно навостриться читать эту нотацию  и даже редактировать её непосредственно в адресной строке.

Другая полезная возможность предоставляется контроллером. Если в htm-файле заменить <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-v2.js">app-v2</a> на <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-auto.js">app-auto</a>, можно заставить ботов сражаться друг с другом, не отвлекаясь на кликанье по доске мышью. Помните странные числовые типы ботов в <b>heuristic-ai.js</b>?

<source lang="javascript">
...
Dagaz.AI.findBot = function(type, params, parent) {
  if ((type == "heuristic") || (type == "common") || 
      (type == "1") || (type == "2")) {
      return new Ai(params, parent);
  } else {
      return findBot(type, params, parent);
  }
}
...
</source>
Бот с типом "<b>1</b>" будет загружаться для первого игрока, а с типом "<b>2</b>" для второго. Это конечно не <b>autoplay</b> из <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>, но тоже штука весьма полезная. Кроме того, в отличии от <b>autoplay</b>, только двумя игроками <b>app-auto</b> не ограничивается.

Модуль <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/debug-ai.js">debug-ai</a> ещё один полезный инструмент, который стоит взять на вооружение. Иногда, при отладке логики игры, бывает недостаточно просто воспроизвести позицию. В таких случаях, бывает необходимо, чтобы бот воспроизводил ходы по заданному списку и <b>debug-ai</b> умеет это делать. Именно с его помощью я отлаживал "<a href="https://glukkazan.github.io/elimination/apocalypse.htm">Апокалипсис</a>".

Ну вот, в общем-то и вся премудрость. Как я уже сказал, дело нудное, но не сверхъестественное. И я буду рад, если в этом деле ко мне кто нибудь присоединиться. Кстати, буквально два дня назад на почту проекта пришло первое письмо. Garrick Wells здорово помог мне с <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/shogi-family/data/micro-shogi.txt">дебютами</a> для <a href="https://glukkazan.github.io/shogi/micro-shogi.htm">Micro Shogi</a>. Попутно, я обнаружил и <a href="https://github.com/GlukKazan/Dagaz/commit/55235fdaab840198c26e89c45a01255b6b69c98e">исправил</a> серьёзный баг, затронувший эту и несколько других игр. Это именно та форма сотрудничества, к которой я стремлюсь.
</cut>

Dagaz: Быстрее, Лучше, Умнее…

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>— Как взмывают ангелы дружно в ряд…
— Дружно в ряд, дружно в ряд…
— Поднимают головы! И летят! И летят!..

сэр Терри Пратчетт "Ночная стража"</i></b>

Рано или поздно, всегда наступает момент, когда количество неизбежно переходит в качество. Накапливаются новые игры, нуждающиеся в осмыслении, <a href="https://glukkazan.github.io/index.html">проект</a> обрастает новыми возможностями, возможности комбинируются между собой. Если всё не рушится под собственной тяжестью, результат может превзойти самые смелые ожидания. То что не убивает - делает нас сильнее!
<cut>
Вот пример подобной "суммы технологий". Игра, в общем-то не слишком сложная, но очень неожиданная. <a href="https://glukkazan.github.io/elimination/apocalypse.htm">Апокалипсис</a> - на поле четыре всадника и поддерживающая их пехота. Привычные нам ходы <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D1%84%D0%B8%D0%B3%D1%83%D1%80%D1%8B">шахматных фигур</a>. Пешки, дойдя до последней линии, ожидаемо превращаются во всадников, но количество всадников на каждой стороне не может превышать двух. Игрок, первым потерявший всех своих всадников, проигрывает. Дьявол, как всегда, скрывается в деталях. Фигуры ходят одновременно!

<oembed>https://www.youtube.com/watch?v=THDgcSuKFBU</oembed>
<spoiler title="Что это означает с точки зрения проекта?">
Прежде всего, подобно головоломкам, это "игра для одного" - игрок делает ход, а бот "подмешивает" в него свой, не зная, какой ход сделал человек. Это игра с не полной информацией, хотя и в очень непривычном для нас виде. Здесь нет игральных кубиков или "тумана войны", но каждый из игроков, выполняя ход, не знает, как сходит его противник одновременно с ним.

Разумеется, возможны коллизии. Например, оба игрока могут одновременно сходить на одно и то же пустое поле или пешка может попытаться съесть фигуру, уходящую тем же ходом от удара. <a href="https://en.wikipedia.org/wiki/Apocalypse_(chess_variant)">Правила игры</a> хорошо описывают эти нюансы. Пешке разрешается выполнять диагональный ход, при условии того, что она собралась кого-то побить, даже если фигура ушла с этой позиции, а результат конфликта за пустое поле определяется рангом фигур. Всадник всегда убивает пешку, если же фигуры равны - они уничтожаются обе (что, кстати, делает возможными ничейные исходы).

<spoiler title="Слияние ходов">
<source lang="javascript">
Dagaz.Model.join = function(design, board, a, b) {
  var x = getPiece(design, board, a);
  var y = getPiece(design, board, b);
  if ((x !== null) && (y !== null)) {
      var r = Dagaz.Model.createMove();
      r.protected = [];
      checkPromotion(design, board, a, x, b);
      checkPromotion(design, board, b, y, a);
      var p = a.actions[0][1][0];
      var q = b.actions[0][1][0];
      if ((p == q) && (x.type > y.type)) {
          r.actions.push(b.actions[0]);
          r.actions.push(a.actions[0]);
      } else {
          r.actions.push(a.actions[0]);
          r.actions.push(b.actions[0]);
      }
      if (p == q) {
          if (x.type > y.type) {
              r.actions[0][2] = [ Dagaz.Model.createPiece(2, 2) ];
              r.protected.push(x.player);
              r.captured = p;
          } else {
              if (x.type == y.type) {
                  r.actions[0][2] = [ Dagaz.Model.createPiece(2, 1) ];
                  r.actions[1][2] = [ Dagaz.Model.createPiece(2, 1) ];
                  r.capturePiece(p);
              } else {
                  r.actions[0][2] = [ Dagaz.Model.createPiece(2, 1) ];
                  r.protected.push(y.player);
                  r.captured = p;
              }
          }
      }
      return r;
  } else {
      return a;
  }
}
</source></spoiler>
Задача непростая, но механизм "расширения ходов" с ней прекрасно <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/elimination/apocalypse-promotion.js">справляется</a>. Действительно, как я уже неоднократно говорил раньше, на этапе постобработки мы можем не только запретить ход (нарушающий, например, инвариант игры), но и добавить в него вообще любые произвольные действия, в том числе, полученные из хода, сформированного ботом. 

Есть правда одна тонкость - обычно, постобработка выполняется сразу после генерации, для всех сформированных ходов. В данном случае, так делать нельзя, поскольку это неизбежно приведёт к "комбинаторному взрыву" (игра хоть и небольшая, но всё равно приятного мало). Самое главное, делать этого и не нужно. Есть способ проще. Никто ведь не сказал, что мы не можем <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/app-sync.js">переписать контроллер</a>. У модульности есть свои преимущества.
</spoiler>
С точки зрения AI бота, игра, во многом, "оказуаливается". Здесь нет необходимости в выполнении просмотра на много ходов в глубину. Важно угадать, как будет ходить противник! Меняется тактика игры. Практически бесполезно пытаться атаковать всадников, находящихся "под боем" - они наверняка убегут. "Вилки" - более перспективны, но придётся выбирать, какого из всадников бить. Если же у противника остался всего один всадник (а у вас их полный комплект), можно попытаться "подкараулить" его, сходив на выбранное им поле. Только не делайте это пешкой! Есть нюансы связанные с превращением фигур, но, в целом...

<spoiler title="Всё сводится к набору эвристик">
<source lang="javascript">
...
var isCovered = function(design, board, pos, player, type) {
  var r = false;
  _.each(Dagaz.Model.GetCover(design, board)[pos], function(pos) {
      var piece = board.getPiece(pos);
      if ((piece !== null) && (piece.player == player)) {
          if (_.isUndefined(type) || (piece.type == type)) {
              r = true;
          }
      }
  });
  return r;
}

Ai.prototype.getMove = function(ctx) {
  var moves = Dagaz.AI.generate(ctx, ctx.board);
  if (moves.length == 0) {      
      return { done: true, ai: "nothing" };
  }
  timestamp   = Date.now();
  var enemies = 0;
  var friends = 0;
  _.each(ctx.design.allPositions(), function(pos) {
      var piece = ctx.board.getPiece(pos);
      if ((piece !== null) && (piece.type == 1)) {
          if (piece.player == 1) {
              enemies++;
          } else {
              friends++
          }
      }
  });
  var eval = -MAXVALUE;
  var best = null;
  _.each(moves, function(move) {
      var e = _.random(0, NOISE_FACTOR);
      if (move.isSimpleMove()) {
           var pos = move.actions[0][0][0];
           var trg = move.actions[0][1][0];
           var piece = ctx.board.getPiece(pos);
           if (piece !== null) {
               var target = ctx.board.getPiece(trg);
               if (piece.type == 1) {
                   if (isCovered(ctx.design, ctx.board, pos, 1)) e += MAXVALUE;
                   if (target === null) {
                       if (isCovered(ctx.design, ctx.board, trg, 1, 0)) e += LARGE_BONUS;
                       if (isCovered(ctx.design, ctx.board, trg, 1, 1)) {
                           if ((enemies == 1) && (friends == 2)) {
                               e += BONUS;
                           } else {
                               e -= MAXVALUE;
                           }
                       }
                   } else {
                       if (target.type == 1) {
                           e += SMALL_BONUS;
                       } else {
                           e += BONUS;
                       }
                   }
               } else {
                   if (isCovered(ctx.design, ctx.board, pos, 1)) e += SMALL_BONUS;
                   if ((target === null) && isCovered(ctx.design, ctx.board, trg, 1)) e -= MAXVALUE;
                   if (friends == 1) e += BONUS;
                   if (target !== null) e += SMALL_BONUS;
                   if ((move.actions[0][2] !== null) && (move.actions[0][2][0].type != piece.type)) {
                       if (friends == 1) {
                           e += MAXVALUE;
                       } else {
                           e -= MAXVALUE;
                       }
                   }
               }
           }
      }
      if ((best === null) || (eval < e)) {
           console.log("Move: " + move.toString() + ", eval = " + e);
           best = move;
           eval = e;
      }
  });
  return {
      done: true,
      move: best,
      time: Date.now() - timestamp,
      ai:  "aggressive"
  };
}
</source></spoiler>
<a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">
<img align="center" src="https://habrastorage.org/webt/hh/by/cs/hhbycsfa5xuwxcxnfsqqhpp5aag.png" /></a>
Другая крайность - игры большие и сложные настолько, что мало мальский просмотр в глубину для них невозможен технически. Здесь мы <b>вынуждены</b> использовать более <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/aggressive-ai-v4.js">казуальный AI</a>, просматривающий позицию всего на 1-2 хода вперёд, причем даже на эту глубину, просмотреть все имеющиеся ходы не удастся! Во всяком случае, за комфортное для человека время поиска хода ботом в течение 2-3 секунд.

<spoiler title="Ещё немного о производительности">
Большие и сложные игры обнажают все проблемы, связанные с производительностью. Обычно, то насколько быстро выполняется код, связано с  качеством работы AI (чем больше позиций успевает рассмотреть он за отведённое время - тем лучше работает), но иногда проблемы с производительностью становятся более очевидными. В процессе работы над <a href="https://en.wikipedia.org/wiki/Tenjiku_shogi">Tenjiku shogi</a>, я заметил, что в некоторых позициях время реакции пользовательского интерфейса становилось просто неприлично большим (порядка 10-15 секунд). 

<img align="center" src="https://habrastorage.org/webt/zf/hc/-b/zfhc-bqbwi9rcrxqkwbpjmnuemw.png" />
Всё дело в "Огненном демоне" (и подобных ему фигурах). Обратите внимание на диаграмму справа. Помимо обычных "range"-атак, "демон" имеет право, в любой момент, выполнить до трёх одно-шаговых перемещений в произвольном направлении, при этом, ему разрешается возвращаться на ранее пройденные поля. Это настоящий "комбинаторный убийца" производительности! В начальной позиции, когда все подобные фигуры "зажаты", этот эффект проявляется не так сильно, но когда они выходят на оперативный простор... Количество возможных вариантов ходов желающие могут подсчитать самостоятельно (на диаграмме ниже представлены графики изменения среднего количества допустимых ходов, в течение игры, для нескольких известных игр).

<img align="center" src="https://habrastorage.org/webt/ck/n4/xn/ckn4xniuhfw5r3-ehvcn9zv74ao.png" />
Здесь следует немного рассказать об архитектуре Dagaz. Главная идея заключается в том, что, прежде чем передавать управление пользователю или боту, модель игры генерирует <b>все</b> возможные ходы из текущей позиции. Это позволяет рассматривать совокупность ходов "целиком" и помогает решить ряд проблем <a href="http://zillions-of-games.com/">Zillions of Games</a>, связанных с составными ходами. Кроме того, такой подход очень удобен для разработки ботов. Но есть одна проблема.

Для пользователя, сложный составной ход представляет собой <b>последовательность</b> различных действий (перемещений, взятий и, возможно, сбросов новых фигур на доску). Где-то должен быть код, позволяющий по последовательности пользовательских "кликов" выбрать единственный ход из ранее сформированного и возможно большого списка. И такой код в Dagaz, разумеется <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/move-list-v2.js">есть</a>.

<spoiler title="В нём и скрывалась ошибка">
<source lang="javascript">
MoveList.prototype.isUniqueFrom = function(pos) {
  var c = 0;
  _.each(this.moves, function(move) {
      _.each(this.getActions(move), function(action) {
          if ((action[0] !== null) && (_.indexOf(action[0], pos) >= 0)) c++;
      });
  }, this);
  return c == 1;
}

MoveList.prototype.isUniqueTo = function(pos) {
  var c = 0;
  _.each(this.moves, function(move) {
      _.each(this.getActions(move), function(action) {
          if ((action[1] !== null) && (_.indexOf(action[1], pos) >= 0)) c++;
      });
  }, this);
  return c == 1;
}
...
MoveList.prototype.getStops = function() {
  var result = this.getTargets();
  _.each(this.moves, function(move) {
      var actions = _.filter(this.getActions(move), isMove);
      if ((actions.length > 0) && (actions[0][0].length == 1) && 
          (actions[0][1].length == 1)) {
          if (Dagaz.Model.smartFrom) {
              if (this.isUniqueFrom(actions[0][0][0]) && !this.canPass()) {
                  result.push(actions[0][0][0]);
              }
          }
          if (Dagaz.Model.smartTo) {
              if (this.isUniqueTo(actions[0][1][0])) {
                  result.push(actions[0][1][0]);
              }
          }
      } else {
      ...
      }
  }, this);
  return _.uniq(result);
}
</source></spoiler>
Видите в чём проблема? Функция <b>getStops</b> строит список всех завершающий полей каждого хода и, для этого, перебирает все ходы в цикле, но при включенных опциях <b>smartFrom</b> или <b>smartTo</b> (опции немедленного выполнения хода по первому "клику", при отсутствии альтернативных вариантов), выполняется <b>вложенный</b> перебор всех ходов. А ходов формируется много!

На небольших играх, вроде шашек или шахмат, ошибка никак не проявлялась. Даже в начальной позиции <a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">Tenjiku shogi</a> она не была заметна. Понадобились "убийцы производительности", чтобы её выявить. А для локализации ошибки очень пригодился модуль <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/utils/kpi.js">KPI</a>, без которого я попросту не знал бы, где искать проблему. Сейчас ошибка исправлена и, в результате, весь код стал лучше.
</spoiler>
Итак, мы ограничены в глубине просмотра и должны принять верное (или хотя бы не катастрофическое) решение за ограниченное время. При этом, крайне желательно, чтобы обеспечивалось выполнение следующих принципов:

<ol>
	<li>Безусловно, должен выбираться ход ведущий к немедленной победе</li>
	<li>Не должен выбираться ход, на который имеется ответ, ведущий к немедленной победе</li>
	<li>Выбранный ход должен обеспечивать наибольшее улучшение позиции</li>
</ol>
<spoiler title="Как оценивать позицию?">
Самый простой способ - оценка материального баланса. Каждому типу фигур присваивается стоимость, затем складываем стоимости своих фигур и отнимаем стоимости фигур противника. Оценка грубая, но для действительно сложных игр, пожалуй, единственно возможная. Улучшенная оценка должна учитывать мобильность фигур и их взаимные угрозы (об этом я буду говорить ниже). Для "больших" игр со сложными правилами, оценка взаимных угроз может оказаться слишком накладной.

<spoiler title="Простейшая оценочная функция">
<source lang="javascript">
Dagaz.AI.eval = function(design, params, board, player) {
  var r = 0;
  _.each(design.allPositions(), function(pos) {
      var piece = board.getPiece(pos);
      if (piece !== null) {
          var v = design.price[piece.type];
          if (piece.player != player) {
              v = -v;
          }
          r += v;
      }
  });
  return r;
}
</source></spoiler>
Вторым инструментом является эвристика. Это просто числовая оценка <b>хода</b>, а не позиции, позволяющая отличать "плохие" ходы от "хороших". Разумеется, в первую очередь, будут рассматриваться "хорошие" ходы, а на рассмотрение "плохих" времени попросту может не остаться. Простейшая эвристика может включать стоимость взятой фигуры, но помимо этого, желательно оценивать стоимость фигуры, выполняющей ход, возможные превращения, угрозы и т.п.

<spoiler title="Пример эвристики">
<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  var r        = 0;
  var player   = board.player;
  var start    = null;
  var stop     = null;
  var captures = [];
  _.each(move.actions, function(a) {
      if ((a[0] !== null) && (a[1] === null)) {
          var pos = a[0][0];
          var piece = board.getPiece(pos);
          if ((piece !== null) && (piece.player != player)) {
               r += design.price[piece.type] * ai.params.CAPTURING_FACTOR;
               if (!_.isUndefined(board.bonus) && (board.bonus[pos] < 0)) {
                   r -= board.bonus[pos];
               }
          }
          captures.push(pos);
      }
      if ((a[0] !== null) && (a[1] !== null)) {
          if (start === null) {
              start = a[0][0];
              if (!_.isUndefined(board.bonus)) {
                  r += board.bonus[start];
              }
          }
          stop = a[1][0];
      }
  });
  var price = 0;
  if (start !== null) {
      var piece = board.getPiece(start);
      if (piece !== null) {
          price = design.price[piece.type];
      }
  }
  _.each(move.actions, function(a) {
      if ((a[0] !== null) && (a[1] !== null)) {
          var pos = a[1][0];
          var piece = board.getPiece(pos);
          if (_.indexOf(captures, pos) < 0) {
              if ((piece !== null) && (piece.player != player)) {
                   r += design.price[piece.type] * ai.params.CAPTURING_FACTOR;
                   if (!_.isUndefined(board.bonus)) {
                       r += Math.abs(board.bonus[pos]);
                   }
              }
              if (a[2] !== null) {
                  var promoted = a[2][0];
                  r -= price * ai.params.SUICIDE_FACTOR;
                  if (promoted.player == player) {
                      r += design.price[promoted.type] * ai.params.PROMOTING_FACTOR;
                  }
              }
          } else {
              r -= price * ai.params.SUICIDE_FACTOR;
          }
      }
      if ((a[0] === null) && (a[1] !== null) && (a[2] !== null) && 
          (_.indexOf(captures, a[1][0]) < 0)) {
          var pos = a[1][0];
          var piece = board.getPiece(pos);
          if (piece !== null) {
              if (piece.player != player) {
                  r += design.price[piece.type] * ai.params.CAPTURING_FACTOR;
              }
          }
          piece = a[2][0];
          if (piece.player == player) {
              r += design.price[piece.type] * ai.params.CREATING_FACTOR;
          }
      }
  });
  if (!_.isUndefined(board.cover) && (start !== null) && (stop !== null)) {
      if (isAttacked(design, board, board.player, stop, start, price)) {
          r -= price * ai.params.SUICIDE_FACTOR;
      }
  }
  return r;
}
</source></spoiler>
Важно понимать, что максимальное значение эвристики вовсе не означает, что именно этот ход будет выбран. Эвристика задаёт только порядок просмотра ходов. В рамках этого порядка, выбирается ход наибольшим образом увеличивающий значение оценочной функции (после выполнения ответного хода противника с максимальной эвристикой). Можно принудительно исключать часть ходов из рассмотрения, задавая им отрицательное значение эвристики, но это средство следует использовать с осторожностью, лишь в тех случаях, когда есть стопроцентная уверенность, что рассматриваемый ход не просто бесполезный, а именно вредный.

<spoiler title="Стоимость фигур">
<source lang="javascript">
    ...
    design.addPiece("King", 32, 10000);
    design.addPiece("Prince", 33, 10000);
    design.addPiece("Blind-Tiger", 34, 3);
    design.addPiece("Drunk-Elephant", 35, 3);
    design.addPiece("Ferocious-Leopard", 36, 3);
    design.addPiece("Gold-General", 37, 3);
    design.addPiece("Silver-General", 39, 2);
    design.addPiece("Copper-General", 40, 2);
    design.addPiece("Chariot-Soldier", 41, 18);
    design.addPiece("Dog", 43, 1);
    design.addPiece("Bishop-General", 44, 21);
    design.addPiece("Rook-General", 46, 23);
    design.addPiece("Vice-General", 48, 39);
    design.addPiece("Great-General", 49, 45);
    ...
</source></spoiler>
Помните, выше я говорил о трёх принципах? Королевским фигурам (типов таких фигур в игре может быть несколько) имеет смысл присваивать очень высокую стоимость. Этим мы убиваем сразу двух зайцев: во первых, ход берущий королевскую фигуру получит максимально-возможную эвристику (и всегда будет рассматриваться в первую очередь), кроме того, отсутствие на доске королевской фигуры заметным образом скажется на значении оценочной функции, что также весьма удобно. К сожалению, в применении к <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматам</a> этот трюк не актуален, поскольку <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%BE%D0%BB%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">король</a> в них никогда не берётся.
</spoiler>
Следует отметить, что оценивать позицию всегда следует лишь по завершении ответного хода противника! Если имеется цепочка разменов, следует просматривать её до конца, в противном случае, может получиться так, что атакующая фигура будет отдана за менее ценную.

Игры более чем двух игроков - ещё одно применение казуальных "одноходовых" AI. Всё дело в оценочной функции. Минимаксные алгоритмы работают только в том случае, если оценка с точки зрения одного игрока совпадает с оценкой другого, взятой с противоположным знаком. То что теряет один - приобретает другой. Если игроков трое (<a href="https://glukkazan.github.io/xiangqi/qiquo-xiangqi-kanji.htm">или больше</a>) - всё ломается. Разумеется, всё ещё можно применять алгоритмы на основе метода "<a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a>", но с ними связаны другие трудности.

<a href="https://glukkazan.github.io/shogi/yonin-shogi.htm">
<img align="center" src="https://habrastorage.org/webt/fl/yr/lb/flyrlb-vy6r4e0-yj32ynn26j04.png" /></a>
<a href="https://glukkazan.github.io/shogi/yonin-shogi.htm">Yonin Shogi</a> - вариант "<a href="https://en.wikipedia.org/wiki/Shogi_variant">японских шахмат</a>" для четырёх игроков. Большинство правил, в этой игре, остаются неизменными, но изменяется цель игры. Понятие "мата", в известной степени, теряет смысл. В самом деле, если "восток" угрожает королю "юга" - это ещё не повод для защиты от "шаха", пока "запад" и "север" не скажут своё слово. С другой стороны, если угроза так и не будет устранена, следующим ходом "восток" съест короля. Таким образом, в Yonin Shogi разрешается брать королей (и это является целью игры).

Кроме того, игра не заканчивается взятием короля (подобный исход был бы слишком скушен, для оставшихся трёх игроков). Игрок теряющий короля выбывает из игры, теряя право своего хода. Так как королей разрешается брать, они, как и все прочие фигуры, попадают в резерв и могут быть в любой момент поставлены на доску. Игрок <b>обязан</b> выставить короля из резерва, если на доске его королей не осталось. После всего сказанного, цель игры становится очевидна - побеждает тот, кто соберёт всех четырёх королей (когда я делал игру для <a href="http://zillions-of-games.com/">Zillions of Games</a>, осознать этот нюанс мне помог <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=505">Howard McCay</a>).

<spoiler title="Всё сказанное выше ведёт к простой мысли">
Существуют игры, в которых не могут применяться сложные алгоритмы поиска в глубину, а само понятие оценочной функции должно быть переосмыслено. Чтобы сохранить качество работы алгоритмов AI приемлемым, необходимо улучшать оценки и эвристики, возможно, за счёт их усложнения. Очевидным способом является введение мобильности - количества всех возможных ходов, совершаемых игроком, за вычетом ходов противника.

<code>
eval = A * material-balance + B * mobility; где A >= 0, B >= 0, A + B = 1
</code>
При применении "одноходовых" алгоритмов, оценка мобильности творит чудеса. Тупая игра бота становится более "осмысленной". Есть правда один минус - для того чтобы оценить мобильность, необходимо построить (или хотя бы пересчитать) все возможные ходы за каждого из игроков, а это - очень дорогая операция. Поскольку мы, всё равно, вынуждены этим заниматься, хочется "выжать" из генерации ходов всё возможное, а также минимизировать количество таких операций.

<spoiler title="Покрытие">
<source lang="javascript">
Dagaz.AI.eval = function(design, params, board, player) {
  var r = 0;
  var cover = board.getCover(design);
  _.each(design.allPositions(), function(pos) {
      var defended = _.filter(cover[pos], function(p) {
          var piece = board.getPiece(p);
          if (piece === null) return false;
          return piece.player == player;
      });
      if (defended.length > 0) r++;
  });
  return r;
}
</source></spoiler>
Так я пришёл к идее "покрытия". Это просто массив массивов. Для каждого из полей (а любое поле в Dagaz всегда кодируется целым числом) сохраняется, возможно пустой, список позиций, на которых расположены фигуры, способные это поле побить. При этом (и это важно) не делается различий между пустыми и занятыми полями, а также владельцами "бьющих" фигур. Список возможных ходов вычисляется для всех игроков <b>одновременно</b>, а за счёт кэширования, ещё и однократно.

Разумеется, универсальный алгоритм построения "покрытия" пригоден далеко не для всех игр. Для <a href="https://glukkazan.github.io/checkmate/chess.htm">Шахмат</a> и <a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Шашек</a> он работает, а вот для <a href="https://glukkazan.github.io/elimination/spock-board.htm">Спока</a> уже нет (поскольку, в этой игре фигуры могут беспрепятственно проходить через другие фигуры своего цвета). Это не должно смущать. Также как оценочную функцию и эвристики, алгоритм построения "покрытия" можно переопределять, используя имя <b>Dagaz.Model.GetCover</b>. Более того, даже в тех случаях, когда универсальный алгоритм работает, бывает полезно подумать о его кастомизации. Специализированные алгоритмы, как правило, более производительны.
</spoiler>
<oembed>https://www.youtube.com/watch?v=xrgoW2_ZC-g</oembed>
Вот <a href="https://glukkazan.github.io/elimination/maharadja-variant.htm">пример</a> использования "покрытия" в реальной игре. Это по прежнему простейший "одношаговый" алгоритм и его очень легко обмануть, но действия бота кажутся осмысленными! Анализируя покрытие, AI никогда не оставляет свои фигуры без защиты и стремится максимально "развернуть" их на доске, максимизируя количество полей, находящихся под боем. Это хорошая тактика, безусловно приводящая к победе при игре против одного "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B0%D1%80%D0%B0%D0%B4%D0%B6%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Махараджи</a>". Также хорошо этот алгоритм показывает себя в "<a href="https://glukkazan.github.io/checkmate/charge-light-brigade.htm">Charge of the Light Brigade</a>", "<a href="https://glukkazan.github.io/checkmate/dunsanys-chess.htm">Dunsany's Chess</a>", "<a href="https://glukkazan.github.io/checkmate/horde-chess.htm">Horde Chess</a>", "<a href="https://glukkazan.github.io/checkmate/weak.htm">Weak!</a>" и прочих "малых" шахматных играх. Для меня очевидно, что использование "покрытия" поможет улучшить и более сложные алгоритмы, но прежде чем перейти к ним, мне необходимо потренироваться.

<oembed>https://www.youtube.com/watch?v=nDOLry-do9A</oembed>
Обратите внимание на то, что где-то в районе <a href="https://youtu.be/nDOLry-do9A?t=341">5:39</a> все перемещения резко ускоряются. Это объясняется просто. Параллельно с анимацией движения плашек (просто, чтобы человек не скучал), бот ведёт поиск целевой позиции и после того как её находит, идёт к ней по прямой, не теряя время на дополнительные вычисления. 

<spoiler title="Кстати">
Мне не удалось пронаблюдать этот эффект на FireFox 52.6.0. В Хроме и даже в IE алгоритм нашёл решение примерно за 5 минут, а в "Огненном лисе" продолжал неторопливо двигать плашки в течение минут пятнадцати, покуда я его не вырубил (при этом память жрал как не в себя). Я пока не нашёл объяснения этому феномену.
</spoiler>
Для меня, это значительный шаг вперёд, по сравнению с <a href="https://www.youtube.com/watch?v=l4oi8r747a0">предыдущей версией</a>. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/bruteforce-ai-v4.js">Алгоритм</a> представляет собой простейший <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83">поиск в ширину</a> (не <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83">в глубину</a>! это важно, нас ведь интересует кратчайшее решение?). Повторные позиции отсекаются, при помощи <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist hash</a>, что кстати делает возможной (хотя и крайне маловероятной) ситуацию, при которой решение может быть не найдено в результате коллизии. Кроме того, приоритет при поиске отдаётся узлам, являющимся потомками текущего узла анимации (для того чтобы минимизировать количество необходимых возвратов, после обнаружения решения).

<spoiler title="Попутно, я сделал ещё одну штуку">
Дело в том, что в Zillions of Games есть опция, назначения которой я никогда не понимал. Называется она "progressive levels". Как только вы заканчиваете один уровень игры, она немедленно загружает следующий, просто по порядку. Теперь, думаю, я уловил в чём тут смысл. Попробуйте погасить эти лампочки:

<a href="https://glukkazan.github.io/light-off/hex-light-off-01.htm">
<img align="center" src="https://habrastorage.org/webt/1a/ej/zy/1aejzy62kpn-7cvomapgmaax01a.png" /></a>
Согласитесь, это затягивает. А уж на то, как кто-то решает головоломки за тебя, можно вообще <a href="https://glukkazan.github.io/sliding-puzzles/fujiware_1-ai.htm">смотреть до бесконечности</a>. Но это только половина дела! Как и практически любую опцию Dagaz, <b>мой</b> "progressive levels" можно кастомизировать.

<a href="https://glukkazan.github.io/sliding-puzzles/washington_1.htm">
<img align="center" src="https://habrastorage.org/webt/o_/aj/lp/o_ajlpvgnzcglfojk3vd-rhwozy.png" /></a>
Эта головоломка была посвящена избранию <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%88%D0%B8%D0%BD%D0%B3%D1%82%D0%BE%D0%BD,_%D0%94%D0%B6%D0%BE%D1%80%D0%B4%D0%B6">Джорджа Вашингтона</a> на пост президента и, первоначально, я реализовал её не вполне корректно. Для <b>правильного</b> решения необходимо провести красный квадрат через все четыре угла поочерёдно, но в Dagaz можно задать только одну цель. Здесь и вступает в действие <b>кастомный</b> "progressive levels".

Как только мы доходим до очередной цели, загружается следующий уровень, но расстановка фигур, при этом, берётся из предыдущего! Мы просто продолжаем с того места где остановились. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/model/common-setup.js">Модуль</a>, используемый для передачи позиции между уровнями, ценен сам по себе. Теперь, если включить лог браузера вовремя, можно вернуться к любой ранее пройденной позиции, практически в каждой из игр. Достаточно скопировать в URL строку, следующую в логе за надписью "Setup:". Это здорово помогает в отладке!

Кастомный "progressive levels" применим в играх со сложным жизненным циклом, таких как <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a>. Эта игра не заканчивается при достижении <b>одной</b> из фигур последней линии! По <a href="http://www.boardspace.net/kamisado/english/RULES%20ENG.pdf">правилам</a>, фигура вошедшая в лагерь противника получает ранг "сумоиста" и дополнительные возможности, после чего, фигуры расставляются по оговоренному алгоритму и начинается следующий раунд. Теперь, Dagaz умеет это! Не сомневаюсь, возможность будет полезной при реализации многих традиционных <a href="https://glukkazan.github.io/mancala/mancala.svg">манкал</a>. А при очень большом желании, на его основе, вполне можно сделать какой нибудь простенький <a href="https://ru.wikipedia.org/wiki/Roguelike">рогалик</a>.
</spoiler>

<a href="https://glukkazan.github.io/breakthrough/horn-chess.htm">
<img align="center" src="https://habrastorage.org/webt/cv/d9/n7/cvd9n7nfma6bohidvqv4gejg12k.png" /></a>
Это детская игра <a href="https://sites.google.com/site/boardandpieces/list-of-games/horn-chess">родом из Китая</a>. Чёрные камни не могут перемещаться вниз, белый - двигается в любую сторону. Прежде чем читать дальше, попробуйте самостоятельно "зажать" белый камень в вершине "рога". Если не получается - ничего страшного:

<spoiler title="Даю подсказку">
<oembed>https://www.youtube.com/watch?v=0cx8jRmYvjA</oembed>
</spoiler>
Чем-то похоже на "<a href="https://glukkazan.github.io/breakthrough/french-military-small.htm">Французскую военную игру</a>" или "<a href="https://glukkazan.github.io/breakthrough/game-of-dwarfs.htm">Игру гномов</a>", но, на мой взгляд, "Роговые шахматы" намного глубже и сложнее этих игр. Если не верите, попробуйте справиться с <a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm">этим</a>. При всей внешней незатейливости, игра совсем не проста. Я видел пару научных статей (на китайском), посвящённых ей. И это хороший материал для отладки <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/ab-ai-v2.js">более сложных AI</a>.

<spoiler title="Главное - не напутать со знаками!">
<source lang="javascript">

Dagaz.AI.eval = function(design, params, board, player) {
  var r = 0;
  var white = null;
  var black = [];
  for (var pos = 0; pos < design.positions.length - 3; pos++) {
      var piece = board.getPiece(pos);
      if (piece !== null) {
          if (piece.player == 1) {
              if (white === null) {
                  black.push(pos);
              } else {
                  r += MAXVAL / 2;
              }
          } else {
              white = pos;
          }
      }
  }
  if (white !== null) {
      r += white;
  }
  if (black.length == 2) {
      if ((black[0] + 1 == black[1]) && (black[1] + 1 == white)) {
          if (board.player == 1) {
              r = MAXVAL;
          } else {
              r = -MAXVAL;
          }
          if (player == 1) {
              r = -r;
          }
      }
  }
  return r;
}

Dagaz.AI.heuristic = function(ai, design, board, move) {
  var b = board.apply(move);
  return design.positions.length +
         Dagaz.AI.eval(design, ai.params, b, board.player) -
         Dagaz.AI.eval(design, ai.params, board, board.player);
}
...
AbAi.prototype.ab = function(ctx, node, a, b, deep) {
  node.loss = 0;
  this.expand(ctx, node);
  if (node.goal !== null) {
      return -node.goal * MAXVALUE;
  }
  if (deep <= 0) {
      return -this.eval(ctx, node);
  }
  node.ix = 0;
  node.m  = a;
  while ((node.ix < node.cache.length) && (node.m <= b) && 
         (Date.now() - ctx.timestamp < this.params.AI_FRAME)) {
      var n = node.cache[node.ix];
        if (_.isUndefined(n.win)) {
          var t = -this.ab(ctx, n, -b, -node.m, deep - 1);
          if ((t !== null) && (t > node.m)) {
              node.m = t;
              node.best = node.ix;
          }
        } else {
            node.loss++;
        }
      node.ix++;
  }
  return node.m;
}
</source></spoiler>
<a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm?setup=02;03;-19">
<img align="center" src="https://habrastorage.org/webt/de/cn/1e/decn1emepgcw-an_njtmbejda5m.png" /></a>
Вот один из ключевых моментов. Двигаем правый чёрный камень вверх. Более слабый "одношаговый" <a href="https://glukkazan.github.io/breakthrough/horn-chess.htm?setup=02;03;-19">алгоритм</a> идёт вниз, после чего чёрные легко загоняют его в угол. Минимаксная реализация - делает правильный ход, после которого может победить, если чёрные допустят ошибку. Это не означает, что поймать белых невозможно, но просмотр на несколько ходов вперёд значительно улучшает их игру!

Выше, на примере <a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">Tenjiku Shogi</a>, я уже показывал, что различные настольные игры могут сильно отличаться друг от друга. Прежде всего, это касается вариативности - усреднённого количества допустимых ходов на той или иной стадии игры. Этот параметр определяет применимость алгоритма AI, при разработке бота. Совершенно очевидно, что минимаксный алгоритм, использованный мной в <a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm">Horn Chess</a> не будет работать нормально в действительно больших играх, наподобие <a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">Ko Shogi</a> или <a href="https://glukkazan.github.io/xiangqi/gwangsanghui.htm">Gwangsanghui</a>. С другой стороны, применённый в них "агрессивный" алгоритм будет играть слишком слабо, в таких играх как "<a href="https://glukkazan.github.io/checkmate/chess.htm">Шахматы</a>". Но это только часть проблемы.

<a href="https://glukkazan.github.io/custodian/ming-mang-small.htm">
<img align="center" src="https://habrastorage.org/webt/uj/ti/ml/ujtimlfdgk2r1s8ehgqpi_p_vug.png" /></a>
Главные отличия заключены в механике. К счастью, это именно то, что может быть кастомизировано оценочной функцией и эвристиками. Плохая новость заключается в том, что додуматься до того, как они должны быть простроены просто бывает далеко не всегда. Игры с "<a href="https://en.wikipedia.org/wiki/Custodian_capture">Custodian</a>"-захватом (такие как тибетский "<a href="https://en.wikipedia.org/wiki/Ming_Mang_(game)">Минг-Манг</a>") прекрасно иллюстрируют мой тезис.

<spoiler title="Здесь недостаточно простой оценки материального баланса!">
<source lang="javascript">
var eval = Dagaz.AI.eval;

Dagaz.AI.eval = function(design, params, board, player) {
  var r = eval(design, params, board, board.player);
  var cover = board.getCover(design);
  var cnt = null;
  _.each(cover, function(list) {
      var cn = 0;
      _.each(list, function(pos) {
          var piece = board.getPiece(pos);
          if (piece !== null) {
              if (piece.player == board.player) {
                  r--;
              } else {
                  cn++;
              }
          }
      });
      if ((cnt === null) || (cnt < cn)) {
           cnt = cn;
      }
  });
  r += cnt * 3;
  if (board.player != player) {
      return -r;
  } else {
      return r;
  }
}

var done = function(design, board, player, pos, dir, trace, captured) {
  var p = design.navigate(player, pos, dir);
  if (p !== null) {
      var piece = board.getPiece(p);
      if (piece !== null) {
          if (piece.player == player) {
              _.each(trace, function(pos) {
                  if (_.indexOf(captured, pos) < 0) {
                      captured.push(pos);
                  }
              });
          } else {
              trace.push(p);
              done(design, board, player, p, dir, trace, captured);
              trace.pop();
          }
      }
  }
}

var capture = function(design, board, player, pos, dir, dirs, trace, captured) {
  var p = design.navigate(player, pos, dir);
  if (p !== null) {
      var piece = board.getPiece(p);
      if (piece !== null) {
          if (piece.player == player) {
              _.each(trace, function(pos) {
                  if (_.indexOf(captured, pos) < 0) {
                      captured.push(pos);
                  }
              });
          } else {
              trace.push(p);
              capture(design, board, player, p, dir, dirs, trace, captured);
              if (trace.length > 1) {
                  _.each(dirs, function(dir) {
                      var pos = design.navigate(player, p, dir);
                      if (pos !== null) {
                          var piece = board.getPiece(pos);
                          if ((piece !== null) && (piece.player != player)) {
                              trace.push(pos);
                              done(design, board, player, pos, dir, trace, captured);
                              trace.pop();
                          }
                      }
                  });
              }
              trace.pop();
          }
      }
  }
}

var checkCapturing = function(design, board, pos, player, captured) {
  var trace = [];
  capture(design, board, player, pos, 3, [0, 1], trace, captured);
  capture(design, board, player, pos, 1, [3, 2], trace, captured);
  capture(design, board, player, pos, 2, [0, 1], trace, captured);
  capture(design, board, player, pos, 0, [3, 2], trace, captured);
}

Dagaz.Model.GetCover = function(design, board) {
  if (_.isUndefined(board.cover)) {
      board.cover = [];
      _.each(design.allPositions(), function(pos) {
           board.cover[pos] = [];
           if (board.getPiece(pos) === null) {
               var neighbors = [];
               var attackers = [];
               _.each(design.allDirections(), function(dir) {
                   var p = design.navigate(1, pos, dir);
                   if (p !== null) {
                       var piece = board.getPiece(p);
                       if (piece !== null) {
                           neighbors.push(piece.player);
                           attackers.push(piece.player);
                       } else {
                           while (p !== null) {
                               piece = board.getPiece(p);
                               if (piece !== null) {
                                   attackers.push(piece.player);
                                   break;
                               }
                               p = design.navigate(1, p, dir);
                           }
                       }
                   }
               });
               if (neighbors.length > 1) {
                   var captured = [];
                   if ((_.indexOf(attackers, 1) >= 0) && 
                       (_.indexOf(neighbors, 2) >= 0)) {
                       checkCapturing(design, board, pos, 1, captured);
                   }
                   if ((_.indexOf(attackers, 2) >= 0) && 
                       (_.indexOf(neighbors, 1) >= 0)) {
                       checkCapturing(design, board, pos, 2, captured);
                   }
                   if (captured.length > 0) {
                       board.cover[pos] = _.uniq(captured);
                   }
               }
           }
      });
  }
  return board.cover;
}
</source></spoiler>
В оценочной функции, мне пришлось не просто использовать "покрытие", но и серьёзно переделать алгоритм его вычисления. Что касается эвристики, она в этой игре совершенно элементарна:

<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  return move.actions.length;
}
</source>
Чем больше фигур возьмёт ход (от этого зависит его размер) - тем лучше! Над оценочной функцией пришлось серьёзно потрудиться, но результат того определённо стоил:

<oembed>https://www.youtube.com/watch?v=QeE6VQzxpNg</oembed>
Замечу, на видео представлена работа простейшего "одноходового" алгоритма (можно заметить, что при отсутствии "безопасных" ходов он не всегда играет достаточно эффективно). Как я уже говорил выше, учёт в оценке мобильности и "покрытия" творит чудеса!

И напоследок, видео ещё одной, крайне необычной, игры с custodian-захватом:

<oembed>https://www.youtube.com/watch?v=qJ_G8PyDBDg</oembed>
<b><i>А всех дам спешу поздравить с наступающим праздником!</i></b>
</cut>

Подарков мешок

<img align="left" src="https://habrastorage.org/webt/jo/yc/cv/joyccvvvdz5asdxyplahlbn4jgq.png" /><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;– Ящик! – рявкнул отец Кабани и надолго замолчал, делая странные движения щеками...&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;– Ящик... – повторил отец Кабани упавшим голосом. – Это мы говорим, будто мы выдумываем. На самом деле все давным-давно выдумано. Кто-то давным-давно все выдумал, сложил все в ящик, провертел в крышке дыру и ушел... Ушел спать...&nbsp;
&nbsp;
А. и Б. Стругацкие "<a href="http://www.rusf.ru/abs/books/tbb00.htm">Трудно быть богом</a>"</i></b>&nbsp;
&nbsp;
На носу Новый год и время дарить подарки. За год было сделано немало. Мой <a href="https://glukkazan.github.io/">проект</a> растёт на глазах и, что самое главное, становится умнее. Как именно он это делает - отдельная история, которую я обязательно расскажу, как нибудь, в другой раз. Сейчас - время заглянуть в мешок и посмотреть, что приготовил для нас Dagaz.
<cut>
Начать свой обзор, я хочу с великолепной игры Тревора Трурана "<a href="https://en.wikipedia.org/wiki/Games_of_the_Discworld#Thud">Бац!</a>", разработанной по мотивам одноимённого произведения всеми любимого <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D1%82%D1%87%D0%B5%D1%82%D1%82,_%D0%A2%D0%B5%D1%80%D1%80%D0%B8">Терри Пратчетта</a>. С <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2224">этой</a> игры я начал (по серьёзному) осваивать <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Теперь в неё можно поиграть <a href="https://glukkazan.github.io/elimination/thud.htm">в вебе</a>. Кстати, доску для игры рисовал мой сын (а я её только чуть-чуть подредактировал).

<a href="https://glukkazan.github.io/elimination/thud.htm">
<img align="center" src="https://habrastorage.org/webt/bx/2t/5v/bx2t5vgeo18sdnkddny6wpj4at8.png" /></a>
Картинка кликабельна (как и все последующие в статье). Для меня "Бац!" хорош своей асимметричностью. Игра за троллей довольно тривиальна. Подходя вплотную, они убивают всех, кто находится поблизости. Дварфам, напротив, приходится потрудиться. Они более мобильны и их больше, но чтобы атаковать тролля (запрыгнуть на него), им приходится строить линию. Дварф, находящийся с краю, может "отпрыгнуть" на число шагов не превышающее размера собранной группы (тролли умеют "прыгать" аналогичным образом).

В современном мире, настольные игры, как правило, симметричны, но в древности это было не так. "<a href="https://glukkazan.github.io/elimination/fox-and-geese-british.htm">Лиса и гуси</a>", "<a href="https://glukkazan.github.io/control/asalto.htm">Асальто</a>", "<a href="https://glukkazan.github.io/breakthrough/french-military-small.htm">Французская военная игра</a>" - все эти игры ассиметричны (и были невероятно популярны, в своё время). Также ассиметричны игры семейства "<a href="https://en.wikipedia.org/wiki/Tafl_games">Тафл</a>", сохранившиеся до наших дней благодаря трудам <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%BD%D0%B5%D0%B9,_%D0%9A%D0%B0%D1%80%D0%BB">Карла Линнея</a>, а также неуёмной любви финского народа к разнообразным развлечениям.

<a href="https://glukkazan.github.io/custodian/brandubh.htm">
<img align="center" src="https://habrastorage.org/webt/ye/6l/lv/ye6llvzwlkp0pc2vwfoesyghuuc.png" /></a>
Белым необходимо сопроводить своего короля от "трона", расположенного в центре доски, к любому из угловых полей. Их противники стараются помешать сделать это. В отличии от аналогичных игр на больших досках, все фигуры, а не только король, могут перемещаться всего на один шаг, в любом из ортогональных направлений. Во всех играх семейства действует древняя форма <a href="https://en.wikipedia.org/wiki/Custodian_capture">кооперативного захвата</a>. Для того чтобы убрать фигуру с доски, её необходимо с двух сторон окружить своими фигурами (одним ходом можно захватить до трёх фигур). 

Пустой "трон" и угловые поля (на которые не могут заходить никакие фигуры кроме короля), также могут использоваться для выполнения захвата. Любая фигура может безопасно вставать между двумя противниками (такая ситуация не считается захватом). При попытке захвата короля, белые имеют право на выполнение ещё одного хода (если этим ходом они не убирают с доски одного из противников, взявших короля в окружение, белым засчитывается поражение). Кроме того, если король находится на "троне" или рядом с ним, его необходимо окружать со всех четырёх сторон.

<a href="https://glukkazan.github.io/control/gala.htm">
<img align="center" src="https://habrastorage.org/webt/td/uq/f_/tduqf_tfwvkrviqagg3xy0cwc14.png" /></a>
Ещё одна игра, на которую, скорее всего, оказал влияние "Тафл". Средневековые "<a href="http://www.chessvariants.com/historic.dir/gala.html">Фермерские шахматы</a>". Сходство с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматами</a>, впрочем, довольно отдалённое. Я уже писал об этой игре <a href="https://geektimes.ru/post/262146/">раньше</a>. Для победы, необходимо провести <b>двух</b> своих королей в центр доски - "святое место". Вообще, надо сказать, что Шахматы далеко не сразу стали такими, какими мы привыкли их видеть.

<spoiler title="История с географией">
Всё началось, пожалуй, с <a href="https://en.wikipedia.org/wiki/Ashtapada">Аштапады</a> - индийской доски, размером 8x8 полей, использовавшейся для "<a href="http://skyruk.livejournal.com/273902.html">боевых гонок</a>". Игры подобного рода распространены в Индии и по сей день, но правила самой "Аштапады", к сожалению, утеряны. Ясно только, что разметка самой доски связана именно с этой игрой. Для определения дальности хода фигур в игре использовались кости D4 (с четырьмя гранями). Сами фигуры должны были, по спирали обойдя всю доску, дойти до центра доски.

В какой-то момент, на этом основании, родилась сложная тактическая игра "<a href="https://en.wikipedia.org/wiki/Chaturanga">Чатуранга</a>", разделившая фигуры на четыре типа войск (название "Чатуранга" переводится как "четырёхчастная"). Где-то в сети, я видел (и с тех пор никак не могу найти) объяснение хода фигур, исходя из результата броска костей (напомню, что в игре использовались кости с четырьмя гранями).

<ul>
	<li>"<b>1</b>" (в некоторых наборах "<b>5</b>") - Пешки и короли, перемещающиеся всего на один шаг. Пешки двигались "только вперёд" и (единственные из фигур) брали не так как ходили (на одно поле вперёд, по диагонали).</li>
	<li>"<b>2</b>" - Слон (в некоторых источниках "лодка"). С этой фигурой больше всего путаницы. По всей видимости, первоначально он ходил на две клетки в ортогональном направлении. Потом направление сменилось на диагональное (встречается ещё один вариант перемещения, сохранившийся в тайском "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%80%D1%83%D0%BA">Макруке</a>" - на одну клетку в четырёх диагональных направлениях или на одну клетку вперёд, как ноги и хобот слона). Перемещаясь на две клетки, слон, как и привычный нам шахматный конь, мог "перепрыгивать" фигуры (в индийских боевых гонках, фигуры перепрыгивались, не блокируя движение).</li>
	<li>"<b>3</b>" - Конь перемещался на три шага (два вперёд и один вбок). Столь причудливый способ перемещения связывается с тем, что в Аштападе, выполняя ход на три шага, фигура довольно часто двигалась именно таким образом (на поворотах). Разумеется, конь, как и слон, мог перепрыгивать другие фигуры.</li>
	<li>"<b>4</b>" - Колесница (в некоторых источниках слон) - самая дальнобойная фигура. Перемещалась на любое количество клеток по прямой (в ортогональном направлении), но не могла "перепрыгивать" другие фигуры.</li>
</ul>
<a href="https://glukkazan.github.io/checkmate/chaturanga.htm">
<img align="center" src="https://habrastorage.org/webt/rv/xs/aa/rvxsaavvlr2qexefaaj9lxpsnhk.png" /></a>
Теория о том, что Шахматы произошли от игры <a href="https://pt.wikipedia.org/wiki/Chaturaji">четырёх игроков</a> является, по всей видимости, <a href="http://skyruk.livejournal.com/274559.html">ошибочной</a>. Такой вариант игры также встречается, но, скорее всего, появился гораздо позже. В игре двух игроков, короля дополнял "министр", также перемещавшийся всего на одно поле, но только в диагональных направлениях. Очень слабая и тихоходная фигура.

Персидский "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандж</a>" внешне почти ничем не отличался от "Чатуранги". Изменились правила превращение пешек, но, самое главное, впервые появились концепции <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мата</a>. В "Чатуранге" требовалось захватить или "оголить" раджу (оставить его без фигур). В "Шатрандже" шах стал неприкосновенной фигурой. Запрещалось оставлять его под угрозой, а для победы требовалось поставить его в безвыходной положение (<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мат</a> или <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82">пат</a>). Оголение короля считалось ничьёй. Поскольку, в связи с тотальной тихоходностью фигур, дебюты в Шатрандже были весьма неторопливы, большое распространение получили <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%B8%D1%8F">табии</a> - начала игры с оговоренных игроками позиций:

<a href="https://glukkazan.github.io/checkmate/shatranj-mushaihi.htm">
<img align="center" src="https://habrastorage.org/webt/_f/3u/n1/_f3un1du-qbrlg6s4ecyrw6vlek.png" /></a>
<spoiler title="Шаг в сторону">
Проблему "неторопливых дебютов" в разных странах решали по разному. Например, в эфиопском <a href="https://en.wikipedia.org/wiki/Senterej">Senterej</a>, игроки просто начинали игру одновременно и перемещали фигуры не обращая внимания друг на друга, вплоть до первого соприкосновения с противником (надо сказать, что это хорошо согласуется с африканским темпераментом). Пожалуй, наиболее новаторским образом подошли к этому вопросу <a href="https://en.wikipedia.org/wiki/Sittuyin">бирманцы</a>.

<a href="https://glukkazan.github.io/checkmate/sittuyin-1.htm">
<img align="center" src="https://habrastorage.org/webt/ra/ob/7p/raob7peoa1diwkydsuddufzpoai.png" /></a>
В этой игре, возникшей задолго до <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B-960">Фишера</a>, только порядок расстановки пешек жёстко регламентирован. Остальные фигуры игрок волен расставлять (на своей стороне) так, как ему заблагорассудится (ну разве что первая линия всегда зарезервирована для ладей). Это правило придаёт игре невероятное тактическое разнообразие и делает практически бесполезным "зазубривание" разнообразных дебютов.

<a href="https://glukkazan.github.io/checkmate/makruk.htm">
<img align="center" src="https://habrastorage.org/webt/ls/se/mf/lssemfl7oviucvvwreaorsfgggg.png" /></a>
В тесном родстве с Ситтуйином состоит тайский "<a href="http://skyruk.livejournal.com/275784.html">Макрук</a>". В силу того, что превращение пешек, в этой игре, происходит уже на шестой линии (превращаются они всё в того же слабого "ферзя"), а количество таких превращений не ограничено (в отличии, например, от Ситтуйина) игра в эндшпиле становится весьма своеобразной и на редкость интересной. Известный советский шахматист и экс-чемпион мира <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D0%BC%D0%BD%D0%B8%D0%BA,_%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BC%D0%B8%D1%80_%D0%91%D0%BE%D1%80%D0%B8%D1%81%D0%BE%D0%B2%D0%B8%D1%87">Владимир Крамник</a> серьёзно увлекался этой игрой. Вот что он <a href="http://skyruk.livejournal.com/275784.html">говорил</a> о ней:

<blockquote>Макрук носит более стратегический характер, чем шахматы, ... Вы должны планировать комбинации в более общем контексте. Тайский макрук можно уподобить эндшпилю в международных шахматах.</blockquote>

<a href="https://glukkazan.github.io/checkmate/chess.svg">
<img align="center" src="https://habrastorage.org/webt/gs/k1/0r/gsk10rpijcaddnsrp6oq4ldwjlq.png" /></a>
Скорее всего, именно Макрук послужил основой для <a href="https://glukkazan.github.io/xiangqi/xiangqi.svg">китайской</a> и <a href="https://glukkazan.github.io/shogi/shogi.svg">японской</a> ветвей семейства шахматных игр. Утверждать это со стопроцентной точностью, разумеется, невозможно - слишком сильно эти игры видоизменились, но, во всяком случае, расстановка пешек и в "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8">Сянцы</a>" и в "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>" более всего напоминает аналогичную именно в "Тайских шахматах".
</spoiler>
Следующим этапом на пути к Шахматам стало изобретение современного шахматного слона в "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%80%D1%8C%D0%B5%D1%80%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Курьерских шахматах</a>" - игре  XIII—XVIII веков. Появление дальнобойных фигур, перемещающихся по диагонали, привело к необходимости использования знаменитой "шахматной" разметки доски, в свою очередь сыгравшей огромную роли в развитии и распространении <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Шашек</a>. Играть в "Курьерские шахматы", как правило, также начинали со своего рода табии:

<a href="https://glukkazan.github.io/checkmate/courier-chess-variant.htm">
<img align="center" src="https://habrastorage.org/webt/xa/_p/6d/xa_p6dpyfjz_xdyqcuzbqvgufaw.png" /></a>
После изобретения дальнобойного шахматного ферзя, началась новейшая история Шахмат. Последние изменения в правилах были связаны с добавлением правил "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">Рокировки</a>", прыжка пешек на две клетки вперёд, с начальной позиции и связанного с этим правила "<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a>". Относительно последнего, впрочем, нет полной ясности. В малазийском "<a href="http://skyruk.livejournal.com/278047.html">Майн Чаторе</a>" существует похожее правило, но брать можно только пешку, движение которой вперёд заблокировано другой пешкой игрока (это до странности похоже на <a href="https://en.wikipedia.org/wiki/Custodian_capture">кооперативное взятие</a> в играх "зажимного" типа, таких как "Тафл").
</spoiler>
В наше время, вариации этой игры также поражают своим <a href="https://en.wikipedia.org/wiki/List_of_chess_variants">разнообразием</a>. Не все они одинаково интересны, но иногда среди них попадаются настоящие жемчужины. Мне, например, очень понравились варианты игры с <a href="https://en.wikipedia.org/wiki/List_of_chess_variants#Different_number_of_pieces">неравными армиями</a>.

<a href="https://glukkazan.github.io/checkmate/horde-chess.htm">
<img align="center" src="https://habrastorage.org/webt/hh/w3/pl/hhw3pldg3viafzxddoxqgmxlfo0.png" /></a>
Здесь соблюдаются все шахматные правила (во всяком случае те, которые имеют смысл, в рамках начальной расстановки фигур). Эти игры неплохо сбалансированы и, кроме того, могут развлечь тех, кому наскучила привычная шахматная игра. Если же простого изменения начальной расстановки недостаточно, есть ещё более смелые игры, сметающие на своём пути все шаблоны:

<oembed>https://www.youtube.com/watch?v=twfM1HklVHg</oembed>
В <a href="https://glukkazan.github.io/checkmate/platform-chess.htm">Platform Chess</a> все привычные нам шахматные правила также соблюдаются (переучиваться не надо), но сама концепция игрового поля - трансформера буквально взрывает мозг. Для тех же, кто настольным играм предпочитает старые добрые головоломки я подготовил 60 уровней "<a href="https://glukkazan.github.io/sokoban/sokoban-01.htm">Сокобана</a>" (клавиатурные стрелки работают).

<a href="https://glukkazan.github.io/sokoban/sokoban-01.htm">
<img align="center" src="https://habrastorage.org/webt/yr/rw/na/yrrwnaes5xx_6omjr9cllgnak70.png" /></a>
<b><i>Всех с наступающим Новым Годом!</i></b>
</cut>

В поисках Спока

<img align="left" src="https://habrastorage.org/webt/d-/cm/6n/d-cm6nq_nhkqwimicu1anqhqrqk.png" /><b><i>- А мне вот чо любопытно, - сказал Угрыз. &nbsp; 
 - А зачем у тебя на шляпе пробки?
 - Чтобы мух отгонять, - объяснил Ринсвинд.
 - И как, получается?
 - Ясен перец нет, - фыркнул Клэнси. 
 - Если бы помогало, кто-нибудь до ентого давно бы уже додумался.
 - Ну да. Я и додумался, - сказал Ринсвинд. 
 - Будь спок.
&nbsp;
&nbsp; &nbsp; &nbsp;сэр Терри Пратчетт "Последний континент"</i></b>

Эта игра символизирует непрерывный духовный поиск, борьбу со стереотипами и примирение со своим альтер эго. Ладно, кого я пытаюсь обмануть? Я просто увидел её во сне.
<cut>
Само собой, с классической схемой "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C,_%D0%BD%D0%BE%D0%B6%D0%BD%D0%B8%D1%86%D1%8B,_%D0%B1%D1%83%D0%BC%D0%B0%D0%B3%D0%B0">камень-ножницы-бумага</a>" я был знаком задолго до этого. Также как и c её "расширенной" версией, призванной решить проблему высокой вероятности "переигровки" при выбрасывании оппонентами одинаковых фигур (впрочем, героям "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B3%D0%BE_%D0%B2%D0%B7%D1%80%D1%8B%D0%B2%D0%B0_(%D1%82%D0%B5%D0%BB%D0%B5%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB)">Теории большого взрыва</a>" это дополнение, по понятным причинам, не помогает). Напомню правила:

<blockquote>Ножницы режут бумагу. Бумага заворачивает камень. Камень давит ящерицу, а ящерица травит Спока, в то время как Спок ломает ножницы, которые, в свою очередь, отрезают голову ящерице, которая ест бумагу, на которой улики против Спока. Спок испаряет камень, а камень, разумеется, затупляет ножницы
</blockquote>
<spoiler title="Существуют и ещё более расширенные схемы">
<img align="center" src="https://habrastorage.org/webt/27/tq/ts/27tqtskp82d42rllmxkxftxfbom.jpeg" />
Но я бы не хотел углубляться в эзотерику.
</spoiler>
Я давно хотел приспособить эти (или похожие на них) правила к шахматным играм. Подобные схемы взаимодействия фигур, позволяют выполнять сложные тактические построения, "закрываясь" от одних фигур другими. При этом, в игре нет "самой сильной" фигуры, каждая фигура может быть побита какой-то другой.

<spoiler title="Параллели и меридианы">
Разумеется, здесь нельзя не вспомнить о знаменитой китайской игре "<a href="http://skyruk.livejournal.com/427724.html">Джунгли</a>", послужившей прототипом для более "взрослой" версии "<a href="http://skyruk.livejournal.com/428408.html">Китайских военных шахмат</a>". В западных странах, больше известна очень похожая на них, но пожалуй более простая игра "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%BE">Стратего</a>". Во всех этих играх, целью является не уничтожение фигур противника, а прорыв на вражескую территорию и "захват флага". Сложные взаимозависимости "силы" фигур служат лишь фоном, заставляющим геймплей заиграть новыми красками.

Сходные принципы используются и в "<a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a>" - сложной шахматной игре 18-го века. Проблемой этой игровой системы является наличие "артиллерии" - большого количества фигур "стреляющих" на дальние дистанции без перемещения на атакуемую позицию. Без какого либо сдерживающего фактора, игра превратилась бы в бессмысленную бойню. Положение спасают "Shield" и "Shield Unit", находящиеся на поле в большом количестве и иммунные к выстрелам.
</spoiler>
Часть требований к новой игре была связана с тем, что я планировал использовать её для отладки игрового AI, в рамках своего проекта <a href="https://glukkazan.github.io/">Dagaz</a>. Игровое поле должно было быть небольшим. Я остановился на квадратной доске размером 5x5 клеток. Чтобы фигуры не "толкались" на столь ограниченном пространстве, я разрешил им "перепрыгивать" дружественные фигуры также, как если бы это были пустые поля. Сами фигуры должны были стать узнаваемыми:

<b>Камень</b> - перемещается на одно поле в любом из восьми направлений (хотя, через цепочку фигур своего цвета, может неожиданно перепрыгнуть и на другой конец доски). Согласно схеме, он атакует "Ножницы" и "Ящерицу" - главных убийц в игре (и, разумеется, иммуннен к их атакам). Это наиболее массовая фигура, составляющая, своего рода, живой щит. Фигура мобильная, но тихоходная.

<b>Ножницы</b> - могут перемещаться только по диагоналям (при необходимости перепрыгивая фигуры своего цвета), бьют "Ящерицу" и "Бумагу" ("Спока" - главную фигуры игры, "Ножницы" не бьют). Это аналог шахматного "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Слона</a>".

<b>Ящерица</b> - самый сильный убийца, аналог шахматного "<a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D1%80%D0%B7%D1%8C">Ферзя</a>", перемещается в любом из восьми направлений на любое количество полей и бьёт "Бумагу" и "Спока". Должна перемещаться по полю очень осторожно, поскольку уязвима для атак "Ножниц" и "Камня".

<b>Бумага</b> - перемещается ортогонально, как шахматная "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладья</a>". Также как и "Ящерица", бьёт "Спока", но, кроме того, может атаковать ещё и "Камень".

<b>Спок</b> - главная фигура в игре. Если у игрока не остаётся ни одного "Спока" (а в процессе игры их может появиться несколько) - он проиграл (также, традиционно, поражением считается невозможность выполнения очередного хода). "Спок" перемещается как шахматный "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Конь</a>", но только на занятое поле (своей фигурой, или фигурой противника - не важно). При этом, "Спок" может атаковать любую фигуру, но не убивает её а превращает в другую (превращённая фигура появляется на том поле, откуда "Спок" начал движение). "Камень" превращается в "Ножницы", "Ножницы" в "Ящерицу" и так далее. Разумеется, превращённая фигура всегда становится дружественной.

<a href="https://glukkazan.github.io/elimination/spock.htm">
<img align="center" src="https://habrastorage.org/webt/nl/s7/gw/nls7gw80afa3xic_bbtmfk0zzei.png" /></a>
Начальная расстановка чем-то напоминает шахматную. "Спок" - главная фигура, расположен по центру. Обе "Бумаги", также как и шахматные "Ладьи" - по флангам. "Камни" перед ними прикрыты "Ножницами", но более важно то, что "Бумага" не может атаковать вражеский "Камень" первым ходом, поскольку подставится под атаку "Спока". Резервный "Спок", плюс лишение оппонента сильной фигуры - желанная добыча. 

"Ящерицы" - самой сильной фигуры, в начальной расстановке нет. Получить её можно только в процессе игры, превращением из "Ножниц". "Спок" не может превратить дружественные "Камни" из начальной позиции, так как подставится под удар вражеской "Бумаги". Может показаться, что "Спок" не может атаковать вражеского "Спока" непосредственно (поскольку подставится под удар и окаменеет), но это не так. Появление на поле b3 (или d3) "Бумаги" (не имеет значения чьей) приведёт к немедленной победе "синих".

<oembed>https://www.youtube.com/watch?v=YfKIkjv4zwQ</oembed>
В целом, игра получилась именно такой как я и планировал. Динамичной, неожиданной, коварной. Что ещё более важно, на каждом этапе игры, ходы, при относительно небольшом их количестве, широко варьируются от сильных до очень слабых. Один неверный ход может привести к немедленному поражению.

Spock позволил мне хорошо поработать над игровым AI и хотя результаты этих работ пока очень скромны, моё понимание <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BA%D1%81">минимакса</a>, да и <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">UCT</a> тоже, значительно улучшилось. Всё это тема для другой статьи. Пока же, я предлагаю читателям насладиться новой оригинальной <a href="https://glukkazan.github.io/elimination/spock.htm">игрой</a>, а также <a href="https://glukkazan.github.io/shogi/mini-shogi.htm">другими</a> <a href="https://glukkazan.github.io/shogi/ren-shogi.htm">играми</a> <a href="https://glukkazan.github.io/races/hanoi-5.htm">и</a> <a href="https://glukkazan.github.io/races/swappers-8.htm">головоломками</a>, вошедшими в итерацию 1.1.7 <a href="https://glukkazan.github.io/">проекта</a>.
</cut>

Шашки со странностями

<img align="left" src="https://habrastorage.org/webt/59/cd/16/59cd16af7f7a8759803747.png"/><b><i>Всё страньше и страньше! 
Всё чудесатее и чудесатее! 
Всё любопытственнее и любопытственнее! 
Всё страннее и страннее!

Льюис Кэрролл "Алиса в Стране чудес"</i></b>

Ошибаются те, кто думают, что шашки это какая-то игра. Как человек, <a href="https://glukkazan.github.io/">посвятивший вопросу некоторое время</a>, со всей ответственностью могу заявить, что только лишь одной игрой дело совсем не ограничивается! И речь здесь не только о <a href="https://glukkazan.github.io/checkers/russian-checkers.htm">русских</a>, <a href="https://glukkazan.github.io/checkers/english-checkers.htm">английских</a>, <a href="https://glukkazan.github.io/checkers/spanish-checkers.htm">испанских</a>, <a href="https://glukkazan.github.io/checkers/italian-checkers.htm">итальянских</a> и даже <a href="https://glukkazan.github.io/checkers/international-checkers.htm">международных</a> шашках. Всё это лишь верхушка айсберга. Встречаются и более странные, <b>гораздо более странные</b> игровые системы. И я вам о них расскажу.
<cut>
Для начала, стоит определиться с тем, что делает шашки шашками. Каковы критерии принадлежности игры этому семейству? Многие считают, что главным отличием шашек от шахмат является игра однотипными фигурами. Разумеется, это очень поверхностное суждение. В шашках есть дамки. И они - важная составляющая игры. Лишь очень <a href="https://glukkazan.github.io/checkers/senegalese-checkers.htm">немногие</a> разновидности шашек <b>действительно</b> играются фигурами одного типа. Так что же является главным? На мой взгляд, две вещи:

<ul>
	<li>Завершение игры при отсутствии возможных ходов</li>
        <li>Обязательность взятия</li>
</ul>
Прежде всего, в шашечных играх нет какой-то специальной цели, типа взятия главной фигуры или расстановки фигур по определённой схеме. Цель игры максимально проста - оставить противника без возможности хода! Не важно как мы этого добьёмся - "съев" все фигуры или "заперев" их. Второй особенностью является обязательность взятия. Если имеется возможность атаки фигуры противника, мы <b>должны</b> её брать!

От игры к игре этот принцип варьируется, но остаётся едва ли не главным правилом большинства шашечных игр (мне известна лишь <a href="http://mlwi.magix.net/bg/ossetian.htm">одна</a> традиционная игра, в которой взятие не является обязательным). Попытки отказа от этого правила <a href="https://en.wikipedia.org/wiki/Huff_(board_games)">предпринимались</a>, но в современной шашечной игре не прижились (за исключением отдельных африканских разновидностей). Это не случайно, поскольку обязательное взятие - основа всей комбинационной игры. Только оно позволяет заманить противника в ловушку и, в сочетании с составными ходами, позволяет "пожертвовав меньше, забрать больше".

<a href="https://glukkazan.github.io/checkers/unusual-checkers.svg">
<img src="https://habrastorage.org/webt/59/ce/0d/59ce0df08e0f6429271086.png" /></a>

Как обычно, можно "потыкать" в картинку, чтобы во что нибудь из всего этого поиграть. Цветом показаны традиционные игры. Что касается игр "не традиционных", то всё это, как правило, относительно недавние изобретения. Как и в случае с фантастикой, здесь, на мой взгляд, прекрасно работает "принцип одного допущения". Берётся известная игра и в ней изменяется всего одно правило. Например, разрешается "съедать" свои фигуры. С учётом обязательного взятия, <a href="https://glukkazan.github.io/checkers/samoedy.htm">игровой процесс</a> получается довольно не скучным:

<oembed>https://www.youtube.com/watch?v=cGgA9odOByY</oembed>
Не менее забавной получается <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm">игра</a>, в которой разрешается "ходить" фигурами противника (обязательное взятие остаётся "в силе", для обеих сторон). Разумеется, эти принципы можно комбинировать. Так на свет рождаются "Ставропольские самоеды". Иногда, определить, в чём заключается отличие от традиционной игры, бывает довольно непросто. Например, "<a href="https://glukkazan.github.io/checkers/bahrain-dama.htm">Бахрейнские шашки</a>" отличаются от <a href="https://glukkazan.github.io/checkers/turkish-dama.htm">турецких</a> очень незначительно. Конечно, гораздо чаще различия бывают более заметны.

<spoiler title="Два метра колючей проволоки">
Все помнят результат скрещивания ежа с ужом? С двумя самыми знаменитыми (во всяком случае, на нашей территории) играми подобные эксперименты проводили неоднократно. Шашечная игра, с добавленными в неё шахматными фигурами, придуманная в 1948 году <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BB%D0%BE%D0%BC%D0%B1,_%D0%A1%D0%BE%D0%BB%D0%BE%D0%BC%D0%BE%D0%BD_%D0%92%D0%BE%D0%BB%D1%8C%D1%84">Соломоном Голомбом</a>, дала название всему семейству. <a href="https://en.wikipedia.org/wiki/Cheskers">Cheskers</a> - "слово-бумажник", в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%B2%D0%BE%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5">лучших традициях</a> Льюиса Кэрролла. <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BC%D0%B0%D1%82%D1%8B">Русскоязычное название</a>, на мой взгляд, чуть менее благозвучно, но также соблюдает традиции.

<a href="https://glukkazan.github.io/checkers/cheskers.htm">
<img align="center" src="https://habrastorage.org/webt/59/ce/30/59ce3029d84cc254023422.png" /></a>
Строго говоря, <a href="https://glukkazan.github.io/checkers/cheskers.htm">это</a> уже не совсем шашки. Изменена цель игры - побеждает тот, кто первым съест всех королей противника, но, в отличии от шахмат, количество королей на доске может быть увеличено! Именно в них превращаются "рядовые" фигуры на последней линии (поскольку за основу взяты <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">английские</a>, а не <a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">русские</a> шашки, короли получаются вполне тихоходными). Дополнительные фигуры "Слон" и слегка изменённый "Конь" также придают игре некоторое разнообразие. Главным является принцип обязательного взятия. Он действует для всех фигур!

<oembed>https://www.youtube.com/watch?v=_I7vRHg76Xs</oembed>
Не менее успешно <a href="https://glukkazan.github.io/checkmate/belarusian-chess.htm">детище</a> белорусских товарищей. Здесь действуют все правила как шахмат так шашек (в их русской разновидности), причём бой обязателен только для шашечных фигур. Как это ни странно, игра получается довольно интересной. За счёт того, что взятие шашкой более приоритетно чем даже защита от шаха, в игре <a href="http://www.gambiter.ru/checkers/item/276-chess-checkers.html">вполне возможны</a> такие казусы как мат королём. 
</spoiler>
<a href="https://glukkazan.github.io/checkers/swedish-checkers.htm">Шведские шашки</a> - довольно любопытная разновидность игры для четырёх человек. Впрочем, вряд ли о ней знают в Швеции. Обычно этот номер проделывается с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B2%D0%B5%D0%B4%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">шахматами</a>. Суть в том, что игра ведётся пара на пару одновременно на двух досках. Взятые фигуры передаются "в резерв" напарнику и могут быть введены им в игру на другой доске. <a href="http://www.gambiter.ru/checkers/item/188-shashechnye-shvedki.html">Шашечные шведки</a> - прекрасный пример применения некоего общего принципа, для создания новой игры. Игра очень молодая, но по ней уже проводятся турниры.

<a href="https://glukkazan.github.io/checkers/column-checkers.htm">
<img align="center" src="https://habrastorage.org/webt/59/d1/36/59d1369747d11883108112.png" /></a>
<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовые шашки</a> - игра, напротив, более почтенного возраста. Как и в "Шведках", фигуры в ней никогда не покидают игру, но делают это совершенно по другому! При выполнении взятия, вражеская фигура берётся "в плен", уходя под основание "башни" и может быть впоследствии освобождена (при взятии, с "башни" всегда снимается одна, самая верхняя шашка). Сказать, что это усложняет игру - значит очень сильно преуменьшить масштаб того, насколько эта игровая механика сбивает с толку даже самых опытных шашистов!

<oembed>https://www.youtube.com/watch?v=iD_ChvZSLO0</oembed>
Башни с несколькими фигурами одного цвета на вершине обретают невероятную силу, пожалуй даже большую чем сила "летающих дамок". Кстати, ловля одинокой дамки (даже на большаке!) и связанная с этим "ничейная смерть" в столбовых шашках не являются такой уж большой проблемой. Это вообще на редкость продуманная и сбалансированная игра единственным недостатком которой является, пожалуй, только её высокая сложность (как для людей, так и для компьютеров).

Столбовые шашки послужили источником вдохновения и для других игр, таких как "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D1%81%D0%BA%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Ласка</a>", разработанная в 1911 году великим шахматным гроссмейстером <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D1%81%D0%BA%D0%B5%D1%80,_%D0%AD%D0%BC%D0%B0%D0%BD%D1%83%D1%8D%D0%BB%D1%8C">Эмануэлем Ласкером</a>. Впрочем, русскому человеку, <a href="https://glukkazan.github.io/checkers/laska.htm">играть</a> в неё тяжело. Дамки в этой игре "тихоходные", взятые из <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">английских шашек</a>. В результате чего, при равной игре соперников, эндшпили бывают весьма затяжными и, как правило, ничейными. В какой-то степени, развитием идеи столбовых шашек являются "<a href="https://glukkazan.github.io/checkers/northern-checkers.htm">Северные</a>", а также разнообразные варианты "<a href="https://skyruk.livejournal.com/328070.html">Многоэтажных</a>" шашек.

К чему я это всё? Шашек много! С самым разным градусом странности. Это живое, динамично развивающееся семейство настольных игр. Глупо "хоронить" шашки лишь по той причине, что кому-то удалось полностью рассчитать на компьютере (даже не из любой возможной, а только лишь из начальной позиции) одну из самых простейших их разновидностей. Играйте в шашки! Они интересные.
</cut>

Dagaz: Шажки

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>- Давненько не брал я в руки шашек! 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- говорил Чичиков, подвигая тоже шашку. 
- Знаем мы вас, как вы плохо играете! 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- сказал Ноздрев, выступая шашкой. 
&nbsp;
Николай Васильевич Гоголь "Мёртвые души"&nbsp;
</i></b>
Я очень смутно помню диалектику Гегеля, которую нам давали в институте. Обычно, неудержимая сонливость побеждала меня в самом начале лекций. Помню только, что-то говорилось о том, что "история развивается по спирали". Вроде бы это связывалось с принципом "отрицания отрицания". Я не вполне уверен в универсальности этого закона, но в отношении меня он выполняется. Сколько себя помню, я снова и снова делаю одно и тоже. Это мой способ стать лучше. Как бы там ни было, я вновь делаю шашки. И это здорово!
<cut>
Как я уже неоднократно говорил, шашки - это сложно! Сами шашечные игры возможно и проще <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахмат</a> (хотя сравнивать их не совсем корректно, игры принципиально разные), речь не о том. Реализация шашек гораздо сложнее! Если Шахматы "подложили свинью" с каскадными ходами (<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>), то в играх шашечного семейства имеется сразу две ещё более сложных "опции":

<ul>
	<li><b>Приоритеты</b> и ...</li>
	<li><b>Составные ходы!</b></li>
</ul>
Приоритеты - это то, что делает шашки особыми! Практически во всех шашечных играх (за очень редким исключением), взятие является обязательным, хочется вам того или нет. На этом построена вся комбинационная игра. Вы можете "поддавать" свои шашки, выстраивая фигуры противника таким образом, чтобы потом забрать их одним ударом (а заодно и провести дамку). Отдать меньше, чтобы забрать больше! Но это только верхушка айсберга!

<oembed>https://www.youtube.com/watch?v=zMpxcNG2UDQ</oembed>
В этой партии (позиция взята из книги Ю.Барского и Б.Герцензона "Приключения на шашечной доске"), белые не просто жертвуют фигуры, вынуждая противника ходить определённым образом. Они пользуются тем, что чёрные обязаны выполнить все взятия и (в это время) свободно перемещают по доске свои фигуры, подготавливая финальную ловушку. Своими ходами белые создают "роздых" и это превосходная иллюстрация того, насколько красивой может быть позиционная игра в шашках.

<spoiler title="К слову сказать">
Взятия в шашках не всегда были строго обязательными. И в русских шашках и в английских и даже в ещё более раннем Алькуэрке существовало "<a href="https://habrahabr.ru/post/258437/">правило гнева</a>", позволявшее забрать "зевнувшую" фигуру, не выполнившую взятие. Такое действие не считалось ходом и называлось "взять за фук" (Huffing - в "Английских шашках"). Я ещё застал это правило в раннем детстве, но похоже, история уже вынесла окончательный приговор.

Правило гнева ставит крест на любой комбинационной игре! Опытный шашист предпочтёт лишиться "зевнувшей" фигуры, вместо того чтобы сознательно лезть в ловушку, из за которой он проиграет всю партию. В настоящее время, это правило применяется лишь в некоторых африканских разновидностях игры, традиционно играемых на больших досках и на высокой скорости.
</spoiler>
Для меня, приоритеты - это, прежде всего, оптимизация. В самом деле, используя "<a href="https://habrahabr.ru/post/320474/">фирменную магию</a>" Dagaz, я могу запретить выполнение любых ранее сформированных ходов на стадии пост-обработки (именно так я и поступаю в <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkmate/nam-dinh-invariant.js">шахматных</a> <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkmate/chessence-invariant.js">играх</a>). Более того, я могу изменять сгенерированные ходы и даже добавлять к ним новые. Но всё это ценой памяти и времени (а когда за дело берётся <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/uct-ai.js">UCT-бот</a>, и то и другое становится весьма критично). Производительность, в моём случае, это не столько интерактивность, сколько "разумность" компьютерного оппонента. Работая быстрее, бот успеет разобрать большее количество позиций!

В случае шашек, генерация ходов сводится к двум возможным ситуациям. Когда взятий нет - "тихих" ходов не так много. Всё меняется когда взятия появляются. Поскольку я генерирую все составные ходы целиком, в дело включается комбинаторика. Например, вот в этом <a href="https://github.com/GlukKazan/Dagaz/blob/master/tests/checkers-test.js">тесте</a>, заурядная позиция с дамкой генерирует 42 возможных хода! И этих ходов было бы <b>гораздо</b> больше, если бы по правилам "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашек</a>" я не <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/maximal-captures.js">отфильтровывал</a> ходы со взятием максимального количества фигур! Добавление к этому списку ещё и "тихих" ходов, с их последующей фильтрацией в пост-обработке, было бы пустым расточительством.

<spoiler title="Здесь-то я и словил первый нетривиальный баг">
<oembed>https://www.youtube.com/watch?v=tid7yT7UnFc</oembed>
<a href="http://homepages.di.fc.ul.pt/~jpn/gv/gauntlet.htm">Gauntlet</a> - очень динамичная и довольно интересная шашечная игра. Разработал её Phillip L.Leduc в 1980 году. Игра ассиметрична. Белым необходимо прорваться (хотя бы одной фигурой) на последнюю горизонталь. Чёрные - стараются не допустить этого. Взятия аналогичны шашечным, но, поскольку все фигуры двигаются только в одном направлении, полноценная реализация составных ходов не требуется (кстати, есть ещё одна, традиционная <a href="https://glukkazan.github.io/stalemate/konane.htm">гавайская игра</a>, со сходным механизмом взятия). Приоритеты, в этой игре, напротив, используются, поскольку взятия обязательны и это важная составляющая игры. 

В определённых ситуациях, модель переставала генерировать ходы, что приводило к немедленному останову игры. Было понятно, что ошибка связана с механизмом обработки приоритетов, но я не сразу разобрался, в чём дело. Вначале я даже перенёс логику фильтрации в расширение, отключив приоритеты (как я уже сказал, это всего лишь вопрос производительности). Когда ошибка стала повторяться и в шашках, стало понятно, что с проблемой необходимо разобраться.

<spoiler title="Всё дело вот в этом коде">
<source lang="javascript">
var priors = [];
_.chain(_.keys(this.pieces))
 .filter(function(pos)  
    { return Dagaz.Model.sharedPieces || 
             Dagaz.Model.isFriend(this.pieces[pos], this.player); 
    }, this)
 .each(function(pos) {
     var piece = this.pieces[pos];
     _.chain(design.pieces[piece.type])
      .filter(function(move) { return (move.type == 0); })
      .each(function(move) {
          var g = Dagaz.Model.createGen(move.template, move.params, this.game.design);
          g.init(this, pos);
          addPrior(priors, move.mode, g);
      }, this);
  }, this);
...
for (var i = 0; i <= design.modes.length; i++) {
     var f = false;
     if (!_.isUndefined(priors[i])) {
         while (priors[i].length > 0) {
            var g = priors[i].pop();
            g.generate();
            if (g.completed && !g.move.isPass()) {
                if (cont && (g.moveType == 0)) {
                    CompleteMove(this, g);
                }
                f = true;
            }
         }
     }
     if (f) break;
     if (i >= design.modes.length) break;
}
</source></spoiler>
Здесь перебираются все фигуры игрока и для каждой из них создаются генераторы, для каждого возможного хода. Генераторы раскладываются в небольшой хэш, в соответствии с приоритетами ходов. Затем хэш просматривается, начиная с наиболее высокого приоритета. Если удаётся сгенерировать хотя бы один ход, генераторы ходов более низких приоритетов не рассматриваются.

Ошибка была в том, что я помечал ход как сгенерированный раньше времени, при первом взятии. В результате, генератор видел взятие, помечал ход, а после этого шёл дальше и натыкался на занятое поле, в том месте, где он должен был разместить фигуру. Это приводило к сбросу почти завершённого хода, но поскольку ход был уже помечен, низкоприоритетные "тихие" ходы попросту отбрасывались. После <a href="https://github.com/GlukKazan/Dagaz/commit/1eaaf2e94466fa9f734b682f66a902c8e6661949">исправления</a>, AI Gauntlet-а стал играть гораздо лучше. Производительность - это важно!
</spoiler>
Думаю, настало время немного рассказать о шашках. Многие из нас знакомы только с <a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">русской</a> и, возможно, <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">международной</a> версией этой игры. На самом деле, шашек (даже если рассматривать только традиционные игры) больше. Гораздо больше! Игры очень похожи друг на друга и, зачастую, различаются лишь мелкими деталями.

<a href="https://glukkazan.github.io/checkers/checkers.svg">
<img src="https://habrastorage.org/web/6ab/8fd/883/6ab8fd883ec241869244560307faf63d.PNG"/></a>

Картинка кликабельна. Дважды! За начало отсчёта возьмём средневековые "<a href="https://glukkazan.github.io/checkers-like/alquerque.htm">Алькуэрк</a>" и "<a href="https://glukkazan.github.io/elimination/fox-and-geese-british.htm">Лису и гусей</a>". Похоже, что это первые игры, в которых появилось составное взятие. Идея здесь в том, что выполнив "шашечное" взятие, фигура получает право продолжить ход, взяв ещё одну фигуру. И так, до тех пор, пока есть кого брать.

Связи на моей диаграмме довольно условны. Они отражают не историческое развитие (его, в наше время, восстановить уже вряд ли удастся), а скорее взаимосвязи различных вариантов правил игры. Так, например, "<a href="https://glukkazan.github.io/checkers/senegalese-checkers.htm">Сенегальские шашки</a>" вряд ли являются предтечами "<a href="https://glukkazan.github.io/checkers/turkish-dama.htm">Турецких шашек</a>" и, соответственно, всего "ортогонального" направления. Они более архаичны, это факт, но скорее всего, имело место параллельное развитие от какого-то неизвестного общего предка.

Со стороны другого семейства, произошло одновременно два важных исторических события - отказ от ортогональных перемещений (в пользу диагональных) и использование традиционной шахматной доски (на волне роста популярности Шахмат, это решение самым благотворным образом сказалось на распространении игры). Мы вновь не знаем, где и когда это случилось. Возможно, связующим звеном послужили "<a href="http://skyruk.livejournal.com/256132.html">Дана</a>" - Филиппинские шашки, сложно сказать.

"<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Английские шашки</a>" служат корнем "диагонального" семейства, поскольку используют наиболее примитивный вариант правил. Не превращённые фигуры в них не могут двигаться назад (даже выполняя взятие), дамки отличаются только тем, что имеют право двигаться в любую сторону. Это очень неторопливая игра. Итальянцы "повернули" доску на 90 градусов и сделали дамки неприкосновенными (простые фигуры не могут "рубить" их). Кстати, имеется интересная <a href="https://glukkazan.github.io/checkers/italian-damone.htm">разновидность игры</a>, развивающая эту идею:

<oembed>https://www.youtube.com/watch?v=HSZc3RGZO_0</oembed>
В "<a href="https://glukkazan.github.io/checkers/spanish-checkers.htm">Испанских шашках</a>" доска всё также развёрнута на 90 градусов, но здесь появляются "летающие" дальнобойные дамки (простые фигуры по прежнему не могут "рубить" назад). Дамки становятся очень сильными и впервые возникает задача их "ловли".

<spoiler title="Каждый шашист должен уметь делать это!">
Три дамки ловят одну (при условии того, что она не заняла "большак" - главную диагональ доски). Это интересная задача, для решения которой можно использовать, как минимум, два тактических построения: знаменитый "<a href="http://www.gambiter.ru/checkers/item/63-treugolnik-petrova.html">Треугольник Петрова</a>" и менее известный "<a href="http://www.gambiter.ru/checkers/item/73-shtyk-gonyaeva.html">Штык Гоняева</a>".

<oembed>https://www.youtube.com/watch?v=6Lzw0rcUDbI</oembed>
Желающие попрактиковаться могут сделать это <a href="https://glukkazan.github.io/checkers/russian-checkers-ending.htm">здесь</a>.
</spoiler>
<a href="https://glukkazan.github.io/checkers/argentinian-checkers.htm">Аргентинский</a> и <a href="https://glukkazan.github.io/checkers/thai-checkers.htm">тайский</a> варианты игры ограничивают мобильность дамок, разрешая им останавливаться лишь на первом поле за взятой фигурой (если оно свободно, разумеется). Кстати, точно таким же образом "<a href="https://glukkazan.github.io/checkers/greek-checkers.htm">Греческие шашки</a>" ограничивают подвижность "турецких дамок". Далее идут уже привычные нам варианты игры, разрешающие "взятие назад" простыми фигурами.

<spoiler title="Ещё немного о взятиях">
Практически все варианты шашек с дальнобойными дамками (кроме "Турецких" и "Греческих") используют правило "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>", также направленное на ограничение мобильности дамок. Суть его в том, что взятые фигуры убираются с доски лишь по завершении хода. Это ограничивает дамку, мешая её перемещениям (разумеется, повторные взятия фигур, в течение хода, запрещены). С этим правилом был связан второй сложный баг текущей итерации.

Я решил поступить просто - <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/deferred-captures.js">переместить</a> все взятия составного хода в его последний частичный ход. Это сработало как и было задумано - фигуры оставались на доске в течение всего хода и удалялись с доски после его завершения. Разумеется, мне пришлось внести <a href="https://github.com/GlukKazan/Dagaz/commit/b79cc66a783bca9d450d8ee197d12a3c64790305">изменения в модель</a>, препятствующие повторному взятию фигур (в противном случае, генератор ходов просто зацикливался и ни до какой "магии расширений" дело просто не доходило). К сожалению, я забыл сделать главное - запустить <a href="https://github.com/GlukKazan/Dagaz/blob/master/tests/checkers-test.js">тесты</a> после этого изменения! В результате, я потратил много времени. Логика составных взятий "сломалась" весьма не тривиальным и довольно незаметным образом. Это было внезапно и ужасно. Всё сломалось!

<spoiler title="В конце концов, я нашёл решение">
<source lang="javascript">
ZrfMoveGenerator.prototype.isCaptured = function(pos, level) {
  if (this.parent) {
      return this.parent.isCaptured(pos, level);
  }
  if (_.isUndefined(this.captured)) {
      this.captured = [];
  }
  if (this.captured[pos] && (this.captured[pos] < level)) return true;
  _.each(Dagaz.Model.getDesign().allPositions(), function(p) {
      if (this.captured[p] && (this.captured[p] >= level)) {
          delete this.captured[p];
      }
  }, this);
  this.captured[pos] = level;
  return false;
}

ZrfMoveGenerator.prototype.capturePiece = function(pos) {
  if (Dagaz.Model.deferredStrike) {
      if (this.isCaptured(pos, this.level)) return false;
  }
  this.move.capturePiece(pos, this.level);
  if (!Dagaz.Model.deferredStrike) {
      this.setPiece(pos, null);
  }
  return true;
}
</source></spoiler>
Но сил и времени на это было потрачено очень много. Никогда не забывайте про тесты! И ещё, никогда не делайте вот так:
<source lang="javascript">
_.chain(move.actions)
 .filter(function(action) {
      return (action[0] !== null) && (action[1] === null);
  })
 .each(function(action) {
      action[3] = mx;
  });
</source>Последствия будут чудесны, но вряд ли вам понравятся! Не изменяйте поля (пусть даже самые безобидные) внутри коллекции, которую итерируете. Лучше пересоздайте её, пусть она остаётся иммутабельной:

<source lang="javascript">
var actions = [];
_.each(move.actions, function(action) {
    var pn = action[3];
    if ((action[0] !== null) && (action[1] === null)) {
        pn = mx;
    }
    actions.push([ action[0], action[1], action[2], pn ]);
});
move.actions = actions;
</source></spoiler>
<a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Русские шашки</a> (кстати есть <a href="https://glukkazan.github.io/checkers/80-cells-checkers.htm">ещё один</a> весьма оригинальный способ решения проблемы "дамка на большаке") отличаются от <a href="https://glukkazan.github.io/checkers/international-checkers.htm">международных</a> (помимо размера доски, разумеется) всего одной значимой деталью. В русских шашках, превращение в дамку происходит "на лету". Ход не прерывается и фигура продолжает взятие уже как дамка (с точки зрения программной реализации, это было наиболее очевидное поведение). В международных - фигура продолжает взятие, даже попав на поле превращения, но "рубит" как простая фигура, а само превращение происходит только в том случае, если фигура заканчивает свой ход на последней горизонтали. Здесь пришлось сочинить <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers/international-extension.js">специальное расширение</a>, впрочем, его отладка не вызвала никаких проблем.

Тем временем, Алькуэрк тоже эволюционировал. Развитие происходило параллельно развитию шашек и почерпнуло из последних такие идеи как ход простых фигур "только вперёд", "летающие дамки" и даже правило "турецкого удара". Получились вполне самобытные и весьма оригинальные игры "<a href="https://glukkazan.github.io/checkers-like/zamma.htm">Замма</a>" и "<a href="https://glukkazan.github.io/checkers-like/kharbaga.htm">Харбага</a>", могу порекомендовать их тем, кто устал от шахматной доски.

<oembed>https://www.youtube.com/watch?v=3fPM0KSQEmk</oembed>

<spoiler title="Финны сохранили для нас ещё одну древнюю игру">
<a href="https://glukkazan.github.io/checkers-like/dablot-prejjesne.htm">
<img align="center" src="https://habrastorage.org/web/6bd/a45/f85/6bda45f85a1b4530b734899a1ec71750.PNG"/></a>
<a href="https://en.wikipedia.org/wiki/Dablot_Prejjesne">Эта игра</a> гораздо ближе к Алькуэрку. В ней нет "летающих дамок", нет даже превращений! В игре есть "король" и "принц", но эти должности пожизненные. Простые фигуры не могут стать "монаршими особами". Также они не могут угрожать "титулованным" фигурам (в этом отношении, игра похожа на "Итальянские шашки"). Игра довольно неторопливая, но имеет своих почитателей.

Для меня <a href="https://glukkazan.github.io/checkers-like/dablot-prejjesne.htm">Dablot</a> был интересен более сложной системой приоритетов. Взятия в игре обязательны, но не для "короля" или "принца". То есть, если есть возможность взятия простой фигурой - брать необходимо (можно брать и другой фигурой, даже "королём", если такой ход есть), но если угрозу создаёт только "король" или "принц", разрешается делать "тихий" ход. Всё это вылилось в довольно простое <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/checkers-like/dablot-invariant.js">расширение</a> (на уровне ZRF приоритеты пришлось отключить). Впрочем, и здесь я умудрился слегка <a href="https://github.com/GlukKazan/Dagaz/commit/85e09de4570ab560560c13bf1dabcee9aa6454a2">напахать</a>:

<source lang="diff">
  if (_.chain(board.moves)
       .filter(function(move) {
           return _.isUndefined(move.failed);
        })
       .filter(function(move) {
           return move.actions.length > 1;
        })
       .filter(function(move) {
           ...
-        }).value().length > 1) {
+        }).value().length >= 1) {
        _.chain(board.moves)
         .filter(function(move) {
             return move.actions.length == 1;
          })
         .each(function(move) {
             move.failed = true;
          });
  }
</source></spoiler>
Венцом развития этого направления игр я считаю мадагаскарскую "<a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">Фанорону</a>". Она уже совсем непохожа на шашки, поскольку использует совершенно иной механизм взятия. Общие черты конечно есть - взятие тоже составное. При этом, Фанорона - единственная известная мне игра, в которой цепочку взятий игрок имеет право прерывать (само взятие по прежнему остаётся обязательным)!

<oembed>https://www.youtube.com/watch?v=NAVVsEBT8W8</oembed>
Эта игра стала для меня настоящей проверкой на прочность. Здесь было всё: и ломка модели и переписывание контроллера и новые забавные баги. Но всё хорошо, что хорошо кончается. Итерация завершена и я могу с чистой совестью отправляться в отпуск!
</cut>

Dagaz: Забегая вперёд

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i>Сто тринадцать раз в секунду оно тянется, и достает все дальше. Если бы пришло подтверждение, сигнал — оно могло бы остановиться, и оно не останавливается. Оно тянется и находит всё новые способы. Оно импровизирует, оно изучает. Оно не сознает, что делает...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Джеймс Кори "Пожар Сиболы"</i></b>

Вообще говоря, "сильный" игровой AI не является моим приоритетом. Глупо соревноваться со специализированными игровыми движками, занимаясь универсальным и имея лишь однопоточный JavaScript, встроенный в браузер, в качестве вычислительного ресурса. Кроме того, есть целый ряд игр, в которых потребности в сложном AI просто не возникает. Вот <a href="https://glukkazan.github.io/breakthrough/french-military-small.htm">здесь</a>, например, весь AI сводится к <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/breakthrough/breakthrough-ai.js">поиску кратчайшего пути</a>, а в <a href="https://glukkazan.github.io/stalemate/hunt.htm">этой игре</a> с задачей прекрасно справляется <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/random-ai.js">рандом</a>. Увы, такие игры скорее исключение чем правило. Гораздо чаще, приходится изрядно потрудиться, чтобы программа делала ходы, которые не казались бы попросту идиотскими.
<cut>
Целью моего <a href="https://glukkazan.github.io/">проекта</a> является популяризация настольных игр. Я ищу малоизвестные или просто забытые настольные игры и стараюсь вернуть их к жизни. Самые разные игры: древние, современные, сложные и совсем детские, для двух игроков или большего их количества. Даже для одного игрока (головоломки - это тоже игры). Критерий один - <a href="https://github.com/GlukKazan/Dagaz/blob/master/doc/games.txt">игры</a> должны быть интересны! По крайней мере, мне.

На текущей стадии развития проекта не подразумевается серверная часть хоть сколь-нибудь более сложная чем просто набор html-страничек с сопутствующим кодом на JavaScript. Я хочу чтобы игра загружалась и работала в любом современном Web-браузере, в том числе и локально, без доступа к Internet. Всевозможные соревнования, рейтинги и всё что связано со взаимодействием игроков-людей между собой - всё это не про мой проект. Возможно это будет, но вряд ли в ближайшем будущем.

И здесь на первый план выходит разработка ботов и управляющих ими алгоритмов. То есть, интерактивная доска с максимально полным контролем правил игры - это конечно хорошо, но чтобы заинтересовать человека, возможно совсем не знакомого с игрой, с ним надо играть. А поскольку игра людей между собой пока не предусмотрена, приходится заниматься ботами.

<h2><b>Основной инстинкт</b></h2>
Как я уже говорил, есть игры, в которых от машины требуется не столько интеллект, сколько инстинкты. И это не значит, что игры плохие! Как правило, такие игры ассиметричны. От одной из сторон требуется творческий подход (этим займётся человек), игра другой стороны более рутинна. Вот хороший <a href="https://glukkazan.github.io/elimination/maharadja.htm">пример</a> такой игры.

Имея на своей стороне полную шахматную "армию", требуется поймать (съесть) всего одну фигуру - Махараджу, сочетающую в себе ходы шахматного коня и ферзя. Это очень сильная фигура, но, при правильной игре белых, исход предрешён. С другой стороны, игра за чёрных довольно тривиальна. Реализация <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/aggressive-ai.js">бота</a> мало чем отличается от рандомного. Он делает следующее:

<ol>
	<li>Среди всех доступных ходов ищет ход непосредственно ведущий к победе (в нашем случае, это взятие короля противника)</li>
	<li>Если такого хода нет, ищет любой ход берущий фигуру противника и не подставляющий "Махараджу" под ответный удар</li>
	<li>Если подходящих ходов нет - делает любой безопасный ход</li>
	<li>Если нет безопасных ходов - передаёт эстафету другому боту (как правило, рандомному)</li>
</ol>
Как это ни странно, подобная нехитрая стратегия пригодна для многих игр. Во всяком случае, в первом приближении. Вот видео <a href="http://www.di.fc.ul.pt/~jpn/gv/archimedes.htm">игры</a> с довольно экзотическими правилами взятия. Фигуры немедленно снимаются с доски, если им угрожают (по правилам хода шахматного ферзя) три и более фигур противника:

<oembed>https://www.youtube.com/watch?v=SJtaql0lNww</oembed>
Вот ещё один пример. В "<a href="http://www.di.fc.ul.pt/~jpn/gv/3musketeers.htm">Трёх мушкетёрах</a>" взятия выполняются только одним из противников, но зато на каждом ходу. Задача другого игрока - направить "мушкетёров" таким образом, чтобы они оказались на одной вертикали или горизонтали. Если цель не будет достигнута и любая из сторон не сможет сделать очередной ход - "мушкетёры" победят:

<oembed>https://www.youtube.com/watch?v=OzaMmuKBbO8</oembed>
Играя за "мушкетёров", вполне можно было бы обойтись рандомом, но было бы обидно, если бы компьютер выстраивал линию случайно, имея в запасе другой, безопасный ход. Бот должен играть более <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/careful-ai.js">осторожно</a>. Код прост настолько, насколько это возможно.

<spoiler title="Выбор безопасного хода">
<source lang="javascript">
CarefulAi.prototype.getMove = function(ctx) {
  var result = [];
  // Генерируем все ходы из текущей позиции
  _.chain(Dagaz.AI.generate(ctx, ctx.board))
    // Просто проверка наличия действий внутри хода, на всякий случай
   .filter(function(move) {
       return move.actions.length > 0;
    })
    // Для каждого хода
   .each(function(move) {
     // Применяем ход к текущей позиции, получая новую позицию
     var b = ctx.board.apply(move);
     // Если цель противника не достигнута
     if (b.checkGoals(ctx.design, ctx.board.player) >= 0) {
         // Добавляем ход к списку безопасных ходов
         result.push(move);
     }
  }, this);
  if (result.length > 0) {
      // Выбираем любой случайный ход из списка безопасных
      var ix = this.params.rand(0, result.length - 1);
      return {
          done: true,
          move: result[ix],
          ai:   "careful"
      };
  }
  // Если нет безопасных ходов
  if (this.parent) {
      // Обращаемся к Рандому 
      return this.parent.getMove(ctx);
  }
}
</source></spoiler>
Разумеется, я вовсе не хочу сказать, что боты не играли бы в эти игры лучше, используя более сложные алгоритмы, но и самые простейшие решения имеют своё применение (например, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/random-ai.js">рандом</a> может бросать кости в тех играх, где это требуется). Кроме того, у простых алгоритмов имеется одно важное достоинство. Они работают очень быстро.

<h2><b>Игры для одного</b></h2>
В случае головоломок, игровой AI является не столько необходимостью, сколько способом "набить" руку. В конце концов, предполагается, что человек будет решать их сам! С другой стороны, можно до бесконечности смотреть, как компьютер пытается решить головоломку вместо тебя:

<oembed>https://www.youtube.com/watch?v=QNsRGQBKitg</oembed>
Простой алгоритм <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/bruteforce-ai.js">перебора</a> (ничего более эффективного для этого класса головоломок пока не придумали). Чтобы позиции не повторялись, используем <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist Hash</a>. В этом видео, можно заметить, что одиночные квадратики как то слишком уж долго вальсируют друг с другом. Всё потому что бот считает их <b>разными</b> фигурами. Это <a href="https://github.com/GlukKazan/Dagaz/commit/7a9e23bfc6fb39a18620ccfad9688094cbad7efd">легко</a> исправить. Теперь решение находится гораздо быстрее:

<oembed>https://www.youtube.com/watch?v=l4oi8r747a0</oembed>
Другой момент, который лично меня очень сильно нервировал, заключался в том, что не дойдя до заветной цели всего пару шагов "по прямой", бот мог сделать шаг "в сторону" и двигать плашки ещё с полчаса, уходя от решения всё дальше и дальше. Чтобы решить эту проблему, я использовал время выделяемое для анимации хода. За 100 миллисекунд, практически незаметные для человека, можно успеть перебрать сотни позиций.

<spoiler title="Забегание вперёд">
<source lang="javascript">
  var x = [];
  var queue = [ ctx.board ];
  var timestamp = Date.now();
  while ((Date.now() - timestamp < this.params.AI_FRAME) && queue.length > 0) {
      var board = queue.shift();
      var moves = cache(x, board);
      if (board.checkGoals(Dagaz.Model.getDesign(), board.player) != 0) {
          return {
              done:  true,
              move:  traceMove(ctx, board),
              ai:    "win"
          };
      }
      for (var i = 1; i < moves.length; i++) {
           var b = board.apply(moves[i]);
           var k = getKey(b);
           if (_.isUndefined(x.cache[k]) && !isLoop(ctx, b)) {
               queue.push(b);
           }
      }
  }
  ...
</source></spoiler>
Просто перебираем всевозможные ходы, пока есть время. Если находим цель - идём к ней по прямой! Хотя работа этого бота довольно наглядна, он использует не лучший способ, чтобы решить задачу. Было бы разумнее потратить больше времени вначале, чтобы заняться анимацией уже после того как решение найдено. Именно так я и поступил при разработке бота для решения пасьянсов "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D0%B8%D1%82%D0%B5%D1%80_(%D0%B8%D0%B3%D1%80%D0%B0)">Солитёра</a>":

<oembed>https://www.youtube.com/watch?v=Zoo92gVSHOQ</oembed>
По примеру <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%B9%D0%B1%D0%BD%D0%B8%D1%86,_%D0%93%D0%BE%D1%82%D1%84%D1%80%D0%B8%D0%B4_%D0%92%D0%B8%D0%BB%D1%8C%D0%B3%D0%B5%D0%BB%D1%8C%D0%BC">Лейбница</a>, я <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/solitaire/solitaire-ai.js">решаю</a> эту задачу в обратную сторону, то есть, начиная с одной фишки стоящей в центре доски и выполняя обратные ходы, пытаюсь построить исходную фигуру. Под таким углом зрения, задача сводится к обычному <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D1%81_%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%BE%D0%BC">поиску с возвратом</a>. Вот кусок лога:

<spoiler title="Немного текста">
Goal: 10,16,17,18,24,31
Current: 22,23
Current: 22,25,24
Current: 22,27,24,26
Current: 22,27,38,26,31
Current: 24,27,38,26,31,23
Current: 22,27,38,24,31,25
Current: 22,27,38,26,29,30
Current: 22,27,38,26,33,32
Current: 22,27,38,26,17,24
Current: 22,27,10,26,17
Current: 24,27,10,26,17,23
Current: 22,27,10,24,17,25
Current: 22,27,10,26,15,16
Current: 22,27,10,26,19,18
Current: 22,27,10,26,31,24
Current: 22,39,24,32
Current: 22,37,24,32,38
Current: 22,23,24,32,38,30
Current: 22,37,26,32,38,25
Current: 22,37,10,32,38,17
Current: 22,37,24,30,38,31
Current: 22,37,24,34,38,33
Current: 22,37,24,46,38,39
Current: 22,37,24,18,38,25
...
</spoiler>
Можно заметить, что я прерываю перебор по достижении набора из 6 позиций (из такого количества фигур состоял искомый пасьянс). Разумеется, это не единственная оптимизация. При наивном подходе, описанном выше, позиции могут повторяться. Как всегда, когда речь заходит о повторении позиций, на помощь приходит Zobrist Hash (на самом деле, он помогает ещё раньше: прежде чем сравнивать позиции поэлементно гораздо эффективнее в начале сравнить их хэши).

<spoiler title="Кстати говоря">
С отладкой этого бота произошёл забавный казус. Так получилось, что разработанные игры я запускаю, в основном, под FireFox-ом лишь изредка проверяя их на Chrome и IE. Однажды, уже при выкладывании релиза, выяснилось, что solitaire-ai, прекрасно работая под IE и FireFox, под Chrome работает в десятки раз медленнее! Это было не сильно критично, но очень странно. 

Для выяснения ситуации пришлось использовать профайлер. В результате оказалось, что причиной тормозов в Chrome является этот самый console.log. Даже если сама консоль закрыта. После того как я убрал консольный вывод, всё заработало с примерно одинаковой скоростью. Мораль в этой истории очень проста. Если вам необходимо выводить большой объём текста (например, в отладочных целях) и вы собираетесь использовать для этого console.log - подумайте ещё раз.
</spoiler>
Изрядно потренировавшись на пазлах, можно переходить к более сложным материям.

<h2><b>Оно тянется</b></h2>
Довольно очевидно, что для более менее серьёзных игр, вроде шахмат или шашек, потребуется более сложный AI, чем всё то, о чём я писал выше. Выбор, по большому счёту, невелик: Минимакс, с его "<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0-%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">Альфа-бета отсечением</a>" и метод "<a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Монте-Карло</a>" (и по <a href="https://habrahabr.ru/post/208580/">тому</a> и по <a href="https://habrahabr.ru/post/282522/">другому</a> имеются замечательные статьи на Хабре). Каждый из этих подходов универсален. У каждого из них есть свои плюсы и минусы. Не претендуя на полноту обзора, перечислю первое, что приходит в голову.

<ol>
	<li>Чтобы использовать метод минимакса, необходимо определить функцию, выполняющую оценку позиции (как разработчик настольных игр со стажем, могу заметить, что для некоторых игр это может быть очень непросто).</li>
	<li>Альфа-бета отсечение особенно эффективно при выполнении поиска в глубину, либо комбинированного поиска (в ширину, до некоторой гарантированной глубины, например на 2-3 хода, после чего, в глубину, не более чем на N уровней). Это делает его малопригодным в условиях ограниченных вычислительных ресурсов и, самое главное, при необходимости вывода ответа не позднее заданного времени (пусть знающие люди поправят меня, если я ошибаюсь).</li>
	<li>Эффективность альфа-бета отсечения можно значительно улучшить, применяя предварительно ранжирование ходов по их качеству (как я скажу ниже, при использовании метода "Монте-Карло" такие эвристики тоже полезны).</li>
	<li>При использовании метода минимакса, перебор в глубину нельзя останавливать в произвольном месте. При обнаружении форсированных ходов (в Шахматах такими являются шахи и взятия фигур) поиск следует продолжать до возникновения более "спокойной" позиции.</li>
	<li>При использовании метода "Монте-Карло" симуляция производится до терминальной позиции (победы одного из игроков или признания ничьей). В играх с большой продолжительностью партии это может быть проблемой.</li>
</ol>
Приняв во внимание все эти соображения, я решил, не сбрасывая со счетов метод минимакса окончательно, в текущей итерации сосредоточиться на методе <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/kernel/controller/ai/uct-ai.js">Монте-Карло</a> (разумеется, подобрав подходящие для него задачи). В качестве одной из игр, для тестирования работы алгоритма, я выбрал "<a href="https://glukkazan.github.io/elimination/kono.htm">Четырёхпольное Коно</a>" - детскую игру родом из Кореи.

Это простая игра со взятиями, целью которой является лишение противника всех его фигур или возможности хода. Взятие в Коно довольно своеобразно. Чтобы забрать фигуру противника, на неё необходимо "приземлиться", перепрыгнув одной из своих фигур через другую (благодаря этому, можно начать игру, несмотря на то, что в начальной позиции доска полностью забита фигурами). Вот отладочный вывод при расчёте одного из ходов (ограничение времени ~3 секунды):

<spoiler title="Отладочный лог">
Player: Black
d2 - c2
Goal: 1; Deep: 26; Player: 1; P1: a2; P2: a4,a3,b3,c3,c2
Goal: 1; Deep: 20; Player: 1; P1: a1; P2: a4,b4,c4,d4,b3
Goal: 1; Deep: 16; Player: 1; P1: b1; P2: a4,b4,d4,a3,c3,d3
Goal: 1; Deep: 34; Player: 1; P1: c2; P2: a4,b4,d4,b3
Goal: 1; Deep: 22; Player: 1; P1: c3; P2: a3,b3,d3,b2,d2
Goal: 1; Deep: 24; Player: 1; P1: b1; P2: a4,b4,c3,b2,c2
Goal: 1; Deep: 30; Player: 1; P1: d2; P2: a4,c4,b3,b2
Goal: 1; Deep: 12; Player: 1; P1: a1; P2: a4,b4,c4,b3,d3,d2
Goal: 1; Deep: 34; Player: 1; P1: b1; P2: a4,b4,a3,c1
Goal: 1; Deep: 60; Player: 1; P1: d2; P2: a4,b4,b3,b1,c1
Goal: 1; Deep: 34; Player: 1; P1: d2; P2: a3,c2,a1,b1
Goal: 1; Deep: 36; Player: 1; P1: b1; P2: a4,d4,a3,d3,c2
Goal: 1; Deep: 32; Player: 1; P1: c1; P2: b4,a3,c3,a2,c2
Goal: 1; Deep: 24; Player: 1; P1: c2; P2: b3,b2
Goal: 1; Deep: 70; Player: 1; P1: a1; P2: b3,b2
Goal: 1; Deep: 38; Player: 1; P1: b1; P2: a4,b4,c3,a2,b2
Goal: 1; Deep: 28; Player: 1; P1: a1; P2: a4,d4,b3,c3,c2
Goal: 1; Deep: 34; Player: 1; P1: b2; P2: a4,b4,d4,a3,d3
Goal: 1; Deep: 20; Player: 1; P1: c1; P2: a4,b4,c4,d4,a3,c3
Goal: 1; Deep: 18; Player: 1; P1: c2; P2: a4,c4,a3,c3,b2,d1
Goal: 1; Deep: 28; Player: 1; P1: a2; P2: d4,c3,d3,c2
Goal: 1; Deep: 34; Player: 1; P1: d1; P2: b4,a3,b3,d3,a2
Goal: 1; Deep: 30; Player: 1; P1: b1; P2: a4,a3,b3,c3,b2,c2
Goal: 1; Deep: 36; Player: 1; P1: a2; P2: b4,a3,b3
Goal: 1; Deep: 24; Player: 1; P1: c1; P2: b4,a3,b3,d3
Goal: 1; Deep: 36; Player: 1; P1: a1; P2: a4,c3,a2,c2
Goal: 1; Deep: 22; Player: 1; P1: c1; P2: a4,b4,c4,d4,b2,c2
Goal: 1; Deep: 38; Player: 1; P1: c3; P2: a4,d4,b3,b2,c2
Goal: 1; Deep: 46; Player: 1; P1: a1; P2: a4,b4,c4,b2,c2
Goal: 1; Deep: 38; Player: 1; P1: a1; P2: a4,b4,d3,c2,d2
Goal: 1; Deep: 28; Player: 1; P1: b1; P2: b4,c4,d4,c3,a2
Goal: 1; Deep: 20; Player: 1; P1: d2; P2: a4,b4,c4,b3,c2
Goal: 1; Deep: 20; Player: 1; P1: c1; P2: a4,b3,c3,b2
Goal: 1; Deep: 48; Player: 1; P1: d1; P2: a3,a2,b2
Win = 5; All = 11; Move = d3 - c3
Win = 6; All = 12; Move = d3 - d2
Win = 13; All = 18; Move = a3 - b3
Win = 7; All = 13; Move = c4 - c3
Win = 3; All = 8; Move = b4 - b3
Player: White
a3 - b3
</spoiler>
Имея перед глазами такой вывод, можно оценивать корректность работы алгоритма. Первое, на что следует обратить внимание это то, соответствуют ли "цели", зафиксированные алгоритмом, целям игрока согласно правилам игры. В процессе отладки, у меня была пара ситуаций, когда алгоритм пытался искать попросту "не то". Если с целями всё нормально, смотрим на оценку ходов (Win - количество зафиксированных побед, All - общее количество сыгранных игр). UCT "из коробки" работает, в принципе неплохо, но я внёс пару изменений:

<ol>
	<li>Ограничил глубину поиска (100 по умолчанию)</li>
	<li>Добавил эвристики ходов</li>
</ol>
<spoiler title="Для Коно эвристика выглядит следующим образом">
<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  var r = 1;
  if (move.actions.length > 0) {
      var pos = move.actions[0][1][0];
      if (board.getPiece(pos) !== null) {
          r += 9;
      }
  }
  return r;
}
</source></spoiler>
То есть, взятия в 10 раз более предпочтительны чем "тихие" ходы. Здесь следует заметить, что  в отличии от метода минимакса, сортировать ходы в Монте-Карло (в соответствии с их эвристиками) бесполезно. Необходимо строить алгоритм таким образом, чтобы вероятность выбора хода была пропорциональна его эвристической оценке. Оба нововведения благоприятно сказались на статистике побед/сыгранных игр для Коно и я взялся за другие игры.

<oembed>https://www.youtube.com/watch?v=DxmMkTZKroI</oembed>
В этой <a href="http://www.di.fc.ul.pt/~jpn/gv/dodgem.htm">игре</a> взятий нет. Для победы, необходимо провести свои фигуры через всё поле, после чего вывести их с доски (это считается за ход). Двигаться можно только вперёд, влево и вправо (по ортогоналям). Фигуры противника перемещаются перпендикулярно движению и мешают пройти. Запирать фигуры противника нельзя! При всей кажущейся незатейливости, игра довольно глубока. Просто попробуйте сыграть в неё с <a href="https://glukkazan.github.io/races/dodgem-5x5.htm">компьютером</a>.

<spoiler title="Эвристика довольно очевидна">
<source lang="javascript">
Dagaz.AI.heuristic = function(ai, design, board, move) {
  var r = 1;
  for (var i = 0; i < move.actions.length; i++) {
      if ((move.actions[i][0] !== null) && (move.actions[i][1] !== null)) {
           var d = move.actions[i][1][0] - move.actions[i][0][0];
           if ((board.player == 1) && (d < -1)) {
                r += 10;
           }
           if ((board.player == 2) && (d == 1)) {
                r += 10;
           }
      }
      if ((move.actions[i][0] !== null) && (move.actions[i][1] === null)) {
           r += 5;
      }
  }
  return r;
}
</source>
Если фигура двигается вперёд, а не вбок - считаем ход предпочтительным.
</spoiler>
С точки зрения отладки, игра дала информацию о поведении алгоритма на больших досках. Все оценки количества побед для ходов мгновенно обнулились. Алгоритм просто не успевал найти ни одной победы, в результате чего начал делать первые попавшиеся ходы (совсем не лучшие). Увеличение глубины поиска помогло не сильно  - трёх секунд явно не хватало на набор "критической" массы партий, сыгранных в фазе симуляции. Пришлось учитывать эвристики при выборе хода:

<spoiler title="Изменения в UCT">
<source lang="javascript">
function UctAi(params) {
  this.params = params;
  ...
  if (_.isUndefined(this.params.UCT_COEFF)) {
      this.params.UCT_COEFF = Math.sqrt(2);
  }
}

UctAi.prototype.getMove = function(ctx) {
  this.generate(ctx, ctx.board);
  ...
  var mx = null;
  for (var i = 0; i < ctx.childs.length; i++) {
      var u = 0;
      if (ctx.childs[i].win > 0) {
          u = ctx.childs[i].win / ctx.childs[i].all;
      }
      var h = this.heuristic(ctx.design, ctx.board, ctx.childs[i].move);
      var w = this.params.UCT_WEIGHT * u + (1 - this.params.UCT_WEIGHT) * h;
      if ((mx === null) || (w > mx)) {
          mx = w;
          ctx.result = ctx.childs[i].move;
      }
      console.log("Weight: " + w + "; Win = " + ctx.childs[i].win + "; All = " + ctx.childs[i].all + "; Move = " + ctx.childs[i].move.toString());
  }
  ...
}
</source></spoiler>
Ходы по эвристикам конечно хуже чем то, что даёт UCT, но, в не очень сложных играх, они дают компьютеру "дожить" до того момента, когда UCT сможет работать. Весовые коэффициенты подобраны таким образом, чтобы эвристики оказывали заметное влияние лишь в тех случаях, когда алгоритм Монте-Карло не работает.

Следующей игрой стала <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Камисадо</a>. Я уже писал о ней <a href="https://geektimes.ru/post/263072/">раньше</a>. Нельзя сказать, что метод Монте-Карло работает здесь вполне удачно. Программа делает вполне адекватные ходы, но если задаться целью, победить её совсем не сложно:

<oembed>https://www.youtube.com/watch?v=oK3rROwrm9M</oembed>
Главная причина в том, что я не смог придумать для этой игры простую и адекватную эвристику. В результате, программа делает свои ходы "на ощупь". При наличии достаточных вычислительных ресурсов это не было бы проблемой (алгоритм Монте-Карло подходит для этой игры как нельзя кстати), но 3 секунды расчёта хода в одном потоке - это пока максимум того, что я могу себе позволить (кстати, UCT можно очень хорошо масштабируется при наличии нескольких потоков).

Конечно же, метод Монте-Карло, в том виде, как он у меня сейчас реализован, подходит далеко не для всех игр. Я не собираюсь на нём зацикливаться. Для игр, подобных Шахматам, пожалуй, минимакс подойдёт лучше. Я ещё буду иметь возможность исследовать этот вопрос. Также, у меня есть кое какие мысли по поводу улучшения текущей реализации UCT. Посмотрим, что получится лучше.
</cut>

Dagaz: Репетиция

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>- Неправда! В этой сказке говорится совсем не то.
- Но если ты уже знаешь, что говорится в этой сказке, зачем мне ее читать?
- Затем, что я хочу её услышать!

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тед Чан "<a href="https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D1%82%D0%B2%D0%BE%D0%B5%D0%B9_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8">История твоей жизни</a>"</i></b>&nbsp;
&nbsp;
&nbsp;
Это большое событие, когда что-то вдруг начинает работать. Маловразумительные страницы кода на Java и JavaScript, ещё менее понятный XML, картинки, нарисованные в Paint-е - всё это вместе! 
Теперь, это можно запустить и "потрогать". Тесты можно было запускать и раньше, они помогали добраться до этого дня. Но разве можно сравнить тесты с работающей программой? Работоспособный релиз! Для многих, эта веха знаменует конец пути.

Надеюсь, что для меня это только начало...
<cut>
В качестве первой задачи для пробы сил я выбрал "Sliding Puzzles" - головоломки с движущимися частями. Всё началось с игры "<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%D0%B2_15">15</a>" и <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B9%D0%B4,_%D0%A1%D1%8D%D0%BC%D1%8E%D1%8D%D0%BB%D1%8C">Сэма Лойда</a>. Этот выдающийся предприниматель предложил крупный денежный приз за решение задачи, не имеющей решения. И мир сошёл с ума. Когда градус безумия стих, другие люди предложили склеивать части пятнашек между собой, чтобы получить ещё более интересные (но уже имеющие решение) головоломки.

<img align="center" src="https://habrastorage.org/web/47f/940/2fd/47f9402fdd81400ea2026f223dfa92d1.jpg"/>
Папина головоломка - пожалуй самая ранняя из известных головоломок этого рода (под таким именем она продавалась в Америке ещё в 1926 году). Большой квадрат надо переместить в правый нижний угол. Это просто. Здесь (почти) нет тупиков и развилок, сложно сбиться с пути.

Доставить квадрат в левый нижний угол - чуть сложнее. Если разрезать одну из прямоугольных частей на два маленьких квадрата и уложить в коробку по другому, можно получить гораздо более сложную головоломку.

<img align="center" src="https://habrastorage.org/files/e55/657/040/e556570401c04d08b28fb4df2a1685ae.JPG"/>
В детстве мне подарили такую. Я так её и не решил. Во Франции эта головоломка известна под названием "L'Ane rouge" (Рыжий осёл). Большой квадрат требуется разместить внизу, ровно по середине (иногда делалось отверстие, через которое его можно было выдвинуть из коробки). Насколько я знаю, минимальное количество ходов требуемое для решения "Рыжего осла", неизвестно. Мартин Гарднер, в своей книге "<a href="http://publ.lib.ru/ARCHIVES/G/GARDNER_Martin/_Gardner_M..html#015">Математические досуги</a>" описывает решение, состоящее из 81 хода.

Конечно же, "Рыжий осёл" не самая сложная головоломка. Игр такого типа невероятно много (и некоторые из них очень сложны). Известны головоломки с не выпуклыми частями (как "<a href="http://www.cs.brandeis.edu/~storer/JimPuzzles/ZPAGES/zzzMasPuzzle.html">Мамина головоломка</a>" или "<a href="https://sites.google.com/site/geduldspiele/SolutionEscottPuzzle">Головоломка Эскота</a>"). Некоторые наборы разрабатывались в честь исторических событий (таких как избрание <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%88%D0%B8%D0%BD%D0%B3%D1%82%D0%BE%D0%BD,_%D0%94%D0%B6%D0%BE%D1%80%D0%B4%D0%B6">Джорджа Вашингтона</a> президентом Америки или полёты знаменитых лётчиков). Это целый мир, богатый и разнообразный.

В отличии от игры "15" не существует простого способа, для того чтобы определить имеет ли такая головоломка решение. Только перебор! Не удивительно, что программисты к ним так <a href="http://nontwistypuzzles.ru/programms/programms.php?id=5">неровно дышат</a>. Меня это поветрие также не миновало. Я делал "Рыжего осла", когда осваивал Delphi. Позже, я разрабатывал мобильное приложение под Android. Теперь я делаю это снова, правда на этот раз сами головоломки не являются целью - они всего лишь способ, для того чтобы убедиться в работоспособности выбранного мной подхода. Частное применение более универсального продукта.

С точки зрения <a href="https://github.com/GlukKazan/Dagaz">Dagaz</a>, головоломки - это игры для одного игрока. Здесь есть доска и фигуры, есть правила перемещения и условия завершения игры. Нет взаимодействия двух (или большего количества игроков). Для меня этого удобно, поскольку позволяет запустить проект в отсутствии части модулей, необходимых для реализации более сложных игр. Это нулевая итерация. Своего рода пререлиз проекта.

<spoiler title="Как выглядит реализация Sliding puzzles на ZRF?">
<source lang="lisp">
; for (2,1)-pieces
(define shift2x1 ((verify (empty? w)) from w to cascade e e from w to (count-move) add)
  ((verify (empty? e)) from e to cascade w w from e to (count-move) add)
  (w (verify (piece? $1))(verify (empty? w)) e from w to cascade from w to (count-move) add)
  (e (verify (piece? $1))(verify (empty? e)) w from e to cascade from e to (count-move) add)
  ((verify (empty? n))(verify (empty? ne)) e 
   (verify (piece? $1)) w from n to cascade se from n to (count-move) add) 
  ((verify (empty? n))(verify (empty? nw)) w 
   (verify (piece? $1)) e from n to cascade sw from n to (count-move) add)
  ((verify (empty? s))(verify (empty? se)) e 
   (verify (piece? $1)) w from s to cascade ne from s to (count-move) add) 
  ((verify (empty? s))(verify (empty? sw)) w 
   (verify (piece? $1)) e from s to cascade nw from s to (count-move) add)
                  
  (w (verify (empty? w)) 
     (verify empty?) e from w w to cascade e e e from w w to (count-move) add)
  (w (verify (piece? $1)) w (verify (empty? w)) 
     (verify empty?) e e from w w to cascade e from w w to (count-move) add)
  (e (verify (empty? e)) 
     (verify empty?) w from e e to cascade w w w from e e to (count-move) add)
  (e (verify (piece? $1)) e 
     (verify (empty? e)) (verify empty?) w w from e e to cascade w from e e to (count-move) add)
)
</source></spoiler>
И это только один из макросов управляющих согласованным перемещением фигур-тайлов! Конкретно этот обеспечивает перемещение плашки размером 2x1, повёрнутой горизонтально (для вертикальной плашки используется другой хардкод). Разумеется, не <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=831">этот</a> ужасный ужас является моей целью! В <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sliding-puzzles/donkey.zrf">Dagaz</a> всё гораздо проще!

<source lang="lisp">
(define step (
  $1 add
))
</source>
Вот и всё! Разумеется, в реальной жизни всё не бывает так просто. Для того, чтобы головоломка работала как надо, фигуры-тайлы, составляющие одну плашку, должны двигаться синхронно. Кроме того, они не должны "наезжать" на тайлы других плашек, расположенных на доске. Всё это невероятно сложно описывается на ZRF. Нет абсолютно никакого смысла этим заниматься.

<spoiler title="На JavaScript это делается гораздо проще!">
<source lang="javascript">
var distinctMode = false;

var isEqual = function(a, b) {
  if ((a == 0) || (b == 0)) return false;
  return a == b;
}

var isEmpty = function(board, pos, value) {
  var piece = board.getPiece(pos);
  if (piece === null) return true;
  return isEqual(piece.getValue(0), value);
}

var isSubset = function(x, y) {
  for (var i = 0; i < x.actions.length; i++) {
       var action = x.actions[i];
       if (_.chain(y.actions)
            .filter(function(a) {
                return a[0][0] == action[0][0] &&
                       a[1][0] == action[1][0];
             })
            .size()
            .value() == 0) return false;
  }
  return true;
}

Dagaz.Model.getPieceTypes = function(piece, board) {
  var tag = piece.getValue(0);
  return _.chain(board.pieces)
   .compact()
   .filter(function(piece) {
        return piece.getValue(0) == tag;
    })
   .map(function(piece) {
        return piece.type;
    })
   .uniq()
   .value();
}

var CheckInvariants = Dagaz.Model.CheckInvariants;

Dagaz.Model.CheckInvariants = function(board) {
  _.chain(board.moves)
   .filter(function(move) {
       if (move.actions.length != 1) return false;
       var action = move.actions[0];
       if (!action[0]) return false;
       if (!action[1]) return false;
       if (action[0][0] == action[1][0]) return false;
       if (board.getPiece(action[0][0]) === null) return false;
       return true;
    })
   .each(function(move) {
       var design = board.game.design;
       var action = move.actions[0];
       var from   = action[0][0];
       var delta  = action[1][0] - from;
       var piece  = board.getPiece(from);
       var value  = piece.getValue(0);
       if (isEmpty(board, action[1][0], value)) {
       _.chain(_.range(design.positions.length))
        .filter(function(pos) {
            return pos != from;
         })
        .filter(function(pos) {
            if (board.getPiece(pos) === null) return false;
            return isEqual(board.getPiece(pos).getValue(0), value);
         })
        .each(function(pos) {
            var target = pos + delta;
            if ((Dagaz.find(design.positions[pos], delta) < 0) ||
                (target < 0) || 
                (target >= design.positions.length) ||
                !isEmpty(board, target, value)) {
                move.failed = true;
            } else {
                move.movePiece(pos, target, null, 1);
            }
         });
       } else {
            move.failed = true;
       }
    });
  if (distinctMode) {
      var moves = [];
      _.chain(board.moves)
       .filter(function(move) {
            return (_.isUndefined(move.failed));
        })
       .each(function(move) {
           if (_.chain(moves)
            .filter(function(m) {
                return isSubset(m, move) && isSubset(move, m);
             })
            .size()
            .value() == 0) {
                moves.push(move);
           }
        });
      board.moves = moves;
  }
  CheckInvariants(board);
}
</source></spoiler>
<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sliding-puzzles/sliding-puzzle.js">Этот</a> модуль делает всё что нам требуется. Да, он сложный, но пишется всего один раз, после чего используется повторно во всех головоломках такого типа. Подключение JavaScript-модуля к ядру Dagaz, написанному на JavaScript - выполняется гораздо проще чем подгрузка DLL-ек, написанных на C++ в Windows-приложение Zillions of Games. Почему бы этим не пользоваться?

<source lang="lisp">
  (option "smart-moves"    from)
  (option "sliding-puzzle" true)
</source>
Магический модуль подключается второй опцией. Первая включает режим более дружественного перемещения фигур. Что ещё требуется, чтобы описать новую головоломку? Немножко шаблонного кода для описания доски и игрока:

<source lang="lisp">
  (players You)
  (turn-order You)

  (board
     (grid
         (start-rectangle 0 0 100 100)
         (dimensions
           ("a/b/c/d/e" (100 0)) ; files
           ("3/2/1" (0 100)) ; ranks
         )
         (directions (n 0 -1) (s 0 1) (e 1 0) (w -1 0))
     )
  )
</source>
Если размер доски не 5x3 потребуется слегка подредактировать линейки grid-а. Далее описываем сами фигуры (тайлы):

<source lang="lisp">
(define T
  (piece
     (name  $1$2)
     (help  " ")
     (image You "images/$1.bmp")
     (attribute value $2)
     (moves
        (step n) (step s) (step w) (step e)
     )
  )
)

(T R0000  1)
(T R0010C 2) (T R0001P 2)
(T R0100C 3) (T R1000C 3)
(T R0010P 4) (T R0001C 4)
(T R0000P 5)
(T R0100P 6) (T R1000P 6)
(T R0000C 7)
(T R0000  8)
(T R0000  9)
</source>
Макрос под именем "T" просто избавляет нас от большого количества однообразной писанины. Единички и нолики в имени фигуры кодируют картинку, используемую для отображения тайла на доске. Добавляемое к ним число - идентификатор группы. Тайлы у которых оно совпадает перемещаются вместе (это, а также проверку возможности такого перемещения, обеспечивает наш магический скрипт). Осталось описать начальную расстановку фигур:

<source lang="lisp">
  (board-setup
     (You 
         (R00001 b3)
         (R0010C2 c3) (R0001P2 c2)
         (R0100C3 d3) (R1000C3 e3)
         (R0010P4 a2) (R0001C4 a1)
         (R0000P5 b2)
         (R0100P6 d2) (R1000P6 e2)
         (R0000C7 b1)
         (R00008 c1)
         (R00009 d1)
     )
  )
</source>
и цель игры:

<source lang="lisp">
  (win-condition (You) (and 
     (absolute-config R0010C2 (a2 b2 c2 d2 e2))
     (absolute-config R0100C3 (a2 b2 c2 d2 e2))
     (absolute-config R1000C3 (a2 b2 c2 d2 e2))
     (absolute-config R0001C4 (a2 b2 c2 d2 e2))
     (absolute-config R0000C7 (a2 b2 c2 d2 e2))
  ))
</source>
Собрав всё вместе, получаем практически честный <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sliding-puzzles/donkey.zrf">ZRF-файл</a>. Запустить его в <a href="http://www.zillions-of-games.com">Zillions of Games</a> не удастся по двум причинам.

<ol>
        <li>Традиционный Zillions of Games ничего не знает про опцию  "<b>sliding-puzzle</b>"</li>
	<li>Числовые атрибуты он тоже не поддерживает (а стоило бы)</li>
</ol>
Теперь, в дело вступает <a href="https://github.com/GlukKazan/Dagaz/tree/master/utils/z2j">Z2J</a> - это такая специальная утилита для превращения ZRF-файлов во что-то более понятное для Dagaz. Написана на Java с использованием <a href="https://ru.wikipedia.org/wiki/XSLT">XSLT</a>-процессора <a href="https://xml.apache.org/xalan-j/">Xalan</a>:

<source lang="bash">
/usr/bin/java -classpath "./z2j.jar:./log4j-1.2.jar:./xalan-2.7.1.jar:./serializer-2.7.1.jar" com.gluk.z2j.app.App ./twins.zrf
</source>
После её запуска, в том же каталоге где лежал ZRF-файл, появляются ещё два файла (на XML-файлы внимание можно не обращать, они для отладки). <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sliding-puzzles/twins.js">JavaScript</a>-файл содержит всё необходимое для настройки модели, а <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/debug/games/sliding-puzzles/twins.htm">html-файл</a> создаётся просто для удобства. Его можно запустить.

<oembed>https://www.youtube.com/watch?v=6k7PqgwKCVA</oembed>
В принципе, всю эту часть с написанием ZRF-файла и его трансляцией в JavaScript-код можно опустить, набив все необходимые настройки руками, но набивать, таким образом, придётся довольно много и при этом очень легко ошибиться. Я думаю о том, чтобы создать небольшую библиотеку, поддерживающую создание наиболее употребительных конфигураций досок и шаблонов ходов. Если я это сделаю, ZRF-файл можно будет не писать, ограничившись разработкой JavaScript-кода. 

<h2><b>Что в итоге</b></h2>
Выбранный мной подход доказал свою работоспособность. Код выложен под свободной лицензией, желающие могут пользоваться. Промежуточное создание ZRF-файла кому-то может показаться избыточным, но для меня, с моим опытом разработки приложений под Zillions of Games, это удобно. Впрочем, я работаю над тем, чтобы сделать этот шаг не обязательным. Для запуска настольных игр всё ещё не хватает пары важных (и очень сложных) модулей и, разумеется, ботов. Я также работаю над этим. Я не собираюсь останавливаться. Настольных игр <a href="https://github.com/GlukKazan/Dagaz/blob/master/doc/games.txt">очень много</a>. Хватит надолго.
</cut>

Дороги, которые нас изменяют

<img align="left" src="https://habrastorage.org/files/4c1/d99/40d/4c1d9940da2a4d66b2b292ec722b34ae.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Je ne comprendre pas,- жалобно сказал он.- Я не понимаю.  У
нее нет вид?  Или я не понимаю по-русску?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Нет, все правильно, Шарль,- сказал Юрковский.- Вид у нее,
конечно, есть.  Только разный, понимаете?  Когда она на потолке,
она как потолок.  Когда на диване - как диван...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- А когда на Грегуар, она как Грегуар,- сказал Моллар.- Ви
все шутите.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А. и Б. Стругацкие "<a href="http://www.rusf.ru/abs/books/pna00.htm">Путь на Амальтею</a>"</i></b>&nbsp;
&nbsp;
Я начал свою программистскую деятельность лет в десять. Возможно раньше, точно уже не помню. Помню только как "помогал" отцу программировать древние Искры, на бумажке высчитывая адреса условных и безусловных переходов в машинном коде и воодушевлённо загоняя латунные кольца в текстолитовые планшеты. Каждое кольцо несло в себе информацию ровно на один бит.
<cut>
Потом, как-то сразу, появились восьмибитные компьютеры. Все журналы, которые я с упоением читал, в то время, от Радио до приложения ЮТ-а "Для умелых рук" (возможно, за исключением "Юного натуралиста") печатали всё новые и новые схемы персональных компьютеров! К сожалению, с паяльником я всегда обращался гораздо хуже, чем мой отец. Руки у меня были совсем не умелые.

С деталями проблем не было, ящики стола были ими забиты. Однажды, когда я просто заикнулся о том, что хочу сделать осциллограф, в качестве курсового проекта для УПК, отец молча сходил в кладовку и принёс оттуда электронно-лучевую трубку. До сих пор не понимаю, откуда он её взял и для чего она была нужна ему самому. Дело в том, что при всём этом домашнем изобилии, радиодетали были страшным дефицитом (как многое в то время). Иногда, по ночам, приходилось делать вылазки на известную всему городу радиосвалку, чтобы раскопать (буквально) что-то интересное.

В общем, свой компьютер я так и не собрал. Разумеется, это не означает, что у меня не было доступа к компьютерам! У моего друга (кстати, в отличии от меня, он штамповал <a href="https://ru.wikipedia.org/wiki/ZX_Spectrum">Спектрумы</a> и <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%9E%D0%9D">АОН</a>-ы на <a href="https://ru.wikipedia.org/wiki/Zilog_Z80">Z80</a> как пирожки) был шикарный, по тем временам, <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80-06%D0%A6">Вектор 06Ц</a> (Ц - означало цветной!), а мне самому, на выходные и под честное слово давали легендарную <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%9A_(%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%BE_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2)#.D0.91.D0.9A-0010">БК</a>-шку! Причём, вместе с монитором. Я пёр всю эту тяжесть на своём горбу через весь район (да, времена были не спокойные), а к понедельнику возвращал обратно.

<img align="center" src="https://habrastorage.org/files/359/4d0/b23/3594d0b23770491eb0dcec1c473a466b.PNG"/>
Я начал с <a href="https://ru.wikipedia.org/wiki/GW-BASIC">Бейсика</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D0%BA%D0%B0%D0%BB">Фокала</a>. Впрочем, вопреки знаменитому высказыванию Дейкстры, я не считаю, что меня это сильно испортило. Возможно, потому, что перед ними, всё таки, были машинные коды Искр? Не знаю. Я читал Вирта и Липски и переводил алгоритмы на Бейсик. На Бейсике тех лет было чудовищно сложно выразить рекурсию (в основном потому, что вместо локальных аргументов функций приходилось использовать вполне себе глобальные массивы), но я этого добился.

Когда (на том самом Векторе) я написал на Бейсике свою версию "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%93%D0%B8%D0%BB%D1%8C%D0%B1%D0%B5%D1%80%D1%82%D0%B0">кривой Гильберта</a>", мой друг не поверил, что это будет работать. По его словам, входов в подпрограммы там было гораздо больше чем выходов! Разумеется, он был не прав. Дело ведь не в количестве. <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%B2%D0%BE%D1%81%D1%8C%D0%BC%D0%B8_%D1%84%D0%B5%D1%80%D0%B7%D1%8F%D1%85">Восемь ферзей</a> заставили поволноваться уже меня. Вектор слишком долго не подавал признаков жизни! Впрочем, через пару минут он выдал первую позицию. Впоследствии, меня это часто поражало. Тот ужасный и абсолютно непонятный (мне непонятный!) код, который я писал, вопреки всем ожиданиям, всегда работал именно так, как я и планировал (ну, возможно, после пары исправлений глупейших опечаток).

Мы ещё долго мучали тот Вектор. Когда надоедали игры, писали на Бейсике (вид на тессеракт изнутри, пожалуй, навсегда изменил моё мировоззрение). Или пытались разобраться в Форте (да, он там тоже был!). Однажды, мы его даже "сломали". Мы просто не могли пройти мимо возможности установки основания системы счисления в ноль! На "дописках" к кассетам порой находились удивительные вещи. Именно тогда я впервые увидел "Китайские шахматы"! Разумеется, правила пришлось вычислять "на ощупь", поскольку все пояснения к игре были также на китайском.

Мои игры с компьютерами никак не влияли на выбор будущей профессии. Я собирался стать химиком! Всё изменилось после знаменательной поездки в Москву, в ходе которой, родители поддались моим уговорам и приобрели <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%B8%D0%BA%D0%B0_%D0%9C%D0%9A-61">МК-61</a>, подшивку старых номеров "Кванта" и головоломку "Кристалл". Пожалуй, это была моя самая результативная поездка в Москву! В первый же день, сделав все эти приобретения, я заперся на квартире у родственников, со своими сокровищами. На внешние раздражители я больше не реагировал.

<img align="center" src="https://habrastorage.org/files/83d/6dc/b05/83d6dcb0582c4ef197f433634a1391d0.JPG"/>
У меня появился свой персональный компьютер! Со всеми его <a href="https://ru.wikipedia.org/wiki/%D0%95%D0%B3%D0%B3%D0%BE%D0%B3%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F">ЕГГОГ</a>-ами, причудами <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%B2%D0%B8">160-шагового цикла</a> и "машинными" кодами. Я старался по максимуму использовать <b>все</b> возможности. Уменьшение программы на один байт приводило меня в экстаз. ПМК изменил всё. Он стал причиной, по которой я подал документы в Авиационный институт (на 4-ый факультет), а не на химфак Казанского государственного университета, как собирался. ПМК и тот факт, что в КАИ я проходил вне конкурса и без вступительных экзаменов (я был медалистом, да).

КАИ встретил меня <a href="http://www.jaymoseley.com/hercules/compilers/pascal8000.htm">8000-ым Паскалем</a> и <a href="http://dssp.petrsu.ru/~IVK/Fortran_IV/fortran.files/FORTRAN.htm">IV-ым Фортраном</a>. Ещё нам преподавали <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">Лисп</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BB%D0%BE%D0%B3_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Пролог</a>. И очень много самой разной математики! Впрочем, наверное, недостаточно много (до сих пор не знаю, что такое тензор). Весь второй этаж седьмого дома занимал ВЦ. Одна машина! ЕС-1046 (цельнодраный <a href="https://ru.wikipedia.org/wiki/IBM_System/370">IBM 370</a>). И она была в моём полном распоряжении! Моём и еще двух десятков человек, работавших одновременно в "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85_%D0%BC%D0%B0%D1%88%D0%B8%D0%BD">Системе Виртуальных Машин</a>". <a href="https://ru.wikipedia.org/wiki/PDP-11">PDP-11</a> (с третьего этажа) я запомнил гораздо хуже.

В КАИ я связался с "плохой компанией" и быстро стал грозой вычислительного центра. В отличии от админов, мы с удовольствием читали системную документацию (на русском языке!) и с не меньшим удовольствием применяли полученные знания на практике. Я умел делать удивительные вещи. Создавал приватные дисковые разделы, менял пароли виртуальных машин и писал канальные программы для анимации псевдографики на алфавитно-цифровом дисплее.

Всего парой команд с консоли я мог убрать свою виртуальную машину из списков контролируемых монитором виртуальных машин (машинное время ей продолжало выделяться). После этого, я становился полностью неуязвим. Такую виртуалку нельзя было даже увидеть, не то что остановить! Кроме того, я мог скрывать файлы со своими художествами, причём скрывать так, что их нельзя было восстановить, не зная имени. Разумеется, администраторы что-то подозревали. После некоторых наших шалостей приходилось перегружать реальную машину, и это их не радовало! Иногда нас пытались ловить, но как-то лениво и совсем не изобретательно. Я ни разу не попался.

Средства, обеспечивающие безопасность СВМ, по нынешним меркам, могут показаться смешными. Пароли шифровались двухбайтовым xor-ом, а системные привилегии задавались битовой маской. Да, эта маска находилась в реальной, а не виртуальной памяти, но две (из восьми, насколько я помню) привилегий обеспечивали к ней доступ (различными способами). И обе они были предоставлены <b>всем</b> пользователям ВЦ "по умолчанию"! Это было весёлое время.

Потом, в городе появились первые клоны IBM PC. <a href="https://ru.wikipedia.org/wiki/IBM_PC/XT">XT</a>-шки, а вслед за ними и <a href="https://ru.wikipedia.org/wiki/IBM_PC/AT">AT</a> с 286-ыми процессорами оказались и на нашей кафедре. К 3-ему курсу я был уже замечен преподавателями и привлечён к их индивидуальной трудовой деятельности. Я писал софт на Turbo Pascal-е и 2-ом FoxBase для Компрессорного завода. Так началась моя профессиональная деятельность.

Работа "на кафедре" приносила совсем немного денег. Её главным достоинством было то, что поработав таким образом примерно полгода я "примелькался" и мне стали доступны более интересные предложения. У одного из преподавателей кафедры ЭВМ (сам я был с кафедры Прикладной математики) была собственная фирма и мне предложили на ней поработать.

Компания производила и затем продавала самые разные вещи. В основном, ориентированные на безопасность. Видеоглазки, домофоны, кодовые замки с ИК-картами (поскольку камеры домофонов работали частично в ИК-диапазоне, с ними произошёл забавный казус на одной из выставок) и прочее. В числе прочего было несколько "криптоустройств", подключаемых к <a href="https://ru.wikipedia.org/wiki/ISA">ISA</a>-шине компьютера. Презентацию на одно из таких устройств мне и предложили сделать, в качестве вступительного задания. Я сделал её за одну ночь на кафедре. Поскольку с PowerPoint-ом, в те времена, я знаком не был, пришлось использовать всё тот же (уже Borland) Pascal. В графическом режиме и с <a href="https://ru.wikipedia.org/wiki/EGA">EGA</a>-видеоэффектами. Разумеется, работу я получил.

<img align="center" src="https://habrastorage.org/files/80e/b57/3a1/80eb573a16104a06b57d586847caeb67.jpg"/>

Это было время, когда я вплотную познакомился с Borland C++ и x86 ассемблером. Впоследствии, мне сильно повезло, поскольку всю нашу команду забрало под своё крыло РЦИ Национального банка. К набору моих игрушек добавились HP-UX сервер и 6-ой Oracle (правда, тогда поработать с ним не удалось). Поскольку я был очарован <a href="https://ru.wikipedia.org/wiki/Turbo_Vision">Turbo Vision</a>, первым делом я засел за разработку аналогичной библиотеки под <a href="https://ru.wikipedia.org/wiki/Curses">curses</a>. Впрочем, нет. Действительно первым делом я написал вот это:

<source lang="cpp">
int main(int argc,char ** argv) {
   for (;!fork(););
   return 0;
}
</source>
К тому времени подоспел диплом. В университете (теперь уже университете!) я почти не показывался, пробив себе, через научрука индивидуальный график. Асимметричная криптография, <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80">транспьютеры</a> и робастные методы в статистике. <a href="https://ru.wikipedia.org/wiki/RSA">RSA</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%94%D0%B8%D1%84%D1%84%D0%B8_%E2%80%94_%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0">Диффи-Хелман</a> - вот всё, что из этого осталось в памяти (да и то, не пригодилось).

Окончание ВУЗ-а и мой последующий уход в армию ознаменовались скандалом. РЦИ не хотело меня отпускать и, специально для меня, ввело должность (пробив её через руководство Центробанка), предусматривавшую бронь от армии (мимо аспирантуры я благополучно пролетел, в силу своей врождённой безалаберности). К сожалению, я узнал о брони уже в тот момент, когда вёл сепаратные переговоры с военкоматом, на предмет того, чтобы меня не высылали из Казани (профессия программиста имеет свои преимущества). Руководство Нацбанка пообещало, что в банках я больше работать не буду. Пока, так оно и есть.

Прослужив год, я вернулся в другую страну. Это было ужасное время. К счастью, один из моих сокурсников работал начальником отдела АСУ в Детской республиканской клинической больнице. Он меня и приютил. Зарплата была не бог весть какая, но и работа не шибко пыльная. Мы писали софт на <a href="https://ru.wikipedia.org/wiki/FoxPro">FoxPro</a> (знания FoxBase пригодились) для нужд больницы. Я отточил свою технику работы с FoxPro до совершенства! Например, научился открывать неограниченное число модальных окон, невзирая на дурацкие ограничения по количеству одновременно выполняемых read-ов (так вроде назывался тот вызов?).

Другим для меня ударом стало повсеместное воцарение Windows. Я много писал на C++ и ассемблере, в том числе, резидентные программы и драйвера, но делал это под <a href="https://ru.wikipedia.org/wiki/MS-DOS">MS DOS</a>, в реальном режиме! К защищённому режиму и Windows я не знал как подступиться. Однажды, я пожаловался на этот факт своему знакомому (одному из той самой "плохой компании") и услышал от него замечательный ответ: "В чём дело? Просто берёшь Delphi и пишешь!". Так я и сделал.

Работа в одной из гос. организаций позволила мне освоить Delphi и, что самое главное Oracle. Седьмая версия, затем 8.0 и божественная 8.1.7. Я до сих пор считаю, что это лучшее, из того, что делал Oracle. Что там говорить, она включала в себя реализацию сервера БД в виде NLM-модуля для <a href="https://ru.wikipedia.org/wiki/Novell_NetWare">Novell Netware</a>! Освоив Oracle, Delphi и его <a href="https://ru.wikipedia.org/wiki/BDE">BDE</a> (чтобы связать одно с другим) я был готов выйти на "вольные хлеба".

Подходящее предложение не заставило себя долго ждать. В городе собиралась появиться первая компания кабельного телевидения! Благодаря новому генеральному директору (снова обойдусь без имён), дело было "на мази". Не хватало самой малости - биллинговой системы. У меня спросили, смогу ли я написать биллинг и я честно ответил "Да", поскольку понятия не имел, что это такое. Биллинг кабельного телевидения я написал (и им долгое время пользовались). Первого абонента (в соседнем доме) поехали подключать зимой, "на саночках".

На этой работе, было много всего разного. Поддержка Internet-биллинга (на этот раз фирменного, а не самописного), внедрение карт оплаты, система голосового оповещения, цифровое телевидение... Не было главного, работа "придворным программистом" (в моих глазах) не шла ни в какое сравнение с  местом захудалого юниора в компании, занимающейся разработкой ПО целенаправленно. Мне вновь пообещали, что я не смогу вернуться (на этот раз, в подразделения ТАИФ-а), но не сдержали обещания. В ТВТ я возвращался позже, на полставки, перед самым приобретением её МТС-ом.

На новой работе меня встретили Delphi (куда же без него), C++ (в этот раз, под Windows) и конечно же Oracle. Для начала, нашу команду (меня и ещё одного бывшего сотрудника ТВТ) заняли разработкой RADIUS сервера. Потом были Netflow, SNMP и маленькая (но очень гордая и специализированная) InMemory база данных. Всё это даже внедрялось (где-то в Чехии). Я был фанатом Рихтера и Александреску и писал разные Compile Time ужасы вроде вот <a href="https://habrahabr.ru/post/179089/">этого</a>.

<img align="center" src="https://habrastorage.org/files/1ff/d10/f3e/1ffd10f3e0e74ba2b11174ed56667df6.jpg"/>
Затем (другая жизнь, другой проект) был .Net и XSLT для системы массовой и полностью автоматической генерации разнообразных платёжек в форматах Word, Excel и PDF. В этот раз, я был уже тимлидом. В следующем проекте, пришлось программировать <a href="https://ru.wikipedia.org/wiki/Cisco">циски</a> при помощи JavaScript, но это было уже не важно. В моей группе насчитывалось около 10 человек из трёх городов и 90% времени занимала организационная работа.

После этого годичного кошмара, я вновь вернулся к самостоятельной разработке, найдя свою нишу в компании (почему-то, никто кроме меня не согласился разбираться с <a href="https://habrahabr.ru/post/186900/">АТС</a>-ками). Между делом освоив Perl, пишу я, в основном, на Java. Фронтенд пишется на ней же, при помощи <a href="https://ru.wikipedia.org/wiki/Google_Web_Toolkit">GWT</a>. Потихоньку осваиваем Postgres. JavaScript я изучаю уже "для души", для одного своего маленького <a href="https://github.com/GlukKazan/Dagaz">pet-проекта</a>. Недавно поступило предложение попробовать свои силы в <a href="https://ru.wikipedia.org/wiki/Go">Golang</a>, но я пока отказываюсь. Наверное, дело в недостаточной мотивации.

Мы то, чем мы пишем. Сегодня это Java и JavaScript. Я стараюсь по максимуму использовать их возможности, но не собираюсь на них останавливаться. Я не знаю на чём буду писать завтра. Мне (почти) 45 лет и я открыт для всего нового.
</cut>

Dagaz: От простого к сложному

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>かたつぶりそろそろ登れ富士の山

Тихо-тихо ползи, улитка, по склону Фудзи, 
вверх, до самых высот
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%81%D0%B0,_%D0%9A%D0%BE%D0%B1%D0%B0%D1%8F%D1%81%D0%B8">小林一茶 (Кобаяси Исса)</a>
</i></b>
Я много <a href="https://habrahabr.ru/post/320474/">писал</a> о том, что хочу получить в итоге. <a href="https://habrahabr.ru/post/322212/">Рассказал</a>, как этим можно пользоваться, но оставил без ответа один простой вопрос. Почему я <b>убеждён</b> в том, что всё <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src">это</a> (ладно-ладно, <b>почти</b> всё это) работает? У меня есть секретное оружие! И сегодня я хочу о нём рассказать.
<cut>
Проект, который я пишу сложен. Я разрабатываю универсальную модель, потенциально пригодную для описания <b>любых</b> настольных игр. Нечего и думать о том, чтобы разработать такой проект "с нуля", запустить и проверить, работает ли он. Тем более, что и запускать-то пока нечего. Нет ни контроллера ни сколь нибудь завалящего представления, под которыми эту модель можно было бы запустить. Но я должен уже сейчас проверять и отлаживать написанный код! Потом, когда контроллер и представление появятся, отладить его весь, целиком, будет попросту невозможно!

Я не первый, кто сталкивается с такой проблемой и способ её решения давно <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">придуман</a>. Для тестирования своего кода, я использую <a href="https://qunitjs.com/">QUnit</a>, но конечно же, это не единственное подобное решение в мире JavaScript. Я не придерживаюсь методологии <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">TDD</a>, в том отношении, что не стараюсь предварять написание кода тестами, но стараюсь максимально покрыть тестами весь код модели. Это помогает мне решить следующие задачи:

<ul>
	<li>Поиск и исправление глупых ошибок и опечаток в коде</li>
	<li>Проверка совместимости используемых решений с различными платформами (браузерами)</li>
	<li><a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Регрессионное тестирование</a> (изменяя что-то, я должен быть уверен, что ничего не сломал)</li>
	<li>Минимальное документирование (тесты фиксируют способы использования интерфейсов модели)</li>
</ul>
<spoiler title="Подход уже успел себя оправдать">
В самом начале разработки, когда с JavaScript-ом я был ещё очень сильно "на Вы", я брал за основу код <a href="https://www.jocly.com/#/about">Jocly</a>. Сейчас, мне приходится избавляться от много из того, что было написано тогда, но на тот момент, надо было с чего-то начинать. Я хорошо (как показало время, недостаточно хорошо) понимал задачу, но очень плохо знал язык. Вот один из образчиков кода тех времён:

<spoiler title="Поиск элемента в массиве">
<source lang="javascript">
if ([].indexOf) {
   Model.find = function(array, value) {
     return array.indexOf(value);
   }
} else {
   Model.find = function(array, value) {
      for (var i = 0; i < array.length; i++) {
          if (array[i] === value) return i;
      }
      return -1;
   }
}
</source></spoiler>
Да-да, преждевременная оптимизация. Если массивы поддерживают "<b>indexOf</b>", пользуемся им, в противном случае, ищем вручную, в цикле. Поскольку я с самого начала строил модель таким образом, чтобы работать только с числовыми значениями, по прошествии некоторого времени, я решил соптимизировать кое что ещё:

<spoiler title="Массивы целочисленных значений">
<source lang="javascript">
if (typeof Int32Array !== "undefined") {
   Model.int32Array = function(array) {
      var a = new Int32Array(array.length);
      a.set(array);
      return a;
   }
} else {
   Model.int32Array = function(array) {
      return array;
   }
}
</source></spoiler>
Логика та же. Те кто могут - пользуются числовыми массивами, остальные пользуются тем чем могут. Некоторое время всё это прекрасно работало. На тех браузерах, которыми я пользовался. Но в один прекрасный момент, я запустил свои тесты на IE11. И творение Microsoft-а не замедлило нанести свой удар. Тесты не отработали. Всё вылилось в <a href="https://github.com/GlukKazan/JoclyGames/commit/87032851ad1fed49e219935755dd26d1797ed99b">это</a> исправление. Я не хочу сказать, что этот код сильно лучше (сейчас он уже переписан), но если бы я не запускал тесты регулярно и на разных платформах, то попросту не узнал бы о проблеме! Unit-тесты действительно работают.
</spoiler>
Разрабатывая тесты, я двигаюсь от простого кода к более сложному. Перед тем как проверять сложную логику генерации хода (это главное из того чем занимается модель), я должен убедиться в правильности работы всех используемых ей частей. Все классы, используемые в моей модели, можно ранжировать по нарастанию "сложности": 

<ul>
	<li><b>ZrfPiece</b> - описание фигуры (объекта на доске)</li>
	<li><b>ZrfDesign</b> - описание топологии доски и игровых правил</li>
	<li><b>ZrfMove</b> - описание хода, изменяющего состояние игры</li>
	<li><b>ZrfMoveGenerator</b> - генератор возможных ходов "по шаблону"</li>
	<li><b>ZrfBoard</b> - хранилище игрового состояния и генератор всех допустимых ходов</li>
</ul>
Класс <b>ZrfPiece</b> настолько прост, что его тестирование даже не требует наличия полноценного игрового <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/turkish-dama.js">дизайна</a>. Тем не менее, у него имеются некоторые не очевидные особенности, которые необходимо проверить. Например, логика создания нового объекта при изменении типа, владельца либо какого-то из атрибутов фигуры.

<spoiler title="Всё это элементарно проверяется">
<source lang="javascript">
QUnit.test( "Piece", function( assert ) {
  var design = Model.Game.getDesign();
  design.addPlayer("White", []);
  design.addPlayer("Black", []);
  design.addPiece("Man", 0);
  design.addPiece("King", 1);
  var man  = Model.Game.createPiece(0, 1);
  assert.equal( man.toString(), "White Man", "White Man");
  var king = man.promote(1);
  assert.ok( king !== man, "Promoted Man");
  assert.equal( king.toString(), "White King", "White King");
  assert.equal( man.getValue(0), null, "Non existent value");
  var piece = man.setValue(0, true);
  assert.ok( piece !== man, "Non mutable pieces");
  assert.ok( piece.getValue(0) === true, "Existent value");
  piece = piece.setValue(0, false);
  assert.ok( piece.getValue(0) === false, "Reset value");
  var p = piece.setValue(0, false);
  assert.equal( piece, p, "Value not changed");
  Model.Game.design = undefined;
});
</source></spoiler>
Создаём вручную самый минимальный "дизайн" (два игрока, два типа фигур и никакого намёка на доску) и вручную же выполняем все интересующие нас проверки. После этого спокойно пользуемся <b>ZrfPiece</b>, не ожидая от него никаких подвохов. Даже если впоследствии выяснится, что что-то проверить забыли, просто добавим ещё несколько проверок. Далее тестируем более сложный код:

<spoiler title="Дизайн игры">
<source lang="javascript">
QUnit.test( "Design", function( assert ) {
  var design = Model.Game.getDesign();
  design.addDirection("w");
  design.addDirection("e");
  design.addDirection("s");
  design.addDirection("n");
  assert.equal( design.dirs.length, 4, "Directions");
  design.addPlayer("White", [1, 0, 3, 2]);
  design.addPlayer("Black", [0, 1, 3, 2]);
  assert.equal( design.players[0].length, 4, "Opposite");
  assert.equal( design.players[2].length, 4, "Symmetry");
  design.addPosition("a2", [ 0, 1, 2,  0]);
  design.addPosition("b2", [-1, 0, 2,  0]);
  design.addPosition("a1", [ 0, 1, 0, -2]);
  design.addPosition("b1", [-1, 0, 0, -2]);
  var pos = 2;
  assert.equal( design.positionNames.length,4, "Positions");
  assert.equal( Model.Game.posToString(pos), "a1", "Start position");
  pos = design.navigate(1, pos, 3);
  assert.equal( Model.Game.posToString(pos), "a2", "Player A moving");
  pos = design.navigate(2, pos, 3);
  assert.equal( Model.Game.posToString(pos), "a1", "Player B moving");
  ...
  Model.Game.design = undefined;
});
</source></spoiler>
<b>ZrfDesign</b> - это на 99% навигация по игровой доске. Её и проверяем. Дизайн снова создаём вручную (теперь уже с небольшой доской), после чего прогоняем наиболее типичные тест-кейсы. И не забываем, в конце, очистить созданный дизайн! Чтобы он не ломал другие тесты.

<spoiler title="Кстати, вот прямо сейчас выяснилось">
Я был сильно не прав, когда посчитал дизайн игры <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">синглтоном</a>! Не говоря уже о серверной версии, которой попросту необходимо уметь работать с несколькими различными моделями игр одновременно, существует ещё один любопытный кейс. Работая над простейшими игровыми <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src/js/debug/ai">ботами</a>, я вспомнил о <a href="http://www.battlevschess.com/en/">замечательной игре</a>.

<oembed>https://www.youtube.com/watch?v=F1r3WUKJ0kM</oembed>
По полю разбросаны мины, но как заманить на них противника, при условии, что он про них знает? Ему ведь нет абсолютно никакого резона просто терять фигуру, встав на "заминированное" поле. Задача решается просто. Бот, с которым мы играем, может получить слегка отличающийся дизайн игры. Доска, правила хода фигур - всё будет тем же, за одним маленьким исключением. О минах он не будет знать ничего. 

Фактически, это единственный адекватный способ реализации игр с неполной информацией, таких как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=554">Kriegspiel</a> или <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2515">Luzhanqi</a>, конечно, если мы не хотим, чтобы компьютер видел все наши фигуры, а мы его нет. В любом случае, сейчас я над этим работаю. И в этом мне вновь помогают unit-тесты! При выполнении столь обширного рефакторинга, жизненно необходимо знать, что у тебя ничего не развалилось!
</spoiler>
Далее, тесты становятся всё более и более высокоуровневыми. Генерация отдельного хода по шаблону классом <b>ZrfMoveGenerator</b>, применение хода к игровому состоянию и, наконец, генерация набора ходов определённой позицией:

<spoiler title="Бой нескольких фигур дамкой">
<source lang="javascript">
QUnit.test( "King's capturing chain", function( assert ) {
  Model.Game.InitGame();
  var design = Model.Game.getDesign();
  var board  = Model.Game.getInitBoard();
  board.clear();
  assert.equal( board.moves.length, 0, "No board moves");

  design.setup("White", "King", Model.Game.stringToPos("d4"));
  design.setup("Black", "Man", Model.Game.stringToPos("c4"));
  design.setup("Black", "Man", Model.Game.stringToPos("a6"));
  design.setup("Black", "Man", Model.Game.stringToPos("f8"));

  board.generate();
  assert.equal( board.moves.length, 2, "2 moves generated");
  assert.equal( board.moves[0].toString(), "d4 - a4 - a8 - g8 x c4 x a6 x f8", "d4 - a4 - a8 - g8 x c4 x a6 x f8");
  assert.equal( board.moves[1].toString(), "d4 - a4 - a8 - h8 x c4 x a6 x f8", "d4 - a4 - a8 - h8 x c4 x a6 x f8");

  Model.Game.design = undefined;
  Model.Game.board = undefined;
});
</source></spoiler>
При всей лаконичности теста, это уже, практически, полноценная игра! Во всяком случае, один ход из неё. Здесь тестируются и составные ходы и ход "скользящей" фигурой и приоритет взятия и даже <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/kernel/model/maximal-captures.js">правило большинства</a>, реализованное как игровое расширение и предписывающее взятие максимально-возможного количества вражеских фигур! Этот небольшой тест покрывает практически всю функциональность модели. И когда что-то ломается, мы это видим, и сразу же <a href="https://github.com/GlukKazan/JoclyGames/commit/ff74cedd4e25fb4acdb8e9a87e461e474853abbe">исправляем</a>.

Ещё одна вещь, в которой помогают unit-тесты - это рефакторинг! В какой-то момент, мы решили, что в проекте <b>будет</b> использоваться <a href="http://underscorejs.ru/">Underscore</a>. Эта замечательная библиотека помогает писать код в <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">функциональном стиле</a>, делая его более лаконичным и сопровождаемым. Чтобы было понятнее, приведу один пример "из жизни" проекта. 

Функциональное программирование тем полезнее, чем сложнее задача. Если код совсем простой, переписывание его в функциональном стиле мало что даст. Но если задачка чуть посложнее, преимущества функционального подхода становятся более очевидными. 

<oembed>https://www.youtube.com/watch?v=csy39T5G220</oembed>
Помните эту <a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html">игру</a>? У неё есть два забавных правила:

<ul>
	<li>Если перемещение камня создает новый ряд, то игрок получает право захватить <b>любой</b> из камней противника</li>
	<li>Когда игрок остается всего с тремя камнями, его камни превращаются в "летающие".  Эти камни могут перемещаться ("перелетать") не только в одну из соседних, но вообще в <b>любую</b> свободную клетку на доске.</li>
</ul>
Я отметил ключевое слово. Что значит "игрок может захватить любой камень противника"? Если у противника <b>N</b> фигур на доске, то ровно такое количество раз мы обязаны продублировать каждый ход, приводящий к построению "ряда". Эти ходы будут отличаться лишь взятой фигурой! В <a href="http://zillions-of-games.com/">Zillions of Games</a> всё именно так и делается. И это невообразимо усложняет реализацию игры! А ведь есть ещё правило "летающих" камней...

Есть другое решение. Мы можем сформировать всего <b>один</b> ход, перечислив в нём все позиции потенциального взятия. Разумеется, это не означает, что мы возьмём <b>все</b> камни, вовсе нет! Взят будет лишь один из перечисленных. Ход станет недетерминированным. То же с перемещениями. Если "летающий" камень может построить "ряд", получается декартово произведение всех результативных ходов на множество позиций занятых вражескими фигурами.

Я придумал хороший <a href="https://habrahabr.ru/post/320474/">способ</a>, при помощи которого пользовательский интерфейс может работать с такими ходами, но для AI-ботов он неприменим! AI должен получать на вход строго детерминированные ходы! Это означает, что должен быть механизм, превращающий недетерминированные ходы в детерминированные.

<spoiler title="Вот первый вариант того, что я когда-то написал">
<source lang="javascript">
var getIx = function(x, ix, mx) {
  if (ix > x.length) {
      x = [];
      return null;
  }
  if (ix == x.length) {
      c.push(0);
      return 0;
  }
  var r = x[ix];
  if (r >= mx) {
      if (ix + 1 >= x.length) {
          x = [];
          return null;
      }
      for (var i = 0; i <= ix; i++) {
          x[ix] = 0;
      }
      x[ix + 1]++;
  }
  return r;
}

ZrfMove.prototype.determinate = function() {
  var r = [];
  for (var x = [0]; x.length > 0; x[0]++) {
      var m = Model.Game.createMove();
      var ix = 0;
      for (var i in this.actions) {
           var k = 0;
           var fp = this.actions[i][0];
           if (fp !== null) {
               k = getIx(x, ix++, fp.length);
               if (k === null) {
                   break;
               }
               fp = [ fp[k] ];
           }
           var tp = this.actions[i][1];
           if (tp !== null) {
               k = getIx(x, ix++, tp.length);
               if (k === null) {
                   break;
               }
               tp = [ tp[k] ];
           }
           var pc = this.actions[i][2];
           if (pc !== null) {
               k = getIx(x, ix++, pc.length);
               if (k === null) {
                   break;
               }
               pc = [ pc[k] ];
           }
           var pn = this.actions[i][3];
           m.actions.push([fp, tp, pc, pn]);
      }
      r.push(m);      
  }
  return r;
}
</source></spoiler>
60 строк совершенно непонятного и абсолютно неподдерживаемого кода! Скорее всего, он даже не работает! Я так и не протестировал его.

<spoiler title="Вместо этого, я его переписал">
<source lang="javascript">
ZrfMove.prototype.getControlList = function() {
  return _.chain(this.actions)
   .map(function (action) {
        return _.chain(_.range(3))
         .map(function (ix) {
              if (action[ix] === null) {
                  return 0;
              } else {
                  return action[ix].length;
              }
          })
         .filter(function (n) { return n > 1; })
         .value();
    })
   .flatten()
   .map(function (n) { return _.range(n); })
   .cartesian()
   .value();
}

ZrfMove.prototype.determinate = function() {
  var c = this.getControlList();
  if (c.length > 1) {
      return _.chain(c)
       .map(function (l) {
           var r = new ZrfMove();
           var pos = 0;
           _.each(this.actions, function (action) {
              var x = [];
              _.each(_.range(3), function (ix) {
                 pos = pushItem(this, action[ix], l, pos);
              }, x);
              x.push(action[3]);
              if (isValidAction(x)) {
                  this.actions.push(x);
              }
           }, r);
           return r;
        }, this)
       .filter(isValidMove)
       .value();
  } else {
      return [ this ];
  }
}
</source></spoiler>
Код стал длиннее и, на первый взгляд, не выглядит более понятным. Но давайте присмотримся к нему повнимательнее. Для начала, попробуем разобраться в задаче. Описание хода (<b>ZrfMove</b>) состоит из набора действий (<b>actions</b>), каждое из которых представляет собой кортеж из четырёх элементов:

<ol>
	<li>Начальная позиция (<b>from</b>)</li>
	<li>Конечная позиция (<b>to</b>)</li>
	<li>Фигура (<b>piece</b>)</li>
	<li>Номер частичного хода (<b>num</b>)</li>
</ol>
Поскольку превращение фигур в "Мельнице" отсутствует и составные ходы не используются, для нас важны только первые два из этих значений. Их достаточно, чтобы описать любое выполняемое действие:

<ul>
	<li>Добавление фигуры на доску (сброс) - <b>from == null && to != null</b></li>
	<li>Удаление фигуры (захват) - <b>from != null && to == null</b></li>
	<li>Перемещение фигуры - <b>from != null && to != null && from != to</b></li>
</ul>
 Но это только половина дела! На самом деле и <b>from</b> и <b>to</b> (и даже <b>piece</b>, но речь не о ней) - тоже массивы! В случае, если ход детерминированный, каждый из таких массивов содержит ровно по одному элементу. Наличие в любом из них большего количества значений означает возможность выбора (с которой мы и должны разобраться).

<spoiler title="Недетерминированный ход">
<source lang="javascript">
var m = [ [ [0], [1, 2] ], [ [3, 4, 5], null ] ]; // Незначимые элементы опущены
</source></spoiler>
Имеется перемещение фигуры с позиции <b>0</b> на любую из двух позиций (<b>1</b> или <b>2</b>) и захват одной фигуры противника с позиций <b>3</b>, <b>4</b> или <b>5</b>. Для начала, можно выбрать размер всех "недетерминированных" позиций (содержащих более одного элемента):

<spoiler title="Код">
<source lang="javascript">
m = _.map(m, function(action) {
        return _.chain(_.range(2))
         .map(function (ix) {
              if (action[ix] === null) {
                  return 0;
              } else {
                  return action[ix].length;
              }
          })
         .filter(function (n) { return n > 1; })
         .value();
});
</source></spoiler><spoiler title="Результат">
<source lang="javascript">
m == [ [2], [3] ] // Только "недетерминированные" позиции
</source></spoiler>
Этот массив "сглаживаем", после чего, превращаем каждое числовое значение в range:

<spoiler title="Код">
<source lang="javascript"></source>
  m = _.chain(m)
       .flatten()
       .map(function (n) { return _.range(n); })
       .value();
</spoiler><spoiler title="Результат"><source lang="javascript">
m == [ [0, 1], [0, 1, 2] ]
</source></spoiler>
Теперь нам понадобится операция, в базовой комплектации <a href="http://underscorejs.ru/">Underscore.js</a> не предусмотренная. Что-то вроде <a href="http://www.wikiwand.com/bg/%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">декартова произведения</a>. Ничего страшного.

<spoiler title="Напишем его сами">
<source lang="javascript">
var cartesian = function(r, prefix, arr) {
   if (arr.length > 0) {
       _.each(_.first(arr), function (n) {
          var x = _.clone(prefix);
          x.push(n);
          cartesian(r, x, _.rest(arr));
       });
   } else {
       r.push(prefix);
   }
}
</source></spoiler><spoiler title="И встроим в Underscore.js">
<source lang="javascript">
_.mixin({
  cartesian: function(x) {
     var r = [];
     cartesian(r, [], x);
     return r;
  }
});
</source></spoiler>
Допускаю, что моё решение не вполне "кошерно". Если кто нибудь знает, как сделать лучше, пишите в комментарии. Применим его:

<spoiler title="Код">
<source lang="javascript">
      _.chain(m)
       .map(function(action) {
        return _.chain(_.range(2))
         .map(function (ix) {
              if (action[ix] === null) {
                  return 0;
              } else {
                  return action[ix].length;
              }
          })
         .filter(function (n) { return n > 1; })
         .value();
        })
       .flatten()
       .map(function (n) { return _.range(n); })
       .cartesian()
       .value();
</source></spoiler><spoiler title="Результат">
<source lang="javascript">
[ [0, 0],  [0, 1], [0, 2], [1, 0], [1, 1], [1, 2] ]
</source></spoiler>
Оставшаяся часть задачи немногим сложнее. Необходимо выбрать из исходного варианта хода "недетерминированные" позиции, в соответствии с имеющейся шпаргалкой. Не стану утруждать этим читателя, задача чисто техническая. Самое главное то, что использование функционального подхода позволило разделить довольно сложную задачу на части, которые можно решать и отлаживать по отдельности.

Разумеется, использование функционального подхода не всегда связано с решением подобных головоломок. Обычно, всё несколько проще. В качестве характерного примера могу привести модуль <b><a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/kernel/model/maximal-captures.js">maximal-captures</a></b>, реализующий унаследованную от Zillions of Games опцию, обеспечивающую взятие максимального количества фигур в играх семейства шашек. 

<spoiler title="Так было">
<source lang="javascript">
Model.Game.PostActions = function(board) {
  PostActions(board);
  if (mode !== 0) {
      var moves = [];
      var mx = 0;
      var mk = 0;
      for (var i in board.moves) {
           var vl = 0;
           var kv = 0;
           for (var j in board.moves[i].actions) {
                var fp = board.moves[i].actions[j][0];
                var tp = board.moves[i].actions[j][1];
                if (tp === null) {
                    var piece = board.getPiece(fp[0]);
                    if (piece !== null) {
                        if (piece.type > 0) {
                            kv++;
                        }
                        vl++;
                    }
                }
           }
           if (vl > mx) {
               mx = vl;
           }
           if (kv > mk) {
               mk = kv;
           }
      }
      for (var i in board.moves) {
           var vl = 0;
           var kv = 0;
           for (var j in board.moves[i].actions) {
                var fp = board.moves[i].actions[j][0];
                var tp = board.moves[i].actions[j][1];
                if (tp === null) {
                    var piece = board.getPiece(fp[0]);
                    if (piece !== null) {
                        if (piece.type > 0) {
                            kv++;
                        }
                        vl++;
                    }
                }
           }
           if ((mode === 2) && (mk > 0)) {
               if (kv == mk) {
                   moves.push(board.moves[i]);
               }
           } else {
               if (vl == mx) {
                   moves.push(board.moves[i]);
               }
           }
      }
      board.moves = moves;
  }
}
</source></spoiler><spoiler title="... и так стало">
<source lang="javascript">

Model.Game.PostActions = function(board) {
  PostActions(board);
  var captures = function(move) {
    return _.chain(move.actions)
     .filter(function(action) {
         return (action[0] !== null) && (action[1] === null);
      })
     .map(function(action) {
         return board.getPiece(action[0]);
      })
     .compact()
     .map(function(piece) {
         return piece.type;
      })
     .countBy(function(type) {
         return (type === 0) ? "Mans" : "Kings";
      })
     .defaults({ Mans: 0, Kings: 0 })
     .value();
  };
  if (mode !== 0) {
      var caps = _.map(board.moves, captures);
      var all = _.chain(caps)
       .map(function(captured) {
          return captured.Mans + captured.Kings;
        })
       .max()
       .value();
      var kings = _.chain(caps)
       .map(function(captured) {
          return captured.Kings;
        })
       .max()
       .value();
      board.moves = _.chain(board.moves)
       .filter(function(move) {
           var c = captures(move);
           if ((mode === 2) && (kings > 0)) {
               return c.Kings >= kings;
           } else {
               return c.Mans + c.Kings >= all;
           }
        })
       .value();
  }
}
</source></spoiler>
И тот и другой вариант вполне работающие (на момент рефакторинга код был уже покрыт тестами), но функциональный вариант короче, легче понимается и собран из унифицированных блоков. Поддерживать его, безусловно, гораздо проще. 

В заключение статьи, я хочу озвучить несколько принципов, которыми я стараюсь руководствоваться в работе. Я, ни в коем случае, не хочу делать из них догму, но мне они помогают.

<spoiler title="Ни дня без строчки">
Работа над проектом не должна прерываться! Во всяком случае, на сколь нибудь продолжительное время. Чем дольше перерыв - тем сложнее вернуться к работе. Работа отнимает гораздо меньше времени и сил, если заниматься ей каждый день. Хотя бы понемногу! Это не означает, что нужно "выдавливать" из себя код "через не могу" (так недолго и перегореть). Если проект сложен и интересен, всегда можно найти работу под настроение.
</spoiler><spoiler title="Утром код, вечером тесты">
Да-да, знаю, это идёт в полный разрез с методологией <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">TDD</a>. Но кто сказал, что я её придерживаюсь? <b>Unit-test</b>-ы (очень) полезны, даже если не ставить их во главу угла! Любой код, и простой и сложный, должен быть покрыт тестами, насколько это возможно! При этом, желательно двигаться от простого к сложному, тестируя более сложную функциональность после того как не остаётся сомнений в работоспособности той, на которой она построена. Не следует удалять тесты, пока они не потеряли свою актуальность! Напротив, надо стараться запускать их как можно чаще, в различных окружениях. Я нашёл несколько серьёзных и очень нетривиальных ошибок таким образом!
</spoiler><spoiler title="Не навреди">
Любые изменения не должны ломать код уже покрытый тестами! Не надо <b>commit</b>-ить код со сломанными тестами. Даже если занимался этим кодом весь день! Даже если очень устал, чтобы разобраться с проблемой "здесь и сейчас"! Не работающий код - это мусор. Это бомба, которая может взорваться в любой момент! Если нет сил с ним разобраться, лучше полностью его удалить, чтобы потом переписать заново.
</spoiler><spoiler title="Никогда не сдавайся">
Не надо бояться переписывать код снова и снова! Небольшой рефакторинг, или даже полное переписывание проекта с нуля - это не повод для паники! Это возможность решить задачу лучше.
</spoiler><spoiler title="Если не можешь победить честно - просто победи">
Хороший код решает задачу. Хороший код - понятен и сопровождаем. На этом, всё! Не надо выворачиваться наизнанку просто для того, чтобы "подогнать" его под идеологию <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">ООП</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">ФП</a> или чего-то там ещё! Используя какие-то возможности языка или его окружения, надо думать не о моде, а лишь о полезности этих "фич" для проекта. За модой всё равно не угонишься!
</spoiler>
Безусловно, мне ещё есть куда расти. Я не вижу в этом проблемы. Меняется (надеюсь, что в лучшую сторону) моё понимание языка, а вместе с ним, меняется и код. А unit-тесты просто помогают мне в этом.
</cut>

Dagaz: Архитектура

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Все это так архитектура, 
Вас от недуга излечу,
Вы мне доверьтесь, как врачу, 
Поможет вам моя микстура.

Советы Тристана - "<a href="https://www.kinopoisk.ru/film/77206/">Собака на сене</a>"</i></b>

В своей предыдущей <a href="https://habrahabr.ru/post/320474/">статье</a> я много рассказывал о том, как устроен генератор ходов <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/zrf-model.js">Dagaz</a>. Пожалуй, я поставил телегу впереди лошади. Моё наиподробнейшее описание, совершенно не помогает понять главного - того, каким образом всё это можно использовать. На самом деле, это просто.
<cut>
<h3><b>Проще некуда</b></h3>
Для того, чтобы пользоваться генератором ходов, совершенно необязательно досконально разбираться в том, как он работает. Важно понимать назначение всего лишь трёх классов. И первый из них - это <b>ZrfBoard</b>. Как должно быть ясно из наименования, этот класс описывает доску. 

<spoiler title="Я хочу, чтобы меня поняли правильно">
Я не говорю о размере или форме доски. Вся информация о допустимых позициях (полях доски), а также связях между ними (направлениях) хранится в экземпляре класса <b>ZrfDesign</b> и не изменяется в процессе игры! Я много писал об этом в <a href="https://habrahabr.ru/post/242547/">предыдущих</a> <a href="https://habrahabr.ru/post/270033/">статьях</a> и не хочу повторяться. Дизайн игры не является темой настоящий статьи. Мы можем рассматривать его как "чёрный ящик".
</spoiler>
<b>ZrfBoard</b> содержит описание <b>состояния</b> игры, на момент начала определённого хода. По большей части, это информация о размещении на доске фигур. Для её изменения  достаточно всего двух методов:

<ul>
	<li><b>getPiece(position)</b> - возвращает объект класса <b>ZrfPiece</b>, содержащий информацию о фигуре размещённой на указанной позиции (или <b>null</b>, если эта позиция пуста)</li>
	<li><b>setPiece(position, piece)</b> - помещает на указанную позицию фигуру (также как и в предыдущем случае, вместо фигуры может передаваться <b>null</b>)</li>
</ul>
Все позиции - это просто целочисленные значения (индекс большого линейного массива). Для преобразования в более привычное строковое представление (и обратно), используются глобальные функции <b>Model.Game.posToString</b> и <b>Model.Game.stringToPos</b>. Описание фигуры (<b>ZrfPiece</b>) немногим сложнее:

<spoiler title="Конструктор">
<source lang="javascript">function ZrfPiece(type, player) {
  this.type   = type;
  this.player = player;
}
</source></spoiler>
Тип фигуры и её владелец (и то и другое - целочисленные значения). Важно понимать, что это неизменяемые значения. Один и тот же экземпляр <b>ZrfPiece</b> может использоваться на нескольких позициях доски одновременно и даже на позициях различных экземпляров <b>ZrfBoard</b>, описывающих состояние игры в разные моменты времени.

<spoiler title="Но что делать, если изменить фигуру необходимо?">
Например, шахматная <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">пешка</a>, дойдя до последней горизонтали, может превратиться в одну из четырёх фигур, а в таких играх как "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B2%D0%B5%D1%80%D1%81%D0%B8">Реверси</a>" может изменяться владелец фигуры. Решение очевидно - любой метод, изменяющий "состояние" фигуры, на самом деле, просто возвращает новый экземпляр класса, оставляя старый объект без изменения:

<spoiler title="Превращение фигуры">
<source lang="javascript">
ZrfPiece.prototype.promote = function(type) {
  return new ZrfPiece(type, this.player);
}
</source></spoiler>
Может показаться, что я уделяю этому слишком много внимания, но на самом деле, это важно. Дело в том, что помимо информации о типе и владельце, класс <b>ZrfPiece</b> может содержать дополнительные числовые значения - атрибуты фигур. Простейший пример использования атрибутов - <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a> в Шахматах). Признак того, что фигура перемещалась ранее и не может быть задействована в рокировке, может быть сохранён в одном из её атрибутов. Изменение значения любого атрибута также порождает новый экземпляр <b>ZrfPiece</b>, не изменяя существующий.
</spoiler>
Есть ещё два метода, о которых необходимо знать, чтобы использовать <b>ZrfBoard</b>:

<ul>
	<li><b>generate()</b> - возвращает массив <b>всех</b> ходов, доступных из текущей позиции</li>
	<li><b>apply(move)</b> - применяет к текущей позиции выбранный ход</li>
</ul>
Хотя мы и можем изменять состояние <b>ZrfBoard</b> методом <b>setPiece</b>, мы не должны этого делать напрямую. Вместо этого, мы должны выбрать ход (один из списка всех возможных) и применить его к состоянию доски методом <b>apply</b>, который, как и в случае с изменением <b>ZrfPiece</b>, вернёт новый экземпляр объекта.

<spoiler title="Разумеется, ходы привязаны к игроку">
Каждый экземпляр <b>ZrfBoard</b> привязан к владельцу - игроку выполняющему очередной ход. Помимо перемещения фигур, метод <b>apply</b> переключает и игрока. Это не обязательно простое чередование двух игроков. Времена глупых ограничений <a href="http://wiki.jocly.com/index.php/Jocly_Basics">Jocly</a> ушли в прошлое.
</spoiler>
Вот и всё, что необходимо знать для применения <b>ZrfBoard</b>. Дизайн игры и связанные с ним алгоритмы генерации ходов могут быть очень сложными, но это ничего не меняет. Формируем все доступные ходы методом <b>generate</b> и применяем выбранный ход методом <b>apply</b> (получая новое состояние). Начальное состояние доски может быть получено при помощи глобальной функции <b>Model.Game.getInitBoard</b>.

<h3><b>Что бы мы без них делали</b></h3>
Ходы - это то что переводит одно игровое состояние в другое. Проблема в том, что ходы далеко не всегда такие простые какими могут показаться. В <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандже</a> (непосредственном предшественнике <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахмат</a>), для полного описания любого хода вполне достаточно задать начальную и конечную позицию. Даже взятия и превращения описывать не обязательно. Пешка всегда превращается в <a href="https://en.wikipedia.org/wiki/Ferz_(chess)">ферзя</a>, а взятие всегда "шахматное". Но уже в самих Шахматах всё не так просто!

<oembed>https://www.youtube.com/watch?v=K2KCCl3IHGc</oembed>

Появляется <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">пешка</a>, <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">способная бить фигуру не на том поле</a>, на которое она ходит. Появляется "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>" - ход, при выполнении которого перемещаются сразу две фигуры! Становится понятно, что ход должен состоять из нескольких действий. Какие это действия? Я могу перечислить три типа:

<ul>
	<li><b>movePiece(from, to, piece)</b> - перемещение фигуры</li>
	<li><b>capturePiece(position)</b> - взятие фигуры (удаление её с доски)</li>
	<li><b>dropPiece(position, piece)</b> - сброс фигуры (добавление на доску)</li>
</ul>
Хочу заметить, что все эти сложности не только для того, чтобы реализовать "рокировку" и "взятие на проходе". Эти правила - пробный камень, позволивший вовремя расширить функциональность <b>универсального</b> решения. Те же самые "каскадные" ходы, которые команда <a href="http://www.zillions-of-games.com/">Ziilions of Games</a> ввела в свой продукт для того, чтобы выполнять в шахматах рокировку, можно с большим успехом использовать во множестве других, совершенно непохожих игр. Например, в этой:

<oembed>https://www.youtube.com/watch?v=gF772r8JXIc</oembed>
Каскадный ход - это не обязательно рокировка! Фактически - это любой ход, при выполнении которого перемещается сразу несколько фигур. Подобные "нестандартные" правила сильно обогащают продукт! И если Шахматы подарили нам ходы "каскадные", то и у <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашек</a> тоже нашлось чему поучиться.

<oembed>https://www.youtube.com/watch?v=zMC6_vQ8_IA</oembed>

Составной ход выполняется "по частям" и это важно, потому что, часто, игрок может выбрать несколько различных продолжений выполняемого им составного хода. Ход не завершён, пока не выполнены все его частичные ходы, но удобный пользовательский интерфейс должен предоставлять возможность выполнения каждого частичного хода по отдельности! С другой стороны, AI-ботам удобнее рассматривать составной ход целиком, как единую сущность изменяющую игровое состояние. Это действительно сложная проблема, на которой я остановлюсь ниже.

Что ещё нужно знать о классе ZrfMove? Всего два метода:

<ul>
	<li><b>toString(part)</b> - получение текстовой нотации хода</li>
	<li><b>changeView(part, view)</b> - изменение визуального представления игры</li>
</ul>
Из предыдущего раздела, мы помним, что можем применить ход к экземпляру класса <b>ZrfBoard</b>, чтобы изменить позицию на доске. Метод <b>changeView</b> делает то же самое, но по отношению к внешнему, для модели игры, визуальному представлению. Представление получает от модели простые команды:

<ul>
	<li><b>move(from, to, player, piece)</b> - перемещение фигуры</li>
	<li><b>delete(position)</b> - удаление фигуры с доски</li>
	<li><b>create(position, player, piece)</b> - добавление фигуры</li>
</ul>
Это почти то же самое, что и действия добавляемые в ход, за тем исключением, что вместо числовых значений, используемых моделью, передаются строки, описывающие позиции и фигуры в известной представлению текстовой нотации. Что касается метода <b>toString</b>, то это просто получение нотации хода в понятной человеку форме. Ненулевое значение <b>part</b> позволяет получить описание соответствующего частичного хода. Передав в аргумент 0, можно получить полное описание составного хода.

<h3><b>Оправданная сложность</b></h3>
Итак, на каждом этапе игры у нас имеется игровое состояние и список ходов (разрешённых правилами игры) на выбор. Этого вполне достаточно для корректной работы приложения, но с точки зрения реализации пользовательского интерфейса, список ходов - не самая удобная вещь. Давайте ещё раз посмотрим, как работает пользовательский интерфейс Zillions of Games:

<oembed>https://www.youtube.com/watch?v=MEqBDMVycLs</oembed>
Прежде всего, пользователь выбирает одну из своих фигур (указывая поле, на котором она находится). Далее, если имеется несколько вариантов выполнения частичного хода, целевые позиции помечаются и пользователь может перетащить на одну из них фигуру. Если же возможный ход всего один, он выполняется немедленно (работает опция <b>"smart moves"</b>). Это удобно. Это <b>гораздо</b> удобнее чем предложение выбора из следующего списка ходов:

<ol>
	<li><b>d8-g8-g3-d3-d7-h7-h5-a5-a7-e7-e1-c1-c6-a6-a1</b></li>
	<li><b>d8-g8-g3-d3-d7-h7-h5-a5-a7-e7-e1-a1-a6-c6-c1</b></li>
	<li><b>d8-h8-h3-d3-d7-g7-g5-a5-a7-e7-e1-c1-c6-a6-a1</b></li>
	<li><b>d8-h8-h3-d3-d7-g7-g5-a5-a7-e7-e1-a1-a6-c6-c2</b></li>
	<li><b>...</b></li>
</ol>
Вообще говоря, это работа для <b>контроллера</b>, но здесь слишком много специфичной логики уже реализованной в <b>модели</b>. Контроллеру совершенно не обязательно знать о том, что ходы делятся на перемещающие фигуры (возможно несколько фигур сразу) и добавляющие их на доску. Контроллер не должна волновать правильность порядка выполнения действий, при выполнении каждого частичного хода. Опция <b>"smart moves"</b> его также волновать не должна. Всё это реализовано в модели! 

<ul>
	<li><b>getPositions()</b></li>
	<li><b>setPosition(position, view)</b></li>
</ul>
Вот два самых главных метода нового класса, призванного обеспечить взаимопонимание модели и контроллера. Вместо "плоского" массива ходов, мы получаем от <b>ZrfBoard</b> экземпляр класса <b>ZrfMoveList</b>, содержащий этот список. Контроллер вызывает метод <b>getPositions</b>, для получения массива позиций, доступных для выполнения очередного шага. Одна из этих позиций выбирается при помощи пользовательского интерфейса и передаётся методу <b>setPosition</b>. 

Этот метод возвращает контроллеру текстовую нотацию частичного хода (для отображения в списке ходов), вносит необходимые изменения в визуальное представление доски и готовит <b>ZrfMoveList</b> к выполнению следующего шага. Цикл повторяется до тех пор, пока очередной вызов <b>getPositions</b> не вернёт пустой список. Это означает, что мы дошли до конца составного хода. Чаще всего, выбранной последовательности шагов соответствуют всего один возможный ход из всего списка. Чаще всего, но не всегда!

<oembed>https://www.youtube.com/watch?v=YfeiPu3fDgI</oembed>
Здесь возможно четыре различных хода с совпадающими начальными и конечным позициями перемещения. Для нас это означает, что после того как метод <b>getPositions</b> вернёт пустой список, <b>ZrfMoveList</b> будет содержать более одного допустимого хода. Контроллер должен предоставить пользователю возможность выбора из этого списка. Список допустимых ходов может быть получен вызовом метода <b>getMoves</b> (по мере передачи в <b>setPosition</b> новых значений, этот список будет уменьшаться). Есть ещё несколько методов, о которых стоит сказать:

<ul>
	<li><b>back(view)</b> - откат к предыдущему частичному ходу</li>
	<li><b>getCapturing()</b> - получение списка позиций, находящихся "под боем"</li>
	<li><b>canPass()</b> - проверка возможности завершения составного хода</li>
	<li><b>pass()</b> - завершение составного хода</li>
</ul>
Если с первыми двумя методами всё более менее понятно, то следующие два требуют пояснения. Существуют игры (шашки к ним не относятся), в которых игрок имеет право прервать выполнение составного хода. Например, в "<a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанороне</a>", хотя первое взятие является обязательным (как и в шашках), игрок может прервать цепочку взятий в любой момент:

<img align="center" src="https://habrastorage.org/files/5bf/8b2/20b/5bf8b220bd0548069eb15f130af3d521.png"/>
Хотя игрок может продолжить взятие ходом "<b>D4-C5</b>", он имеет право отказаться от этой возможности, нажав кнопку "<b>Pass</b>". Частным случаем этой ситуации является отказ игрока от выполнения <b>всего</b> составного хода (в некоторых играх, например в "<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>", это допускается). Перед получением списка позиций, контроллер должен вызывать метод <b>canPass</b>, для определения допустимости досрочного завершения составного хода. Вызов метода <b>pass</b> завершит выполнение хода (если это допускается правилами). После этого, контроллеру останется получить список допустимых ходов, выбрать один из них и применить его к <b>ZrfBoard</b>, для получения нового состояния.

<oembed>https://www.youtube.com/watch?v=UhNUrrtH9Kg</oembed>
Я рассказал далеко не о всех возможностях класса <b>ZrfMoveList</b>. В некоторых играх (например в "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельнице</a>", показанной выше) логика выполнения хода может быть гораздо более сложной. Она может включать в себя множественные перемещения фигур, недетерминированные захваты и сбросы фигур и даже недетерминированные перемещения! Для нас важно, что все эти сложности надёжно скрыты за простым и понятным интерфейсом класса <b>ZrfMoveList</b>. Да, сам этот класс <b>очень</b> сложен, но эта сложность оправдана! Ведь не будь её, нам пришлось бы в ещё большей степени усложнить контроллер.
</cut>

Dagaz: эволюция вместо революции

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>В этом мире того, что хотелось бы нам НЕТ!
Мы верим, что в силах его изменить	ДА!
&nbsp;
Юрий Шевчук</b></i>&nbsp;
&nbsp;
&nbsp;
&nbsp;
Те из вас, кто читал мои статьи, должны знать о том, что я, довольно давно, занимаюсь изучением метаигровой системы <a href="http://www.zillions-of-games.com">Zillions of Games</a>. За всё это время, я разработал чуть менее полусотни <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">игр</a> и изучил эту платформу вдоль и поперёк. Моей целью является разработка аналогичной (а желательно более функциональной) системы с открытым исходным кодом. О ходе этой работы я и хочу рассказать.
<cut>
<h2><b>По образу и подобию</b></h2>
Как я уже сказал, я очень хорошо понимаю как именно работает Zillions of Games. Мне не мешает отсутствие её исходных кодов, поскольку я не собираюсь заниматься портацией этого продукта. Речь идёт о разработке новой системы с нуля, с учётом достоинств (и в ещё большей степени недостатков) всех известных мне, на текущий момент, метаигровых платформ. Перечислю их:

<ul>
	<li><a href="http://www.zillions-of-games.com">Zillions of Games</a> - наиболее известная метаигровая система, о которой я много писал</li>
	<li><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a> - довольно интересный проект, реализованный как модуль расширения Zillions of Games, но способный также работать и автономно</li>
	<li><a href="http://www.di.fc.ul.pt/~jpn/ludae/index.htm">The LUDÆ project</a> -  Забавная система, предназначенная для автоматизированной разработки новых настольных игр</li>
	<li><a href="https://www.jocly.com/#/about">Jocly</a> - Современная и очень интересная разработка (к сожалению, качество реализованных под неё игр оставляет желать лучшего)</li>
</ul>
Все эти продукты работают и делают ровно то, для чего они и предназначены - помогают, с затратой больших или меньших усилий, создавать компьютерные реализации разнообразных настольных игр. Речь идёт не только о Шашках и Шахматах! Количество и (что самое главное) разнообразие уже созданных игр превосходит все ожидания. В этом главное достоинство метаигровых систем - работающий прототип новой и достаточно сложной настольной игры можно создать буквально за пару часов! 

<spoiler title="Ложка дёгтя">
Главный их недостаток также очевиден. Ни одному универсальному игровому "движку" никогда не сравняться (по производительности) с программами специализированными, ориентированными на одну и только одну настольную игру. С этим напрямую связана и "интеллектуальность" ботов, призванных составить компанию игроку-человеку, пребывающему в одиночестве. Все универсальные игровые системы играют очень слабо, но поскольку речь, как правило, идёт о довольно экзотических играх, это не является очень большой проблемой. Вряд ли программе повезёт встретиться с человеком, играющим, например, в <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%8E_%D1%81%D1%91%D0%B3%D0%B8">Chu Shogi</a> на уровне гроссмейстера.

Помимо этого общего недостатка (а также фатального недостатка, связанного с закрытостью исходных кодов), каждый из перечисленных проектов обладает и индивидуальными особенностями. Так, Zillions of Games использует <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">лиспо</a>-подобный <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a>, весьма облегчающий процесс описания настольных игр, но несколько ограничивающий функциональность доступную разработчику. Реализовать, с его помощью, можно <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1001">действительно</a> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=10">очень</a> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=244">многое</a>, но далеко не всё. Некоторые игры, такие как "<a href="https://habrahabr.ru/post/234587/">Ритмомахия</a>" или "<a href="http://www.iggamecenter.com/info/ru/kauri.html">Каури</a>", разработать на чистом <a href="https://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> решительно невозможно. Иные, наподобие "<a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a>" или "<a href="https://en.wikipedia.org/wiki/Janggi_variants">Gwangsanghui</a>", сделать можно, но столь сложным образом, что существенно страдает их производительность (а следовательно и "интеллект" AI).

Расширение Axiom Development Kit появилось как попытка улучшения Zillions of Games. Поскольку эта библиотека оперирует числами (а не только булевскими флагами, как Zillions of Games), такие игры как "Ритмомахия" становятся <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2282">реализуемыми</a>, но сам процесс разработки местами напоминает кошмар (я немного <a href="https://habrahabr.ru/post/276329/">писал</a> об этом). В качестве DSL, Axiom использует Forth Script (подмножество языка <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Форт</a>) и этот язык (а главное отладка программ на нём) <b>действительно</b> намного сложнее тёплого и лампового ZRF. Кроме того, сделать с его помощью можно далеко не всё. Разработка таких игр как "<a href="http://cyclowiki.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Таврели</a>" или, упомянутая выше "Каури", по прежнему, не представляется возможной.

Про "LUDÆ" я мало что могу рассказать (поскольку никогда не видел этого продукта вживую), что же касается Jocly, то недостатком этой системы (на мой взгляд) является полный отказ от использования какого либо DSL для описания игр. Фактически, это <a href="https://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a>-фреймворк для разработки настольных игр на языке JavaScript. Даже внесение довольно тривиальных изменений в уже разработанные игры превращается в весьма трудоёмкий <a href="https://habrahabr.ru/post/280334/">процесс</a>. Игры, созданные самими авторами, также не лишены серьёзных ошибок (я связываю это со сложностью процесса разработки). Например, в "<a href="https://www.jocly.com/#/game/alquerque-bell">Алькуэрке</a>" возникают ситуации при которых одни и те же фигуры "берутся" по нескольку раз за ход, а в "<a href="https://www.jocly.com/#/game/turkish-draughts">Турецких шашках</a>" ошибочно действует правило "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>" - главное что отличает эту игру от других <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A2.D1.83.D1.80.D0.B5.D1.86.D0.BA.D0.B8.D0.B5">шашечных систем</a>.
</spoiler>
Знакомство с Jocly подтолкнуло меня к пересмотру некоторых решений. Для дальнейшей разработки я твёрдо решил использовать JavaScript, поскольку это очевидно наиболее простой путь к созданию расширяемой и кроссплатформенной системы с современным интерфейсом. Однопоточность немного отпугивает, но, на самом деле, этот момент важен исключительно для AI (да и в нём, использовать многопоточность правильно совсем не просто), а мы уже (для себя) выяснили, что AI не самая сильная сторона метаигровых систем.

С другой стороны, для меня совершенно очевидна необходимость наличия некоего DSL для описания наиболее рутинных моментов настольных игр. Непосредственное использование JavaScript для разработки всей игровой модели придаёт процессу небывалую гибкость, но требует усердия и сосредоточенности (и, как показала практика, даже их наличие не сильно помогает). В идеале, хотелось бы обеспечить совместимость с базовым ZRF, чтобы иметь возможность запускать в новой системе, если и не все <a href="http://www.zillions-of-games.com/games/index.html">две с половиной тысячи игр</a>, то, хотя бы, значительную их часть. Вот что <a href="http://wiki.jocly.com/index.php/Comparison_with_Zillions_of_Games">пишут</a> по этому поводу разработчики Jocly:

<blockquote><i>In ZoG, games are described in a lisp-based language called ZRF. This gives a nice formal framework to the game rules, but introduces a number of limitations when ZRF has no predefined instruction for a given feature. The Jocly approach is quite different since games are developed in Javascript and use APIs to define the rules and user interface. The good with Jocly is that developers can do almost anything they want, the bad is that they must write more code. 

In theory, it would be possible to write a ZRF interpretor in Javascript for Jocly to run any ZoG game. If you are willing to develop that kind of tool, let us know.</i></blockquote>
Я решил двинуться по этому пути, сосредоточившись, правда, не на интерпретации, а на своего рода "компиляции" ZRF-файла в описание игры для Jocly. Постоянный разбор текстового файла, пусть даже и содержащего очень простое описание игры, на языке напоминающем Лисп - это не та задача, которой хотелось бы заниматься в JavaScript.

<spoiler title="Подробности">
Я решил создать <a href="https://github.com/GlukKazan/JoclyGames/tree/master/Z2J/src/java">приложение</a>, превращающее исходный <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/example.zrf">zrf-файл</a>, содержащий описание игры, в <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/example.js">форму</a>, пригодную для загрузки в модель Jocly. Например, вместо <a href="http://embed.jocly.net/jocly/plazza/file-access?game=turkish-draughts&file=checkersbase-model.js">этого</a> файла (для просмотра всех открытых текстов платформы Jocly можно использовать <a href="http://embed.jocly.net/jocly/plazza/inspector#/">Jocly Inspector</a>). Разумеется, требовалась <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/zrf-model.js">прослойка</a>, способная "склеить" это описание с моделью Jocly. Z2J-транслятор однократно выполняет ту работу, которой не хотелось бы заниматься в JavaScript-приложении постоянно. Например:

<spoiler title="Следующее описание игровой доски">
<source lang="lisp">
     (grid
         (start-rectangle 6 6 55 55)
         (dimensions
             ("a/b/c/d/e/f/g/h" (50 0)) ; files
             ("8/7/6/5/4/3/2/1" (0 50)) ; ranks
         )
         (directions (n 0 -1) (s 0 1) (e 1 0) (w -1 0))
     )
</source></spoiler>
<spoiler title="Превращается в ...">
<source lang="javascript">
    design.addDirection("w");
    design.addDirection("e");
    design.addDirection("s");
    design.addDirection("n");

    design.addPosition("a8", [0, 1, 8, 0]);
    design.addPosition("b8", [-1, 1, 8, 0]);
    ...
</source></spoiler>
Фактически, это описание графа, вершинами которого являются отдельные позиции на доске, а дугами (ориентированными) - направления, в которых фигуры могут перемещаться. Целые числа, указанные в массивах, ассоциированных с вершинами графа, представляют собой смещения внутри линейного массива всех позиций, используемых в игре (нулевое значение смещения обозначает отсутствие дуги). При использовании такого подхода, навигация по любому направлению сводится к одному арифметическому сложению:

<spoiler title="ZrfDesign.navigate">
<source lang="javascript">
ZrfDesign.prototype.navigate = function(aPlayer, aPos, aDir) {
  var dir = aDir;
  if (typeof this.players[aPlayer] !== "undefined") {
      dir = this.players[aPlayer][aDir];
  }
  if (this.positions[aPos][dir] !== 0) {
      return aPos + this.positions[aPos][dir];
  } else {
      return null;
  }
}
</source></spoiler>
Ну ладно, есть ещё опциональное изменение направления перемещения, в зависимости от игрока выполняющего ход (так называемая "симметрия"), позволяющее, например, описывать перемещения всех пешек (и чёрных и белых) как перемещение "на север". Если ход будет выполняться чёрными, направление будет изменено на "южное" автоматически. "Нулевая симметрия" позволяет описывать "оппозитные" перемещения для каждого направления (во многих играх это бывает полезно):
<source lang="javascript">
design.addPlayer("White", [1, 0, 3, 2]);
</source>Несколько сложнее преобразуются правила перемещения фигур.

<spoiler title="Ход шашки">
<source lang="lisp">
(define checker-shift (
   $1 (verify empty?)
   (if (in-zone? promotion)
      (add King)
    else
      add
   )
))
</source></spoiler>
<spoiler title="Превращается в ...">
<source lang="javascript">
    design.addCommand(1, ZRF.FUNCTION,	24);	// from
    design.addCommand(1, ZRF.PARAM,	0);	// $1
    design.addCommand(1, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(1, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(1, ZRF.FUNCTION,	20);	// verify
    design.addCommand(1, ZRF.IN_ZONE,	0);	// promotion
    design.addCommand(1, ZRF.FUNCTION,	0);	// not
    design.addCommand(1, ZRF.IF,	4);
    design.addCommand(1, ZRF.PROMOTE,	1);	// King
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.JUMP,	2);
    design.addCommand(1, ZRF.FUNCTION,	25);	// to
    design.addCommand(1, ZRF.FUNCTION,	28);	// end
</source></spoiler>
Это команды стековой машины, каждая из которых очень проста. Например, команда <b>PARAM</b> достаёт числовое значение из массива параметров прикреплённого к шаблону хода (набору команд) и помещает его на стек. Она позволяет параметризировать шаблоны ходов, передавая направления перемещения в параметрах:

<spoiler title="Описание фигуры">
<source lang="javascript">
    design.addPiece("Man", 0);
    design.addMove(0, 0, [3, 3], 0);
    design.addMove(0, 0, [0, 0], 0);
    design.addMove(0, 0, [1, 1], 0);
    design.addMove(0, 1, [3], 1);
    design.addMove(0, 1, [0], 1);
    design.addMove(0, 1, [1], 1);
</source></spoiler>
В качестве третьего параметра передаётся "режим" хода - числовое значение, позволяющее, помимо всего прочего, отделить "тихие" ходы (в шашках) от выполнения взятий. Вся тройка (шаблон + параметры + режим хода) составляет <b>полное</b> описание одного из возможных ходов, выполняемых фигурой.
</spoiler>
Jocly построена по классической <a href="https://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a>-схеме. Для разработки новой игры требуется написать её модель и представление. Модель определяет правила игры, а представление - то, как игра будет показана пользователю. Контроллер, написанный разработчиками, берёт на себя всё остальное (включая зашитых в него ботов).

<img align="center" src="https://habrastorage.org/files/b8c/958/9e0/b8c9589e0d7f4a7bb13babe05148c6d8.PNG"/>
Архитектура универсальной модели, реализуемой <b>Z2J</b> также не очень сложна. Основу составляет компонент <b>Design</b>, содержащий неизменяемое описание правил игры. Состояние игры (размещение фигур на доске) хранится в экземплярах класса <b>Board</b>. Данные этих компонентов также не изменяются. Выполняя ход (применяя объект <b>Move</b> к <b>Board</b>), мы создаём новое состояние. Старое остаётся неизменным!

<img align="center" src="https://habrastorage.org/files/db6/d21/e9d/db6d21e9d485452682cea190633bb5d0.PNG"/>
Для генерации хода (создания объекта <b>Move</b>), используется текущее состояние <b>Board</b>, но одного лишь его недостаточно для реализации всех возможностей ZRF. В процессе генерации хода, ZRF может использовать переменные (флаги и позиционные флаги), не являющиеся частью игрового состояния. Всем этим, а также логикой выполнения команд стековой машины, занимается <b>Move Generator</b>. Если говорить вкратце, такова архитектура модуля <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/zrf-model.js">zrf-model.js</a>.

<h2><b>Дьявол в деталях</b></h2>
Итак, я собирался встроить в Jocly свою модель (zrf-model.js), сконфигурированную <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/example.js">результатом компиляции</a> "<a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/example.zrf">Турецких шашек</a>", вместо <a href="http://embed.jocly.net/jocly/plazza/file-access?game=turkish-draughts&file=checkersbase-model.js">модели</a> Jocly и попытаться запустить всё это, не внося каких либо изменений в <a href="http://embed.jocly.net/jocly/plazza/file-access?game=turkish-draughts&file=checkers-xd-view.js">представление</a> игры. Оглядываясь назад, я понимаю, что идея была авантюрной (почему - расскажу ниже), но именно с этого я начал. От модели требовалось немного:

<ol>
	<li>Хранение текущего состояния игры</li>
	<li>Генерация всех ходов, допустимых для текущего состояния игры</li>
	<li>Изменение состояния игры, путём применения к нему одного из сгенерированных ходов</li>
</ol>
Сложность заключалась в том, что ход, далеко не всегда, сводится к простому перемещению одной из фигур по доске. В наиболее общей форме, ход состоит из последовательности следующих элементарных действий:

<ul>
	<li><b>move</b> - Перемещение фигуры из одной позиции в другую</li>
	<li><b>capture</b> - Удаление фигуры с одной из позиций на доске</li>
	<li><b>drop</b> - Добавление (сброс) новой фигуры на доску</li>
</ul>
Например, взятие фигуры в шашках состоит из одного перемещения своей фигуры и взятия фигуры противника (при этом, взятие не "шахматное", поскольку позиция, с которой оно выполняется, не совпадает с конечной позицией перемещения фигуры), а ходы в таких играх как "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%8D%D0%BD%D0%B4%D0%B7%D1%8E">Рендзю</a>" состоят из единичных сбросов фигур на доску. Не следует думать, что при выполнении хода может перемещаться всего одна фигура! Так, при выполнении <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировки</a> в шахматах, ладья и король перемещаются одновременно, в рамках одного неделимого хода.

<spoiler title="Как это работает">
Генерация хода сводится к формированию списка элементарных действий, выполняемых в правильной последовательности. Это просто последовательная интерпретация команд стековой машины:

<spoiler title="ZrfMoveGenerator.generate">
<source lang="javascript">
ZrfMoveGenerator.prototype.generate = function() {
  this.cmd = 0;
  while (this.cmd < this.template.commands.length) {
     var r = (this.template.commands[this.cmd++])(this);
     if (r === null) break;
     this.cmd += r;
     if (this.cmd < 0) break;
  }
}
</source></spoiler>
Если опустить подробности, связанные с проверками необходимых условий (не нахождение полей под шахом, неподвижность фигур до выполнения хода и т.п.), код выполнения короткой рокировки, выраженный на ZRF может выглядеть так:

<spoiler title="Рокировка">
<source lang="lisp">
(define O-O (
   e e to e
   cascade w w
   add
))
</source></spoiler>
<spoiler title="Превращается в ...">
<source lang="javascript">
design.addCommand(0, ZRF.FUNCTION, 24); // from
design.addCommand(0, ZRF.PARAM, 0);     // e
design.addCommand(0, ZRF.FUNCTION, 22); // navigate
design.addCommand(0, ZRF.PARAM, 1);     // e
design.addCommand(0, ZRF.FUNCTION, 22); // navigate
design.addCommand(0, ZRF.FUNCTION, 25); // to
design.addCommand(0, ZRF.PARAM, 2);     // e
design.addCommand(0, ZRF.FUNCTION, 22); // navigate
design.addCommand(0, ZRF.FUNCTION, 24); // from
design.addCommand(0, ZRF.PARAM, 3);     // w
design.addCommand(0, ZRF.FUNCTION, 22); // navigate
design.addCommand(0, ZRF.PARAM, 4);     // w
design.addCommand(0, ZRF.FUNCTION, 22); // navigate
design.addCommand(0, ZRF.FUNCTION, 25); // to
design.addCommand(0, ZRF.FUNCTION, 28); // end
</source></spoiler>
Помимо параметризованной навигации, всё сводится к перемещению фигур, взятых командой <b>from</b> (неявно выполняемой в начале хода и при выполнении команды <b>cascade</b>), на поле указанное командой <b>to</b> (также формируемой неявно). Сам обработчик команды выглядит элементарно:

<spoiler title="Model.Move.ZRF_TO">
<source lang="javascript">
Model.Game.functions[Model.Move.ZRF_TO] = function(aGen) {
   if (aGen.pos === null) {
       return null;
   }
   if (typeof aGen.piece === "undefined") {
       return null;
   }
   aGen.movePiece(aGen.from, aGen.pos, aGen.piece);
   delete aGen.from;
   delete aGen.piece;
   return 0;
}

ZrfMoveGenerator.prototype.movePiece = function(aFrom, aTo, aPiece) {
  this.move.movePiece(aFrom, aTo, aPiece, this.level);
  if (aFrom !== aTo) {
      this.setPiece(aFrom, null);
  }
  this.setPiece(aTo, aPiece);
}

ZrfMove.prototype.movePiece = function(from, to, piece, part) {
  this.actions.push([ from, to, piece, part ]);
}
</source></spoiler>
</spoiler>
Но всё это - только часть проблемы! В шашках, фигура может (и более того, обязана) выполнить несколько взятий "по цепочке". Пока не выполнены все взятия, ход не передаётся другому игроку. С точки зрения модели и для AI, это один ход! С контроллером и представлением всё немного сложнее. В пользовательском интерфейсе игры, каждое шашечное взятие (частичный ход), должно выполняться по отдельности. Пользователь (игрок) должен иметь возможность выбора того или иного частичного хода на каждом этапе выполнения длинного составного хода.

<spoiler title="Конечно, это не единственно возможный подход">
В Zillions of Games, отдельным ходом считается каждый частичный ход. Это упрощает пользовательский интерфейс, но, с другой стороны, не только усложняет жизнь AI, но и ведёт к более серьёзным проблемам.

<img align="center" src="https://habrastorage.org/files/759/69a/a34/75969aa342a24d159fccd076e7998d08.PNG"/>
Здесь показана последовательность позиций, возникающих при выполнении составного хода в игре "<a href="https://fr.wikipedia.org/wiki/Mana_(jeu)">Mana</a>", разработанной Клодом Лероем в 2005 году. По правилам игры, белый Damyo должен выполнить три последовательных шага, по горизонтали или вертикали, на соседнюю пустую позицию. При этом, все шаги <b>должны</b> быть сделаны и фигуре <b>запрещается возвращаться</b> на ранее пройденные позиции. Как легко видеть, фигура может загнать себя в "тупик", выбрав неправильную последовательность частичных ходов. В Zillions of Games эта проблема неразрешима!

С Шашками всё тоже не просто. Практически во всех традиционных шашечных играх (за исключением <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанороны</a>), игрок <b>обязан</b> продолжать взятия, пока есть такая возможность. Это означает, что выполняя частичный ход содержащий взятие, мы ещё не знаем, завершает он <b>допустимый</b> составной ход или нет.

<spoiler title="Разумеется, с этим можно бороться ...">
но это уже сильно напоминает ...
<spoiler title="''закат Солнца вручную''">
<source lang="lisp">
(define checker-captured-find
   mark
   (if (on-board? $1)  
      $1    
      (if (and enemy? (on-board? $1) (empty? $1) (not captured?)) 
          (set-flag more-captures true)
      )
   )
   back
)

(define king-captured-find
   mark
   (while (and (on-board? $1) (empty? $1))
      $1
   )
   (if (on-board? $1)  
      $1    
      (if (and enemy? (empty? $1) (not captured?)) 
          (set-flag more-captures true)
      )
   )
   back
)

(define checker-jump (
  (verify (not captured?))    
  $1
  (verify enemy?)
  (verify (not captured?))
  $1
  (verify empty?)
  (set-flag more-captures false)
  (if (in-zone? promotion)
      (king-captured-find $1)
      (king-captured-find $2)
      (king-captured-find $3)
   else
      (checker-captured-find $1)
      (checker-captured-find $2)
      (checker-captured-find $3)
  )
  (if (flag? more-captures)
      (opposite $1)
      (markit)
      $1
  )
  (if (not (flag? more-captures))
      (opposite $1) 
      (if enemy?
          capture
      )
      $1
      (capture-all)
  )
  (if (in-zone? promotion)
      (if (flag? more-captures)
          (add-partial King jumptype)
       else
          (add-partial King notype)
      )
   else
      (if (flag? more-captures)
          (add-partial jumptype)
       else
          (add-partial notype)
      )
  )
))
</source></spoiler></spoiler>
Более того, во многих шашечных играх, таких как "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Международные шашки</a>", действует "правило большинства", согласно которому игрок обязан взять максимально возможное количество фигур противника. В некоторых играх уточняется, что приоритетным должно рассматриваться взятие наибольшего количество дамок. Рассматривая каждый частичный ход по отдельности, Zillions of Games вынужденно прибегает к "магии опций":

<ul>
	<li><b>(option "pass partial" true)</b> - разрешает прерывать цепочку взятий</li>
	<li><b>(option "maximal captures" true)</b> - взять максимальное количество фигур</li>
	<li><b>(option "maximal captures" 2)</b> - взять максимальное количество дамок (если количество взятых дамок одинаково - брать максимальное количество фигур)</li>
</ul>
А теперь, просто сравните этот хардкод с тем, ...

<spoiler title="как аналогичную проверку выполняет Jocly">
<source lang="javascript">
		if(aGame.g.captureLongestLine) {
			var moves0=this.mMoves;
			var moves1=[];
			var bestLength=0;
			for(var i in moves0) {
				var move=moves0[i];
				if(move.pos.length==bestLength)
					moves1.push(move);
				else if(move.pos.length>bestLength) {
					moves1=[move];
					bestLength=move.pos.length;
				}
			}
			this.mMoves=moves1;
		}
</source></spoiler>
Когда весь составной ход доступен целиком, ничто не мешает просто подсчитать количество выполняемых им взятий.
</spoiler>
Генерация составного хода - это самое простое применение ZrfMoveGenerator. Каждый экземпляр генератора формирует свой частичный ход, а сами частичные ходы сцепляются в "цепочку" составного хода. К сожалению, это не единственный способ, которым ZRF может пользоваться, чтобы определять ходы. Рассмотрим очень простой кейс, описывающий фигуру, двигающуюся через пустые поля в одном направлении (такую как <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Слон</a>, <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладья</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D1%80%D0%B7%D1%8C">Ферзь</a> в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>):

<spoiler title="Шахматный Rider">
<source lang="lisp">
(define slide (
  $1 (while empty? add $1) 
  (verify enemy?)
  add
))
</source></spoiler>
Можно видеть, что команда <b>add</b>, завершающая формирование хода, используется в теле цикла. Это означает, что фигура может остановиться на любом пустом поле, по пути следования до вражеской фигуры (и это будет считаться корректным ходом). Разумеется, от такого цикла можно избавиться, переписав определение:

<spoiler title="В некоторых играх на ZRF приходится использовать такой способ">
<source lang="lisp">
(define slide-1 (
  $1 (verify enemy?)
  add
))

(define slide-2 (
  $1 (verify empty?)
  $1 (verify enemy?)
  add
))

(define slide-3 (
  $1 (verify empty?)
  $1 (verify empty?)
  $1 (verify enemy?)
  add
))
...
</source></spoiler>
Команда <b>add</b>, выполняемая в теле цикла, приводит к формированию недетерминированного хода. Фигура может остановиться или пойти дальше. Для ZrfMoveGenerator, это означает необходимость клонирования. Генератор создаёт полную копию своего состояния и помещает её в стек, для последующей генерации, после чего, текущая копия завершает формирование хода. Вот как это выглядит:

<spoiler title="Перемещение дамки">
<source lang="lisp">
(define king-shift (
   $1 (while empty?
       add $1
   )
))
</source></spoiler>
<spoiler title="превращается в ...">
<source lang="javascript">
    design.addCommand(3, ZRF.FUNCTION,	24);	// from
    design.addCommand(3, ZRF.PARAM,	0);	// $1
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.FUNCTION,	1);	// empty?
    design.addCommand(3, ZRF.FUNCTION,	0);	// not
    design.addCommand(3, ZRF.IF,	7);
    design.addCommand(3, ZRF.FORK,	3);
    design.addCommand(3, ZRF.FUNCTION,	25);	// to
    design.addCommand(3, ZRF.FUNCTION,	28);	// end
    design.addCommand(3, ZRF.PARAM,	1);	// $2
    design.addCommand(3, ZRF.FUNCTION,	22);	// navigate
    design.addCommand(3, ZRF.JUMP,	-8);
    design.addCommand(3, ZRF.FUNCTION,	28);	// end
</source></spoiler>
Команда <b>FORK</b> клонирует генератор хода вместе со всем его текущим состоянием и работает как условный переход. В порождённом генераторе, управление перейдёт к следующей команде, а родитель передаст управление на заданное параметром количество шагов (да-да это очень сильно напоминает создание процесса в Linux).

<spoiler title="Бремя совместимости">
Для того, чтобы ZRF-описания игр работали после "трансляции" их на JavaScript, недостаточно просто выполнить аналогичные команды в том же порядке. Семантика операций (в части взаимодействия с состоянием доски) должна полностью совпадать с используемой Zillions of Games. Чтобы вы представляли себе всю степень запутанности вопроса, вкратце перечислю основные пункты:

<ul>
	<li>Во время генерации хода, доска доступна в том состоянии, каким оно было на момент начала генерации. Перемещаемая фигура не убирается с исходного поля и, разумеется, не устанавливается на текущее. Это требование понятно (особенно если вспомнить об иммутабельности доски), но в реальной жизни бывает крайне неудобным.</li>
	<li>Состояние флагов (битовых переменных) и позиционных флагов (битовых переменных, привязанных к конкретным позициям) доступно лишь в процессе генерации хода. В случае Zillions of Games, рассматривающей каждый частичный ход как отдельный, это сильно снижает их полезность, но мы должны обеспечить аналогичную семантику, чтобы всё работало.</li>
	<li>Хранение атрибутов (именованных битовых флагов, привязанных к фигурам) не ограничено генерацией хода. Атрибуты - часть состояния доски. Кстати, сами фигуры тоже иммутабельны, изменяя им какой либо из атрибутов, мы создаём новую фигуру.</li>
	<li>Поскольку состояние доски доступно на момент начала генерации хода, прочитать атрибут можно лишь по месту начального расположения фигуры, но если мы хотим изменить атрибут, то делать это надо на той позиции, где фигура завершает своё перемещение (то есть окажется в момент завершения хода). Если изменить атрибут на другом поле (например на исходном) - фатальной ошибки не произойдёт. Значение просто не установится.</li>
	<li>Каскадные ходы не передаются при клонировании ходов. Вернее передаются, но только если отключена опция "<b>discard cascades</b>". Ни разу не видел игры, где это используется!</li>
	<li>Промежуточные взятия и сбросы фигур также не передаются в клонированный ход. В результате, взятие дамкой в "Русских шашках" превращается в настоящую головоломку (от точки возможного завершения хода командой <b>add</b>, выполняемой в цикле, необходимо двигаться назад, чтобы взять ранее перепрыгнутую вражескую фигуру.</li>
	<li>Мы не можем взять фигуру, у которой на том же ходу изменился тип, значение атрибута или владелец! Это больше похоже на баг, но из песни слова не выкинешь.</li>
	<li>Если ход завершается на позиции содержащей фигуру, "шахматное взятие" выполняется автоматически. Если на том же поле вызвать команду <b>capture</b> явно, будет удалена и та фигура, которая выполняла ход (таким образом можно делать фигуры-камикадзе). Аналогичным образом (командой <b>create</b>) можно менять тип и владельца фигуры.</li>
	<li>Если включена опция отложенного взятия, при продолжении хода, все взятия фигур должны перемещаться в последний частичный ход составного хода. Этой опции, по понятным причинам, нет в ZRF, но когда она нужна, её так не хватает! Реализация правила "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>" в ZRF - это форменное мучение! К счастью, мы рассматриваем составной ход целиком. Почему бы не реализовать такую полезную опцию?</li>
</ul>
Это не полный список. Просто первое, что пришло в голову. Помимо этого, необходимо реализовать цикл перебора всех своих фигур, способных выполнить перемещение (в Zillions of Games, игрок может двигать только свои фигуры), а также всех пустых полей, на которые фигуру можно "сбросить".

<spoiler title="Всё вместе это выглядит как-то так">
<source lang="javascript">
var CompleteMove = function(board, gen) {
  var t = 1;
  if (Model.Game.passPartial === true) {
      t = 2;
  }
  for (var pos in board.pieces) {
       var piece = board.pieces[pos];
       if ((piece.player === board.player) || (Model.Game.sharedPieces === true)) {
           for (var move in Model.Game.design.pieces[piece.type]) {
                if ((move.type === 0) && (move.mode === gen.mode)) {
                    var g = f.copy(move.template, move.params);
                    if (t > 0) {
                        g.moveType = t;
                        g.generate();
                        if (g.moveType === 0) {
                            CompleteMove(board, g);
                        }
                    } else {
                        board.addFork(g);
                    }
                    t = 0;
                }
           }
       }
  }
}

ZrfBoard.prototype.generateInternal = function(callback, cont) {
  this.forks = [];
  if ((this.moves.length === 0) && (Model.Game.design.failed !== true)) {
      var mx = null;
      for (var pos in this.pieces) {
           var piece = this.pieces[pos];
           if ((piece.player === this.player) || (Model.Game.sharedPieces === true)) {
               for (var move in Model.Game.design.pieces[piece.type]) {
                   if (move.type === 0) {
                       var g = Model.Game.createGen(move.template, move.params);
                       g.init(this, pos);
                       this.addFork(g);
                       if (Model.Game.design.modes.length > 0) {
                           var ix = Model.find(Model.Game.design.modes, move.mode);
                           if (ix >= 0) {
                               if ((mx === null) || (ix < mx)) {
                                   mx = ix;
                               }
                           }
                       }
                   }
               }
           }
      }
      for (var tp in Model.Game.design.pieces) {
           for (var pos in Model.Game.design.positions) {
               for (var move in Model.Game.design.pieces[tp]) {
                    if (move.type === 1) {
                        var g = Model.Game.createGen(move.template, move.params);
                        g.init(this, pos);
                        g.piece = new ZrfPiece(tp, this.player);
                        g.from  = null;
                        g.mode  = move.mode;
                        this.addFork(g);
                        if (Model.Game.design.modes.length > 0) {
                            var ix = Model.find(Model.Game.design.modes, move.mode);
                            if (ix >= 0) {
                                if ((mx === null) || (ix < mx)) {
                                    mx = ix;
                                }
                            }
                        }
                    }
               }
           }
      }
      while ((this.forks.length > 0) && (callback.checkContinue() === true)) {
           var f = this.forks.shift();
           if ((mx === null) || (Model.Game.design.modes[mx] === f.mode)) {
               f.generate();
               if ((cont === true) && (f.moveType === 0)) {
                   CompleteMove(this, f);
               }
           }
      }
      if (cont === true) {
          Model.Game.CheckInvariants(this);
          Model.Game.PostActions(this);
          if (Model.Game.passTurn === 1) {
              this.moves.push(new ZrfMove());
          }
          if (Model.Game.passTurn === 2) {
              if (this.moves.length === 0) {
                  this.moves.push(new ZrfMove());
              }
          }
      }
  }
  if (this.moves.length === 0) {
      this.player = 0;
  }
  return this.moves;
}
</source></spoiler>
Алгоритм построен таким образом, чтобы продолжения ходов "затирали" свои более короткие "префиксы" (разумеется, если не включена опция "<b>pass partial</b>").
</spoiler>
Используя два этих способа (выстраивание генераторов ходов в "цепочку" и клонирование) можно реализовать любые конструкции языка ZRF. Конечно, реализация получается не простой и, в силу необходимости обеспечения совместимости с семантикой ZRF, довольно запутанной. Это не очень большая проблема, если код работает. Проблема в том, что сам ZRF далеко не идеален!

<h2><b>Разжать пальцы</b></h2>
Этот год начался с разочарований. Для начала, я зашёл в тупик в своих <a href="https://habrahabr.ru/post/309096/">попытках</a> создания универсального <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a>, пригодного для простого описания всех известных мне настольных игр. Универсально, в принципе, получалось, "понятно" - нет. Даже относительно простые игры, такие как <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанорона</a>, норовили описаться в какой-то ужас.

<spoiler title="Вроде этого">
(*)[p]|((\1[ex])*;~1(~1[ex])*)
</spoiler>
<spoiler title="Даже на ZRF это выглядит понятнее">
<source lang="lisp">
(define approach-capture (
    $1
    (verify empty?)
    to
    $1
    (verify enemy?)
    capture
    (while (enemy? $1) $1 capture)
    (add-partial capturing)
))

(define withdrawl-capture (
    $1
    (verify empty?)
    to
    back
    (opposite $1)
    (verify enemy?)
    capture
    (while (enemy? (opposite $1)) (opposite $1) capture)
    (add-partial capturing)
))
</source></spoiler>
C Jocly дело тоже как-то сразу не задалось. Мне не понравилась её архитектура. Начнём с того, что для хранения состояния доски в ней используется мутабельный синглтон Model.Board. Как с этим работать AI-боту - ума не приложу. Но главное даже не в этом. <a href="http://embed.jocly.net/jocly/plazza/file-access?game=english-draughts&file=checkersbase-model.js">Одна</a> модель в ней совершенно не похожа на <a href="http://embed.jocly.net/jocly/plazza/file-access?game=3dchess&file=base-model.js">другую</a> (просто не имеет ничего общего). При этом, активно используются "магические" члены, наподобие <b>mWho</b> или <b>mMoves</b>, а представление должно "знать" о том как устроена модель, поскольку использует её наравне с контроллером!

Мои надежды "подменить" модель были заранее обречены на неудачу! То есть, мне вполне возможно и удастся подменить <a href="http://embed.jocly.net/jocly/plazza/file-access?game=turkish-draughts&file=turkish-model.js">модель</a> "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашек</a>" так, чтобы с ней работало соответсвующее <a href="http://embed.jocly.net/jocly/plazza/file-access?game=turkish-draughts&file=turkish-xd-view.js">представление</a>, но для любой другой игры (даже для "<a href="http://embed.jocly.net/jocly/plazza/file-access?game=english-draughts&file=draughts-model.js">Английских шашек</a>") пришлось бы начинать всё с начала, потому что её модель от "Турецких шашек" отличалается весьма значительно. Я понимал, что не готов, помимо модели, заниматься ещё и разработкой представления и пребывал в глубокой депрессии. А потом, в работу включился @jonic и на горизонте немного посветлело.

Мы решили отказаться от попыток интеграции с Jocly и разработать недостающие контроллеры (для сетевых и локальных игр, а также утилиту autoplay), представления (2D и 3D), а также ботов (в ассортименте) самостоятельно. Причём, всей этой работой согласился заняться @jonic, чтобы я смог сосредоточиться на работе над моделью. Первым делом я избавился от дурацких унаследованных ограничений Jocly. Да, теперь модель поддерживает игры для более чем двух игроков! А потом я вошёл во вкус...

<spoiler title="Это список запланированных мной опций">
<ul>
	<li><b>maximal-captures   = true</b> - Правило большинства (например в "Международных шашках")</li>
	<li><b>pass-partial       = true</b> - Возможность прерывания составного хода (как в "Фанороне")       </li>
	<li><b>pass-turn          = true</b> - Возможность пропуска хода</li>
	<li><b>pass-turn          = forced</b> - Возможность пропуска хода при отсутствии других ходов</li>
	<li><b>discard-cascades   = true</b> - Сброс каскадных перемещений при завершении версии хода</li>
	<li><b>include-off-pieces = true</b> - Учёт фигур находящихся в резерве при подсчёте</li>
	<li><b>recycle-captures   = true</b> - Перевод игр в резерв при выполнении взятия</li>
	<li><b>smart-moves        = true</b> - Режим "интеллектуального" UI (при наличии единственного хода)</li>
	<li><b>smart-moves        = from</b> - Перемещает фигуру при указании стартовой позиции</li>
	<li><b>smart-moves        = to</b> - Перемещает фигуру при указании целевой позиции</li>
</ul>
<ul>
	<li><b>zrf-advanced       = true</b> - Все опции zrf-advanced</li>
	<li><b>zrf-advanced       = simple</b> - Упрощённая семантика перемещения фигур при генерации хода</li>
	<li><b>zrf-advanced       = fork</b> - Взятия и сбросы переносятся через ZRF_FORK</li>
	<li><b>zrf-advanced       = composite</b> - Доступность флагов установленных предыдущими частичными ходами</li>
	<li><b>zrf-advanced       = mark</b> - Поддержка вложенных вызовов mark/back</li>
	<li><b>zrf-advanced       = delayed</b> - Реализация правила "Турецкого удара" (во всех шашках, кроме турецких)</li>
	<li><b>zrf-advanced       = last</b> - Очистка пометок last-from и last-to при завершении составного хода</li>
	<li><b>zrf-advanced       = shared</b> - Возможность хода чужими фигурами (как в "Ставропольских шашках")</li>
	<li><b>zrf-advanced       = partial</b> - Возможность продолжения составного хода не только фигурой, завершившей частичных ход</li>
	<li><b>zrf-advanced       = numeric</b> - Поддержка работы с числовыми значениями (как в "Ритмомахии")</li>
	<li><b>zrf-advanced       = foreach</b> - Поддержка оператора foreach для поиска позиции на доске</li>
	<li><b>zrf-advanced       = repeat</b> - Поддержка команды повторения хода (пропуск хода всеми игроками)</li>
	<li><b>zrf-advanced       = player - </b>Поддержка команд для определения текущего игрока, следующего, принадлежности фигур</li>
	<li><b>zrf-advanced       = global</b> - Поддержка глобальных значений состояния (как в Axiom)</li>
</ul>
<ul>
	<li><b>board-model        = heap</b> - Хранение неупорядоченного множества фигур на позиции (как в манкалах)</li>
	<li><b>board-model        = stack</b> - Хранение упорядоченного множества фигур на позиции (как в "Столбовых шашках")</li>
	<li><b>board-model        = quantum</b> - Квантовая доска (фигура одновременно присутствует на нескольких позициях)</li>
</ul></spoiler>
Я же говорил, что ограничения ZRF мне тоже не нравятся? Меньшая часть этих опций - унаследованные настройки Zillions of Games, поддерживать которые необходимо. Остальное - расширения, доселе в ZRF не виданные. Так все опции <b>zrf-advanced</b> (их можно включить все вместе, одной командой) - расширяют семантику ZRF, делая её более удобной (я постарался учесть <a href="http://www.frontiernet.net/~alcove/chess/zogfeedback.html">пожелания</a> <a href="http://zillionsofgames.com/discus/messages/5/174.html?1079204040">пользователей</a> Zillions of Games), а опции <b>board-model</b> - вводят новые типы досок.  

<spoiler title="Об этом стоит сказать подробнее">
Работая с фигурами на доске, Zillions of Games придерживается некоторых соглашений. В частности, одно игровое поле не может быть занято более чем одной фигурой. Следствием этого является упрощённая реализация "шахматного взятия" (не требуется явно вызывать <b>capture</b> для удаления фигуры на целевом поле). Разумеется, не во всех играх это удобно. Существует целая <a href="http://www.di.fc.ul.pt/~jpn/gv/towers.htm">категория</a> игр (таких как "<a href="https://fr.wikipedia.org/wiki/Puluc">Пулук</a>" и "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовые шашки</a>"), в которых по доске перемещаются "стопки" фигур, установленных друг на друга.

<oembed>https://www.youtube.com/watch?v=7cz8B2Zu-Qs</oembed>
До тех пор, пока "стопки" имеют ограниченную и небольшую высоту, можно схитрить, объявив каждое возможное <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5">размещение</a> фигур отдельным типом фигуры. Но возможность такого решения - скорее исключение, чем правило. Уже при увеличении размера стопки до 6 фигур, количество типов фигур, необходимых для реализации каждого размещения, превышает возможности Zillions of Games. С этим тоже можно бороться, переходя на работу с трёхмерными досками, но гораздо удобнее иметь возможность работы с упорядоченными наборами (размещениями) фигур.

<oembed>https://www.youtube.com/watch?v=0NRdY6p7xic</oembed>
Комбинаторные <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%87%D0%B5%D1%82%D0%B0%D0%BD%D0%B8%D0%B5">сочетания</a> также востребованы в настольных играх. <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%BA%D0%B0%D0%BB%D0%B0">Манкалы</a> являются древнейшим и едва ли не наиболее массовым их семейством. Пока речь идёт о камнях одного цвета, можно использовать тот же фокус с назначением отдельного типа фигуры каждому сочетанию (разработка манкал на ZRF трудоёмка, но вполне возможна), но существуют манкалы, использующие камни <a href="http://mancala.wikia.com/wiki/Kauri">двух</a> и <a href="http://mancala.wikia.com/wiki/10_Mighty_Men">более</a> типов. Есть и другие игры (такие как <a href="https://en.wikipedia.org/wiki/Rithmomachy">Ритмомахия</a>), в которых возможность манипуляции неупорядоченными наборами фигур крайне востребована.

<oembed>https://www.youtube.com/watch?v=QVmppOuYUCE</oembed>
Квантовые доски - наиболее эзотерическая разновидность. В этих играх, одна фигура может <b>одновременно</b> присутствовать на нескольких полях доски (с различной вероятностью). Я не уверен, что буду делать этот тип досок, но игры, в которых такие доски востребованы, определённо <a href="https://arxiv.org/pdf/1603.04751v2.pdf">существуют</a>.
</spoiler>
Сами опции реализованы как подгружаемые JavaScript-модули. Например, если в игре (как в "Международных шашках") требуется брать максимальное количество фигур, необходимо загрузить соответствующий <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/maximal-captures.js">модуль</a>, после загрузки <b>zrf-model</b>. Подключение модуля производится функцией checkVersion:

<spoiler title="В ZRF-файле">
<source lang="lisp">
...
(option "maximal captures" true)
...
</source></spoiler>
<spoiler title="В JavaScript-файле">
<source lang="javascript">
...
 design.checkVersion("z2j", "1");
 design.checkVersion("zrf", "2.0");
 design.checkVersion("maximal-captures", "true");
...
</source></spoiler>
Модель проверит совместимость версий затребованных модулей и подключит соответствующие опции. Этот расширяемый механизм натолкнул меня на интересную мысль. В некоторых играх существуют правила, реализовать которые, используя только ZRF, дьявольски трудно. В большинстве случаев, эти правила сводятся к дополнительным проверкам, влияющим на возможность выполнения того или иного хода. Вынесение проверок в подгружаемые опции избавит меня от необходимости расширения базового языка для их реализации (что было бы совсем не просто).

<spoiler title="Стоит отметить, что разработчики Zillions of Games пошли по тому же пути">
Они прекрасно осознавали, что хотя правила некоторых игр (например Го) и могут быть описаны на ZRF (очень сложно), это никак не поможет AI, встроенному в Zillions of Games, справиться с самими играми. В программу была добавлена возможность "расширения" игр, <a href="http://www.zillions-of-games.com/progsample.html">подключением</a> специально разработанных DLL-модулей. Хотя API этих расширений довольно неудобно и рассчитано лишь на взаимодействие с AI, некоторые разработчики стали использовать подключаемые библиотеки и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=14">для генерации ходов</a>. 

Апофеозом работы в этом направлении стала разработка Грегом Шмидтом его <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a> - погружаемой библиотеки, выполняющей генерацию ходов, на основании описаний игр, выполненном на языке ForthScript. Она многократно расширила возможности Zillions of Games, но не сделала процесс разработки более комфортным. Используя JavaScript, я нахожусь в более выгодном положении. По крайней мере, мне не придётся компилировать свои расширения!
</spoiler>
Поясню на примере. Существует разновидность "Турецких шашек", о которой я узнал совсем недавно. Единственное отличие "Бахрейнских шашек" от турецких заключается в том, что в них запрещено отвечать нападением на нападение противника. Можно съесть напавшую фигуру или уйти из под удара, но нельзя напасть на другую фигуру в ответ! С учётом того, что правило распространяется и на дамки, реализация этой игры на ZRF получилась довольно <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/BahrainDama.zrf">сложной</a> и, что самое главное, не очень "прозрачной". Но если я использую расширяемые опции, мне нет никакой необходимости усложнять код в ZRF!

<spoiler title="Bahrain Dama">
<source lang="lisp">
(variant 
  (title "Bahrain Dama")
  (option "bahrain dama extension" true)
)
</source></spoiler>
Я могу взять "<a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/example.zrf">Турецкие шашки</a>" и подключить опцию выполняющую необходимые проверки. Подгружаемый модуль подменяет метод постобработки хода и, при необходимости, может запретить ранее сгенерированный ход! Сама <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/bahrain-dama-extension.js">логика</a> проверки может быть сколь угодно сложной, она всё равно будет понятнее аналогичной реализации на ZRF! Дело не ограничивается дополнительной валидацией уже сгенерированных ходов. Опция может "обогащать" ход! Например, выполняя ход в "<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>", необходимо сделать следующее:

<ul>
	<li>Проверить 4 соседних камня (3 на границе доски или 2 в углу).</li>
	<li>Если соседний камень принадлежит врагу, построить "связную" группу камней, в которую он входит, и сосчитать количество её дамэ (свободных пунктов, с которыми граничит группа).</li>
	<li>Если вражеская группа не граничит со свободными пунктами - удалить все её камни.</li>
	<li>Если ни одна из вражеских групп не удалена, построить группу, содержащую только что добавленный камень</li>
	<li>Если у построенной группы нет дамэ, запретить ход (Строго говоря, не всегда. <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%98%D0%BD%D0%B3%D0%B0">Правилами Инга</a> разрешён суицид групп, состоящих из более чем одного камня).</li>
</ul>
Всё это можно "спрятать" в <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/go-extension.js">JavaScript-расширение</a>! Оно не только выполнит необходимые проверки, но и дополнит ход удалением вражеских камней. ZRF-описание игры становится <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/zrf/go.zrf">элементарным</a>! Более того, тоже расширение подходит и для других игр! Например, для "<a href="http://senseis.xmp.net/?MultiColorGo">Многоцветного Го</a>".

<h2><b>Больше чем один ход...</b></h2>
Расширяемые опции позволили взглянуть на проект по новому, но одна маленькая задача по прежнему не давала мне покоя. В некоторых играх, при определённых условиях, допускается взятие с доски <b>любой</b> фигуры противника. Например, в "<a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html">Мельнице</a>":

<ul>
	<li>Игроки ставят на доску и перемещают свои фигуры, стараясь поставить 3 фигуры "в ряд".</li>
	<li>Если это удаётся, игрок получает право снять с доски любую фигуру противника.</li>
	<li>При этом, должно отдаваться предпочтение фигурам не стоящим "в ряду" (фигуры составляющие ряд берутся в последнюю очередь).</li>
	<li>Если у игрока остаётся 3 фигуры, он получает возможность перемещать их в <b>любое</b> место доски (не только по отмеченным линиям).</li>
	<li>Проигрывает игрок, у которого осталось меньше 3 фигур.</li>
</ul>
<oembed>https://www.youtube.com/watch?v=csy39T5G220</oembed>
<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=428">Нельзя сказать</a>, что это нереализуемо на ZRF, но код получается <b>очень</b> запутанный. Ну и вообще, генерация набора ходов, одинаковых практически во всём, кроме забираемой фигуры - довольно унылое решение. Я подумал, что было бы гораздо удобнее, если бы в действиях ходов можно было использовать <b>массивы</b> позиций:

<source lang="diff">
ZrfMove.prototype.capturePiece = function(pos, part) {
- this.actions.push([ pos, null, null, part]);
+ this.actions.push([ [pos], null, null, part]);
}
</source>
Это была довольно-таки глобальная <a href="https://github.com/GlukKazan/JoclyGames/commit/5ddcd5cf5edb17757127eb242a77da297c48292d">переделка</a> кода, но <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/tests/checkers-test.js">unit-тесты</a>, в очередной раз, помогли. Пока такие недетерминированные ходы планируется формировать только из JavaScript-расширений, в рамках "обогащения" ходов, формируемых максимально простым ZRF-описанием игры. Если говорить о "<a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/morris-extension.js">Мельнице</a>", то речь идёт о всё том же добавлении в ход взятий фигур. Просто вместо набора одиночных взятий, добавляется одно недетерминированное:

<spoiler title="Магия недетерминизма">
<source lang="javascript">
Model.Game.CheckInvariants = function(board) {
  var design = Model.Game.design;
  var cnt = getPieceCount(board);
  for (var i in board.moves) {
       var m = board.moves[i];
       var b = board.apply(m);
       for (var j in m.actions) {
            fp = m.actions[j][0];
            tp = m.actions[j][1];
            pn = m.actions[j][3];
            if ((fp !== null) && (tp !== null)) {
                if (checkLine(b, tp[0], board.player) === true) {
                    var all = [];
                    var captured = [];
                    var len = design.positions.length;
                    for (var p = 0; p < len; p++) {
                         var piece = b.getPiece(p);
                         if (piece.player !== board.player) {
                             if ((checkLine)(b, p, b.player) === false) {
                                 captured.push(p);
                             }
                             all.push(p);
                         }
                    }
                    if (captured.length === 0) {
                        captured = all;
                    }
                    if (captured.length > 0) {
                        captured.push(null);
                        m.actions.push([captured, null, null, pn]);
                    }
                }
                ...
                break;
           }
       }
  }
  CheckInvariants(board);
}
</source></spoiler>
Но это более широкая концепция. Не только взятие может быть недетерминированным! Помните, что в "Мельнице" есть правило, по которому три оставшиеся фигуры игрока могут прыгать "куда угодно". Фактически, это недетерминированное перемещение на любую свободную позицию:

<spoiler title="Ещё немного магии">
<source lang="javascript">
                ...
                if (cnt === 3) {
                    var len = design.positions.length;
                    for (var p = 0; p < len; p++) {
                        if (p !== tp[0]) {
                            var piece = board.getPiece(p);
                            if (piece === null) {
                                tp.push(p);
                            }
                        }
                    }
                }
                ...
</source></spoiler>
Перемещаемая фигура также может быть массивом! Согласно правилам превращения в Шахматах, пешка, достигая последней горизонтали, может превратиться в любую из 4 фигур (Конь, Слон, Ладья, Ферзь), на выбор игрока. Это ни что иное как недетерминированное превращение, выполняемое при перемещении фигуры. В ZRF-коде пешку можно превратить, например, в ферзя, а в <a href="https://github.com/GlukKazan/JoclyGames/blob/master/Z2J/src/js/debug/chess-promotion.js">JavaScript-расширении</a> :

<spoiler title="... обогатить это превращение">
<source lang="javascript">
var promote = function(arr, name, player) {
  var design = Model.Game.design;
  var t = design.getPieceType(name);
  if (t !== null) {
      arr.push(design.createPiece(t, player));
  }
}

Model.Game.CheckInvariants = function(board) {
  var design = Model.Game.design;
  for (var i in board.moves) {
       var m = board.moves[i];
       for (var j in m.actions) {
            fp = m.actions[j][0];
            tp = m.actions[j][1];
            if ((fp !== null) && (tp !== null)) {
                var piece = board.getPiece(fp[0]);
                if ((piece !== null) && (piece.getType() === "Pawn")) {
                    var p = design.navigate(board.player, tp[0], design.getDirection("n"));
                    if (p === null) {
                        var promoted = [];
                        promote(promoted, "Queen",  board.player);
                        promote(promoted, "Rook",   board.player);
                        promote(promoted, "Knight", board.player);
                        promote(promoted, "Bishop", board.player);
                        if (promoted.length > 0) {
                            m.actions[j][2] = promoted;
                        }
                    }
                }
                break;
            }
       }
  }
  CheckInvariants(board);
}
</source></spoiler>
Для контроллера изменяется немногое. Получив от модели ход, допустимый для текущего состояния доски, он должен проверить размер массивов в каждом из действий. Если передаётся более одного элемента, контроллер должен перебрать все возможные варианты, формируя детерминированные ходы. Думаю, не стоит говорить  о том, что с подобным недетерминизмом следует быть осторожным. Декартово произведение нескольких независимых позиций способно породить просто невероятное количество различных ходов!

<h2><b>Промежуточные итоги</b></h2>
В целом, могу сказать, что мне нравится направление развитие проекта. Я отказался от идеи создания чего-то революционно нового (хоть это было и не просто) и сосредоточился на достижимых, но ни чуть не менее интересных целях. Можно сказать, что из двух известных птиц я предпочитаю "журавля в руках". Работа над проектом помогает освоить новый для меня язык, а присоединение к проекту нового, более опытного разработчика несёт надежду, что работа всё-таки увенчается успехом. Я отказался от "революции", но проект продолжает эволюционировать!
</cut>

Мой Рагнарёк

<img align="left" src="https://habrastorage.org/webt/ti/lf/tq/tilftqvaf4dlybdwymop3-ved_o.jpeg" /><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- У меня с собой свиток, где записано "Прорицание Вёльвы". Там ясно  сказано,  как  все  должно  быть...  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Многое  уже  невозможно изменить, но если Один все-таки схватится с Фенриром, и Тор  подоспеет вовремя, чтобы вступить  в битву  с Ирмугандом, все  пойдет как  надо.&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Макс Фрай</i></b>

Я уже давно хотел разработать настольную игру, основанную на каком нибудь легендарном событии, а что может быть эпичнее и легендарнее чем сама "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B3%D0%BD%D0%B0%D1%80%D1%91%D0%BA">Гибель богов</a>"?
<cut>
Согласно <a href="http://norse.ulver.com/src/edda/voluspa/ru.html">пророчеству</a>, в день Рагнарёка чудовищный волк Фенрир освободится от своих пут и проглотит Солнце, погрузив мир во тьму, а когда из глубин всплывёт мировой змей Ёрмунганд, море выйдет из берегов. К ним примкнёт и огненный великан Сурт с пылающим мечом, который выжжет землю, повелительница загробного царства Хель и коварный бог огня Локи вместе с инеистыми великанами — гримтурсенами и ётунами. Из Хельхейма приплывает корабль мертвецов Нагльфар. Войско сынов Муспельхейма проскачет по радужному мосту Биврёст, который при этом разрушится.

<img align="center" src="https://habrastorage.org/files/ebe/60e/a50/ebe60ea50cb6498b973ebae433731157.JPG"/>
<spoiler title="Идею игры подсказала одна из разработок Catalyst Game Labs">
Игра <a href="https://en.wikipedia.org/wiki/The_Duke_(board_game)">Duke</a> (Герцог) по праву считается одной из лучших абстрактных настольных игр, разработанных в последнее время. Игровой процесс, в целом, похож на "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a>". Правила перемещения фигур схематично изображены на самих фигурах (нотация оказалась настолько удачной, что породила множество всевозможных подражаний).

<oembed>https://www.youtube.com/watch?v=VNggd-6ZNkg</oembed>
Игра начинается на пустой доске (по договорённости игроков, предварительно на ней могут быть размещены "горы"). Каждый из игроков размещает своего "Герцога" на первой линии, после чего новые фигуры вводятся в игру "сбросом" на одну из пустых клеток граничащих с "Герцогом". Важным является тот факт, что выполняя такой "сброс", игрок не знает какую именно фигуру добавит на доску (новые фигуры достаются из мешка и ставятся на доску "не глядя").

Другой особенностью игры является "переключение" фигур при выполнении ими очередного хода. Фигура переворачивается, открывая схему перемещений изображённую на оборотной стороне (более подробно о правилах игры можно прочитать <a href="http://www.catalystgamelabs.com/download/The%20Duke%20Rulebook%20Lo-Res_FINAL.pdf?053ad1">здесь</a>). Подобная игровая механика ни в коем случае не является изобретением игры "Герцог". Очень похожие правила используются в игре "<a href="https://en.wikipedia.org/wiki/Kyoto_shogi">Kyoto shogi</a>", придуманной Tamiya Katsuya в 1976 году:

<oembed>https://www.youtube.com/watch?v=bFLFBx5-9qU</oembed>
Схематичное изображение правил выполнения хода на самих фигурах также неоднократно использовалось ранее. Например, в игре "Escalation" 1988-го года, это дизайнерское решение существенным образом обыгрывается в правилах, поскольку фигуры выполняющие взятие объединяют свои способности со способностями взятых фигур.

<oembed>https://www.youtube.com/watch?v=HeOlz3ce6xA</oembed>
</spoiler>
Взяв за основу незначительно изменённый дизайн (мне пришлось уменьшить размеры фигур, чтобы доска помещалась на экран среднестатистического монитора), позволяющий не запоминать все нюансы правил, а ориентироваться на простейшие пиктограммы, я двинулся дальше. Моей целью было создание новых типов фигур, поведение которых напоминало бы известных персонажей эпоса.

Помимо этого, я сосредоточился на различных игровых ситуациях - "мирах", на которые разделена вся игра. Начальные уровни представляют собой, своего рода, учебник, знакомящий игрока с тактическими особенностями фигур, задействованных в игре. Каждый мир поделён на три уровня, в соответствии с сложностью прохождения. Главных миссий в игре также три (по числу главных антагонистов). В общей сложности, игра содержит 15 вариантов (5 миров, по 3 уровня в каждом).

<h4><b>На крыльях ветра</b></h4>
Вальхалла - первый мир, с которого я начал разработку (но не по сюжету игры). Согласно <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D0%BB%D1%8C%D1%85%D0%B0%D0%BB%D0%BB%D0%B0">германо-скандинавской мифологии</a>, это дворец воинов павших в бою. С поля боя воинов забирают бессмертные девы-воительницы - валькирии, летающие над землёй на крылатых конях. По своим способностям, они напоминают мне "летающие дамки" в русских или турецких шашках - максимальная мобильность и возможность взятия нескольких фигур за один ход.

<img align = "center" src="https://habrastorage.org/files/4fe/ab6/94f/4feab694f55c4c79808596b684cd34e3.PNG"/>
Можно заметить, что здесь изображено три формы - между первыми двумя происходит переключение (таким образом, валькирия чередует диагональные и ортогональные перемещения), а третья - универсальная. Она сочетает в себе правила перемещения первых двух форм и может быть получена только превращением фигуры. Пустой треугольник означает перемещение по прямой на пустое поле, а крестик показывает как удаляются вражеские фигуры (по правилам шашек). На закрашенные квадраты внимание можно не обращать. В мире Вальхаллы они не работают (по причинам, о которых я расскажу ниже).

<img align = "center" src="https://habrastorage.org/files/723/7b1/2f4/7237b12f419343e3af7c415deb238fa7.PNG"/>
Антагонистами валькирий являются ледяные великаны - ётуны. Это, действительно, полная их противоположность - неторопливые фигуры, двигающиеся всего на один шаг (на соседнее поле), при условии что оно пусто (именно это означает заполненная "точка"). Взятия осуществляются по правилам мадагаскарской "<a href="https://en.wikipedia.org/wiki/Fanorona">Фанороны</a>":

<img align="center" src="https://habrastorage.org/files/caa/43f/f3d/caa43ff3dfd94f12be08c52f3e2add37.jpg"/>
На поле 8x8 такая фигура может взять до 6 противников за раз (и после этого продолжить бой). Более того, ётуны в Вальхалле даже сильнее чем шашки Фанороны! В Фанороне игрок бьёт либо те шашки к которым подходит, либо те, от которых отступает. В Вальхалле бьются и те и другие! Несмотря на свою силу, ётуны остаются очень тихоходными. Манёвренности валькирий они могут противопоставить лишь своё количество:

<oembed>https://www.youtube.com/watch?v=1qrN8abGbcc</oembed>
По сюжету игры, орды ётунов осаждают Вальхаллу. Дойдя до последней линии, ётуны превращаются в "универсальную" форму (только в этом "мире", не в основной игре). Для победы достаточно получить четырёх "превращённых" ётунов. Соответственно, валькириям требуется снизить количество ётунов ниже этого уровня (до трёх и менее). Сложность игры (человек играет за валькирий) легко регулируется количеством осаждающих фигур.

<h4><b>Один в поле - воин!</b></h4>
Следующим этапом стало добавление новых типов младших фигур (в дополнение к валькириям и ётунам). Вообще, младших фигур в игре не так много и каждую из них хотелось сделать особенной, добавив какую-то уникальную способность. Все младшие фигуры используют составные ходы (но каждая по своему, не так как это делают валькирии или ётуны). Основа любого войска, воин - единственная фигура способная сражаться как на стороне "света", так и за "силы зла" (и, в силу чувства солидарности, не атакующая своих враждебных собратьев):

<img align="center" src="https://habrastorage.org/files/ab5/13e/ca9/ab513eca90784e71bcf5e87827113b3d.PNG"/>
Ход, кодируемый закрашенным кружочком, выглядит ничем не примечательно - поочерёдное чередование ходов фигур <a href="https://en.wikipedia.org/wiki/Ferz_(chess)">Ferz</a> и <a href="https://en.wikipedia.org/wiki/Wazir_(chess)">Wazir</a>. Если бы возможности воина ограничивались лишь этим, получилась бы очень слабая и медлительная фигура. Закрашенная точка позволяет переместиться немного дальше, чтобы побить вражескую фигуру обычным ходом, после чего воин может "прыгнуть" снова. В таком режиме "берсерка" он способен обойти всю доску:

<oembed>https://www.youtube.com/watch?v=IdflD4HKP0E</oembed>
В целом, получается похоже на ход шахматного "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">коня</a>", за исключением того, что воин не может "перепрыгивать" через другие фигуры и может не поворачивать после выполнения "прыжка". Задачка обхода шахматной доски послужила превосходной вводной - первым "миром" игры. Воин обязан взять все фигуры одним составным ходом, потому что если на доске останется хотя бы один ётун, то он легко одержит победу.

<img align="center" src="https://habrastorage.org/files/c87/fd5/fe5/c87fd5fe520f43a6aa5399923c5d4027.PNG"/>
<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%B2%D1%8B">Альвы</a> и противостоящие им <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BD%D0%BE%D0%BC%D1%8B">цверги</a> завершают список младших фигур. Здесь появляется новая разновидность хода - "выстрел" (в случае цвергов это скорее удар топором). Фигура может атаковать вражескую фигуру находящуюся на поле помеченном звёздочкой, "не сходя с места". Кроме того, обе фигуры могут прыгать на не занятое поле. Составные ходы альвов и цвергов реализованы по разному. Альв, после взятия вражеской фигуры, может сделать дополнительный выстрел, а цверг, после прыжка, рубит противника топором.

<h4><b>Мы сожгли последний мост</b></h4>
<a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B2%D1%80%D1%91%D1%81%D1%82">Биврёст</a> - "трясущаяся дорога". Радужный мост ведущий в <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B3%D0%B0%D1%80%D0%B4">Асгард</a>. В день Рагнарёка, огненные великаны проскачут по нему в долину <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%B3%D1%80%D0%B8%D0%B4%D1%80">Вигридр</a>, спеша на последнюю битву. Мост рухнет. И в мире не будет радуги.

<spoiler title="Огненные великаны - пожалуй, самая сложная часть игры">
Как в техническом смысле, так и в плане игрового баланса. Это фигуры обладающие пассивной способностью сжигать врагов вокруг себя. Я уже <a href="https://geektimes.ru/post/269152/">сталкивался</a> с подобным, когда работал над "<a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a>". В этой игре много интересных фигур. Пожалуй, даже слишком много. Скромный "Engineer" (軍吏 gunri) теряется на их фоне.

<img src="https://habrastorage.org/files/29a/3cc/e75/29a3cce754ae41a297136db13a3c573d.PNG"/>
Это тихоходная и малоопасная фигура, способная превратиться в "Poison flame" (毒火 dokka). "Отравленное пламя" гораздо более опасно, хотя и остаётся столь же тихоходным. Любая вражеская фигура, попавшая в её ближайшую окрестность (в том числе и своим ходом) просто исчезает с доски. 

Здесь следует заметить, что хотя <a href="https://en.wikipedia.org/wiki/Ko_shogi#Promotion">правила превращения</a> в "Ko Shogi" гораздо более разнообразны чем правила превращения в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a> или <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>, превращение фигуры "Engineer" может рассматриваться лишь как крайне маловероятное событие (слишком слаба эта фигура). Возможно, по этой причине, правилами плохо проработан следующий, довольно важный вопрос:

<blockquote>It is not clear what happens when two opposing poison flames meet. Nor what happens if any other opposing piece lands next to a poison flame. See the fire demon in tenjiku shogi for some possibilities.</blockquote> 
<img src="https://habrastorage.org/files/d5f/bb6/ff9/d5fbb6ff9adf4fab8f2e1337ee0176ba.PNG"/>

В "<a href="https://en.wikipedia.org/wiki/Tenjiku_shogi">Tenjiku shogi</a>" вопрос взаимодействия вражеских "огненных" фигур проработан более детально (что не удивительно, поскольку "Огненные демоны" играют едва ли не самую важную роль в этой игре):

<blockquote><ul>
	<li>Burn: Wherever the fire demon stops, all adjacent opposing pieces except fire demons are removed from the board, in addition to any piece on the square it lands on. That is, a fire demon can capture up to eight pieces per turn (one it displaces, and seven it burns on adjacent squares).</li>

	<li>Passive burn: Any piece stopping next to an opposing fire demon is removed from the board (after making its capture, if any). Such so-called "suicide moves" do not count as a turn for the stationary player: the fire demon passively burns opposing pieces that land on adjacent squares without using up a turn. (BrlR[mKa3K] + immediate xK)</li>
</ul>
Conflict between fire demons: When one fire demon lands next to another, it is only the moving piece that is immolated. The stationary fire demon survives, as do all other adjacent pieces.</blockquote>
Если "Огненный демон" подходит к вражескому, он сгорает. Фигура, стоявшая неподвижно, остаётся на доске. И в "Ko Shogi" и в "Tenjiku shogi" сгорают лишь вражеские фигуры. Это придаёт игре тактическое разнообразие (например, фигура может атаковать вражескую, стоящую в зоне действия "Огненного демона", сгорев при этом). В "Рагнарёке" я решил отказаться от этого принципа. Все "огненные фигуры" сжигают все "не огненные" (и свои и чужие), оказавшиеся в области действия. Кроме того, в игре "Рагнарёк", огненные фигуры могут выступать лишь на стороне Хаоса.
</spoiler>
<img align="center" src="https://habrastorage.org/files/0a4/f9f/cae/0a4f9fcaee1f4cc383b55c0ad3c125b3.PNG"/>
Это довольно таки мобильные фигуры, но их способности по "сжиганию" других фигур ограничены четырьмя соседними полями. На оставшиеся четыре ближних поля фигура может ходить, выполняя шахматное взятие. Дальние прыжки могут выполняться лишь на пустые поля (таким образом, огненного великана можно заблокировать, заняв поле, на которое он мог бы прыгнуть). Предводитель огненных великанов, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%80%D1%82">Сурт</a> - более мощная, но менее маневренная фигура. Сурт может призывать огненных великанов на поле боя и отдавать им приказы.

<img align="center" src="https://habrastorage.org/files/b02/657/bec/b02657bec3d34a1697eb38b3e5744d51.PNG"/>
<spoiler title="Разрушающееся поле - ещё одна важная часть игрового процесса">
Шахматные игры такого типа - не редкость. <a href="http://www.iggamecenter.com/info/ru/amazons.html">Амазонки</a>, <a href="http://www.iggamecenter.com/info/ru/shakti.html">Шакти</a>, <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=100">Caïssa</a> - во всех этих играх могут выполняться ходы, разрушающие само игровое пространство. Фигуры не могут посещать разрушенные поля. С каждым ходом пространства для манёвра остаётся всё меньше. Это игра на выживание! Я не большой поклонник подобного рода игр, но решил использовать эту игровую механику для одного из миров "Рагнарёка".
</spoiler>
Задача "Огненных всадников" (игрок играет за них) - дойти Суртом до нижнего края доски или уничтожить все противостоящие фигуры. На другой стороне выступают светлые <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%B2%D1%8B">альвы</a>. Это отчасти соответствует скандинавской мифологии, но главная причина прагматическая. Эффективно противостоять "огненным" фигурам могут лишь фигуры "стреляющие" - бьющие на расстоянии, без изменения своей позиции. Им не обязательно уничтожать фигуры противника, достаточно загнать их на уже разрушенную часть доски с которой они не смогут выбраться.

<oembed>https://www.youtube.com/watch?v=-NQuQ6yiTzo</oembed>

<h4><b>Дева и её пёс</b></h4>
<a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D0%BB%D1%8C">Хель</a> - хозяйка подземного мира. Сине-белая великанша, дочь <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%BA%D0%B8">Локи</a> и <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D1%80%D0%B1%D0%BE%D0%B4%D0%B0">Ангрбоды</a>. В день Рагнарёка, плечом к плечу с Локи и Суртом, она восстанет на битву с ненавистными асами и поведёт своих мертвецов  на штурм Асгарда!

<img align="center" src="https://habrastorage.org/files/555/697/e03/555697e030c946aba17eee8ac76a3e7d.JPG"/>
Пожалуй, это самая интересная фигура "Рагнарёка". Она довольно тихоходна, но компенсирует это уникальной пассивной способностью. Хель может замораживать младшие фигуры (воинов, альвов, цвергов и даже валькирий). Фигуры, попавшие под действие "заморозки" превращаются в статистов. Они могут быть перемещены из опасной зоны приказом старшей фигуры, но сами по себе, никаких действий предпринять не могут.

<img align="center" src="https://habrastorage.org/files/83a/041/f06/83a041f062fc4afc94e08f799d02e178.PNG"/>
Этим способности Хель не ограничиваются. На "замороженные" поля могут призываться ледяные великаны - ётуны (естественно, на них действие "заморозки" не распространяется), а сами замороженные фигуры могут быть обращены на сторону Хель (кроме бесстрашных валькирий). Но и это ещё не всё! Хель может резко увеличить "мобильность" своей заморозки, призвав на поле боя верного пса - <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%BC_(%D0%BC%D0%B8%D1%84%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F)">Гарма</a>.

<img align="center" src="https://habrastorage.org/files/cf8/ccf/a72/cf8ccfa72b08496492889fb1a61aff9b.PNG"/>
Задача Гарма - оперативная доставка "заморозки" в любую точку игрового пространства. Эта фигура не может бить врагов вдалеке, но способна максимально быстро добраться до них чтобы "заморозить". Замороженные фигуры могут быть "обращены" Хель (не важно, как далеко от неё они находятся). Кроме того, Гарм может "перепрыгивать" через фигуры находящиеся поблизости. 

Для демонстрации совместных способностей Хель и Гарма, я разработал "мир" <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D0%BB%D1%8C%D1%85%D0%B5%D0%B9%D0%BC">Хельхейм</a>. По сюжету игры, в царство Хель вторгается отряд живых воинов. Игрок, управляя Хель и Гармом, отражает нападение, частично уничтожая воинов, частично обращая их на свою сторону.

<oembed>https://www.youtube.com/watch?v=eODFhNd1kyY</oembed>

<h4><b>Последняя битва</b></h4>
Но вот, пробил час последней битвы. <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D0%BD%D1%80%D0%B8%D1%80">Фенрир</a> освободился от пут и поглотил Солнце. <a href="https://ru.wikipedia.org/wiki/%D0%81%D1%80%D0%BC%D1%83%D0%BD%D0%B3%D0%B0%D0%BD%D0%B4">Ёрмунганд</a> выполз на берег и море вышло из берегов. <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%80%D1%82">Сурт</a> обрушил радужный мост. Чудовищный <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B3%D0%BB%D1%8C%D1%84%D0%B0%D1%80">Нагльфар</a> привёз своих мертвецов. <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%8B">Асы</a> и все <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%B9%D0%BD%D1%85%D0%B5%D1%80%D0%B8%D0%B8">эйнхерии</a>, во главе с Одином, вышли на бой в долине <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%B3%D1%80%D0%B8%D0%B4%D1%80">Вигридр</a>. Самое время с ними познакомиться.

<img align="center" src="https://habrastorage.org/files/818/f1b/7b5/818f1b7b54d74c67b7557122b37f6ae3.PNG"/>
<a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD">Один</a> - отец богов и людей. Мудрец и воин. Предводитель воинства асов. Не самая сильная фигура в игре. Он может отдавать приказы всем своим воинам, но не может их призывать. Может бить на два поля и прыгать через фигуры, но не в северо-западном направлении (левый глаз Одина был отдан, в обмен на мудрость). Он может то, чего не могут все остальные.

<spoiler title="Немножко магии">
Один - отец рун. Девять суток провисел он на стволе древа <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D0%B3%D0%B4%D1%80%D0%B0%D1%81%D0%B8%D0%BB%D1%8C">Иггдрасиль</a>, пронзив себя собственным копьём. За это, ему открылись <a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D0%BD%D1%8B">руны</a> - алфавит древних викингов, широко используемый в мистической и гадательной практике. Всего рун 24 (в игре, я использовал лишь 14 из них), каждая имеет своё значение. Один может бросать руны, а руны творят магию.

<img align="center" src="https://habrastorage.org/files/18f/7ec/4ce/18f7ec4ce4634675a8a37f50bee66888.PNG"/>
Все руны, выбрасываемые в игре (кроме пустой руны), оказывают своё действие. Но не всегда это действие легко заметить. Руны могут превращать одни фигуры в другие, призывать воинов, защищать фигуры или замораживать их. Руны могут изменять расположение фигур и даже сам рельеф местности. Руны не могут быть побиты другими фигурами и могут быть использованы в качестве щитов. У них есть только один недостаток. Когда Один бросает руну, никому не известно, какая руна выпадет.
</spoiler>

<img align="center" src="https://habrastorage.org/files/dcc/f48/d74/dccf48d74da8471e904106bf49e2e52a.PNG"/>
<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%BA%D0%B8">Локи</a> - главный антагонист Одина. Бог хитрости и обмана. Отец чудовищ. Само воплощённое безумие. Как и Один, это не очень сильная фигура, способная выполнять действия, недоступные остальным фигурам. Например, Локи - единственная фигура, которая может изменять расположение фигур противника (меняя их местами со своими фигурами). Локи может захватывать руны выброшенные Одином (правда не все, а только обратимые) и использовать их в своих целях. Локи может призывать чудовищ.

<img align="center" src="https://habrastorage.org/files/306/279/2bc/3062792bce734527b629d23d37617d46.PNG"/>
<a href="https://ru.wikipedia.org/wiki/%D0%81%D1%80%D0%BC%D1%83%D0%BD%D0%B3%D0%B0%D0%BD%D0%B4">Ёрмунганд</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D0%BD%D1%80%D0%B8%D1%80">Фенрир</a> - хтонические чудовища. Фигуры, двигающиеся прямолинейно, на любую дистанцию, проходя сквозь другие фигуры (свои или противника - не важно) и уничтожая их. Только руна, гора или граница игрового поля могут остановить их движение. Поскольку Фенрир двигается "зигзагом" (по диагонали, переключая направление после каждого хода), он может "застрять" в углу доски. Если это произойдёт, он имеет право выполнить "ход на месте", потратив ход игрока на разворот.

<img align="center" src="https://habrastorage.org/files/0ef/21a/9a1/0ef21a9a1c164c009954c85014aff8d4.PNG"/>
<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B5%D0%B9%D0%BF%D0%BD%D0%B8%D1%80">Слейпнир</a> - третье порождение Локи, не столь однозначен. Это восьминогий конь, способный быстро перемещаться по полю. Само его имя переводится как "скользящий" или "шустрый". Чередование ходов шахматной "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладьи</a>" и "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Слона</a>" - вполне подходящая метафора для этой фигуры. Слейпнир лишён способности "проникающего" хода, но может перевозить на себе Локи или Одина. 

<img align="center" src="https://habrastorage.org/files/235/e61/121/235e611215c0416db3eea086ad305bab.PNG"/>
Оседлав Слейпнира, Локи получает новое качество. Он по-прежнему умеет призывать чудовищ и захватывать руны, но становится гораздо более мобильным. Его ходы становятся более симметричными и он обретает дополнительную способность "удара", не сходя с места (аналогичную способности цвергов). Он становится менее уязвим. Выстрелы по этой фигуре "убивают" Слейпнира, оставляя Локи пешим на доске. Впрочем, Локи может "спешиться" и самостоятельно. Для этого, достаточно выполнить "Прыжок", возможно убив при этом фигуру противника.

<img align="center" src="https://habrastorage.org/files/2e8/008/c5b/2e8008c5b1be4cb1b27e09f7b4afc1ce.PNG"/>
Существует ещё одна возможность, для того чтобы "спешить" Локи. Один может напасть на всадника. В этом случае, Один и Локи меняются местами. Один оказывается на коне, а Локи остаётся пешим. В случае, если Один решит сойти с коня, Слейпнир продолжит борьбу уже на стороне "сил Света". Во всяком случае до тех пор, пока Локи вновь не захватит его.

<img align="center" src="https://habrastorage.org/files/341/1de/933/3411de93350349bba173af33d211d9dd.PNG"/>
Остались ещё два "божества поддержки" - <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%8E%D1%80">Тюр</a>, потерявший руку в процессе пленения Фенрира (той самой цепью из звука кошачьих шагов, корней гор и всего прочего, чего более нет на этом свете) и <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%80_(%D0%BC%D0%B8%D1%84%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F)">Тор</a>, с его легендарным молотом. Это призыватели младших фигур - воинов, альвов и валькирий. Тип призываемой фигуры определяется случайно. Тор, в дополнение к этому, обладает способностью удара "по площадям" (квадрат 3x3, не содержащий дружественных фигур) и перемещения на дальние дистанции. Он самый сильный из асов.

Напоследок стоит рассказать о ещё одной уникальной особенности игры - тех самых чёрных квадратах, упомянутых мной в рассказе о валькириях. Это щиты, оберегающие другие фигуры от ряда атак, таких как "шахматное взятие" или "выстрелы". Их действие аналогично руне "<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%B3%D0%B8%D0%B7">Algiz</a>"). К сожалению, в "мире Вальхаллы" они бесполезны. Просто потому, что не защищают от специфических атак ётунов.

Это всё, что я хотел рассказать об игре. В качестве постскриптума, хочу поделиться с вами фрагментом замечательного стихотворения великого американского писателя - <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B2%D0%BA%D1%80%D0%B0%D1%84%D1%82,_%D0%93%D0%BE%D0%B2%D0%B0%D1%80%D0%B4_%D0%A4%D0%B8%D0%BB%D0%BB%D0%B8%D0%BF%D1%81">Говарда Филлипса Лавкрафта</a>.

<spoiler title="Тевтонская боевая песнь">
<b><i>Замкнёт кольцо творенья Рагнарёк,
Биврёст разрушит Суртура орда,
Погибнут Боги, люди от меча,
Исчезнет солнце, море всё пожрёт,
Погаснут звёзды, Хаос снизойдёт.
Затем Альфёдр создаст свой мир иной,
Богов, людей наполнив чистотой.
Придёт страна блаженная Обилья,
Не будет в ней пороков и насилья.</i></b>
</spoiler>
<b><i>Всех с наступающим Новым Годом!</i></b>
</cut>

Странные игры

<img align="left" src="https://habrastorage.org/files/af5/587/778/af55877786bb425f9503d6adadb1a8a8.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Ну, если ты смотришь такого рода спили, то знаешь про них больше меня, - сказал я. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Мне как-то попалась такая бойкая формулировка: мол, риторы умели менять прошлое и делали это с удовольствием; инкантеры могли изменять будущее, но прибегали к своему умению крайне неохотно. ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Им приходилось менять будущее в ответ на действия риторов.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Нил Стивенсон "Анафем"</i></b>

Странные книги побуждают меня делать странные игры. "Анафем" Нила Стивенсона не исключение. Моя статья - один большой спойлер на это произведение. Если вы собираетесь читать её, прежде прочитайте книгу! Я вас предупредил...
<cut>
Эта книга о монахах. О монахах, по большей части, не верящих в бога. Эта книга о людях, посвятивших всю свою жизнь науке. Их отношения с миром сложны. Неуёмная жажда познания сделала их слишком опасными. Они проникли вглубь атомного ядра - мирские власти запретили им это. Они раскрыли тайны генетических цепочек - последовало второе разорение. Сильные мира отобрали у них всё, отгородили их от мира на столетия и тысячелетия. Наивно было полагать, что это кого-то остановит. Инаки разработали новый праксис.

<spoiler title="Философское отступление">
В своей книге, Нил Стивенсон развивает философские идеи Платона, Лейбница, Канта, Гёделя и Гуссерля, согласно которым, помимо Арба (мира в котором развёртывается повествование), существует множество других миров. Миры связаны между собой и по связям может передаваться информация, но только в одном направлении. Более высокие миры служат источниками абстрактных идей (кноонов) для миров лежащих ниже "по фитилю". Сам "фитиль" представляет собой гигантский (возможно бесконечный) ориентированный граф.

<img align="center" src="https://habrastorage.org/files/c3a/1a6/253/c3a1a6253fa94ea09fe75f65c98dccf6.png"/>
Автор раскрывает и механизм такой передачи данных. По его словам, каждый человеческий мозг представляет собой, своего рода, распределённый квантовый компьютер, существующий одновременно во множестве альтернативных миров. Обдумывая какую либо идею, мозг непрерывно общается со множеством своих "альтер эго", получая "советы" из миров, находящихся выше "по фитилю". Таким образом, мозг ничего не изобретает, а лишь открывает уже существующее.

Жители Арба нашли иное применение этому механизму. Лишённые (после второго разорения) какого либо технического оборудования, эвенедриканцы (приверженцы идеи о главенстве семантики над синтаксисом) задумались о механизмах мысли. Развив эти идеи, они обнаружили возможность воздействия на окружающий мир самой мыслью. Из всех возможных альтернатив любого события инкантеры (адепты этого учения) могли выбирать наиболее благоприятные для себя.

Противостоявшие им фаантиты (последователи идей Проца о главенстве синтаксиса над семантикой) изыскали иной способ изменения реальности. Манипулируя воспоминаниями и материальными свидетельствами, риторы научились изменять результат событий уже случившихся в прошлом. Их открытое столкновение с инкантерами привело к обнародованию сведений о новых праксисах и третьему разорению со стороны мирских властей.

Впрочем, знания не были утрачены. Прекрасно осознавая всю стратегическую ценность подобных умений, мирские власти дозволили практиковать их в трёх ("нерушимых") храмах на тысячелетия отгороженных от внешнего мира. Надо сказать, что для самих их обитателей эти практики вовсе не были лишними, поскольку позволили увеличить срок жизни на столетия, до совершенно невообразимых пределов. Мирские власти также не прогадали. По крайней мере дважды, инаки спасали мир от глобальных катаклизмов, используя свои тайные знания.
</spoiler>
Я был вдохновлён романом Нила Стивенсона. В моей голове родилась (и стала грызть меня изнутри) идея новой игры. За основу я решил взять <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашки</a>. У шашек есть две совершенно замечательные особенности: обязательность взятия и составные ходы. На мой взгляд, это именно те две вещи, что делают шашки тактически интересными. Используя правило обязательного взятия, мы можем заманивать противника в ловушки, а составные ходы позволяют брать по нескольку фигур за ход.

Диагональные системы (наподобие "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Русских шашек</a>") показались мне не очень подходящими для моих целей (в игре теряется половина доски!) и я разрешил ортогональные ходы (как в "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашках</a>"). Также, я решил не заморачиваться с превращением фигур в дамки.

<spoiler title="Это было смелым решением">
Дело в том, что правила превращений в шашках придуманы не просто так. Для того, чтобы шашки "не топтались на месте", ходы назад простым фигурам запрещены. Шашки двигаются только вперёд! Это делает игру динамичной. Но что делать, когда фигуры дойдут до дальнего края доски? Даже если разрешить им взятие назад (как в старых "<a href="http://mlwi.magix.net/bg/ossetian.htm">Осетинских шашках</a>"), они будут "толпиться" на последней линии и, по большей части, только мешать. Есть игра, в которой эту проблему решили радикально:

<oembed>https://www.youtube.com/watch?v=75feVC4EZoQ</oembed>
В "Сенегальских шашках" ходы назад запрещены, но никаких превращений нет! Шашка, дошедшая до последней линии, просто... убирается с доски. Я решил не использовать таких радикальных решений, а просто разрешил ходы и взятия по всех возможных восьми направлениях. Это могло привести к затягиванию партий, но...
</spoiler>
У меня было секретное оружие! Инкантеры! Согласно Нилу Стивенсону, они могли "изменять будущее", выбирая из всех возможных альтернативных вариантов развития событий наиболее выгодный для себя. Несмотря на кажущуюся замысловатость, реализовать подобную игровую механику довольно легко.

<spoiler title="Собственно, я не первый, кто так делает">
Правила "<a href="http://www.chessvariants.com/other.dir/refusal.html">Refusal Chess</a>" почти во всём аналогичны тем, к которым мы все привыкли. Единственное отличие заключается в том, что игрок не выполняет ход сразу, а "предлагает" его. Противник может запретить выполнение предложенного хода, в таком случае игрок выполняет любой другой допустимый ход. Разумеется, это правило не работает в случае форсированных ходов. Нельзя запрещать игроку защищать его "Короля" от <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)#.D0.92.D0.B5.D1.87.D0.BD.D1.8B.D0.B9_.D1.88.D0.B0.D1.85">шаха</a>. Refusal Chess - это интересный вариант изменения правил, но в ещё большей степени мне нравится другая разновидность шахмат.

<oembed>https://www.youtube.com/watch?v=9lnQnnx68Gs</oembed>
В "<a href="http://www.chessvariants.com/mvopponent.dir/ambiguous-chess.html">Ambiguous Chess</a>" мы не выполняем ход сами, а лишь "помечаем" поле на которое собираемся сходить. Сам ход выполняется за нас, противником и он вправе извратить любое наше благое намерение удобным для себя образом (например, взять фигуру не пешкой, как мы собирались, а целым ферзём, подставив его под удар).
</spoiler>
Почему это важно? Да потому что эта механика, как и правило "двигаемся только вперёд", позволяет бороться с затягиванием игры. Сторона противостоящая инкантерам (риторы)  "намечает" свой ход, помечая одну из своих фигур, доступное пустое поле или фигуру противника. Последний из трёх вариантов является приоритетным. Как и в шашках, если есть возможность "съесть" вражескую фигуру, игрок обязан это сделать. Далее, инкантеры, от имени риторов, выполняют ход, удовлетворяющий этой метке и тут уже только от них зависит, будут ли фигуры риторов "топтаться на месте" или смело идти вперёд.

В отношении меток устанавливаемых риторами действуют два правила. О первом я уже сказал - пометка достижимой вражеской фигуры приоритетна. Второе правило более коварно: риторы не могут намечать <b>однозначный</b> тихий ход. Метка должна устанавливаться таким образом, чтобы у инкантеров существовало более одной возможности для выполнения хода. Если бы правила ограничивались описанными выше, инкантеры легко побеждали бы в любой игре, но у риторов есть свой способ воздействия на реальность.

<spoiler title="Лориты подсказывают, что здесь я тоже не первопроходец">
Я уже <a href="https://habrahabr.ru/post/255621/">упоминал</a> ранее об одной заумной <a href="http://www.chessvariants.com/3d.dir/timeline.html">игре</a> на четырёхмерной доске. Описание игры выглядит немножко запутанным, но суть проста. Каждая фигура оставляет на доске след, который может быть использован для убийства её "в прошлом". Если до этого следа доберётся вражеская фигура, она не только "убьёт" фигуру оставившую след, но и оживит все фигуры убитые с этого момента. Вот как это выглядит на плоскости:

<oembed>https://www.youtube.com/watch?v=YKVO1PJ7EtE</oembed>
Как и в случае с "Ambiguous Chess", я считаю использованный принцип более подходящим для шашек, чем для шахматных игр. В шашках, имеются подходящие события, для "отката" их в прошлом - взятия фигур. Фигура может не оставлять след постоянно, а формировать "ключевые точки", соответствующие выполненным взятиям (в шахматах, в силу специфики их взятия, это выглядело бы менее наглядно).
</spoiler>
Перед выполнением каждого взятия (от своего имени, а не за риторов), фигура инкантера оставляет на доске специальную метку. Если ритор доберётся до этой метки (тихим ходом или завершая взятие - неважно), он не только уберёт с доски оставившего её инкантера, но и "воскресит" все фигуры, взятые после того как была создана метка. 

Каждого инкантера можно убить только один раз. При его взятии с доски удаляются и все оставленные им метки. В частности, из этого следует, что после выполнения серийного взятия, инкантерам выгодно подставиться под удар. Выполнив вынужденное взятие, риторы лишь закрепят их успех. Не буду вас томить и покажу то, что <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/Anathem.zrf">вышло</a> в результате:

<oembed>https://www.youtube.com/watch?v=kr1BHQ89k5E</oembed>
Игра получилась до предела странной. Как, впрочем, и сама книга. Пожалуй, на текущий момент, это лучшая книга из всех, что я читал.
</cut>

Работа над ошибками

<img align="left" src="https://habrastorage.org/files/925/fcf/946/925fcf94685e4cd2b11aa47f812ff213.PNG"/><b><i>- Люди  забыли  эту истину,  - сказал Лис,  
- но ты не забывай:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ты навсегда в ответе за всех, кого приручил...
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Антуан де Сент-Экзюпери "<a href="http://lib.ru/EKZUPERY/mprinc.txt">Маленький принц</a>"</i></b>

Не ошибается только тот, кто ничего не делает. Со временем, ошибки накапливаются. Да что там говорить, прямо сейчас у меня на руках имеется с десяток use case-ов, приводящих к различным ошибкам, в одних только "<a href="https://habrahabr.ru/post/276329/">Квантовых крестиках-ноликах</a>" и совершенно не хватает духу, чтобы ими заняться (код там действительно <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/QXO/Code.4th">адовый</a>). Но иногда я нахожу время, чтобы что-то исправить. И знаете что? Исправлять старые ошибки ничуть не менее интересно, чем делать новые!
<cut>
<h4><b>Старый Ур в новых одёжках</b></h4>
<a href="https://habrahabr.ru/post/224661/">Ур</a> - одна из моих самых первых игр (если не на <a href="http://www.zillions-of-games.com/">Zillions of Games</a>, то на <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> <a href="https://habrahabr.ru/post/226235/">уж точно</a>). Это игра, с которой началось моё увлечение настольными играми! Разумеется, речь идёт не о <a href="http://skyruk.livejournal.com/211326.html">реконструкциях</a> <a href="https://en.wikipedia.org/wiki/Robert_Charles_Bell">Белла</a> или <a href="https://en.wikipedia.org/wiki/H._J._R._Murray">Мюррея</a></a>. При всех своих достоинствах, эти учёные мужи, по всей видимости, редко играли в настольные игры (во всяком случае, по своим правилам). Единственный, на мой взгляд, играбельный <a href="http://skyruk.livejournal.com/231444.html?thread=4494868">вариант</a> правил, для этой игры, был разработан <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрием Скирюком</a>.

<spoiler title="Выглядела игра страшненько">
<oembed>https://www.youtube.com/watch?v=XLmDzqquyQU</oembed>
</spoiler>
К счастью, в творческий процесс практически сразу включился @Nomad1, разработав превосходную реализацию игры под <a href="https://habrahabr.ru/post/225631">Android и iOS</a>. Следует заметить, что в разработке принимал участие ещё один из авторов Хабра. Без превосходных музыкальных тем, созданных @1eqinfinity, игра и вполовину не получилась бы столь атмосферной. Ресурсы Android-версии позволили значительно улучшить <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2262">внешний вид</a> ZoG-версии, но один из важных моментов не давался мне ни в какую.

<spoiler title="Всё дело в ''стопках'' фигур">
По правилам предложенным Дмитрием Скирюком, на доске имеется несколько позиций разрешающих устанавливать до четырёх игровых фишек "друг на друга". Работает такая стопка по принципу <a href="https://ru.wikipedia.org/wiki/LIFO">LIFO</a> - фишка зашедшая на позицию первой уходит последней. Этот механизм позволяет задерживать продвижение фишек противника, "прижимая" их своими. Именно с этим возникли проблемы. В рамках модели <a href="http://www.zillions-of-games.com">Zillions of Games</a>, каждое поле доски может содержать не более одной фигуры.

Я не в первый раз сталкиваюсь с этим ограничением и знаю как с ним бороться. В некоторых играх, таких как "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2369">Focus</a>", можно использовать "составные" фигуры, представляющие собой "стопки" фигур поставленных друг на друга. Аналогичный подход используется в <a href="https://habrahabr.ru/post/272119/">манкалах</a>. К сожалению, для Ура этот способ неприменим, пришлось бы определить слишком много типов фигур. Другой подход заключается в незаметном перемещении фигур "стопки"  на специально выделенные позиции вне доски (как это сделано в <a href="https://habrahabr.ru/post/234587/">Ритмомахии</a>).
</spoiler>
В первой версии Ура, я прятал заблокированные фигуры, незаметно перемещая их на невидимые поля. Когда верхняя фишка уходила, я возвращал фигуры из стопки, по одной, на прежнее место. К сожалению, наглядность страдала. При таком "взгляде сверху", требовалось хорошо разбираться в правилах, чтобы отличать ситуации "сбивания" фишек от их "накрывания". Совсем недавно, мне удалось эту проблему решить:

<oembed>https://www.youtube.com/watch?v=EV4iMOrqvDM</oembed>
<spoiler title="Начал я с Пулука">
Давно хотел сделать <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2525">эту игру</a>. В "Пулуке" фишки могут ставиться друг на друга, но, в отличии от "Фокуса", нет ограничения на размер стопки. Поскольку "составные" фигуры использовать было нельзя, появилась идея отрисовывать тайлы фишек с небольшим наложением друг на друга. И здесь мне здорово помогли наработки от ещё одной <a href="https://habrahabr.ru/post/278853/">игры</a>. Дело в том, что доску в ZRF можно определять двумя способами. Проще всего определить grid:
<source lang="lisp">
(grid
  (start-rectangle 0 54 50 104)
  (dimensions
     ("a/b/c/d/e/f/g" (18 0)) ; files
     ("10/9/8/7/6/5/4/3/2" (0 50)) ; ranks
  )
)
</source>Число 18 (в скобках) - это смещение, на которое сдвигается тайл фигуры при изменении позиции по горизонтали. Поскольку ширина самого тайла равняется 30, фигуры "накладываются" друг на друга. Выглядит это не слишком хорошо:

<img src="https://habrastorage.org/files/8f2/efa/825/8f2efa8258394912b5aa88632bcb99ae.PNG"/>

К счастью, есть способ исправить ситуацию! Этот небольшой <a href="https://github.com/GlukKazan/ZoG/blob/master/utils/perl/grid.pl">скрипт</a> уже один раз помог мне с "Чейзом", поможет и теперь. Он не очень правильный, некорректно работает с отрицательными числами и множественными описаниями grid-ов, но экономит мне кучу времени. Вот как выглядит игра после его применения:

<img src="https://habrastorage.org/files/4bf/67b/fb0/4bf67bfb04204bfbb118b670f18f0e96.PNG"/>

Секрет прост - теперь, каждая позиция описывается индивидуально. Порядок описания позиций определяет z-последовательность "наложения" тайлов друг на друга:
<source lang="lisp">
(positions
 ...
 (g5 108 304 158 354)
 (f5  90 304 140 354)
 (e5  72 304 122 354)
 (d5  54 304 104 354)
 (c5  36 304  86 354)
 (b5  18 304  68 354)
 (a5   0 304  50 354)
 ...
)
</source>
К сожалению, из за специфичного для "Пулука" группового перемещения фигур, картинка "ломается". Накрытая фигура перемещается второй и отрисовывается позже фигуры перемещаемой игроком. Сделать с этим ничего нельзя, так работает Zillions of Games:

<img src="https://habrastorage.org/files/cb0/302/7c8/cb03027c804442aaaca0183785a3791e.PNG"/>

Пулук просто не подходит для такого способа отображения фигур. А вот Ур - подходит!
</spoiler>
В Уре фигуры <b>не</b> перемещаются группами. Одиночная фишка может быть помещена на верх "стопки" (на некоторых полях доски) или уйти с вершины "стопки". В этом отношении, правила игры в "Ур" идеальны, для выбранного подхода. Дело лишь за тем, чтобы правильно определить на доске позиции (сдвинув часть позиций на пару пикселов вверх и влево) и связать их между собой:

<img align="center" src="https://habrastorage.org/files/032/b38/fa7/032b38fa77c44e8fb2fd6143541ac9bd.PNG"/>
Подход работает, но в некоторых случаях картинка ломается:

<img align="left" src="https://habrastorage.org/files/cb0/e56/ff4/cb0e56ff4e1f460a8f16f781abbec1b5.PNG"/>В общем-то, здесь всё понятно. Мы имеем дело с прямоугольными тайлами, частично нарисованными "прозрачным" цветом, но когда ZoG отрисовывает "прозрачный" цвет то берёт часть изображения доски (фонового рисунка), а не фигуры перекрывшей то же место. Я уже сталкивался с подобным когда рисовал фигуры для "<a href="https://habrahabr.ru/post/274043/">MarGo</a>" и знаю как с этим бороться. Требуется всего лишь нарисовать дополнительные тайлы с закрашенными правыми-нижними уголками. Цвет заливки должен совпадать с цветом лежащей ниже фигуры.&nbsp;

К сожалению, одной только подготовкой графических ресурсов дело не ограничивается. Дело в том, что оболочка Zillions of Games "не любит" выполнять "лишнюю" работу. При перемещении <b>одной</b> фигуры, другие не перерисовываются. После выполнения анимации хода, фигура просто отрисовывается на новой позиции, а старая позиция заполняется (опять же) прямоугольным фрагментом фонового изображения доски. Способ "обмануть систему" есть. Необходимо "всего лишь" инициировать перерисовку всех фигур, начиная с низа стопки:

<spoiler title="Вот как это выглядит">
<source lang="lisp">
(define refresh
   (if (im-white?)
       (if friend?
           (create White $1)
        else
           (create Black $1)
       )
    else
       (if friend?
           (create Black $1)
        else
           (create White $1)
       )
   )
)

(define check-refresh
   (if (on-board? down)
       (if (or (and (flag? is-enemy?) not-enemy?)
               (and (not-flag? is-enemy?) enemy?)
           )
           (refresh $3)
        else
           (refresh $2)
       )
    else
       (refresh $1)
   )
)

(define pre-action
   ...
   (if (on-board? down)
       mark down
       (while (and (on-board? up) (not-empty? up))
            (if (or (piece? King) (piece? KingE) (piece? KingF))
                (check-refresh King KingF KingE)
             else
                (check-refresh Man ManF ManE)
            )
            (set-flag is-enemy? enemy?)
            up
       )
       back
   )
)
</source>
</spoiler>
Фактически, все фигуры "стопки" пересоздаются с теми же типами, в рамках выполнения хода снимающего верхнюю фишку. Это уже вполне работоспособное <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/Ur.zrf">решение</a>. Разумеется, если внимательно следить за анимацией, можно заметить кратковременное разрушение картинки при снятии фишки или анимацию перемещения фигуры с залитым "уголком", но по завершении хода картинка восстанавливается во вполне приемлемое состояние. Пожалуй, это лучшее, чего можно добиться средствами Zillions of Games.

<spoiler title="К сожалению, есть ещё одна проблема">
<img align="center" src="https://habrastorage.org/files/a00/3b7/c08/a003b7c08dab4e31afa7f86afa91494d.PNG"/>
Жёлтые прямоугольники - это регионы связанные с фигурами. Можно видеть, что в "стопках" верхние регионы перекрывают нижние. В этом и кроется проблема. Для того, чтобы "кликнуть" по фишке лежащей в основании стопки, требуется попасть мышью в узенькую полоску шириной в пару пикселов. В этом немного помогает курсор мыши - он изменяет форму когда наводится на фигуру способную выполнить ход, но здесь есть большая засада.

Оболочка Zillions of Games поддерживает довольно хитрую опцию, связанную с UI. При включении "smart moves", игроку уже не обязательно перетаскивать фигуры по доске мышью. Если мы кликаем по фигуре, способной выполнить единственный ход - ход будет выполнен автоматически, без всякого перетаскивания. В случае Ура, это очень удобно (а вот в Шахматах, иногда, бывает не очень). Но у опции есть и обратная сторона - если мы кликаем по пустому полю, на которое может быть выполнен единственный ход, то этот ход будет выполнен! Теперь представим себе стопку из трёх фигур. Верхний прямоугольник существенно превосходит по площади двухпиксельные уголки и, если в него возможен ход, то чуть дрогнувшая рука может запросто привести к поражению во всей партии.
</spoiler> 
В качестве бонуса, я получил неожиданный подарок. Вообще, я планировал переписать Axiom-версию вслед за ZRF, но это не понадобилось! Из за упрощения логики игры, AI стал справляться с игрой <b>гораздо</b> лучше. Достаточно сказать, что иногда он у меня выигрывает, а в большинстве случаев, не успевает провести всего одну фишку. Он всё ещё хуже Android-версии, но с ним уже вполне приятно играть.

<h4><b>Охота на "Слона"</b></h4>
<a href="http://www.chessvariants.com/other.dir/elephant_hunt.html">Это</a> была не моя ошибка, но уж очень чесались руки её исправить. Не знаю почему. Речь идёт об одной довольно оригинальной шахмато-подобной <a href="http://www.chessvariants.com/other.dir/elephant_hunt.html">игре</a>, якобы популярной среди пигмеев <a href="https://ru.wikipedia.org/wiki/%D0%98%D1%82%D1%83%D1%80%D0%B8">Итури</a>. Со слов <a href="http://www.chessvariants.com/who/Freederick">автора</a>, описание игры было обнаружено его другом в дневниках французского миссионера Maurice Morceau, датированных 1821 годом:

<blockquote><i>The first written reference to the game of Elephant Hunt was found in the diaries of father Maurice Morceau, a French missionary who disappeared without a trace in 1821 while on a mission to the Ituri forest. His personal effects, including the diaries, were later found in a cannibal village by an anthropological expedition.</i></blockquote>
К сожалению, мы имеем дело лишь с авторской реконструкцией. Описание игры было очевидно неполным, доступа к первоисточнику нет, а контакт с другом был впоследствии потерян. В частности, вызывает сомнение использование в игре перемещения "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">ходом коня</a>" - слишком абстрактного для подобной традиционной игры:

<blockquote><i>The author did mention that the Elephant moved on the 5x5 field on which the 10x10 field for the Pygmies was 'overlaid by halving', and that the Pygmies moved 'by hopping about, like our chess-knight' but I personally doubt they actually made a Knight-move, which is sort of abstract. However, other possible alternatives (like D and/or A) seem to me to be out of the question, as the Pygmies cannot possibly win if colorbound.</i></blockquote>
Кстати, в этой цитате используется "<a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Ralph_Betza.27s_.22funny_notation.22">Ralph Betza's ''funny notation''</a>", о которой я уже писал <a href="https://habrahabr.ru/post/309096/">ранее</a>. Почему меня так заинтересовала эта игра? Попробуем разобраться.

<img align="center" src="https://habrastorage.org/files/5c1/d8a/bdc/5c1d8abdc7264b32b273f5da7c1457f2.PNG"/>
Мы видим одну из редких игр, в которых используются фигуры двух разных размеров. Слон - большая фигура, занимающая сразу четыре поля доски. Он может перемещаться на один "большой" шаг по любой ортогонали и "давит" всё, оказавшееся на четырёх целевых клетках. Ему противостоят "пигмеи", перемещающиеся ходом "Коня", а также один "шаман", двигающийся на одну или две клетки, в любую из восьми сторон. 

Разумеется, "малые" фигуры не могут просто так перемещаться на клетки занятые "слоном" (это было бы слишком просто). Слон может быть "съеден" лишь при условии, что <b>все</b> находящиеся под ним поля атакованы! Сам автор проводит параллели со средневековой европейской игрой, под названием "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%B0_%D0%B8_%D0%B3%D1%83%D1%81%D0%B8">Лиса и гуси</a>". Неплохая задумка, но, к сожалению, реализация подкачала.

<spoiler title="Немного кода">
<source lang="lisp">
(define Ele-shift (
   $1
   (verify not-friend?)
   (verify (not-friend? ul)) 
   (verify (not-friend? ur)) 
   (verify (not-friend? dl)) 
   (verify (not-friend? dr))
   (set-attribute vulnerable?
            (and (attacked? ul) (attacked? ur) (attacked? dl) (attacked? dr)))
   (capture ul) (capture ur) (capture dl) (capture dr)
   add
))

(define Shaman-shift2 (
   $1 (if empty? add $2)
   (verify (and not-friend? (or (empty? c) (vulnerable? c))))
   (if (not-empty? c) (capture c))
   add
))
</source></spoiler>
Здесь сразу две ошибки. Одна обидная, зато другая - фундаментальная! Во первых, совершенно неожиданно, шаман может атаковать одиноко-стоящего слона (при этом, вполне ожидаемо "ломая" картинку). При этом, самого слона он не ест, а просто занимает клетку под ним:

<img align="center" src="https://habrastorage.org/files/770/c20/4c7/770c204c70df4eeeb66c8e305dce0f66.PNG"/>
Корень зла здесь:

<source lang="lisp">
(if empty? add ...)
</source>
Если клетка пустая - то мы на неё встаём (и двигаемся дальше, но это в другой реальности). Фокус в том, что клетка "под слоном" <b>действительно</b> пустая. Она в другом grid-е, маленькая и "слон" не поместился бы в ней, при всём желании. Исправить это довольно легко:

<source lang="lisp">
(define my-empty?
   (and not-friend? (or (empty? c) (vulnerable? c)))
)
...
(if (my-empty?)
    (if (not-empty? c) (capture c))
    add 
$2)
...
</source>
 Дальше - больше:

<img align="center" src="https://habrastorage.org/files/18c/25a/480/18c25a4802b940baa3a2ccaf88149a33.PNG"/>
Вот таким нехитрым способом, используя шамана в качестве наживки, одинокий пигмей может одолеть целого слона! Разумеется, это немного не то, что задумывалось автором. Но почему так получилось? На самом деле, всё просто. Слон может быть взят, если все четыре клетки, на которых он стоит, находятся под боем. Теперь посмотрим код:

<source lang="lisp">
(set-attribute vulnerable?
      (and (attacked? ul) (attacked? ur) (attacked? dl) (attacked? dr)))
</source>
Всё достаточно прозрачно и это бы даже работало, если бы в игре участвовали одни только "пигмеи". Выполняя бой "ходом коня", они <b>не</b> атакуют поля квадрата 2x2, на котором находятся. Шаман - другое дело! Он "покрывает" 3 из 4 полей квадрата, на котором стоит. Остаётся "покрыть" то поле на котором расположился сам шаман и западня готова. И не важно, что шаман будет съеден - атрибут уязвимости будет <b>уже</b> установлен и будет действовать весь следующий ход!

Поняв ошибку, можно легко её исправить. Сам <a href="https://github.com/GlukKazan/ZoG/commit/c78cab2fc6c32ca8eaf1c0f270ceed935b4bbf7d">патч</a> довольно многословен, но его суть проста. Мы отказываемся от использования предиката <b>attacked?</b> в этой игре (он здесь просто не подходит) и заменяем его ручными проверками. Более гибкий подход позволяет предусмотреть особую обработку для "шамана". С внешним видом игры, к сожалению, сделать ничего нельзя. Картинка постоянно "ломается". Эта игра не очень подходит для Zillions of Games (но сама идея, безусловно, интересна).

<h4><b>Не оглядывайся!</b></h4>
В процессе работы над новыми играми, я узнаю платформу Zillions of Games лучше. В голову приходят совершенно новые решения, до которых я не мог додуматься раньше. Часто они оказываются столь хороши, что позволяют исправить другие, более старые игры. Так, в одной из <a href="http://skyruk.livejournal.com/493105.html">статей</a> Дмитрия Скирюка, описывается весьма оригинальная игра "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2524">Поединок</a>", в которой вместо шахматных фигур используются игральные кубики.

<oembed>https://www.youtube.com/watch?v=PiT2WN8ixpg</oembed>

При выполнении хода, кубик перекатывается по доске на то количество шагов, которое было изображено на его верхней грани в начале хода. Движение выполняется не по прямой, направление может изменяться произвольным образом. Это важно, поскольку грань, которой кубик окажется обращён вверх по завершении хода будет зависеть не только от начальной и конечной точки, но и от выбранного пути перемещения.

Подобная разновидность перемещения (с возможным изменением направления на каждом шаге) в настольных играх встречается довольно часто. Это и Thunderclap в "<a href="https://geektimes.ru/post/269152/">Ko Shogi</a>" и тихие ходы фигур в "<a href="https://habrahabr.ru/post/283502/">Nine-Tile Cyvasse</a>" и многое другое. Главная связанная с ним проблема - необходимость запрета возвращения на ранее пройденные поля. Если максимальная дистанция не превышает трёх шагов (как в игре "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2462">Mana</a>" Клода Лероя), достаточно запретить изменение направления движения на строго противоположное (для этого в ZRF имеется замечательный предикат <b>not-last-from?</b>).

<spoiler title="Строго говоря, он не всегда спасает">
В реализации <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/Mana.zrf">Mana</a> на ZRF этот приём работает, но может привести к аварийному завершению игры. В игре возможна (хотя и маловероятна) ситуация, в которой один или два первых частичных хода заведут фигуру в тупик, из которого нет выхода. Это происходит из за того, что каждый частичный ход считается самостоятельным, независимым от других. <a href="http://www.zillions-of-games.com">Zillions of Games</a> не может увидеть проблему, пока не "упрётся в неё носом". <a href="https://www.jocly.com/#/about">Jocly</a>, рассматривающая весь составной ход целиком, позволяет построить более корректную <a href="https://www.jocly.com/#/game/mana">реализацию</a>.
</spoiler>
Если фигура может перемещаться более чем на 3 шага, <b>not-last-from?</b> уже не спасает. Необходимо как-то помечать <b>все</b> ранее пройденные поля. В ZRF, для привязки к полям булевских значений, используются так называемые "позиционные флаги". К сожалению, они не являются частью игрового состояния и автоматически очищаются в начале каждого <b>частичного</b> хода.

<spoiler title="Выход, разумеется, есть">
<source lang="lisp">
(define clear-mark
   mark a0
   (while (on-board? next) 
      next
      (if (and enemy? (piece? Mark))
          capture
      )
   )
   back
)

(define step (
   (create Mark)
   $1 (verify (my-empty?))
   (clear-mark)
   (add-partial $2 $3)
))
</source>
</spoiler>
На посещённых полях можно размещать невидимые фигуры (уж они то безусловно являются частью состояния). Главное не забывать их вовремя удалять! Этот приём настолько универсален, что может пригодиться во множестве совершенно непохожих игр. В первую очередь, в голову приходят всевозможные игры-переходы, такие как "<a href="http://skyruk.livejournal.com/424973.html">Salta</a>" или "<a href="http://skyruk.livejournal.com/488033.html">Traverse</a>", но одними лишь играми семейства "<a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BB%D0%BC%D0%B0">Халма</a>" дело не ограничивается. Тот же самый приём позволил довести до "рабочего" состояния "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2515">Luzhanqi</a>" и давным давно написанные "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2351">Осетинские шашки</a>".

<h4><b>Вместо послесловия...</b></h4>
Продолжая разговор о шашках, хочу заметить, что "работа над ошибками" далеко не всегда сводится к чисто техническим моментам. Очень часто, в процессе работы над игрой, я узнаю что-то новое. Иногда такие "подробности" буквально переворачивают все мои представления об игре, заставляя взглянуть на неё по новому. В качестве примера, хочу рассказать об одной из интереснейших разновидностей "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашек</a>".

<oembed>https://www.youtube.com/watch?v=wAGwt0Bp8ss</oembed>
В эту игру играют в <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%85%D1%80%D0%B5%D0%B9%D0%BD">Бахрейне</a>. Все правила "Турецких шашек" выполняются. Вводится всего лишь одно новое правило, отсутствующее в оригинальной игре. Это правило очень просто формулируется и, в некоторых случаях, существенно влияет на характер игры, делая её более комбинационной. Для меня оно было крайне неожиданной и интересной находкой. Сможете ли вы определить, в чём оно заключается, по записи игры?

<spoiler title="Ответ">
Правило стало сюрпризом для меня. В той разновидности "Турецких шашек", в которую играют в Бахрейне, вводится понятие <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a>, очень похожее на шахматное. Ситуация, когда на одну из фигур осуществляется нападение, называется "Kish" (شك). Правила запрещают отвечать нападением, если предыдущим ходом противник напал на одну из ваших фигур (то есть делать "kish...kish"). При этом, устранять угрозу не обязательно. Можно выполнить любой ход, при условии, что он не угрожает противнику. 

Поскольку тактика "ответного" нападения широко используется в "Турецких шашках", подобное нововведение весьма пикантно разнообразит игру. В свою очередь, для меня было весьма интересно узнать о шашках ещё что-то новое, а также попытаться выразить это посредством <a href="https://github.com/GlukKazan/ZoG/commit/c09e518984ddf79d9ccbd4a89edc38e51c620815">ZRF</a>.
</spoiler>
</cut>

Dagaz: В дебрях нотаций

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Плюнь тому в глаза, кто скажет, что можно обнять необъятное! 
...
 Усердие всё превозмогает!
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Козьма Прутков "<a href="https://ru.wikiquote.org/wiki/%D0%9A%D0%BE%D0%B7%D1%8C%D0%BC%D0%B0_%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2">Мысли и афоризмы</a>"&nbsp;</i></b>

Люди постоянно что-то придумывают. После изобретения <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">шахмат</a>, было разработано ещё несколько тысяч похожих игр. Первоначально, по давней привычке, оставшейся ещё со времён сочинения античных мифов, создавались <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B8%D0%BC%D0%B5%D1%80%D0%B0">химеры</a>, сочетавшие в себе качества двух и более шахматных фигур, но впоследствии фантазия авторов окрепла и стала выдавать более интересные варианты. Чтобы не запутаться во всём этом зоопарке, требовалась какая-то система, возможность классификации новых фигур. И она возникла. Собственно, я знаю <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece">их две</a>. К сожалению, обе они не работают.
<cut>
Разнообразные <a href="https://en.wikipedia.org/wiki/List_of_chess_variants">варианты шахмат</a> всегда были в фокусе внимания шахматного сообщества. В <a href="http://www.mayhematics.com/v/v.htm">специализированных изданиях</a> можно найти описания новых игр, разборы партий, а также статьи по истории шахмат. Попытки систематизации правил никогда не рассматривались как что-то экстраординарное. Скорее это жизненная необходимость. В основу таких классификаций было положено разделение всех шахматных фигур на два больших класса: <b>leapers</b> и <b>riders</b>.

<b>Leaper</b>-ы - прыгающие фигуры (например, шахматный "Конь" - это <b>(1,2)-leaper</b>), перемещающиеся на указанное в скобках количество полей, не обращая внимания на встречающиеся по пути фигуры. Фигуры перемещающиеся на одно поле также можно считать <b>leaper</b>-ами (<a href="https://en.wikipedia.org/wiki/Ferz_(chess)">Ferz</a> из <a href="https://en.wikipedia.org/wiki/Shatranj">Шатранджа</a> - это <b>(1,1)-leaper</b>), но, поскольку они перемещаются на соседнее поле, то могут перепрыгнуть лишь 0 фигур (всё законно). При большом желании, к тому же классу можно отнести и шахматную "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">Пешку</a>", но обычно так не поступают. Большинство ортодоксов вообще не считает её фигурой.

<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладьи</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">слоны</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D1%80%D0%B7%D1%8C">ферзи</a> попадают в другую категорию фигур. Это <b>rider</b>-ы - фигуры, перемещающиеся по прямой через произвольное количество пустых полей (Ладья - <b>(1,0)-rider</b>). Существуют и "прыгающие" <b>rider</b>-ы, такие как <a href="https://en.wikipedia.org/wiki/Nightrider_(chess)">Nightrider</a> (полученный из шахматного коня), но и они, по пути своего следования, могут перемещаться лишь по пустым полям. Предложенная классификация считалась разумной и удобной до тех пор, пока не обнаружились фигуры, которые в неё не укладываются. Так появились <b>Hopper</b>-ы и <b>Locust</b>-ы. Проблему это не решило, поскольку существовали сотни фигур, не являющиеся ни тем ни другим.

<h3>Parlett's movement notation</h3>
Первую масштабную попытку, навести порядок в этом зверинце, предпринял, по всей видимости, <a href="https://en.wikipedia.org/wiki/David_Parlett">David Parlett</a>. В своей книге "<a href="https://books.google.de/books/about/The_Oxford_History_of_Board_Games.html?id=rH6DAAAAMAAJ&redir_esc=y">The Oxford History of Board Games</a>" он использовал нотацию собственного изобретения, для классификации различных фигур используемых в многочисленных вариантах шахматных игр.

<spoiler title="Parlett">
Дистанция:

<ul>
	<li><b>1</b> - перемещение на соседнее поле</li>
	<li><b>2</b> - через одно поле</li>
	<li><b>n</b> - на произвольное количество полей (как Ладья или Слон)</li>
</ul>
Направление:

<ul>
	<li><b>*</b> - Перемещение во всех (восьми) направлениях</li>
	<li><b>+</b> - По ортогоналям (вертикалям и горизонталям)</li>
	<li><b>></b> - Вперёд по вертикали</li>
	<li><b><</b> - Назад по вертикали</li>
	<li><b><></b> - Вперёд и назад по вертикали</li>
	<li><b>=</b> - По горизонтали (вправо или влево)</li>
	<li><b>>=</b> - По горизонтали или по вертикали вперёд</li>
	<li><b><=</b> - По горизонтали или по вертикали назад</li>
	<li><b>X</b> - По диагоналям</li>
	<li><b>X></b> - По диагоналям вперёд</li>
	<li><b>X<</b> - По диагоналям назад</li>
</ul>
Группировка:

<ul>
	<li><b>/</b> - Последовательное выполнение двух ортогональных перемещений</li>
	<li><b>&</b> - Повторение движения в том же направлении</li>
	<li><b>.</b> - Выполнение одного действия вслед за другим</li>
</ul>
Этого набора правил вполне достаточно для описания простых случаев, таких как <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%BE%D0%BB%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Король</a> (<b>1*</b>) или <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладья</a> (<b>nX</b>) в классических Шахматах. Но уже в случае шахматного <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Коня</a> начинаются сложности. Как выразить тот факт, что эта фигура может "перепрыгивать" через другие фигуры? С <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">Пешкой</a> тоже всё непросто. Это единственная фигура в Шахматах выполняющая "тихий" и "ударные" ходы по-разному. Соответственно, требуются специальные символы, позволяющие эти ситуации разделить. Возникла необходимость в расширении нотации:

Условия выполнения хода:

<ul>
	<li><b>i</b> - Первый ход фигурой (например ход Пешкой с начальной позиции через одно поле)</li>
	<li><b>c</b> - Выполнение взятия (ударный ход)</li>
	<li><b>o</b> - Ход без взятия (тихий)</li>
</ul>
Типы ходов:

<ul>
	<li><b>~</b> - Перепрыгивание через другие фигуры</li>
	<li><b>^</b> - Взятие перепрыгиваемой фигуры (как в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашках</a>)</li>
</ul>
Дополнительные типы группировки:

<ul>
	<li><b>,</b> - Разделитель вариантов ходов (например, для Пешки определяется три возможных варианта хода)</li>
	<li><b>-</b> - Определение диапазона возможного перемещения фигуры</li>
</ul></spoiler>
<ul>
	<li>Король: <b>1*</b></li>
	<li>Ферзь: <b>n*</b></li>
	<li>Слон: <b>nX</b></li>
	<li>Ладья: <b>n+</b></li>
	<li>Конь: <b>~1/2</b></li>
	<li>Пешка: <b>o1>, c1X>, oi2></b></li>
</ul>
Что можно сказать об этой нотации? Прежде всего, она не очень-то очевидна и (что гораздо хуже) вовсе не универсальна. Да, мы предусмотрели специальный символ для "прыгающих" фигур и для взятия при "перепрыгивании", как в шашках (<b>cn(^2X>), o1X></b>), но совершенно забыли про такой важный класс фигур, как <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Hoppers">Hoppers</a>. 

В результате, всевозможные "пушки" (например из <a href="https://en.wikipedia.org/wiki/Xiangqi">Xiangqi</a> и <a href="https://en.wikipedia.org/wiki/Janggi">Janggi</a>) остались "за бортом" нашего описания. Более того, даже шахматные фигуры описаны неточно. Да, для пешки описана возможность "прыжка" через пустое поле из начальной позиции (<b>oi2></b>), но где описание <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a>? Где нотация <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировок</a> выполняемых Королём? Если какая-то возможность <b>сложна</b> для описания, это не значит, что описывать её не надо!

<h3>Ralph Betza's ''funny notation''</h3>
<a href="https://en.wikipedia.org/wiki/Ralph_Betza">Ralph Betza</a> - личность, в мире шахмат, также известная. Помимо серьёзного увлечения классическими шахматами, он известен как разработчик более чем 40 весьма оригинальных вариантов этой игры, таких как "<a href="https://en.wikipedia.org/wiki/Chess_with_different_armies">Chess with different armies</a>" или "<a href="http://www.chessvariants.com/crossover.dir/wotn.html">The Way of the Knight</a>". Остро понимая необходимость системы классификации шахматных фигур, Ralph предложил свой <a href="http://www.chessvariants.com/d.betza/chessvar/pieces/notation.html">вариант нотации</a>. Предложенная им система стала, фактически, общепринятым стандартом, используемым для описания возможностей шахматных фигур.

<spoiler title="Betza">
<img align="left" src="https://habrastorage.org/files/eb7/3bc/79f/eb73bc79fd314399bf852a142832699d.PNG"/>Основу описания составляют заглавные буквы латинского алфавита. Каждая из них определяет ход фундаментального leaper-а:

<b>W</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Wazir">Wazir</a> (0,1)-leaper
<b>F</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Fers">Fers</a> (1,1)-leaper ("Ферзь" из <a href="http://skyruk.livejournal.com/292733.html">Шатранджа</a>)
<b>D</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Dabbaba">Dabbaba</a> (0,2)-leaper
<b>N</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Knight">Knight</a> (1,2)-leaper (всем известный шахматный "Конь") 
<b>A</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Alfil">Alfil</a> (2,2)-leaper
<b>H</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Threeleaper">Threeleaper</a> (0,3)-leaper
<b>C</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Camel">Camel</a> (1,3)-leaper
<b>J</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Zebra">Zebra</a> (2,3)-leaper
<b>G</b> - <a href="https://en.wikipedia.org/wiki/Fairy_chess_piece#Tripper">Tripper</a> (3,3)-leaper

Для наиболее употребительных фигур вводятся сокращения. Так шахматный "Король" (<b>K = FW</b>) сочетает в себе ходы фигур Fers и Wazir. <b>Rider</b> получается из <b>leaper</b>-а удвоением заглавной буквы. Шахматный "Слон" (<b>B = FF</b>) - это ни что иное как <b>rider</b>, полученный из фигуры Fers, также как "Ладья" (<b>R = WW</b>) построена на основе фигуры Wazir. Шахматный "Ферзь" (<b>Q = BR</b>) сочетает ходы этих двух фигур. Разумеется, этого недостаточно. Для "Пешки" (самой сложной фигуры) необходимо задавать модификаторы:

<ul>
	<li><b>f</b> - Движение вперёд</li>
	<li><b>b</b> - Движение назад</li>
	<li><b>v</b> - Короткая запись модификатора <b>fb</b></li>
	<li><b>l</b> - Движение влево</li>
	<li><b>r</b> - Движение вправо</li>
	<li><b>s</b> - Короткая запись модификатора <b>rl</b></li>
	<li><b>t</b> - Выполнение одного действия вслед за другим</li>
	<li><b>с</b> - Взятие</li>
	<li><b>m</b> - "Тихий" ход</li>
</ul>
Помимо модификаторов, в нотации Betza могут использоваться цифры. <b>W5</b>, например, определяет ограниченный <b>range</b>, позволяющий перемещаться по ортогоналям, не более чем на 5 шагов. В некоторых случаях, для группировки "атомов" могут использоваться квадратные скобки. Например, <b>t[WB]</b> (или <b>1+.nX</b>, в нотации <b>Parlett</b>-а) описывает фигуру "Aanca", перемещающуюся на одно поле ортогонально и, вслед за тем, на произвольное количество полей по диагонали.
</spoiler>
<ul>
	<li>Король: <b>K = WF</b></li>
	<li>Ферзь: <b>Q = RB</b></li>
	<li>Слон: <b>B = FF</b></li>
	<li>Ладья: <b>R = WW</b></li>
	<li>Конь: <b>N</b></li>
	<li>Пешка: <b>mfWcfF</b></li>
</ul>
Всё это прекрасно, но "Пешка" должна уметь ходить через одно поле из начальной позиции! Нужно больше модификаторов для нотации Betza!

<spoiler title="Betza (продолжение)">
<ul>
	<li><b>g</b> - <a href="https://en.wikipedia.org/wiki/Grasshopper_(chess_piece)">Grasshopper</a></li>
	<li><b>p</b> - "Пушка" (это из "<a href="https://geektimes.ru/post/278182/">Китайских шахмат</a>")</li>
	<li><b>h</b> - Забавный модификатор, о котором скажу чуть ниже</li>
	<li><b>j</b> - Обязательное "перепрыгивание" фигуры</li>
	<li><b>n</b> - Движение без "прыжков" через фигуры</li>
	<li><b>o</b> - Движение по цилиндрической доске</li>
	<li><b>z</b> - Движение фигуры "зигзагом" (ещё один забавный модификатор)</li>
</ul>
Что означает модификатор "<b>h</b>"? Чтобы понять это, требуется вспомнить одну из фигур "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Японских шахмат</a>". Конь в них "прыгающий", как и в классических шахматах, но ходит только вперёд, всего на два поля. Как выразить это, посредством нотации Betza? <b>fN</b> - хорошая попытка, но, двигаясь "вперёд", конь, вообще говоря, может попасть на 4, а не на 2 поля! Модификатор <b>h</b> призван "разрулить" эту ситуацию:

<ul>
	<li><b>ff</b> - Движение "вперёд-вперёд" (как "Конь" в Сёги)</li>
	<li><b>fs</b> - Движение "вперёд-в стороны" (с поля <b>e4</b> можно попасть на <b>c5</b> или <b>g5</b>)</li>
	<li><b>fh</b> - Движение вперёд (на все четыре стороны)</li>
</ul>
Должен сказать, что при использовании "Parlett's notation" японский конь выглядит не лучше: <b>(~1/2)> (narrow)</b>.
</spoiler>
<ul>
	<li>Пешка: <b>mfWcfFimfW2</b></li>
</ul>
Здесь не описано "<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятие на проходе</a>", но не будем слишком мелочными. Разумеется, эта нотация <b>не</b> универсальна! Вот что, по этому поводу, <a href="http://www.chessvariants.com/d.betza/chessvar/pieces/notation.html">пишет</a> сам автор:

<blockquote><i>The notation is not universal or perfect yet. Imagine a piece that moves one square diagonally, and if that square is empty it can continue by jumping two squares diagonally in the same direction, and then three squares (like a Bishop that goes faster and faster!). My notation has no way to describe such a piece.</i></blockquote>
Впрочем, такие ужасы как "Слон" с "изменяемой геометрией хода" вовсе не требуются для того, чтобы поставить нотацию Betza в тупик. Существует масса других забавных фигур, столетиями используемых в многочисленных <a href="https://en.wikipedia.org/wiki/Shogi_variant">вариантах Сёги</a>. Начать, безусловно, следует с <a href="https://en.wikipedia.org/wiki/Chu_shogi">Chu Shogi</a> и её "Льва":

<img align="center" src="https://habrastorage.org/files/8eb/4bc/ed1/8eb4bced148544a9880ae09813c83d74.PNG"/>
Эта фигура делает как бы два хода (оба на одно поле в любую сторону, как "Король"). Таким образом, "Лев" может съесть две фигуры за ход или выполнить ещё более хитрый акробатический номер - съесть фигуру находящуюся рядом с ним и, вторым ходом, вернуться на своё место. Такой ход, в различных "Shogi variants", имеет настолько фундаментальное значение, что ему присвоено имя собственное - <b>igui</b>. И это далеко не самое экзотическое применение концепции "второго хода":

<img align="center" src="https://habrastorage.org/files/a36/74a/abb/a3674aabbbea407ab8ee0d16ed2a09fc.PNG"/>
Это три фигуры из <a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a>. <b>Cavalry</b> (騎総 kisō) очень похожа на фигуру "Льва", но использует ход шахматного "Коня", при этом двигаясь в "ту же" сторону. <b>Winged horse</b> (天馬 temba) - более сильная фигура, продолжающая ход в любом доступном для "Коня" направлении. <b>Twelve-mile fog</b> (五里霧) выглядит проще, двигаясь дважды как Alibaba (<b>AD</b>), но после каждого хода, он может "убить" оказавшуюся с ним рядом фигуру противника ходом <b>igui</b>. Если этих примеров мало - найдутся ещё:
 
<img align="center" src="https://habrastorage.org/files/cd0/438/b9a/cd0438b9ab0748e3a44b27b0ff6d3f3c.PNG"/>
<b>Roaming assault</b> (招揺 shōyō) - "Боевая колесница", двигающаяся на пять (или меньше) полей по прямой, убивая все фигуры противника, попадающиеся на пути. <b>Thunderclap</b> (霹靂 hekireki) делает всё те же пять ортогональных ходов, но произвольно меняя направление! И не надо думать, что такое встречается только в Ko Shogi! <a href="https://en.wikipedia.org/wiki/Dai_dai_shogi">Dai dai shogi</a>, <a href="https://en.wikipedia.org/wiki/Tenjiku_shogi">Tenjiku shogi</a>, <a href="https://en.wikipedia.org/wiki/Taikyoku_shogi">Taikyoku shogi</a> - во всех этих играх используются похожие фигуры. <a href="http://www.chessvariants.com/who/HGMuller">H. G. Muller</a>, разработчик замечательной шахматной программы <a href="http://hgm.nubati.net/">WinBoard/XBoard</a>, <a href="http://www.chessvariants.com/piececlopedia.dir/betzanot.html">предложил</a> ещё один забавный модификатор, позволяющий решить эту проблему.

Модификатор "<b>a</b>" означает выполнение "второго хода", что позволяет описать ход "Льва" как <b>aK</b> (двойной ход "Королём"). Как обычно, дополнительные модификаторы позволяют описывать более сложные ходы. Вот так, например, в расширенной нотации Betza выглядит ход фигуры из "Шашек": <b>fmF(fcafmF)</b>. Можете попробовать расшифровать это сами. Именно эта нотация используется при описании фигур в "исторических" вариантах Сёги:

<ul>
	<li>Cavalry: <b>[NaffN][xN]</b></li>
	<li>Winged horse: <b>aN</b></li>
	<li>Twelve-mile fog: <b>a[DA]acxK</b></li>
	<li>Roaming assault: <b>Wa5fW</b></li>
	<li>Thunderclap: <b>a!5W</b></li>
</ul>
Думаете, нотация Betza стала универсальной? Тогда попробуйте описать, с её помощью, эту игру:

<oembed>https://www.youtube.com/watch?v=64ar37WY2Uc</oembed>
Итак...

<h3>Если у вас есть проблема и вы хотите использовать регулярные выражения...</h3>
Поймите меня правильно, я не ищу сложность ради самой сложности! Мне просто не нравится то, что существующие нотации неконструктивны. В самом деле, что мы делаем когда обнаруживаем новый тип фигуры? Мы добавляем новую букву! За примером далеко ходить не надо. Вот что пишет  H. G. Muller по поводу рокировок:

<blockquote><i>'O' is not an original Betza atom, but many extensions use it as null-move. As such, any repetition of it, like O2, would be pointless, as would be any modifier prefixes. I therefore propose to use O + number as a shorthand for (conventional) castling. (After all, castling in PGN is denoted as O-O or O-O-O.) The number would indicate how many steps the King moves. The move of the Rook (or in general, the corner piece) is implied: it ends up next to the King on its other side. Also implied is that you cannot move through or out of check, and that all squares between King and corner have to be empty. So the full description of a King would be FIDE: <b>WFisO2</b></i></blockquote>
Резервирование отдельной буквы для столь частной вещи как рокировка, мне лично, кажется очень расточительным! Следуя по этому пути, мы начнём резервировать всё новые и новые буквы для всех специфичных ходов! Например, в <a href="https://en.wikipedia.org/wiki/Jetan">Jetan</a>-е "Принцесса", один раз за игру, имеет право прыгнуть на любое свободное поле доски, не находящееся под боем. На рокировку этот ход не похож. Значит нужна новая буква? А что делать когда все буквы закончатся? И это не говоря о том, что на выходе мы имеем не вполне очевидную, не универсальную и, самое главное, избыточную нотацию:

<ul>
	<li><b>g</b> - Grasshopper</li>
	<li><b>p</b> - "Пушка" из "<a href="https://geektimes.ru/post/278182/">Китайских шахмат</a>"</li>
	<li><b>j</b> - Обязательное "перепрыгивание" фигуры</li>
	<li>...</li>
</ul>
<a href="https://en.wikipedia.org/wiki/Grasshopper_(chess_piece)">Grasshopper</a> - это почти то же самое, что и <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D0%BD%D0%B3%D0%B8#.D0.9F.D1.83.D1.88.D0.BA.D0.B0">Пушка</a> (во всяком случае, корейская)! Зачем тратить на него ещё одну букву? И его поведение непосредственно связано с "перепрыгиванием" через фигуры (<b>j</b>)! С нотацией Parlett-а та же история: '<b>~</b>' - перепрыгивание через фигуры, '<b>^</b>' - взятие перепрыгиваемой фигуры, а про <b>hopper</b>-ов мы вообще забыли! Вернёмся к <a href="http://skyruk.livejournal.com/250752.html">Фанороне</a>. Вся проблема заключается в её специфическом способе взятия:

<img align="center" src="https://habrastorage.org/files/caa/43f/f3d/caa43ff3dfd94f12be08c52f3e2add37.jpg"/>
Это не шахматное и не шашечное взятие. С учётом ограниченного размера доски, такой ход можно описать, используя модификатор '<b>a</b>' для нотации Betza, но описание будет <b>очень</b> громоздким! Придётся описывать перемещение фигуры за целевое поле (со взятием по дороге вражеских фигур), а затем возврат, для цепочки каждой длины и для всех восьми направлений! И это не говоря о том, что далеко не на всех полях Фанороны все эти восемь направлений доступны. А ведь Фанорона - не какое-то новомодное изобретение! На Мадагаскаре в эту игру играют с 1600-го года.

<source>
(*)[p]|((\1[ex])*;~1(~1[ex])*)
</source>
Выглядит как полная абракадабра и чем-то напоминает <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">регулярные выражения</a>. В общем-то, это не случайно. Регулярные выражения были придуманы для описания <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82">конечных автоматов</a>, а что такое игровая доска, с перемещающейся по ней фигурой, как не конечный автомат? Рассмотрим составные части более подробно:

<spoiler title="Dagaz">
Фактически, всё выражение представляет собой перечисление действий, выполняемых последовательно или альтернативно. Последовательные действия разделяются запятой ('<b>,</b>'), а альтернативы - символом точки с запятой ('<b>;</b>'). Действия могут группироваться скобками. Поскольку действия изменяют состояние доски и фигур, важно, что запятая определяет <b>порядок</b> выполнения действий. Успешно выполнив все действия, перечисленные через запятую (в большинстве случаев её можно опускать), в указанном порядке, мы генерируем возможный ход.

С альтернативой дело обстоит немного сложнее. Две (или более) альтернативы начинают с <b>одинакового</b> начального состояния и работают <b>независимо</b> друг от друга. Мы достигаем цели если удаётся выполнить любую из альтернатив. Для простоты, можно считать, что запятая связывает действия как '<b>и</b>', а точка с запятой - как '<b>или</b>'. В принципе, этих двух действий уже достаточно, но, чтобы сократить описание, нам потребуются квантификаторы:

<ul>
	<li><b>{n,m}</b> - Повторение действия от <b>n</b> до <b>m</b> раз (n < m)</li>
	<li><b>{n}</b> - Повторение действия <b>n</b> раз ровно</li>
	<li><b>{n,}</b> - Не менее <b>n</b> раз</li>
	<li><b>{,m}</b> - Не более <b>m</b> раз</li>
</ul>
Всё как в регулярных выражениях. Разумеется, определяем и привычные сокращения:

<ul>
	<li><b>?</b> - <b>{0,1}</b></li>
	<li><b>*</b> - <b>{0,}</b></li>
	<li><b>+</b> - <b>{1,}</b></li>
</ul>
Теперь поговорим о действиях. Очевидным действием является перемещение по одному из направлений доски. Традиционно, используются обозначения сторон света: '<b>N</b>', '<b>S</b>', '<b>W</b>', '<b>E</b>' - для ортогональных и '<b>NW</b>', '<b>NE</b>', '<b>SW</b>', '<b>SE</b>' - для диагональных направлений, но, по причинам, о которых я скажу чуть ниже, я бы не хотел использовать двубуквенные обозначения. Вместо них я решил использовать '<b>M</b>', '<b>O</b>', '<b>R</b>' и '<b>T</b>', аналогично тому как это делается в проекте "<a href="http://www.di.fc.ul.pt/~jpn/ludae/system.htm#Link">LUDÆ</a>". Таким образом:

<ul>
	<li><b>N</b> - Сервер</li>
	<li><b>S</b> - Юг</li>
	<li><b>W</b> - Запад</li>
	<li><b>E</b> - Восток</li>
	<li><b>M</b> - Северо-запад</li>
	<li><b>O</b> - Северо-восток</li>
	<li><b>R</b> - Юго-запад</li>
	<li><b>T</b> - Юго-восток</li>
	<li><b>U</b> - Вверх (об этом расскажу ниже)</li>
	<li><b>D</b> - Вниз</li>
	<li><b>+</b> - По ортогоналям (аналогично Parlett и LUDÆ)</li>
	<li><b>X</b> - По диагоналям</li>
	<li><b>*</b> - По всем (стандартным) направлениям</li>
</ul>
Обозначения обобщённых направлений конфликтуют с квантификаторами, но эту коллизию несложно разрешить. Действие перемещения всегда может быть взято в скобки, а квантификатор никогда не может следовать сразу за открывающейся скобкой. Следует заметить, что определения направлений тесно связаны с описанием доски. Выглядит это примерно вот так:

<spoiler title="Доска Фанороны">
<source>
- fanorona-9x5
  grid: a-i x 5-1
    N  = (0, -1)
    E  = (1,  0)
    S  = (0,  1)
    W  = (-1, 0)
    O = a3>b4>c5,a1>b2>c3>d4>e5,c1>d2>e3>f4>g5,e1>f2>g3>h4>i5,g1>h2>i3
    T = a3>b2>c1,a5>b4>c3>d2>e1,c5>d4>e3>f2>g1,e5>f4>g3>h2>i1,g5>h4>i3
    R = c5>b4>a3,e5>d4>c3>b2>a1,g5>f4>e3>d2>c1,i5>h4>g3>f2>e1,i3>h2>g1
    M = c1>b2>a3,e1>d2>c3>b4>a5,g1>f2>e3>d4>c5,i1>h2>g3>f4>e5,i3>h4>g5</source></spoiler>
Если для фигуры задано движение "в любую сторону" ('<b>*</b>'), а позиция, на которой она находится, определяет лишь ортогональные направления - фигура сможет перемещаться только ортогонально. Почему я не хочу использовать двубуквенные обозначения? Всё просто - если я перечисляю несколько альтернативных направлений, то должен разделать их символом точки с запятой (например, движение не превращённой фигуры в "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашках</a>" - <b>W;N;E</b>), но, поскольку такая запись будет встречаться часто, я хотел бы опускать точки с запятой, для большей лаконичности (писать просто - <b>WNE</b>). Мне не хотелось бы, чтобы в этих случаях возникали конфликты с двубуквенными обозначениями направлений.

Другие действия:

<ul>
	<li><b>\1</b>,...<b>\9</b> - Перемещение в направлении, ранее захваченном в переменную</li>
	<li><b>~1</b>,...<b>~9</b> - Перемещение в направлении противоположном захваченному</li>
	<li><b>|</b> - Постановка фигуры на доску (все последующие перемещения выполняем <b>без</b> фигуры)</li>
	<li><b>[...]</b> - Специальные действия, проверки и прочее</li>
</ul>
О переменных стоит рассказать подробнее. Велико искушение описать ход "Ладьи" следующим образом: <b>NEWS+</b> (или даже просто: <b>++</b>), но это будет очевидной ошибкой. Фактически, этим описанием мы говорим, что "Ладья" двигается по ортогонали, один или более шагов, но нигде не упоминаем о том, что движение должно происходить в одном и том же направлении! Это очень похоже на ход ранее упоминавшейся фигуры <b>Thunderclap</b>, но без какого либо ограничения дальности хода.

Выбор направления должен производиться один раз за ход, а это означает, что выбранное направление необходимо зафиксировать в переменной: <b>(+)\1*</b>. Это описание лучше, но и оно не совсем верно. Ладья может двигаться по прямой, до первой вражеской фигуры, но лишь по пустым полям. Чтобы "Ладья" не проходила сквозь другие фигуры, необходимо уточнить описание: <b>(+)([p]\1)*</b>. Буква в квадратных скобках здесь - специальная проверка того, что поле, на котором мы находимся пусто (если это не так, генерация хода прерывается). Это одно из стандартных действий, определяемых спецификацией:

<ul>
	<li><b>[p]</b> - Поле пусто?</li>
	<li><b>[P]</b> - Поле не пусто?</li>
	<li><b>[e]</b> - Вражеская фигура?</li>
	<li><b>[E]</b> - Не вражеская фигура?</li>
	<li><b>[f]</b> - Дружественная фигура?</li>
	<li><b>[F]</b> - Не дружественная фигура?</li>
	<li><b>[a]</b> - Поле атаковано?</li>
	<li><b>[A]</b> - Поле не атаковано?</li>
	<li><b>[s]</b> - Поле защищено?</li>
	<li><b>[S]</b> - Поле не защищено?</li>
	<li><b>[o]</b> - Ход этого типа выполняется в первый раз за игру?</li>
	<li><b>[m]</b> - Фигура перемещалась?</li>
	<li><b>[M]</b> - Фигура не перемещалась?</li>
	<li><b>[r]</b> - Поле посещалось ранее, в пределах составного хода?</li>
	<li><b>[R]</b> - Поле не посещалось ранее, в пределах составного хода?</li>
	<li><b>[l]</b> - Поле начала предыдущего частичного хода?</li>
	<li><b>[t]</b> - Поле завершения предыдущего частичного хода?</li>
	<li><b>[x]</b> - Взятие фигуры</li>
</ul>
Помимо перечисленного, квадратные скобки позволяют расширять спецификацию, вставляя ссылки на обработчики на каком либо универсальном языке программирования (например JavaScript). Указывая цифру в квадратных скобках, мы говорим, что в этом месте необходимо вызывать специальный обработчик, для выполнения действий, описание которых на языке спецификации невозможно либо нецелесообразно (как я уже упоминал выше, никто не может объять необъятное). Хорошим примером игры, иллюстрирующей необходимость подобных расширений, может послужить <a href="https://habrahabr.ru/post/234587/">Ритмомахия</a>.

<spoiler title="Строго говоря, я немного лукавлю">
Определяя ход "Ладьи" как <b>(+)([p]\1)*</b> я описал, как фигура двигается по полю, но здесь нет ничего о том, как выполняется взятие. Во первых, мы не должны иметь возможность завершить ход на поле, занятом фигурой своего цвета. Далее, если на целевом поле есть фигура противника, требуется её взять и уже после этого ставить свою фигуру на доску: <b>[F][ex]?|</b>. С началом хода тоже всё не так просто. Во первых, если у нас определено действие постановки фигуры на доску, должно быть определено и противоположное ему, но самое главное (и об этом очень легко забыть), мы имеем право двигать по полю лишь фигуры своего цвета (в "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A1.D1.82.D0.B0.D0.B2.D1.80.D0.BE.D0.BF.D0.BE.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5">Ставропольских шашках</a>" это не так): <b>[f]^</b>.

Это действительно важные моменты (если мы говорим об универсальной нотации), но повторять их в описании практически <b>каждой</b> фигуры было бы чрезмерно. Разумно сделать эти постфикс и префикс частью описания игровой доски. Доска такого типа (<b>default</b>) обладает двумя свойствами. Во первых (и это главное) - каждое поле доски может содержать не более одной фигуры. Если мы ставим другую фигуру на занятое поле, фигура стоявшая на нём ранее автоматически "забирается". Второе правило заключается в том, что игрок имеет право перемещать только свои фигуры (это справедливо для подавляющего большинства игр).

Такой тип построения доски не является единственно возможным. Я могу определить ещё, как минимум, два типа: <b>stack</b> (для таких игр как "<a href="https://fr.wikipedia.org/wiki/Puluc">Пулук</a>" или "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовые шашки</a>") и <b>heap</b> (для разного рода "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%BA%D0%B0%D0%BB%D0%B0">Манкал</a>"). В случае "столбовых" игр, игрок имеет право перемещать "стопки" фигур (при условии того, что наверху стопки расположена его фигура) и устанавливать "стопки" друг на друга. В манкалах, "фигуры" размещаются на поле неупорядоченной "кучей". Игрок берёт "кучу" целиком и распределяет по другим полям доски. Фигуры на <b>heap</b>-доске не обязательно однотипны! Существует, как минимум одна <a href="http://www.iggamecenter.com/info/ru/kauri.html">манкала</a>, для которой это не так.
</spoiler>
Ещё одним важным конструктивным элементом является навигация внутри квадратных скобок. Например, если нам необходимо выполнить взятие, не перемещая саму фигуру, не обязательно писать что-то вроде <b>N[x]S</b>, запись вида <b>[x>N]</b> будет также вполне корректна.
</spoiler>
После всех этих необходимых разъяснений, я могу "расшифровать" свою нотацию хода фигур в Фанороне:

<source>
(*)           # Двигаемся в произвольном направлении (захватив его в переменную)
[p]           # Если поле не пусто - прерываем генерацию хода
|             # Ставим фигуру на доску
(
  (\1[ex])*   # Двигаемся вперёд и пока есть вражеские фигуры - берём их
  ;           # или
  ~1          # Идём назад (на стартовое поле)
  (~1[ex])*   # Продолжая движение, берём по пути вражеские фигуры
)
</source>
Здесь, я сознательно опускаю моменты связанные с описанием составного хода (это отдельная и довольно <a href="https://habrahabr.ru/post/253397/">интересная тема</a>). Продолжая сравнение нотаций, приведу своё описание ходов шахматных фигур. Жирным шрифтом выделена та часть описания, за которую <b>Parlett</b> и <b>Betza</b> даже не брались (рокировки и взятия "на проходе"):

<ul>
	<li>Король: *[A]<b>;[MA](E[p]){2}[A]|E^[M]W{2};[MA](W[p]){3}[A]|W^[M]E{2}</b></li>
	<li>Ферзь: (*)([p]\1)*</li>
	<li>Слон: (X)([p]\1)*</li>
	<li>Ладья: (+)([p]\1)*</li>
	<li>Конь: N,OM;E,OT;S,TR;W,RM</li>
	<li>Пешка: N[p];OM[e];[M](N[p]){2}<b>;[(te,=Pawn,x)>E]O[l>N];[(te,=Pawn,x)>W]M[l>N]</b></li>
</ul>
Завершить это повествование я хотел бы афоризмом всё того же <a href="https://ru.wikiquote.org/wiki/%D0%9A%D0%BE%D0%B7%D1%8C%D0%BC%D0%B0_%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2">Козьмы Пруткова</a>:

<b><i>Бывает, что усердие превозмогает и рассудок</i></b>

Другие шахматы

<img align="left" src="https://habrastorage.org/files/bac/99d/e23/bac99de236a44a3fbcf2756559be1632.PNG"/><b><i>Многие вещи нам непонятны не потому, что наши понятия слабы; 
но потому, что сии вещи не входят в круг наших понятий. 
&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Козьма Прутков "<a href="http://www.anafor.ru/prutkov/prutkov01.htm">Мысли и афоризмы</a>"&nbsp;
&nbsp;
</i></b>&nbsp;
За столетия своего развития, шахматы подарили нам немало игр. <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%82%D1%83%D1%80%D0%B0%D0%BD%D0%B3%D0%B0">Чатуранга</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандж</a>, <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%80%D1%83%D0%BA">Макрук</a> и <a href="https://en.wikipedia.org/wiki/Sittuyin">Ситтуйин</a> - кажется, им нет числа! Некоторые из них, такие как бурятский <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Шатар</a>, отличаются от привычных нам <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахмат</a> совсем незначительно, иные зашли в своих изменениях так далеко, что казалось бы не имеют с ними совсем ничего общего. Сегодня, я хочу рассказать о корейской шахматной традиции.
<cut>
Начинать разговор о "Корейских шахматах" придётся, как это ни странно, с Китая. Официально считается, что современный вариант <a href="https://en.wikipedia.org/wiki/Xiangqi">Xiangqi</a> был стандартизирован императором У Ди из династии Чжоу в 569 г. нашей эры., но в игры "на доске с фигурами" в Китае играли и ранее. Наиболее древней игрой, с сохранившимся описанием правил, считается достаточно курьёзная "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2487">Сянцы семи царств</a>", описанная советником династии Сун, по имени Сыма Цянь, жившим в 1019-1086 годах нашей эры. Предположительно, эта игра была распространена в период "воюющих царств" с 476 г. до нашей эры, вплоть до объединения Китая в 221 г. до нашей эры. Известно, что существовали и более древние "шахматные" игры (такие как "<a href="http://skyruk.livejournal.com/273963.html">Большое Бо</a>" и "<a href="http://skyruk.livejournal.com/488762.html">Малое Бо</a>"), но описания их правил до наших дней не сохранилось.

<img align="center" src="https://habrastorage.org/files/9bd/b83/6d2/9bdb836d253a4e428138d9f9c9d1b05e.png"/>
Доска для Xiangqi сильно отличается от привычной нам шахматной доски. Фигуры расставляются на пересечения ортогональных линий, а не в клетки доски, как принято в других шахматных играх. Доска разделена на две части "рекой", пересекать которую способны лишь некоторые типы фигур. В глаза бросаются "дворцы", обозначенные пересекающимися диагональными линиями. Генералы (аналог шахматных королей), перемещающиеся на один шаг по вертикали или горизонтали, и их советники, способные перемещаться на один шаг по диагоналям, не могут покидать пределов дворца. Это сильно упрощает задачу <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">матования</a>, поскольку за генералом не приходится бегать по всей доске. Кроме того, хотя генералы  не могут покидать свой "дворец", они могут оказывать влияние друг на друга. Два генерала не могут находиться на одной вертикали, если между ними нет никаких фигур.

Расстановка фигур по первой линии, в целом, напоминает западную. С обоих сторон, дворец окружают "слоны", за ними следуют "кони" и "повозки". Если ходы "повозок" полностью аналогичны правилам перемещения шахматной "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">ладьи</a>", то в правилах перемещения других фигур имеются важные отличия. Правила перемещения "коня" похожи на западные, но в Xiangqi "конь" не может "перепрыгивать" другие фигуры (свои или противника). Это правило приводит к интересным тактическим ситуациям, наподобие следующей:

<img align="center" src="https://habrastorage.org/files/dda/579/e89/dda579e8949045ee9953ea9c196b8814.png"/>
Чёрный "конь" не может атаковать противника, поскольку его перемещение блокировано вражеской пешкой, но может быть съеден "красными", поскольку путь перед их "конём" свободен. "Прыгающей" фигурой в Xiangqi является "слон". Он перемещается ровно на две клетки по диагонали и не может пересекать "реку". Впрочем, даже за "рекой" этим фигурам не удалось бы встретиться со "слонами" противника. Очевидно, "слоны" являются очень слабыми фигурами, но при правильном использовании (особенно в паре), они очень полезны для защиты ключевых пунктов своей территории.

Подобно тому как японские "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>" подарили всему миру принцип "сброса" фигур, "Китайские шахматы" подарили нам "пушку". Это совершенно уникальные фигуры, в первоначальной позиции расположенные на два пункта впереди "коней". Тихий ход "пушки", в Xiangqi, аналогичен перемещению "повозки", но для "боя" вражеской фигуры, ей необходимо "перепрыгнуть" ещё одну фигуру, свою или противника. Эту фигуру называют "экран" или "лафет". Пушки очень опасны в начале игры, но ближе к завершению их ценность падает, поскольку фигур на доске становится всё меньше и найти "лафет", для выполнения боя, становится нелегко.

<img align="center" src="https://habrastorage.org/files/f76/e1f/aab/f76e1faaba78425d9bdfc816b4ff6222.png"/>
Осталось рассказать о "пешках". Их меньше чем в европейских шахматах и они не могут "поддерживать" друг друга "боем" по диагонали. Пешки перемещаются всего на один пункт. До пересечения "реки" (то есть, ровно один ход), "пешки" идут только вперёд, но за "рекой", в лагере противника, они получают право ходить вбок, влево или вправо по горизонтали. В отличии от западных шахмат, не имеет смысла рваться пешками к последней линии. В "Китайских шахматах" пешки ни во что не превращаются (тот кто родился крестьянином - крестьянином свою жизнь и закончит). Достигнув самой дальней горизонтали, пешки смогут двигаться только вбок. Впрочем, это не помешает им зайти во "дворец" противника, чтобы поддержать матовую атаку по последней линии.

Xiangqi очень популярна не только в Китае, но и за его пределами. Во Вьетнаме, эта игра широко известна под названием "Сò tuóng". В других странах, "Китайские шахматы" менее популярны, но поскольку китайцы распространены по всему миру, Xiangqi, пожалуй, можно считать наиболее массовой шахматной игрой. В очень похожую игру играют и в Корее, но корейцы не были бы корейцами, если бы не внесли в игру свои, очень существенные, изменения.

<img align="center" src="https://habrastorage.org/files/61d/a0d/19e/61da0d19e5a443e9b11d288ad2283610.png"/>
Прежде всего, можно заметить, что генерал, теперь, располагается в середине своего дворца. Кроме того, в <a href="https://en.wikipedia.org/wiki/Janggi">Janggi</a> (так называется этот вариант игры) игрокам разрешено изменять начальную расстановку коней и слонов, на своей стороне доски (что, до некоторой степени, роднит эту игру с "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B-960">Шахматами Фишера</a>" и <a href="https://en.wikipedia.org/wiki/Sittuyin">Ситтуйином</a>). В общей сложности, возможно 16 вариантов начального расположения фигур. Главным требованием является наличие коня и слона на каждом фланге.

Имеются и существенные различия в правилах перемещения фигур. Прежде всего, в Janggi, и "генерал" и его "советники" могут перемещаться по всем отмеченным линиям внутри дворца. Также, по диагональным линиям дворца, могут перемещаться "колесницы" и "пушки" (при условии, что они вошли во вражеский дворец). Разумеется, они по прежнему обязаны перемещаться по прямой, с соблюдением всех правил выполнения своего хода. По диагональным линиям дворца (но только вперёд) имеют право двигаться и пешки, зашедшие во вражеский дворец. Кстати, пешки, в Janggi, с самого начала, ещё на своей территории, уже имеют возможность двигаться на один пункт влево или вправо, также как пешки Xiangqi, зашедшие в лагерь противника. Слон в Janggi ходит совсем по-новому:

<img align="center" src="https://habrastorage.org/files/0c0/333/738/0c0333738897431382cee5bfb02a3380.PNG"/>
Также как и "конь", это не "прыгающая" фигура. Обе клетки, через которые проходит "слон", должны быть пустыми. Слоны в Janggi могут "гулять" по территории всей доски (можно заметить, что "река", на корейской доске, отсутствует). Наибольшие изменения претерпела "пушка". В Janggi, для <b>любого</b> её хода (в том числе и тихого) требуется наличие "лафета" (своей или вражеской фигуры). При этом, другая пушка "лафетом" служить не может. Также "пушка" не может быть атакована другой "пушкой" (что позволяет эффективно защищаться от атак пушками).

К Janggi, в Корее, относятся чуть менее серьёзно, чем к Xiangqi в Китае. Janggi считаются игрой простого народа. Интеллектуальная элита этой страны предпочитает Бадук (корейское название игры <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>). Тем не менее, игра всенародно любима и имеет богатую историю. Одним из проявлений такой любви можно считать изобретение различных вариантов игры по изменённым правилам. Более всего, в этом отношении, отличились японцы. Существует просто невероятное количество вариантов игры <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Shogi</a>, придуманных ими (<a href="https://en.wikipedia.org/wiki/Shogi_variant">здесь</a> далеко не все), но и корейцы тоже <a href="https://en.wikipedia.org/wiki/Janggi_variants">кое-что</a> придумали.

<img align="center" src="https://habrastorage.org/files/cda/710/549/cda7105492454c9191765b385d9540ff.png"/>
Вот Gwangsanghui меня как-то сразу заинтересовала. Ещё бы! Игра 18-го века, в которой имеется по целых <b>три</b> "дворца" на каждой стороне! Оставалось разобраться с тем, как ходят фигуры. С этим сразу же возникли трудности. В принципе, искомая информация существовала, но была она <a href="https://librewiki.net/wiki/%EA%B4%91%EC%83%81%ED%9D%AC">на корейском языке</a>. Google Translate помог мало. К счастью, в Иннополисе нашлась добрая кореянка (по имени Jooyoung Lee), которая перевела мне этот чудесный текст на английский язык.

<spoiler title="Текст перевода">
<blockquote>
There are 15 vertical lines and 14 horizontal lines on the board. (15 boxes horizontally, 14 boxes vertically ) 210 boxes over all. 

It is divided into North and South, 6 horizontal lines, that is 90 boxes, on your side, are called "the entire army (三軍)”. The intersection of 5 horizontal lines on your side and 9 middle vertical lines, which are 45 dots, are called “the centre (中軍)”, and the 21 boxes excluding borders of "the centre” are called “내영 (Naeyoung)”. The 9 boxes located at the very centre of Naeyoung are called “Nine Palace (九宮)”.  In the Nine Palace, there are diagonal lines as well and you put your king in the middle. 

Behind the King, both on the left and right, you put 士 (scholar). On both side of 士, you put  象.  車 should be placed on the left and right of 象. 砲 should be placed on the other corner of the Nine Palace (where 士 didn’t take). 馬 should be placed 2 boxes before 象 (which is left and right of 砲). 

24 boxes surrounding "내영 (Naeyoung)” is called “외영(waeyoung)”.

前鋒 is placed in the very centre (that is 2 boxes above the king). 後將 is place in the middle of lower side of “외영(waeyoung)” (that is 2 boxes below the king).

In “외영(waeyoung)”, two places where they have the same horizontal line with the King, you place 奇, and the side corners in the lower side of "(waeyoung)” you should put 游, and above side corners you put 伏.

The empty box in front of 前鋒 is called 營門, on the left of 營門 space out a box and put 步, then on the right side, again space out a box and put 6 騎s. 

The intersection of left 3 vertical lines and 5 bottom horizontal lines is called 左軍(left army) and the intersection of right 3 vertical lines and the 5 bottom lines is called 右軍(right army). The centre of left army and right army is also called Nine palace, which has diagonal lines, and where 將 should be placed. 

Behind 將 of left and right army, place a 士.

In the outer room next to 士 in left and right army, put 車, and inner room next to 士, put 象. The top corners of the nine palace of left and right army, put 馬 inside and put 砲 outside.

The rules for moving the king and 將 is the same as 宮 in traditional Janggi, 車, 馬, 象, 砲, and 士 is same as Janggi as well. 騎 can only move forward 1 diagonally. 步 is same as 卒·兵 in Janggi. 

游 moves like 馬 in Chinese Janggi. 伏 can move 1 diagonally. 游 cannot take other pieces or taken by other pieces on the board. However, it can only be taken by 伏.

奇 can move horizontally or vertically one or two moves like 車. 

You win if you capture 元帥, but if you didn’t, dominant side wins. If 將 from either left or right army is captures, all the pieces in there belongs to the other party (the ownership changes). However, if you capture the piece which captured your 將 right afterwards, you can get all the lost pieces back. 

前鋒 can only be captured when exchanging.</blockquote>
</spoiler>
От себя могу сказать, что это <b>действительно</b> очень интересная игра. Помимо традиционных фигур Janggi, добавляется несколько новых фигур, но суть даже не в них, а в разнообразии тактических ситуаций, порождаемых игрой. Большинство столкновений в игре ассиметричны (ситуацию с "конями" мы уже разбирали выше). Например, в игре есть два вида пешек - традиционные и дополнительные, перемещающие и бьющие на один пункт по диагонали. Первоначально, фигуры расставлены таким образом, что друг напротив друга стоят пешки <b>разных</b> типов. В игре есть фигура (游), перемещающаяся как "конь", которая не может бить другие фигуры и может быть побита только 伏 (подобная фигура (Дипломат) имеется в упомянутой мной выше "<a href="http://www.chessvariants.com/old.dir/ochin7.html">Qiguo Xiangqi</a>",  но там она полностью неуязвима и перемещается как шахматный <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B5%D1%80%D0%B7%D1%8C">ферзь</a>).

Как я и предполагал, интереснее всего дело обстоит с дополнительными "дворцами". Захватывая вражеского генерала, в одном из таких дворцов, мы получаем управление над всеми "приписанными" к нему фигурами, но лишь при условии, что атаковавшая фигура не будет съедена следующим ходом. В какой-то степени это созвучно "правилу сброса" японских Shogi, согласно которому, взятые фигуры не убираются с доски навсегда, а попадают в "резерв" игрока и могут быть использованы им впоследствии. Я думаю, что как и "правило сброса", это правило является метафорой ведения боевых действий, с точки зрения жителей древней Кореи. Захватывая замок, мы получаем "в нагрузку" всю находящуюся в нём челядь, но если атака отбита, "перебежчики" возвращаются под управление своего законного хозяина:

<video>https://www.youtube.com/watch?v=kRrC84x9v_s</video>

Для меня осталась не до конца ясной фраза, относящаяся к фигурам 前 и 後. В правилах сказано "can only be captured when exchanging", при этом, нигде не указывается, как ходят эти фигуры. Я думаю, они должны оставаться неподвижными, защищая исключительно важную, в стратегическом плане, центральную вертикаль. Это не абсолютная защита, поскольку фигуры могут быть взяты, но лишь путём "размена" (то есть с потерей атаковавшей фигуры). Кроме того, цель за ними может быть атакована "пушкой" (砲). Кстати, может показаться, что центральные "пушки" обоих сторон "простреливают" боковые линии вражеского "дворца". Разумеется, это не так! В "Корейских шахматах", одна "пушка" не может использовать другую в качестве "лафета". Кроме того, нельзя начинать игру ходом "пушки".

<video>https://www.youtube.com/watch?v=41e4UDPeyzM</video>

Оставшееся было делом техники. Игра была разработана с использованием "<a href="http://www.zillions-of-games.com/">Zillions of Games</a>" и выложена на <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/Gwangsanghui.zrf">GitHub</a>. Желающие могут ознакомиться. Иллюстрация для <abbr title="Картинка для привлечения внимания">КДПВ</abbr> была взята из <a href="http://skyruk.livejournal.com/426804.html">статьи</a> Дмитрия Скирюка, посвященной арту, связанному с фигурами Xiangqi.

<h3>Update (2021):</h3>
Благодаря углублённой работе с <a href="https://m.blog.naver.com/dndudwp99/222055921690">первоисточниками</a>, выполненной Александром Солнцевым, правила удалось актуализировать. Прежде всего, правила в первоисточнике объяснялись с точки зрения северной армии, а не южной, как мы европейцы привыкли. Все фигуры Janggi перемещаются в соответствии с привычными правилами, за исключением того, что не могут ходить по диагональным "коридорам" во вражеских дворцах. Также, нет правила оппозиции главнокомандующих и генералов. Вообще, в игре нет шаха и мата - для победы, главнокомандующего противника надо просто съесть.

<a href="https://glukkazan.github.io/xiangqi/gwangsanghui-kanji.htm">
<img align="center" src="https://habrastorage.org/webt/ql/ao/vu/qlaovup1j_evwjzkdzd3dwpg3y0.png" /></a>

В игре есть несколько непривычных фигур: Кавалерист (骑) ходит на один шаг диагонально вперёд или вбок. Партизаны (游) - ходят без перепрыгивания, на 2 шага по диагонали (как слон в XiangQi). Засады (伏) бьют на 2 шага ортогонально, затем 1 по диагонали, но не могут выполнять "тихий" ход. Диверсанты (奇) перемещаются как колесницы, но не выходя за пределы 3 рядов, на которых размещены дворцы. Авангард (前) перемещается также, но только за пределами своего лагеря и не может бить фигуры "до первой крови". Арьергард (後) также перемещается как колесница, но только в пределах своего лагеря. Наиболее интересный момент - убийство восточного или западного генералов. Если убийца не будет уничтожен следующим ходом, вся "челядь" (фигуры того же цвета в пределах окрестности дворца 3x5) также будет убита.
</cut>

Шахматы льда и пламени

<img align="left" src="https://habrastorage.org/files/953/753/b07/953753b073234fe7a0396fb3a50bee3d.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Игра эта зовется кайвассой. Ее завезли в Дощатый город на волантинской торговой галере, а сироты разнесли ее вверх и вниз по Зеленой Крови. При дорнийском дворе все помешались на ней...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Десять фигур, каждая из которых ходит по-разному, а доска меняется с каждой игрой, смотря как игроки перемешают свои квадратики.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Джордж Мартин "Пир стервятников"&nbsp;
</i></b>
<b>Cyvasse</b> - ещё одна игра родившаяся в художественном произведении. И как это обычно и бывает, дело вновь не обошлось без участия армии фанатов. Хотя автор и уделяет игре большое внимание (в "Танце с драконами", Тирион Ланистер только и делает, что в неё играет), детальное описание правил, всё же - не дело автора художественного произведения. Впрочем, за фанатами "не заржавело". Разнообразных реализаций "Кайвассы" десятки. <a href="https://play.google.com/store/apps/details?id=appinventor.ai_jared_beal.ECyvasse">Квадратные</a> и <a href="https://play.google.com/store/apps/details?id=com.kapistijn.cyvasse">гексоганальные</a> - найдутся на любой вкус! Я хочу рассказать о <a href="http://zanefisher.github.io/nine-tile-cyvasse/">той</a>, что понравилась мне больше всего.
<cut>
Большинство версий "Кайвассы" (за все не скажу, мог что-то и пропустить) - это всё те же, привычные нам с детства, <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">шахматы</a>, только с катапультами и драконами. Да, фигуры ходят непривычно, а по доске, щедрой рукой, можно разбросать горы и водоёмы, но принципы самой игры не меняются - шахматное взятие и король, которого необходимо съесть. <a href="http://zanefisher.com/">Zane Fisher</a> подошёл к вопросу более творчески. На мой взгляд, его версия игры гораздо более глубока, в тактическом плане. За счёт чего? Вот давайте вместе и посмотрим.

<img align="center" src="https://habrastorage.org/files/123/565/c5e/123565c5ead343f6ad50ec00bede0197.PNG"/>
Б<b>о</b>льшая "естественность" и продуманность - вот что в первую очередь бросилось мне в глаза. Посмотрите, как "конница" обходит "горы". Каждая фигура, в этой игре, может перемещаться не более чем на заданное число шагов и, выполняя "тихий ход", она может "поворачивать" как угодно, главное - не возвращаться на ранее пройденные клетки и не заступать на территорию занятую противником или "горами". Через клетки занятые своими фигурами проходить <b>можно</b> (исключением является "Слон", который не может проходить "сквозь" другие фигуры), нельзя лишь завершать на них ход.

<spoiler title="Это был вызов!">
Так уж получилось, что в чисто техническом плане, реализовать подобные блуждания на <a href="https://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> непросто. Ход фигуры состоит из нескольких шагов в <b>произвольном</b> направлении, как правило, с дополнительным условием не посещения уже пройденных полей. Я делал <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2462">игру</a> с подобной механикой, но в тот раз использовал механизм частичных ходов (да и то не слишком удачно, в редких случаях фигура могла загнать себя в тупик). Когда я совсем уж было думал, что без <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> здесь не обойтись, решение само, вдруг, неожиданно пришло мне в голову:

<spoiler title="Много кода">
<source lang="lisp">
(define check-target
  (if (position-flag? is-target?)
      (set-flag is-succeed? true)
  )
)

(define check-target-dir
  (if (and (on-board? $1)(position-flag? is-target? $1))
      (set-flag is-succeed? true)
  )
)

(define check-dir-3
  (if (on-board? $1)
     $1 
     (if (not (or enemy? (piece? Mount)))
         (check-target)
         (if (not-speared?)
             (check-target-dir $2)
             (check-target-dir $3)
             (check-target-dir $4)
         )
     )
     (opposite $1)
  )
)

(define check-branch-3
  mark
  (if (on-board? $1)
     $1 
     (if (not (or enemy? (piece? Mount)))
         (check-target)
         (if (not-speared?)
             (check-dir-3 $1 $1 $2 $3)
             (check-dir-3 $2 $1 $2 $4)
             (check-dir-3 $3 $1 $2 $5)
         )
     )
  )
  back
)

(define move-3 (
  (check-pass)
  (set-position-flag is-target? true)
  START
  (while (on-board? next)
     next
     (set-flag is-succeed? false)
     (if (or empty? (piece? Point))
         (check-branch-3 w sw nw se ne)
         (check-branch-3 nw w ne se e)
         (check-branch-3 ne nw e w se)
         (check-branch-3 e ne se nw sw)
         (check-branch-3 se e sw ne w)
         (check-branch-3 sw se w e nw)
         (if (flag? is-succeed?) add)
     )
  )
))

(piece
   (name LightHorse)
   ...
   (moves
      (move-3)
      ...
   )
)
</source>
</spoiler>
На самом деле, всё просто. Вместо того чтобы пытаться проложить путь от текущего поля (при таком подходе было бы сложно бороться с дубликатами генерируемых ходов), можно его пометить позиционным флагом, а затем, перебрав <b>все</b> поля доски (благо - их немного, доска небольшая), попытаться добраться до отмеченного поля, за заданное число шагов. Звучит не особо впечатляюще, но для меня это было поворотным пунктом. С этого момента я поверил, что игру можно реализовать на чистом ZRF.
</spoiler>
Взятие осуществляется только "по прямой" и, в большинстве случаев, по "шахматному принципу" - фигура выполняющая взятие становится на место взятой фигуры (здесь снова есть исключение - "Катапульта", о которой я расскажу ниже). При этом, брать можно далеко не любую фигуру! Zane вводит понятие "зацепления"  (<b>Engagement</b>). Также как взятие, "зацепление" распространяется по прямой, на количество шагов индивидуальное для каждого типа фигуры. 

С понятием "зацепления" тесно связано "вооружение" фигуры. Все фигуры делятся на легко-, тяжело- и не вооружённые. "Ополченец" (<b>Rabble</b>) - лёгкая фигура, не может просто так атаковать тяжёлую, например "Слона" (<b>Elephant</b>). Для того чтобы атаковать, ему требуется "зацепление" цели ещё одной лёгкой (или тяжёлой) фигурой. С другой стороны, "Слон" легко может атаковать "Ополченца" (за исключением, разве что случая, когда он находится в воде). Также он может в одиночку "зацепить" любую тяжёлую фигуру противника, даже "Дракона" (<b>Dragon</b>). Не вооружённые (<b>unarmored</b>) фигуры ("Арбалетчик" и "Катапульта") могут быть взяты без "зацепления".

<spoiler title="Это тоже было непросто">
В основном, из за количества писанины. У разных фигур - разная дистанция зацепления, да и вообще, они разные. "Дракон" - может летать через горы, "Копейщики" цепляют всего два поля перед собой, надо учесть действие "воды", а проверка на присутствие дружеских/вражеских "Крепостей" поблизости - это вообще мрак. В общем всё сложно (и не исключено, что в коде есть ошибки), но вроде всё работает как задумано:

<spoiler title="Ещё код">
<source lang="lisp">
(define set-engaged
   (if (flag? is-light-engaged?)
       (set-flag is-heavy-engaged? true)
    else
       (set-flag is-light-engaged? true)
   )
)

(define check-escape
   (if (or enemy? (piece? Mount))
       (set-flag is-escaped? true)
   )
)

(define check-other
   mark
   (set-flag is-escaped? false)
   (if (on-board? $1)
       $1 (check-escape)
       (if (and friend? (not-in-zone? water) 
            (or (piece? Rabble) (piece? LightHorse) (piece? HeavyHorse) (piece? Elephant) (piece? Crossbow) 
                 (piece? Dragon) (piece? Tower) (piece? King)))
           (set-engaged)
           (if (or (piece? HeavyHorse) (piece? Elephant) (piece? Dragon) (piece? Tower))
               (set-flag is-heavy-engaged? true)
           )
           (if (piece? Tower)
               (set-flag is-enemy-tower? true)
           )
       )
   )
   (if (and (on-board? $1) (not-flag? is-escaped?))
       $1 (check-escape)
       (if (and friend? (not-in-zone? water) (or (piece? Elephant) (piece? Crossbow) (piece? Trebuchet) (piece? Dragon)))
           (set-engaged)
           (if (or (piece? Elephant) (piece? Dragon))
               (set-flag is-heavy-engaged? true)
           )
       )
   )
   (if (and (on-board? $1) (not-flag? is-escaped?))
       $1 (check-escape)
       (if (and friend? (not-in-zone? water) (or (piece? Crossbow) (piece? Trebuchet)))
           (set-engaged)
       )
   )
   (if (and (on-board? $1) (not-flag? is-escaped?))
       $1 (check-escape)
       (if (and friend? (not-in-zone? water) (piece? Trebuchet))
           (set-engaged)
       )
   )
   back
)

(define check-spears
   (if (on-board? $1)
       (if (and (friend? $1) (not-in-zone? water $1) (piece? Spears $1))
           (set-engaged)
       )
   )
)

(define check-friend-tower
   (if (on-board? $1)
       (if (and (enemy? $1) (piece? Tower $1))
           (set-flag is-light-engaged? false)
       )
   )
)

(define check-engaged
   (verify (not-piece? Mount))
   (set-flag is-enemy-tower? false)
   (set-flag is-light-engaged? false)
   (set-flag is-heavy-engaged? true)
   (if (or (piece? Crossbow) (piece? Trebuchet))
       (set-flag is-light-engaged? true)
   )
   (if (or (piece? HeavyHorse) (piece? Elephant) (piece? Dragon) (piece? Tower))
       (set-flag is-heavy-engaged? false)
   )
   (check-spears sw) (check-spears se)
   (check-other w) (check-other e) (check-other nw) (check-other ne) (check-other sw) (check-other se)
   (if (and (not-piece? Tower) (not-piece? Crossbow) (not-piece? Trebuchet) (not-flag? is-enemy-tower?))
       (check-friend-tower w) (check-friend-tower e) 
       (check-friend-tower nw) (check-friend-tower ne) 
       (check-friend-tower sw) (check-friend-tower se)
   )
   (verify (and (flag? is-light-engaged?) (flag? is-heavy-engaged?)))
)

(define common-1 (
  $1 (verify enemy?)
  (check-engaged)
  add
))

(piece
   (name King)
   ...
   (moves
      (common-1 w) (common-1 e) (common-1 nw) (common-1 ne) (common-1 sw) (common-1 se)
      ...
   )
)
</source>
</spoiler>
Как я уже сказал, много писанины, но с этого момента, разработка игры стала, по большей части, механической работой. Был, правда, ещё момент с <b>Rabble</b>, но об этом ниже.
</spoiler>
Дистанция "зацепления" совпадает с максимальной дистанцией хода фигуры лишь в самых простых случаях (<b>Rabble</b>, <b>Spears</b> и <b>King</b>). Обычной является ситуация, при которой расстояние, на котором возможно "зацепление", меньше максимального хода фигуры (<b>Light Horse</b>, <b>Heavy Horse</b>, <b>Dragon</b>). Впрочем, есть исключение. "Слон" (<b>Elephant</b>) - тяжёлая фигура перемещающаяся лишь на одну клетку за ход, но "зацепить" вражескую фигуру он может на расстоянии двух клеток! Более того, он может её съесть, передвинувшись на две клетки, но лишь при условии, что путь не загораживают какие либо преграды (в отличии от других фигур, "Слон" не может проходить через клетки, занятые другими фигурами. Все эти особенности делают игру ещё более интересной, в тактическом плане. Посмотрите, например решение одной из задач <a href="http://zanefisher.github.io/nine-tile-cyvasse/introduction.html">учебника</a>:

<img align="center" src="https://habrastorage.org/files/e1e/6a3/74e/e1e6a374e84549ee95a92c11883baec3.PNG"/>

Расстояние "зацепления", для конницы - единичка. Чтобы взять вражескую фигуру (при отсутствии других фигур, выполняющих "зацепление"), придётся подойти вплотную, но во время боя, есть свобода выбора - остановиться на поле взятой фигуры или двигаться дальше (наподобие дамки в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашках</a>). Максимальная дистанция - три шага для <b>Light Horse</b> и два для <b>Heavy Horse</b>. Детальные параметры всех фигур можно посмотреть в <a href="http://zanefisher.github.io/nine-tile-cyvasse/cyvasserules.pdf">руководстве</a> к игре:

<ul>
	<li><b>Rabble</b> (x6) — light armor, movement allowance 1, engagement range 1</li>
	<li><b>Spears</b> (x3) — light Armor, Movement Allowance 1, Engagement Range 1</li>
	<li><b>Light Horse</b> (x3) — light Armor, Movement Allowance 3, Engagement Range 1</li>
	<li><b>Heavy Horse</b> (x2) — heavy armor, Movement Allowance 2, Engagement Range 1</li>
	<li><b>Elephant</b> (x2) — heavy armor, Movement Allowance 1, Engagement Range 2</li>
	<li><b>Crossbows</b> (x2) — unarmored, Movement Allowance 2, Engagement Range 3</li>
	<li><b>Trebuchet</b> (x1) — unarmored, Movement Allowance 1, Engagement Range 4 (min. 2)</li>
	<li><b>Dragon</b> (x1) — heavy armor, Movement Allowance 4, Engagement Range 2</li>
	<li><b>Tower</b> (x2) — heavy armor, Movement Allowance 0, Engagement Range 1</li>
	<li><b>King</b> (x1) — light armor, Movement Allowance 1, Engagement Range 1</li>
</ul>
Там же можно найти информацию об особенностях каждой из фигур. Некоторые из этих примечаний вводят в смущение. Например, для "Арбалетчика" (<b>Crossbows</b>) написано следующее: "<i><b>Crossbows cannot capture</b></i>". Для чего может понадобиться фигура неспособная брать фигуры противника? Вновь, всё дело в "зацеплении"! <b>Crossbows</b> - не защищённая фигура неспособная к ближнему бою, но она может "захватывать" фигуры противника на большом расстоянии. Следующая задача из учебника это иллюстрирует. Если "Арбалетчик" сдвинется так, чтобы "захватить" все цели, "Всадник" сможет побить их за три хода:

<img align="center" src="https://habrastorage.org/files/529/87a/6cf/52987a6cfcf342258708b57099703d20.PNG"/>
<spoiler title="К сожалению, в задачке есть досадный недочёт">
<img align="center" src="https://habrastorage.org/files/827/4a6/36a/8274a636ad174d8386ea982e6e2ed5e1.PNG"/>
Дистанции "тихого хода" <b>Light Horse</b> вполне достаточно, чтобы переместиться на позицию, с которой он может убить все три вражеских фигуры без посторонней помощи. В своей реализации, я <a href="https://github.com/GlukKazan/ZoG/commit/850a9097f72c9e3d1d11d184ce9434aa4630fad9">исправил</a> это, переместив фигуру "Всадника" ниже.
</spoiler>
Другая слабо защищённая (<b>unarmored</b>) фигура - "Катапульта" (<b>Trebuchet</b>). Здесь со взятием всё в порядке! Фигура бьёт издалека, на дистанцию от двух до четырёх шагов (противника расположившегося вплотную "Катапульта" побить не может). Уникальность этой фигуры в том, что после выполнения взятия "Катапульта" продолжает оставаться в тылу. Чтобы взять фигуру противника, она перемещается на один шаг <b>в противоположном</b> направлении (конечно, если там есть свободное место)! Это важное стратегическое оружие, "Катапульту" необходимо всячески оберегать!

<spoiler title="Не было бы счастья, да несчастье помогло">
В процессе подготовки игры к публикации, мне понадобились примеры начальной расстановки фигур. Дело это не простое и я постарался подойти к нему со всем тщанием. На первый взгляд, для фигур почти не остаётся места. Что-то занимают горы, что-то вода (в неё тоже не хочется соваться). К счастью, всё не так плохо как кажется, поскольку большая часть фигур может свободно проходить через территорию, занятую другими дружественными фигурами. Конницу вполне можно ставить во второй ряд, за "Копейщиками" и "Ополченцами". Дракона можно ставить вообще где угодно - он перелетает через горы. После нескольких минут мучений, у меня получилось что-то вроде этого:

<img align="center" src="https://habrastorage.org/files/2d6/fed/ef7/2d6fedef75e243ca8531ac04378d63eb.PNG"/>

Я отослал дистрибутив на публикацию и только потом заметил, что "Катапульты" расположены крайне неудачно. Да, я оставил за ними место, но в оригинальной версии игры, через горы они стрелять не умеют! Возможно этот скриншот так и остался бы забавным казусом, но мне пришла в голову интересная идея: "почему бы катапультам и не стрелять через горы, ведь они стреляют навесом"? Так родилось следующее <a href="https://github.com/GlukKazan/ZoG/commit/aabc21dc6eeb58ab6b407f053e256a532b89377a">дополнение</a>: если на пути выстрела вдруг оказалась гора, "Катапульта" не может выполнить "зацепление", но коль скоро нашёлся "наводчик", уже зацепивший цель, пульнуть в неё камушек поверх гор "Катапульта" вполне способна! По моему, это неплохая идея, добавляющая в игру ещё больше тактических возможностей.
</spoiler>
"Крепость" (<b>Tower</b>) - ещё одна очень странная фигура. Она не двигается! Совсем. В общем-то это даже логично. Где (кроме <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D0%B4%D1%8F%D1%87%D0%B8%D0%B9_%D0%B7%D0%B0%D0%BC%D0%BE%D0%BA_%28%D0%B0%D0%BD%D0%B8%D0%BC%D0%B5%29">японских мультиков</a>) вы видели двигающиеся крепости? Задача крепости - защита (и она с этой задачей прекрасно справляется). Фигура находящаяся вблизи дружеской крепости не может быть "зацеплена". Чтобы её убить, сначала придётся разрушить крепость, а это не просто. Кроме того, "Король" (<b>King</b>) умеет "прыгать" сквозь дружескую "Крепость", оказываясь по другую сторону от неё за один ход.

<spoiler title="Есть мнение, что крепость справляется со своей задачей слишком хорошо">
<img align="center" src="https://habrastorage.org/files/160/ce6/810/160ce6810f8f4af89a0a5a8f7441c3de.PNG"/>
Это последняя задачка из <a href="http://zanefisher.github.io/nine-tile-cyvasse/introduction.html">учебника</a>, которая, по идее, должна решаться за семь ходов. Поймите меня правильно. Короля, в этой позиции, можно съесть "Всадником" всего за три хода! При условии, что он не будет ни на что реагировать, когда "Всадник" подскачет к нему вплотную. В реальной жизни, так не бывает. Для меня очевидно, что сдвинув "Катапульту" вправо и взяв мешающего ей "Ополченца" при помощи "Слона", задачу <b>можно было бы</b> решить за отведённое число ходов. Но мешают крепости! Пока "Копейщики" рядом с ними, они не могут быть "взяты под прицел", а они закрывают "Короля"! В оригинальных правилах, говорится следующее:
<blockquote>A piece that is adjacent to one or more opposing Towers cannot engage any pieces except the adjacent Tower(s)</blockquote>Возможно, здесь имелась в виду ситуация, когда фигура может "зацепить" и "Крепость" и охраняемую ей фигуру (то есть стоит вплотную к ним обеим). Не знаю. Это хорошая тема, над которой стоит подумать. Пока же, я разрешил "Дракону" (<b>Dragon</b>) брать фигуру, находящуюся под защитой крепости, с расстояния в два шага (в радиусе действия его "зацепления", но не вплотную). На мой взгляд, это немного оживляет игру.
</spoiler>
Стоит рассказать о двух самых слабых фигурах, к которым, в равной степени, подходит выражение "мал, да удал". "Копейщик" (<b>Spears</b>) - это, в каком-то смысле, аналог шахматной <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%88%D0%BA%D0%B0">пешки</a>. Может идти только вперёд и атакует всего два поля перед собой (правда, при этом, ни во что не превращается). Чем может быть полезна такая фигура? Конечно же, у неё есть секрет. Контролируемые ею два поля (всего два) ни одна из вражеских фигур не может "проскочить" за один ход. Например, это означает, что конница не может атаковать "Копейщика" с фронта, даже если тот "зацеплен" другой фигурой. Сначала она должна подойти вплотную. <b>Spears</b> - это превосходный защитный юнит, напоминающий "Телохранителя" (<b>Хиа</b>) из монгольской игры <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Хиашатар</a>.

С "Ополченцами" (<b>Rabble</b>) всё обстоит немного проще. Они могут ходить (и "бить") на один шаг, в любую сторону, как "Король". Фокус заключается в том, что игрок имеет право сделать два "тихих" хода "Ополченцами" подряд. Это атакующий юнит. Сделав два "тихих" хода, можно создать две угрозы, в разных концах доски. Одного "Ополченца", скорее всего съедят, но другим можно будет организовать прорыв. Это решение мне тоже безумно нравится.

<spoiler title="Хотя и доставило мне некоторое количество проблем, в части реализации">
Тут вот в чём дело, порядок ходов в ZRF (да и в ZoG в целом) жёстко задан. Если бы каждому из игроков <b>всегда</b> приходилось делать по два хода (как в "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%81%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Марсельских шахматах</a>"), это было бы просто. Как-то вот так:
<source lang="lisp">
(turn-order White White Black Black)
</source>Но нам-то требуется, чтобы право повторного хода предоставлялось только после "тихого" хода <b>Rabble</b> и чтобы вторым ходом был тоже "тихий" ход, но уже другого <b>Rabble</b>. И никак иначе! И, кстати, <b>право</b>, а не <b>обязанность</b>. Вот тут, мне пришлось пойти на компромиссы. Было понятно, что без механизма пропуска хода (<b>pass</b>) здесь не обойтись, но автор на этот счёт <a href="http://zanefisher.github.io/nine-tile-cyvasse/cyvasserules.pdf">выразился</a> предельно чётко: "<i><b>He must move a piece, or forfeit the game</b></i>". К счастью, в ZoG предусмотрен режим, при котором пропуск хода выполняется (автоматически), лишь при отсутствии любых разрешённых ходов (это конечно тоже не совсем правильно, поскольку, при использовании данной опции, игроку <b>не будет</b> засчитано поражение, при отсутствии возможности хода).

<spoiler title="Собственно, код">
<source lang="lisp">
(define rabble-1 (
  (set-position-flag from-pos? true)
  (verify (not-enemy? a8))
  (verify (not is-moved?))
  $1 (verify (or empty? (piece? Point)))
  (set-flag other-rabble? false)
  mark START
  (while (on-board? next)
     next
     (if (not-position-flag? from-pos?)
         (if (and friend? (piece? Rabble))
             (set-flag other-rabble? true)
         )
     )
  )
  back
  (if (flag? other-rabble?)
      (if (empty? a8)
          (create Point a8)
          (set-attribute is-moved? true)
      )
  )
  (if (not-empty? a8)
      (capture a8)
      mark START
      (while (on-board? next)
          next
          (if is-moved?
              (set-attribute is-moved? false)
          )
      )
      back
  )
  add
))

(piece
   (name Rabble)
   ...
      (attribute is-moved? false)
      (moves
         (rabble-1 nw) (rabble-1 ne) (rabble-1 sw) (rabble-1 se) (rabble-1 w) (rabble-1 e)
      )
   )
)
</source>
</spoiler>
Решение не идеально. Двигая первый <b>Rabble</b> мы помечаем его атрибутом, после чего, игрок уже <b>обязан</b> найти и передвинуть какой-то другой свой <b>Rabble</b> (его противник просто пропускает один ход). Во время второго перемещения, кстати, снимается установленный атрибут и если этого не произойдёт, игра, скорее всего, просто остановится. Поэтому, очень важно, ещё на первом ходу, найти хотя бы ещё один <b>другой</b> <b>Rabble</b> и, если такого нет, всю эту магию не включать! Как обычно, задним умом пришла мысль, что хорошо бы еще и проверять <b>возможность</b> хода этим самым другим <b>Rabble</b>. К счастью, это было совсем просто. Так родился <a href="https://github.com/GlukKazan/ZoG/commit/839401c1225c0dcab1e9e87cb73b3a7a26918d8f">патч</a>.
</spoiler>
Осталось рассказать про рельеф местности. Помимо фигур, на доске могут быть расположены "горы" и "водоёмы". С "горами" всё понятно - ни одна фигура не может располагаться "на горе" и только "Дракон" умеет перелетать через горы. Разумеется, "горы" перекрывают "обзор", препятствуя "зацеплению" вражеских фигур (про нюанс с "Катапультой" я уже говорил). С "водоёмами" всё сложнее. Фигуры в них размещать можно, но с потерей возможности "зацепления" ими вражеских фигур. Это также добавляет тактического разнообразия игре.

<spoiler title="В этом месте, у ZoG таки тоже есть свои особенности">
Если с "горами" всё было просто (ну, фигуры и фигуры), то "вода" доставила хлопот. Нет, в принципе, её я тоже мог сделать фигурами. Я как-то раз уже так <a href="https://habrahabr.ru/post/268215">делал</a> и вот к чему всё <a href="https://habrahabr.ru/post/268215/#comment_8600905">привело</a>. Это не лаг был, а такая конструктивная особенность! Впрочем, в тот раз выбора не было. Рисование зелёных квадратиков на чёрном фоне отняло бы кучу времени и раза в два раздуло и без того полуторно-мегабайтный дистрибутив, на 90% заполненный радикально-чёрными "задниками". 

В общем, в этот раз, воду я рисовал прямо на доске, параллельно отмечая её в качестве игровой зоны в описании игры. К сожалению, таким образом, можно нарисовать хоть и <b>любую</b>, но лишь жёстко фиксированную карту. Ни о каком авторском "Nine Tile" речи уже не идёт. А жаль,... но тут уж ничего не попишешь.
</spoiler>
Ну вот, в общем-то, и всё. Игра <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2491">опубликована</a>, с любезного дозволения <a href="http://zanefisher.com/">автора</a>. Интерфейс вышел похуже чем в <a href="http://zanefisher.github.io/nine-tile-cyvasse/">оригинальной версии</a> (например, не подсвечиваются "зацепления"), но зато работает AI. Во всяком случае, задачки учебника решает "на ура". 

<video>https://www.youtube.com/watch?v=0b8u7IyDD2Y</video>

Играет, в принципе, тоже вполне вменяемо (особенно, если компьютер помощнее, да время "на обдумывание" выставлено побольше.

<video>https://www.youtube.com/watch?v=nbQjQV4Y1hc</video>

Сама игра мне <b>очень</b> понравилась. В тактическом плане, она показалась мне не менее сложной чем <a href="https://geektimes.ru/post/269152/">Ko Shogi</a>, выгодно отличаясь от последней большей "лаконичностью" и продуманностью. Все фигуры работают! И для игры вполне достаточно относительно небольшой доски. А о том как ослабить "Крепости" я ещё подумаю.

<spoiler title="P.S.">
В общем, всё просто оказалось с "Крепостями" (это я себе сложностей на пустом месте навыдумывал). В <a href="http://zanefisher.github.io/nine-tile-cyvasse/cyvasserules.pdf">правилах игры</a> написано предельно ясно:
<blockquote>A piece that is adjacent to one or more opposing Towers cannot engage any pieces except the adjacent Tower(s).</blockquote>То есть, если фигура расположена вплотную к вражеской "Крепости", она может "зацеплять" только "Крепость" и никакую другую фигуру! В <a href="https://github.com/GlukKazan/ZoG/commit/09387c6f7bd49e1cfe642a4b25fc6b44941fd7ec?diff=split">результате</a>, девятая задача "<a href="http://zanefisher.github.io/nine-tile-cyvasse/introduction.html">учебника</a>" решается именно так, как это было запланировано автором, а обновлённая версия игры выложена на <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2491">Zillions of Games</a>.
</spoiler><spoiler title="P.P.S.">
Как это обычно и бывает, в процессе написания первого постскриптума к этой статье, я внезапно понял, что принял во внимание не все возможные ситуации. Картинка ниже иллюстрирует проблему:

<img align="center" src="https://habrastorage.org/files/f9d/972/280/f9d97228016d4f34b3c9bc5c8ec1e2d8.PNG"/>
В этой позиции, "Дракон" должен "зацеплять" только ближайшую "Крепость", а не обе сразу. При удалении ближайшей "Крепости", под бой должны попадать оставшаяся "Крепость" и "Король". Вот <a href="https://github.com/GlukKazan/ZoG/commit/741acf5cd1e53c9ae1072de4cdee279532b7b0b5?diff=split">здесь</a> соответствующее исправление. Следует заметить, что ситуации разобранные в постскриптумах в игре хотя и возможны, но маловероятны. Благодаря этому, все ранее сохранённые мной партии остались корректными после выполнения описанных изменений реализации игры.
</spoiler>
</cut>

Война джофуров

<img align="left" src="https://habrastorage.org/files/7bb/a63/f0a/7bba63f0a80546dcb6797033bfe57069.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Должен попросить у вас разрешения. У вас, мои кольца, мои раздельные сущности. Теперь принимайте решение. Должен ли я говорить с внешним миром от лица нас всех? Должны ли мы вновь соединиться, чтобы стать Асксом?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...Этим именем – Аскс – нас называют, когда просят рассказывать. Все согласны? В таком случае Аскс начинает рассказывать… о событиях, свидетелями которых были мы сами, и о тех, о которых нам рассказали другие. Рассказ будет вести “я”, словно наша груда сошла с ума и противостоит миру единственным сознанием.&nbsp;

Дэвид Брин "<a href="https://fantlab.ru/work10286">Риф яркости</a>"&nbsp;</i></b>

Тема игр, придуманных авторами различных художественных произведений, традиционно будоражит воображение. Игры эти очень экзотичны. Они создают необходимый антураж и, часто, служат важной составляющей сюжета. Их много! Только посмотрите на этот замечательный <a href="https://en.wikipedia.org/wiki/List_of_fictional_games">список</a>! К сожалению, поиграть в большую часть из них, нам с вами, никогда не удастся. Обычно, авторы не утруждают себя детальной проработкой правил. Игры, которым удалось перерасти состояние "художественного вымысла" и воплотиться в жизнь (такие как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=519">Jetan</a> или <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=549">Klin Zha</a>), можно пересчитать по пальцам. Практически все они являются результатом упорного труда фанатов соответствующих произведений.

Сегодня я хочу рассказать о своём опыте разработки концепции одной из таких игр. Идея игры пришла мне в голову несколько дней назад (практически сразу, как единое целое) при очередном прочтении замечательного цикла романов "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%B3%D0%B0_%D0%BE_%D0%92%D0%BE%D0%B7%D0%B2%D1%8B%D1%88%D0%B5%D0%BD%D0%B8%D0%B8">Возвышение</a>" написанного американским писателем Дэвидом Брином. Людям, не знакомым с его творчеством, я могу рекомендовать немедленно исправить эту ошибку. Также, я прошу у них прощения, на тот случай, если информация из спойлеров в моей статье каким либо образом испортит впечатление от прочтения этих произведений.
<cut>
<spoiler title="Осторожно, спойлеры!">
В цикле романов Дэвида Брина описывается вселенная, буквально наполненная самыми разными разумными существами. Древние расы <b>патронов</b> несут разум и цивилизацию младшим расам <b>клиентов</b> в бесконечном цикле "возвышения". Благодарные молодые расы обязаны отработать своё приобщение к цивилизации, порой рабским трудом, в течение весьма продолжительного времени, определяемого их патронами. Люди - "звёздные волчата", пришедшие к цивилизации самостоятельно, буквально врываются в это патриархальное сообщество, служа поводом для распространения смут и раздоров. Тот факт, что люди, на момент первого контакта уже цивилизовавшие дельфинов и шимпанзе, получают статус младших патронов, лишь усугубляет положение.

Не все были довольны таким положением дел и вскоре на Джиджо, планете временно укрытой от взора всемогущих галактических институтов, собралось уникальное сообщество из шести рас - изгнанников, совершенно непохожих друг на друга. Одними из самых удивительных были треки - уникальная раса существ, обладающих коллективным разумом. Великолепные химики и целители - треки выглядели как неуклюжие груды склизких колец, водружённых друг на друга, наподобие детской пирамидки. Треки бежали из галактики от своего самого страшного кошмара - индивидуальности. Патроны, возвысившие треки, "подарили" им новый тип колец, сковавший их под властью единого и всепобеждающего <b>эго</b>. Мирные треки превратились в <b>джофуров</b> - одну из самых сильных и неприятных рас во вселенной.
</spoiler>
В четвёртой книге цикла ("Риф яркости"), очень мельком была описана настольная игра, распространённая среди членов общины Джиджо. Как обычно, речь не шла о какой-то строгой детализации правил. Игра под названием "Башня Хайфона" описывалась всего лишь несколькими предложениями. Вот как это выглядело:
<blockquote>Игра состояла в перемещении разноцветных колец по воткнутым в песок и расположенным по углам шестиугольника палкам. Цель – надеть кольца на ваш Домашний Пост в правильном порядке, самое большое на дне, самое маленькое – вверху. Сложная игра, где цвета и рисунки колец означают различные свойства треки. Необходимо правильно сочетать их, чтобы получить идеального треки.</blockquote>Негусто, правда? При первом прочтении романа, я просто не заметил это место, но в этот раз, глаз "зацепился". Я задумался над тем, как должна выглядеть такая игра? Чем она может оказаться интересной? Как должен выглядеть такой геймплей? Аллюзия на известные всем "<a href="https://habrahabr.ru/post/200758/">Ханойские башни</a>" была очевидной. Мне показалась интересной идея "созидательной" игры, в которой фигуры служат не расходным материалом, а используются как составные элементы для создания новых, более сложных сущностей. Я задумался над этим и хочу рассказать о том, что получилось в результате.

<img align="center" src="https://habrastorage.org/files/b32/0a2/6cd/b320a26cd823498d8a4cf2a91f042bf5.gif"/>
<h4><b>Основа</b></h4>
Как я уже сказал выше, механика "<a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D0%B1%D0%B0%D1%88%D0%BD%D1%8F">Ханойских башен</a>" может послужить прекрасной основой для настольной игры. В игре будут задействованы диски 5 разных размеров. Меньшие диски разрешается перекладывать на большие, но не наоборот! Любые диски можно размещать на пустом месте. Победит игрок, первым построивший свои башни. Такая цель, кстати говоря, поможет уберечь игру от "<a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B8%D1%87%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%81%D0%BC%D0%B5%D1%80%D1%82%D1%8C">ничейной смерти</a>". Понятно, что какой-то игрок всегда успеет построить башню раньше. Чтобы свести такую игру к ничьей, надо очень серьёзно постараться.

Строить просто так абы какие "башни" - не очень интересно. Необходимо их как-то персонифицировать. Введём в игру "командные" диски (по 3 штуки на каждого игрока). Пусть это будут диски 2, 3, и 4-го размеров (то есть не основание и не вершина пирамиды). Любая пирамида, содержащая командный диск (даже состоящая из всего одного командного диска) будет "джофуром" игрока (надеюсь, вы прочитали спойлер в предыдущем разделе). Выполняя ход, игрок может переместить своего "джофура" (в соответствии с правилами, определёнными далее), либо переложить диск, находящийся в окрестности одного из его "джофуров", по правилам "Ханойских башен", достраивая, таким образом, своего "джофура". И то и другое перемещение будем называть "действием". Ход игрока будет представлять собой последовательность таких действий.

<spoiler title="Об ''однозначности'' хода в компьютерных играх">
Этот момент не очень существенен для игр, воплощённых в "дереве и камне", но крайне важен для их компьютерных реализаций. Я называю это "однозначностью" определения хода. Когда мы выполняем ход, используя некоторый разработанный UI, очень удобно определять его просто указывая исходное и целевое поле перемещения. В некоторых случаях, бывает достаточно указания одного лишь исходного или целевого поля. Как понимание правил, так и сама реализация сильно упрощаются, если определённый таким образом ход можно понимать лишь единственным образом. 

Хорошим примером неоднозначного определения хода является процесс превращения пешек в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>. Само по себе перемещение однозначно, но пешка может превратиться в одну из четырёх фигур, по желанию игрока. Это несколько усложняет реализацию UI для компьютерных шахмат. К слову сказать, подобное неоднозначное превращение является особенностью лишь привычных нам европейских Шахмат. Во всех остальных традиционных разновидностях этой игры, правила превращения определены однозначно (хотя в "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>" само превращение не всегда является обязательным).
</spoiler>
Геймплей начинает вырисовываться. В начале игры, доска (можно использовать привычную шахматную доску) будет заполнена дисками 5 размеров случайным образом. Некоторые из этих дисков могут быть уложены друг на друга (с соблюдением правила "меньший диск на большем"), а часть полей останется пустыми. Командные диски (6 штук, при игре двух противников) также будут размещены на доске случайным образом (в отличии от обычных дисков, их не следует размещать в пирамидах, чтобы игроки начинали игру в равных условиях). Два командных диска, ни при каких условиях, не могут входить в одну пирамиду. Игроки могут перемещать пирамиды, содержащие их командные диски, а также достраивать их, используя диски находящиеся на доске. Игрок, первым собравший три пятиуровневых пирамиды (обязательно содержащих командные диски), считается победителем.

<h4><b>Самая мякоть</b></h4>
Каждый ход игрока будет состоять из <b>последовательности</b> действий. Но из какого именно их количества? Вообще говоря, игры, в которых ходы игроков состоят из фиксированного набора действий - <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%81%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">не редкость</a>. Я даже, как-то раз, сам <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2368">делал</a> такую игру (придумал её конечно не я, а Tommy De Coninck в 2009 году). Мне было бы интересно привязать "размер" хода к текущему прогрессу игрока. Чем большего успеха он добился в игре - тем легче ему играть далее. Добиться этого, совсем просто.

Пусть каждый из дисков, задействованных в игре, помимо размера, имеет ещё одну характеристику - количество очков, добавляемых им в пирамиду. Пусть это будет целое число от <b>-1</b> до <b>3</b> (да-да, некоторые диски будут <b>отнимать</b> очки, а не добавлять их). Очки дисков, составляющих пирамиду, суммируются. Теперь, самое интересное! Джофуры - сверхэгоистичные существа, во всём стремящиеся к личному главенству. В своей борьбе за власть, они <b>постоянно</b> соревнуются между собой. Самая высокая пирамида игрока будет считаться "главной" (при наличии нескольких пирамид одинаковой высоты, главенствовать будет та, которая имеет большее число очков) и определит количество действий, выполняемых игроком за ход.

Это тонкий момент! Самая высокая пирамида совсем не обязательно будет содержать большее количество очков! В игре возможны ситуации, в которых игроку придётся делать выбор между тем, чтобы достраивать одну из башен, выполняя цель игры или обеспечить большую "мобильность", сохраняя главенство более низких (но и более "весомых") башен. Если принять за правило, что любой из командных дисков будет давать всего одно очко, игроки всегда будут начинать игру в равных условиях, совершая по одному действию за ход.

<spoiler title="О пользе сокрытого">
В игру можно ввести "скрытую" информацию, размещая часть дисков на доске в "перевёрнутом" виде. Игроки смогут увидеть "номинал" диска, лишь выполнив над ним какое-то действие. Например, игрок имеющий лишь три командных диска (составляющих пирамиды единичной высоты), может "открыть" диск с отрицательным числом очков, положив его на один из командных дисков. Тем самым, он немедленно признает своё поражение, поскольку получит 2-уровневую пирамиду, содержащую 0 очков. В результате, у него просто не останется возможности хода.
</spoiler>
Следует тщательно продумать политику назначения дискам их "номиналов". Как я уже сказал выше, каждый из "командных" дисков должен давать по одному очку, а некоторым из "специальных" дисков, описанных в следующем разделе, разумно присвоить нулевой или даже отрицательный номинал. Очевидно, что количество очков в пирамиде не может превысить (4 * 3 + 1 = 13) очков. Такой размер хода вполне адекватен, при наличии у игрока подобной "пирамиды-монстра". Впрочем, "специальные" диски способны увеличить размер хода ещё более. 

<h4><b>Вишенка на торте</b></h4>
Джофуры буквально собирают себя по частям и они не были бы собой, не будь у них в запасе специальных дисков, придающих всему организму  особые, совершенно уникальные свойства. Здесь всё в руках нашего воображения. Мы можем придать "специальным" дискам любые свойства, главное, чтобы они не "ломали" игровую механику. Это хорошая основа для разработки "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0">коллекционной игры</a>" и здесь есть над чем поработать. Я опишу лишь тот "стартовый" набор специальных дисков, который я вижу прямо сейчас.

<h5><b>1-ый уровень</b></h5>
Самые большие диски, лежащие в основании пирамид. В этом слое разумно сосредоточить функциональность, связанную с механизмом перемещения "джофуров". Пирамида "по умолчанию", не имеющая специального основания, может перемещаться как шахматный "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%BE%D0%BB%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Король</a>". На один шаг, в любом из восьми направлений. Разумеется, такая пирамида не может перемещаться на занятые поля, но "джофур" всегда может расчистить себе дорогу, перекладывая близлежащие диски.

<ul>
	<li><b>R</b> - основание позволяющее пирамиде перемещаться по ортогоналям, подобно шахматной "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B4%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Ладье</a>". Джофур теряет возможность выполнения диагональных ходов, но может перемещаться на дальние расстояния, двигаясь по свободным полям.</li>
	<li><b>B</b> - возможность диагональных перемещений по свободным полям (подобно шахматному "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%BD_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Слону</a>").</li>
	<li><b>J</b> - прыжок на любое свободное поле доски. Это сильная возможность и разумно ограничить ход таким образом, чтобы игрок не мог сочетать "прыжок" с выполнением каких либо других действий, в рамках того же хода.</li>
</ul>
<h5><b>2-ой уровень</b></h5>
Хорошее место для определения всевозможных "модификаторов" хода, добавляющих, например, возможность перемещения ходом шахматного "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8C_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Коня</a>" или еще более экзотическим образом. Кроме того, это один из возможных уровней размещения "командного" диска. 

<ul>
	<li><b>F</b> - режим "полёта" через препятствия. Джофур не может встать на занятое поле доски, но может перелететь через него. Этот модификатор хорошо сочетается с дисками <b>R</b> и <b>B</b>, определяющими направление перемещения. Пирамида без специализированного основания может прыгать в любую сторону, но лишь через одно занятое поле. <b>B</b> или <b>R</b> диск даёт возможность полёта над несколькими препятствиями, расположенными вплотную друг к другу. Полёт считается самостоятельным действием и возможен лишь в случае, когда пирамида подошла к препятствию вплотную, а за преградой имеется свободное поле.</li>
	<li><b>M</b> - "отскок" от препятствий. Двигаясь "зигзагом", пирамида может отскочить от нескольких преград на доске, а также от границ доски, в рамках одного действия. Очевидно, что этот модификатор будет полезен лишь при наличии в пирамиде диска <b>B</b>.</li>
	<li><b>A</b> - переход через границу доски таким образом, как если бы доска была замкнута в <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%80_(%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%BE%D1%81%D1%82%D1%8C)">тор</a>. Аналогичным образом, через границу доски, проходит и "влияние", о котором я буду говорить ниже. Находясь у края доски, пирамида может "влиять" на поля, расположенные на другом конце доски.</li>
</ul>
<h5><b>3-ий уровень</b></h5>
Сердцевина пирамиды. Ещё одно возможное место размещение "командного" диска, а также модификаторов свойств самого джофура. Здесь располагаются диски определяющие его "характер".

<ul>
	<li><b>I</b> - инициатива. Это очень важное свойство. При выполнении хода, разумно ограничить игрока одним перемещением каждого джофура за ход. Оставшиеся очки можно "добить" перемещением отдельных дисков или отказаться от выполнения этих действий, передав ход другому игроку. Модификатор <b>I</b> позволяет переместить пирамиду <b>несколько</b> раз за ход.</li>
	<li><b>E</b> - расширение области влияния до размеров квадрата 5x5. Без этого модификатора, игрок может перекладывать лишь одиночные диски, расположенные вплотную к одному из его джофуров. И исходное и целевое поле должны находиться в одной из окрестностей 3x3 пирамид игрока (возможно, в окрестностях разных пирамид, расположенных в относительной близости). Модификатор <b>E</b> расширяет эту окрестность, а также взаимодействует с диском <b>A</b> (распространение "влияния" через границу доски).</li>
</ul>
<h5><b>4-ый уровень</b></h5>
Ещё одно (последнее) место для размещения "командного" диска, а также территория размещения модификаторов "духовности" джофура (по совместительству).

<ul>
	<li><b>S</b> - "запах". Модификатор чрезвычайной мощи. По умолчанию, джофуры различных игроков могут разделять свои области влияния. Конечно игрок не может снять диск с чужой пирамиды (за исключением случая описанного далее), но конкуренция за "свободные" диски может развернуться нешуточная. Модификатор <b>S</b> говорит о "приватности" территории содержащей его пирамиды. Пирамиды противника не могут заходить в эту область или перемещать в её пределах диски. Если пирамида противника, каким-то образом, оказалась в такой области, она "блокируется", не может перемещаться, а также теряет свою область влияния. Если все пирамиды игрока "блокированы", он теряет право хода до тех пор, пока одна из его пирамид не осовободится. Модификатор <b>S</b> неплохо сочетается с <b>E</b>, увеличивающим область действия.</li>
	<li><b>G</b> - увеличение области влияния до размеров всей доски. Этот модификатор определён на одном уровне с <b>S</b> не случайно. Если бы какому-то из игроков удалось собрать <b>S</b> и <b>G</b> в одной пирамиде (что конечно же невозможно), другому оставалось бы лишь немедленно сдаться.</li>
</ul>
<h5><b>5-ый уровень</b></h5>
Область высшей нервной деятельности джофуров. На этом уровне определены самые мощные модификаторы. Разумеется, чтобы использовать их игрок вовсе не обязан строить пирамиду из всех пяти уровней. Чтобы модификатор 5-го уровня начал действовать, достаточно просто разместить его на одном из "командных" дисков, но в полную силу он может развернуться лишь в законченной, пятиуровневой пирамиде. Например, пирамида "<b>J3CSV</b>" станет неплохой заявкой на победу в игре.

<ul>
	<li><b>H</b> - гипноз предоставляет возможность выполнения "диверсионных" манипуляций в отношении пирамид противника, попавших в область влияния джофура. Можно снять с пирамиды диск, понизив её в статусе, либо навязать ей ненужный диск. Эта возможность не действует в отношении пирамид, содержащих большее (чем в атакующей пирамиде) количество очков или модификатор <b>S</b>. Сочетание с диском <b>I</b> (в атакующей или атакуемой пирамиде) предоставляет возможность выполнения <b>нескольких</b> действий, по отношению к одной и той же пирамиде противника, в рамках одного хода.</li>
	<li><b>V</b> - вампиризм (куда же без него), пожалуй, самая интересная возможность. Пирамиды, попавшие в область действия "вампира", временно теряют часть очков. Пирамида "вампир" забирает количество очков не превышающее наибольшего номинала диска в атакующей пирамиде. Разумеется, если атакуемая пирамида содержит всего 1 очко, а атакующая пирамида может забрать 3, забирается лишь одно очко (у атакуемой пирамиды остаётся 0 очков). Очки, собранные с нескольких пирамид, попавших в область действия "вампира", <b>суммируются</b> (разумеется, атакуются лишь пирамиды противника). Если "вампир" является главной пирамидой, собранные им очки увеличивают продолжительность хода игрока. Если атакована главная пирамида противника, отобранные очки уменьшают продолжительность его хода (вплоть до пропуска хода, если остаётся 0 очков)!</li>
</ul>
Конечно же, как и любой специей, "специальными" дисками не стоит злоупотреблять. Следует ограничивать количество специальных дисков на доске и скрывать их в первоначальном раскладе. Также, стоит подумать о назначении нулевых и даже отрицательных номиналов некоторым специальным дискам.

<h4><b>Пара слов под занавес</b></h4>
В этой статье я рассказал о своём опыте разработки концепции логической настольной игры. Игра получилась оригинальной, отличной от большинства известных мне игр. Пока сложно сказать насколько она успешна. Необходимо делать макет игры и отлаживать на нём игровой процесс. 

Что касается компьютерной реализации, то здесь всё непросто (и это ещё одна причина, по которой эта игра меня интересует). Для меня совершенно очевидно, что реализовать её в <a href="http://www.zillions-of-games.com/">ZoG</a> или <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom </a> не удастся. Скорее всего, можно будет использовать <a href="https://www.jocly.com/#/about">Jocly</a> (могут возникнуть некоторые проблемы связанные с частичным сокрытием информации и реализацией составного хода, но я думаю, что они решаемы). Мне потребуется очень хорошо разобраться с этим инструментом. А это именно то, что мне сейчас требуется.
</cut>

Как один программист Jocly подковал

<img align="left" src="https://habrastorage.org/files/413/c68/18b/413c6818b268431da04a72825c1c4fc9.PNG"/><b><i>— Ученик Почтальона Стэнли — пробормотал Грош 
— Сирота, сэр. Очень печальная история... Хороший мальчик, если его не злить, 
... если вы понимаете, что я имею в виду.
— Э… возможно. — сказал Мокрист и поспешно повернулся к Стэнли 
— Итак, знаешь кое-что о булавках? ...
— Нетсэр! — ответил Стэнли...
— О булавках я знаю всё! &nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Пратчетт "<a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%BE%D1%87%D1%82%D0%B0%D1%80%D0%B5%D0%BD%D0%B8%D0%B5">Опочтарение</a>".</i></b>&nbsp;

В далёком 1998 году, <a href="http://www.zillions-of-games.com/">Zillions of Games</a> произвела фурор в среде любителей настольных игр, но она не была лишена недостатков. Главным её недостатком являлась закрытость. Для того, чтобы играть во что-то сверх набора из 48 игр, входящих в демо-комплект, приходилось платить деньги за активацию программы. Было невозможно запустить ZoG на чём-то кроме Windows (с некоторыми версиями этой ОС вполне могли возникнуть проблемы). Сетевой режим был, но только по локальной сети или через модем, Web не подразумевался. С этим ничего нельзя поделать, это <b>закрытый</b> продукт! Кроме того, в настоящее время, он практически не поддерживается. Я думаю, что многие будут рады услышать, что существует альтернатива, свободная от перечисленных выше недостатков. Знакомьтесь, это <a href="https://www.jocly.com/#/about">Jocly</a>.
<cut>
Разработчики Jocly вдохновлялись примером Zillions of Games, но пошли по принципиально иному пути. Во главу угла был с самого начала поставлен Web. Вы можете запустить Jocly-приложение в любом современном браузере, на любой платформе, включая мобильные! В большинстве случаев, вы сможете пользоваться современным 3D-интерфейсом, но если возникнут проблемы с совместимостью, Jocly самостоятельно переключится на 2D. Можно играть как с компьютером, так и с другими людьми, просматривать ранее сыгранные партии и даже общаться с другими игроками через видео-чат. Вот <a href="http://wiki.jocly.com/index.php/All_you_can_do_with_Jocly">здесь</a> можно посмотреть краткое описание возможностей продукта, а также его <a href="http://wiki.jocly.com/index.php/Comparison_with_Zillions_of_Games">сравнение</a> с Zillions of Games.

<img align="left" src="https://habrastorage.org/files/f65/214/e3d/f65214e3df1b4f959438a9c0d8aab2ef.jpg"/>Конечно же, такая огромная бочка мёда никак не могла обойтись без маленькой ложки дёгтя (хотя, это кому как). Jocly не поддерживает каких либо <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a>, наподобие <a href="https://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> или <a href="https://en.wikipedia.org/wiki/Game_Description_Language">GDL</a> и разработку приходится вести на чистом и незамутнённом JavaScript. Сами разработчики <a href="http://wiki.jocly.com/index.php/Comparison_with_Zillions_of_Games">признают</a>, что это более трудоёмкий подход, но у него есть гигантский плюс - на JavaScript можно описать практически всё что угодно. Вернее можно <b>было бы</b> описать, если бы сама Jocly не накладывала пару ограничений. В текущей реализации, поддерживаются лишь игры <b>двух</b> игроков с полной информацией и без случайных событий. Эти довольно-таки суровые ограничения связаны, насколько я понимаю, с используемыми алгоритмами AI (<a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">Alpha–beta</a> и <a href="http://wiki.jocly.com/index.php/Jocly_UCT">UCT</a> <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Monte Carlo</a>).&nbsp;
&nbsp;

Как бы там ни было, разработчики, на мой взгляд, сделали главное - отделили <b>модель</b> игры от её визуального <b>представления</b>. И то и другое можно писать отдельно! Работая над моделью, программист может полностью отвлечься от вопросов её визуализации, а вплотную занявшись представлением, вполне способен реализовать, помимо привычного 2D (единственно-возможного в ZoG), ещё и честный 3D-интерфейс. Это <a href="http://wiki.jocly.com/index.php/XDView">сложно</a>, но вполне реализуемо. При большом желании, <a href="http://wiki.jocly.com/index.php/Changing_the_pieces_with_my_own_set">можно</a> даже разработать свой собственный дизайн фигур, нарисовав его в <a href="http://www.blender.org/">Blender</a>-е. 

Лучший способ понять - сделать что-то, пусть даже совсем небольшое, самому. Поскольку <a href="http://wiki.jocly.com/index.php/Changing_the_pieces_with_my_own_set">материал</a> по кастомизации шахмат на <a href="http://wiki.jocly.com">wiki</a> авторов проекта уже был, я решил посмотреть в сторону шашек. Для просмотра деталей реализации я использовал <a href="http://embed.jocly.net/jocly/plazza/inspector#/">Jocly Inspector</a>. В наличии имелись "Международные", "Английские", "Испанские", "Бразильские шашки". Всё что угодно, кроме "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Русских шашек</a>". Но если чего-то нет - надо просто это сделать!

Любое приложение Jocly можно запустить на своём компьютере (со слов разработчиков, это единственный способ запуска кастомизированных приложений). Сделать это поможет <a href="https://github.com/mi-g/jquery-jocly">Jocly jQuery plugin</a>. Вот <a href="http://mi-g.github.io/jquery-jocly/index.html">здесь</a> имеется неплохая подборка примеров, с демонстрацией его возможностей. Для начала работы, требуется всего три файла: <a href="https://raw.githubusercontent.com/mi-g/jquery-jocly/master/jquery.jocly.min.js">jquery.jocly.min.js</a>, <a href="https://raw.githubusercontent.com/mi-g/jquery-jocly/master/jquery.jocly.min.css">jquery.jocly.min.css</a> и небольшой html-файл. Если делать всё "по правильному", необходимо положить их в каталог документов любого Web-сервера (например <a href="https://httpd.apache.org/">Apache</a>), но, как показала практика, если вы используете <a href="https://www.mozilla.org/ru/firefox/new/">FireFox</a>, достаточно просто загрузить в него наш html-файл (с другими браузерами такой фокус не сработал).

<spoiler title="Вот что он содержит">
<source lang="html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
	<link rel="stylesheet" href="jquery.jocly.min.css">
	<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
	<script src="jquery.jocly.min.js"></script>

    <title>Jocly development stub web page</title>
    <script>
    	$(document).ready(function() {
    		$("#applet").jocly({});
    		$("#applet").jocly("localPlay","custom-draughts",{ });
    		$("#applet").jocly("setFeatures",{
    			notifyEnd: false,
    			hasEndSound: false,		
    		});
    		$("#options").joclyListener("listen","viewOptions",function(message) {
    			console.log("viewOptions",message);
    			$("#options-skin").hide().children("option").remove();
    			if(message.options.skin && message.skins && message.skins.length>0) {
    				message.skins.forEach(function(skin) {
    					$("<option/>").attr("value",skin.name).text(skin.title).appendTo($("#options-skin"));
    				});
    				$("#options-skin").show().val(message.options.skin);
    			}
    			$("#options-notation").hide();
    			if(message.options.notation!==undefined)
    				$("#options-notation").show().children("input").prop("checked",message.options.notation);
    			$("#options-moves").hide();
    			if(message.options.moves!==undefined)
    				$("#options-moves").show().children("input").prop("checked",message.options.moves);
    			$("#options-autocomplete").hide();
    			if(message.options.autocomplete!==undefined)
    				$("#options-autocomplete").show().children("input").prop("checked",message.options.autocomplete);
    			$("#options-sounds").hide();
    			if(message.options.sounds!==undefined)
    				$("#options-sounds").show().children("input").prop("checked",message.options.sounds);
    			$("#options").show();
    		});
    		$("#options").on("change",function() {
    			var options={};
    			if($("#options-skin").is(":visible")) 
    				options.skin=$("#options-skin").val();
    			if($("#options-notation").is(":visible"))
    				options.notation=$("#options-notation-input").prop("checked");
    			if($("#options-moves").is(":visible"))
    				options.moves=$("#options-moves-input").prop("checked");
    			if($("#options-autocomplete").is(":visible"))
    				options.autocomplete=$("#options-autocomplete-input").prop("checked");
    			if($("#options-sounds").is(":visible"))
    				options.sounds=$("#options-sounds-input").prop("checked");
    			$("#applet").jocly("viewOptions",options);
    		});
    		var defaultLevel=0;
    		$("#mode-panel").joclyListener("listen","players",function(message) {
    			console.warn("players",message);
    			function UpdatePlayer(player,key,levels) {
        			if(player.type=="computer") {
        				var select=$("#select-level-"+key);
        				select.empty();
        				for(var i=0;i<levels.length;i++)
        					$("<option/>").attr("value",i).text(levels[i].label).appendTo(select);
        				select.val(player.level);
        				$("#level-"+key).show();
        			} else
        				$("#level-"+key).hide();        				
    			}
    			UpdatePlayer(message.players[1],'a',message.levels);
    			UpdatePlayer(message.players[-1],'b',message.levels);
    			var modeSelect=$("#mode");
    			modeSelect.show();
    			if(message.players[1].type=="self" && message.players[-1].type=="self")
    				modeSelect.val("self-self");
    			else if(message.players[1].type=="self" && message.players[-1].type=="computer")
    				modeSelect.val("self-comp");
    			else if(message.players[1].type=="computer" && message.players[-1].type=="self")
    				modeSelect.val("comp-self");
    			else if(message.players[1].type=="computer" && message.players[-1].type=="computer")
    				modeSelect.val("comp-comp");
    			else
    				modeSelect.hide();
    			message.levels.forEach(function(level,index) {
    				if(level.isDefault)
    					defaultLevel=index;
    			});
    			$("#mode-panel").show();
    		});
    		$("#mode-panel").on("change",function() {
    			console.log("changed mode",$("#mode").val(),$("#select-level-a").val(),$("#select-level-b").val());
    			var players;
    			switch($("#mode").val()) {
    			case "self-self":
    				players={"1":{type:"self"},"-1":{type:"self"}};
    				break;
    			case "self-comp":
    				players={"1":{type:"self"},"-1":{type:"computer",level:$("#select-level-b").val() || defaultLevel}};
    				break;
    			case "comp-self":
    				players={"1":{type:"computer",level:$("#select-level-a").val() || defaultLevel},"-1":{type:"self"}};
    				break;
    			case "comp-comp":
    				players={"1":{type:"computer",level:$("#select-level-a").val() || defaultLevel},
    					"-1":{type:"computer",level:$("#select-level-b").val() || defaultLevel}};
    				break;
    			}
    			$("#applet").jocly("setPlayers",players);
    		});
    		$("#restart").on("click",function() {
    			$("#applet").jocly("restartGame");    			
    		});
    		$("#takeback").on("click",function() {
    			$("#applet").jocly("takeBack");    			
    		});
        	$("#fullscreen").on("click",function() {
        		$("#applet").joclyFullscreen();
        	});
    	});
    </script>
    <style type="text/css">
* {
	box-sizing: border-box;
}
body {
}
#container {
	width: 100%;
	display: table;
	table-layout: fixed;
}
#applet {
	display: table-cell;
	width: 60%;
}
#controls {
	display: table-cell;
	width: 33%;
	vertical-align: top;
	padding: 0 .5em 0 .5em;
}
.box {
	background-color: #f0f0f0;
	border: 2px solid #e0e0e0;
	border-radius: 1em;
	padding: 1em;
}
    </style>
    
    <script type="text/jocly-model-view" data-jocly-game="draughts/custom-draughts">
    <!-- Сюда включаем описание игры -->
    </script>
  </head>
  <body>
	<div id="container">
		<div id="applet"></div>
		<div id="controls">
	       	<div id="mode-panel" style="display: none;" class="box">
	       		<h3>Controls</h3>
	       		<button id="restart">Restart game</button><br/><br/>
	       		<button id="takeback">Take back</button><br/><br/>
	       		<select id="mode">
	       			<option value="self-self">Self / Self</option>
	       			<option value="self-comp">Self / Computer</option>
	       			<option value="comp-self">Computer / Self</option>
	       			<option value="comp-comp">Computer / Computer</option>
	       		</select><br/><br/>
	       		<label id="level-a" for="select-level-a">Computer(A) level<br/>
	        		<select id="select-level-a"></select><br/><br/>
	       		</label>
	       		<label id="level-b" for="select-level-b">Computer(B) level<br/>
	        		<select id="select-level-b"></select><br/><br/>
	       		</label>
	       		<button id="fullscreen">Full screen</button><br/><br/>
	       	</div>
	       	<br/>
	       	<div id="options" style="display: none;"  class="box">
	       		<h3>Options</h3>
	       		<select id="options-skin"></select><br/><br/>
	       		<label id="options-notation" for="options-notation-input">
	       			<input id="options-notation-input" type="checkbox"/> Notation<br/>
	       		</label>
	       		<label id="options-moves" for="options-moves-input">
	       			<input id="options-moves-input" type="checkbox"/> Show possible moves<br/>
	       		</label>
	       		<label id="options-autocomplete" for="options-autocomplete-input">
	       			<input id="options-autocomplete-input" type="checkbox"/> Auto-complete moves<br/>
	       		</label>
	       		<label id="options-sounds" for="options-sounds-input">
	       			<input id="options-sounds-input" type="checkbox"/> Sounds<br/>
	       		</label>
	       	</div>
		</div>
	</div>
  </body>
</html>
</source>
</spoiler>
Для простого запуска игры, можно было бы обойтись минимальным html-файлом, описанным в <a href="http://wiki.jocly.com/index.php/Embed_a_game">этом</a> руководстве, но с его <a href="https://github.com/mi-g/jquery-jocly/blob/master/dev-stub.html">более полным</a> вариантом работать будет гораздо удобнее. Теперь, необходимо включить в html-файл <a href="http://wiki.jocly.com/index.php/Jocly_Basics">JSON-описание</a> игры. Здесь есть тонкий момент. Наш вариант игры будет называться "custom-draughts" (сейчас, это имя встречается в файле дважды). Мы можем взять описание игры из текстового поля Jocly Inspector-а целиком, но если мы изменяем лишь часть файлов, это может быть излишним. Вполне достаточно описать лишь ту часть модели, в которую мы внесли изменения, остальное Jocly возьмёт со своего сайта, но для того, чтобы это работало, имя должно быть составлено следующим образом: "<b>draughts</b>/custom-draughts". Часть имени перед слэшем - имя, своего рода, "родительской" игры, из которой будет браться всё недостающее. Повторюсь, эта часть имени <b>не нужна</b>, если используется полное JSON-описание.

<spoiler title="Здесь всё что нам понадобится">
<source lang="html">
    <script type="text/jocly-model-view" data-jocly-game="draughts/custom-draughts">
    {
	"view": {
	    "js": [
	       "checkers-xd-view.js",
	       "draughts8-xd-view.js"
	    ]
	},
	"model": {
            "js": [
               "checkersbase-custom-model.js",
               "draughts-model.js"
            ],
	    "gameOptions": {
	      	"preventRepeat": true,
      		"width": 4,
      		"height": 8,
      		"initial": {
		        "a": [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3]],
        		"b": [[7,0],[7,1],[7,2],[7,3],[6,0],[6,1],[6,2],[6,3],[5,0],[5,1],[5,2],[5,3]]
      		},
      		"variant": {
                        "compulsoryCatch": true,
                        "canStepBack": false,
                        "mustMoveForward": false,
		        "mustMoveForwardStrict": true,
                        "lastRowFreeze": false,
        		"lastRowCrown": true,
        		"captureLongestLine": true,
                        "kingCaptureShort": false,
                        "canCaptureBackward": true,
                        "longRangeKing": true,
                        "captureInstantRemove": false,
        		"lastRowFactor": 0.001
      		},
      		"uctTransposition": "state"
            }
	}
    }
    </script>

    <script type="text/jocly-resources" data-jocly-game="custom-draughts">
    {
        "checkersbase-custom-model.js": "checkersbase-custom-model.js"
    }
    </script>
</source>
</spoiler>
В первую очередь, в глаза бросается описание размеров доски и начальной расстановки фигур (последнее имеется далеко не во всех Jocly-играх). Немного сложно привыкнуть к тому, что доска описывается как 4x8 (неиспользуемые в диагональных шашечных системах поля моделью не описываются), а все индексы размещения фигур начинаются с нуля. Далее следует список булевских настроек, достаточный (с точки зрения разработчиков) для описания любых шашечных игр. Мы его пополним. Не обязательно указывать все настройки, я составил полный список, исключительно для своего удобства. Важно описать в "<b>text/jocly-resources</b>" все файлы, которые мы будем отдавать со своего сервера. Файл "<b>checkersbase-custom-model.js</b>" - та часть модели, в которую будут вноситься изменения. Первоначально, это просто копия файла "<b><a href="http://embed.jocly.net/jocly/plazza/file-access?game=draughts&file=checkersbase-model.js">checkersbase-model.js</a></b>".

Настало время подумать о том, что мы будем менять. Чем отличаются "Русские шашки" от "Бразильских" (имеющихся в комплекте Jocly)? На самом деле, всего двумя "мелочами". "Бразильские шашки" играются по правилам "Международных" или "Польских шашек", но на доске 8x8. В них действует "правило большинства": из двух и более вариантов взятия игрок должен выбрать тот, при котором "срубит" максимальное количество шашек противника, независимо от их качества. В "Русских шашках" опцию необходимо отключить. С этим всё просто, свойство управляется булевской настройкой "<b>captureLongestLine</b>".

<spoiler title="Кстати">
Интересно посмотреть, как правило большинства реализовано в шашках от Jocly. Если составной ход рассматривается как единое целое, задача становится тривиальной. В самом конце метода генерации ходов "<b>Model.Board._GenerateMoves</b>" имеется следующий фрагмент кода:

<spoiler title="Выбор из списка сгенерированных ходов">
<source lang="javascript">
...
if(aGame.g.captureLongestLine) {
	var moves0=this.mMoves;
	var moves1=[];
	var bestLength=0;
	for(var i in moves0) {
		var move=moves0[i];
		if(move.pos.length==bestLength)
			moves1.push(move);
		else if(move.pos.length>bestLength) {
			moves1=[move];
			bestLength=move.pos.length;
		}
	}
	this.mMoves=moves1;
}
...
</source>
</spoiler>
У нас есть список ходов (в том или ином представлении) и из него необходимо выбрать лишь те ходы, которые берут максимальное количество фигур (в интерпретации Jocly - состоят из максимального числа шагов). В ZoG, с её концепцией "частичных" ходов, пришлось добавлять хардкодную опцию "<b>maximal captures</b>" непосредственно в приложение, чтобы реализовать аналогичный функционал.
</spoiler>
Больше сложностей возникает с другим правилом: если шашка стала дамкой в ходе серии взятий, после превращения она продолжает "рубку" без остановки, уже по правилам дамки. В "Международных", а также "Бразильских шашках", действует другое правило: если шашка оказалась на последней линии в ходе серии взятий и может бить дальше в роли простой шашки, то она продолжает бой и <b>не превращается</b>! Найдём в коде то место, где происходит превращение:

<spoiler title="Это метод ''Model.Board.ApplyMove''">
<source lang="diff">
Model.Board.ApplyMove = function(aGame,move) {
+	var pieceCrowned=false;
	var WIDTH=aGame.mOptions.width;
	var HEIGHT=aGame.mOptions.height;
	var pos0=move.pos[0];
	var pIndex=this.board[pos0];
	var piece=this.pieces[pIndex];
	var player=piece.s;
	piece.l=pos0;
	var toBeRemoved={};
	this.zSign=aGame.zobrist.update(this.zSign,"board",piece.s+"/"+piece.t,piece.p);
	for(var i=1;i<move.pos.length;i++) {
		var pos=move.pos[i];
		this.board[piece.p]=-1;
		piece.p=pos;
+		if (aGame.g.russianCustom==true) {
+			var r=aGame.g.Coord[pos][0];
+			if((player==JocGame.PLAYER_A && r==HEIGHT-1) || (player==JocGame.PLAYER_B && r==0)) {
+				pieceCrowned=true;
+			}
+		}
		this.board[pos]=pIndex;
		var caught=move.capt[i];
		if(caught!=null) {
			if(this.board[caught]>=0)
				toBeRemoved[this.board[caught]]=true;
			this.board[caught]=-1;
		}
		pos0=pos;
	}
	this.zSign=aGame.zobrist.update(this.zSign,"board",piece.s+"/"+piece.t,pos);
	var plp=move.capt[move.capt.length-1]
	piece.plp=plp?plp:move.pos[move.pos.length-2];
	for(var index in toBeRemoved) {
		var piece0=this.pieces[index];
		var other=(1-piece0.s)/2;
		this.pCount[other]--;
		switch(piece0.t) {
			case 0: this.spCount[other]--; break;
			case 1: this.kpCount[other]--; break;
		}
		this.zSign=aGame.zobrist.update(this.zSign,"board",piece0.s+"/"+piece0.t,piece0.p);
		this.pieces[index]=null;
	}
	if(aGame.g.lastRowCrown && this.pieces[pIndex].t==0) {
		var r=aGame.g.Coord[move.pos[move.pos.length-1]][0];
-		if((player==JocGame.PLAYER_A && r==HEIGHT-1) || (player==JocGame.PLAYER_B && r==0)) {
+		if(pieceCrowned || (player==JocGame.PLAYER_A && r==HEIGHT-1) || (player==JocGame.PLAYER_B && r==0)) {
			var piece0=this.pieces[pIndex];
			piece0.t=1;
			var self=(1-player)/2;
			this.spCount[self]--;
			this.kpCount[self]++;
			this.zSign=aGame.zobrist.update(this.zSign,"board",piece0.s+"/0",piece0.p);
			this.zSign=aGame.zobrist.update(this.zSign,"board",piece0.s+"/1",piece0.p);
		}
	}
}
</source>
</spoiler>
Можно заметить, что внесённые изменения, а также модель доски, ходов, фигур и прочего, далеки от интуитивных. В коде выполняется много дополнительных действий (типа вычисления <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist Hash</a>) и во всём этом совсем не трудно заблудиться. Это вам не ZRF! Суть изменений проста - мы запоминаем <b>факт</b> прохождения через последнюю горизонталь (первую для чёрных) и, если он имел место, превращаем фигуру так, как если бы в конце хода оказались на горизонтали превращения. Посмотрим, как всё работает:

<video>https://www.youtube.com/watch?v=uKYhr1YFe90</video>

Вроде бы всё правильно. Не будем обращать внимание на то, что превращение происходит по завершении хода, а не в его процессе. В рамках текущей реализации модели, превращение фигуры посреди хода - не лучшая идея (всё сломается, я проверял)! Но всё ли мы предусмотрели? Чуть-чуть изменим позицию:

<video>https://www.youtube.com/watch?v=mHCBB7VVBLc</video>

Да, это то чего мы боялись. Дойдя до последней горизонтали, шашка "не знает", что дальше она имеет право "есть" как дамка! Попробуем ей объяснить. При выполнении хода, принимать решения о том, кто кого ест, уже немного поздно. Логично искать нужное место в методе генерации ходов, а именно в функции "<b>catchPieces</b>". В её последний параметр передаётся флаг "<b>king</b>", показывающий, что мы имеем дело с дамкой. Попробуем его изменить при прохождении последней горизонтали:

<spoiler title="Я не сразу додумался до такого">
<source lang="diff">
function catchPieces(pos,poss,capts,dirs,king) {
	while(true) {
		var nextPoss=[];
		var nextCapts=[];
		var nextDirs=[];
		aGame.CheckersEachDirection(pos,function(pos0,dir) {
			var r;
			if(aGame.g.canCaptureBackward==false)
				r=aGame.g.Coord[pos][0];
			var dir0=aGame.Checkers2WaysDirections[dir];
+			if (aGame.g.russianCustom==true) {
+				if($this.board[pos0]>=0 && $this.pieces[$this.board[pos0]].s==-$this.mWho) {
+					var pp=aGame.g.Graph[pos0][dir];
+					if (aGame.g.Coord[pp]) {
+						var rr=aGame.g.Coord[pp][0];
+						var HEIGHT=aGame.mOptions.height;
+						if(($this.mWho==JocGame.PLAYER_A && rr==HEIGHT-1) || 
+							($this.mWho==JocGame.PLAYER_B && rr==0)) {
+							king=true;
+						}
+					}
+				}
+			}
			if(!king) {
				if($this.board[pos0]>=0 && $this.pieces[$this.board[pos0]].s==-$this.mWho) {
					var r0,forward;
					if(aGame.g.canCaptureBackward==false) {
						r0=aGame.g.Coord[pos0][0];
						forward=false;
						if(($this.mWho==JocGame.PLAYER_A && r0>=r) || 
							($this.mWho==JocGame.PLAYER_B && r0<=r))
								forward=true;
					}
					if(aGame.g.canCaptureBackward || forward==true) {
						var pos1=aGame.g.Graph[pos0][dir];
						if(pos1!=null && ($this.board[pos1]==-1 || pos1==poss[0])) {
							var keep=true;
							for(var i=0;i<dirs.length;i++)
								if((aGame.g.captureInstantRemove && capts[i]==pos0) ||
									(aGame.g.captureInstantRemove==false && 
										capts[i]==pos0 && dirs[i]==dir0)) {
									keep=false;
									break;
								}
							if(keep) {
								nextPoss.push(pos1);
								nextCapts.push(pos0);
								nextDirs.push(dir0);
							}
						}
					}
				}
			} else { // king
				if(aGame.g.longRangeKing)
					while($this.board[pos0]==-1 || 
						(aGame.g.king180deg && pos0!=null && capts.indexOf(pos0)>=0))
							pos0=aGame.g.Graph[pos0][dir];
				if(pos0!=null) {
					if($this.board[pos0]>=0 && $this.pieces[$this.board[pos0]].s==-$this.mWho) {
						var caught=pos0;
						pos0=aGame.g.Graph[pos0][dir];
						if(aGame.g.kingCaptureShort) {
							if($this.board[pos0]==-1 || pos0==poss[0]) {
								var keep=true;
								for(var i=0;i<dirs.length;i++)
									if(!aGame.g.king180deg) {
										if((aGame.g.captureInstantRemove && 
											capts[i]==caught) ||
											(aGame.g.captureInstantRemove==false && 
											capts[i]==caught && 
													dirs[i]==dir0)) {
											keep=false;
											break;
										}
									} else if(capts[i]==caught) {
										keep=false;
										break;												
									}
								if(keep) {
									nextPoss.push(pos0);
									nextCapts.push(caught);
									nextDirs.push(dir0);
								}
								pos0=aGame.g.Graph[pos0][dir];
							}
						} else {
							while($this.board[pos0]==-1 || pos0==poss[0]) {
								var keep=true;
								for(var i=0;i<dirs.length;i++)
									if((aGame.g.captureInstantRemove && capts[i]==caught) ||
											(aGame.g.captureInstantRemove==false && 
											capts[i]==caught && dirs[i]==dir0)) {
										keep=false;
										break;
									}
								if(keep) {
									nextPoss.push(pos0);
									nextCapts.push(caught);
									nextDirs.push(dir0);
								}
								pos0=aGame.g.Graph[pos0][dir];
							}
						}
					}
				}
			}
			return true;
		});
		if(nextPoss.length==0) {
			if(poss.length>1)
				$this.mMoves.push({ pos: poss, capt: capts });
			break;
		}
		if(!aGame.g.compulsoryCatch && poss.length>1) {
			var poss1=[];
			for(var i=0;i<poss.length;i++)
				poss1.push(poss[i]);
			var capts1=[];
			for(var i=0;i<capts.length;i++)
				capts1.push(capts[i]);
			$this.mMoves.push({ pos: poss1, capt: capts1 });
		}
		if(nextPoss.length==1) {
			pos=nextPoss[0];
			poss.push(pos);
			capts.push(nextCapts[0]);
			dirs.push(nextDirs[0]);
		} else {
			for(var i=0;i<nextPoss.length;i++) {
				var poss1=[];
				for(var j=0;j<poss.length;j++)
					poss1.push(poss[j]);
				poss1.push(nextPoss[i]);
				var capts1=[];
				for(var j=0;j<capts.length;j++)
					capts1.push(capts[j]);
				capts1.push(nextCapts[i]);
				var dirs1=[];
				for(var j=0;j<dirs.length;j++)
					dirs1.push(dirs[j]);
				dirs1.push(nextDirs[i]);
				catchPieces(nextPoss[i],poss1,capts1,dirs1,king);
			}
			break;
		}
	}
}
</source>
</spoiler>
Нам здорово повезло с тем, что признак дамки передаётся в качестве параметра функции. Генератор ходов выполняет обход <b>дерева</b> всех возможных составных ходов. Если бы признак дамки изменялся в объекте фигуры, пришлось бы заботиться об откате изменений, выполненных в модели самим генератором. В противном случае, программа могла бы вести себя <b>непредсказуемо</b>. Посмотрите, как это делается в Axiom:

<spoiler title="Custom Engine">
<source>
: Custom-Engine ( -- )
	-10000 BestScore !
	0 Nodes !
	$FirstMove
	BEGIN
		$CloneBoard
		DUP $MoveString 
		CurrentMove!
		DUP .moveCFA EXECUTE
		MaxDepth Depth !
		0 EvalCount !
		BestScore @ 10000 turn-offset next-turn-offset Score
		0 5 $RAND-WITHIN +
		BestScore @ OVER <
		IF
			DUP BestScore !
			Score!
			0 Depth!
			DUP $MoveString BestMove!
		ELSE
			DROP
		ENDIF
		$DeallocateBoard
		Nodes ++
		Nodes @ Nodes!
		$Yield
		$NextMove
		DUP NOT
	UNTIL
	DROP
;
</source>
</spoiler>
Здесь, мы копируем содержимое доски во временный массив (вызовом <b>$CloneBoard</b>), затем выбираем "лучший" ход, после чего удаляем временное состояние доски (<b>$DeallocateBoard</b>). И так - для каждого уровня просмотра! Как бы там ни было, теперь всё работает, как и было задумано:

<video>https://www.youtube.com/watch?v=vW8jOS-Li60</video>

Не стоит думать, что на этом всё закончено. В Jocly ещё есть, над чем поломать голову! Посмотрите, сможете ли вы сказать, что не так на этом видео игры в "Turkish Draughts"?

<video>https://www.youtube.com/watch?v=w5FQPGAdKbY</video>

<spoiler title="Ответ">
Это немного запутанная тема. В большинстве современных вариантов шашек, действует правило "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкого удара</a>": в процессе сложного взятия, фигуры противника не убираются с доски сразу, а лишь помечаются как взятые. Забираются они все сразу, по завершении хода. Это правило действует практически везде, кроме ... "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецких шашек</a>"! В "Турецких шашках", дамка представляет собой грозную силу. Выполняя взятие, она "расчищает" себе место для последующих ходов. Всего одна дамка <b>может</b> съесть всю армию противника одним ходом!

Судя по видео, в Jocly это не так. На последнем шаге видно, что дамка не может выбрать более длинную цепочку взятий, поскольку ей мешает ранее взятая шашка, не убранная с доски. Люди, далёкие от настольных игр, могут счесть это обстоятельство несущественным, но ни один из серьёзных игроков никогда не станет играть в "Турецкие шашки" по таким правилам! Пока, я не знаю как это исправить. Требуемое исправление сложнее, чем кастомизация, описанная в этой статье. Внеся изменения в генератор ходов, можно заставить дамку "не видеть" ранее взятые шашки, но, кроме того, необходимо обеспечить дамке возможность остановки на полях, занятых взятыми шашками, в том числе и возможность завершения хода на таком поле. Это сложно и я не готов сейчас этим заниматься, но возможно кто-то из читателей предложит работающее решение?
</spoiler>
Мы познакомились с ещё одним интересным "движком" для разработки абстрактных настольных игр. У него есть свои ограничения и процесс разработки в нём не прост. Но у него есть свой, совершенно убийственный набор киллер-фич! Он открытый, кросс-платформенный, Web-ориентированный и, самое главное, он всё ещё поддерживается разработчиками! Проект живёт! Включайтесь в него, и, возможно, он будет жить гораздо дольше чем легендарная Zillions of Games.
</cut>

Погоня с препятствиями

<img align="left" src="https://habrastorage.org/files/112/91a/a5f/11291aa5f1654fd6bde4e3d72868bd5e.PNG"/><b><i>
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Какая медлительная страна! -  сказала  Королева. -  Ну,  а  здесь, 
знаешь ли, приходится бежать со всех ног, чтобы только остаться 
на том  же месте! Если же хочешь попасть в другое место, тогда 
нужно бежать по  меньшей мере вдвое быстрее!&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Льюис Кэрролл "<a href="http://www.lib.ru/CARROLL/carrol1_2.txt">Алиса в Зазеркалье</a>"&nbsp;</i></b>

Сегодня, я хочу рассказать об удивительной и недооценённой игре, с которой я познакомился чуть менее двух лет назад. В каком-то смысле, именно с этой игры, а также с <a href="https://habrahabr.ru/post/224661/">Ура</a>, началось моё знакомство с <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрием Скирюком</a>. В те дни я только начинал интересоваться настольными играми. Мои познания были скудны и, во многом, наивны. Такие игры как "<a href="http://skyruk.livejournal.com/334947.html">Чейз</a>", буквально открыли для меня новый необъятный мир. Даже сейчас, работа над этой игрой, в большой степени, напоминает детективную историю. В этом отношении, игра "<abbr title="англ. ''Погоня''">Chase</abbr>" полностью оправдала как своё название так и сходство с псевдонимом известного <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D0%B5%D0%B9%D0%BC%D1%81_%D0%A5%D0%B5%D0%B4%D0%BB%D0%B8_%D0%A7%D0%B5%D0%B9%D0%B7">американского писателя</a>.
<cut>
Игра была разработана Томом Крушевски и выпущена в продажу компанией "TSR" в 1986 году. Помимо специальной доски, у каждого из игроков имеется по 10 шестигранных игральных кубиков, но несмотря на это игра не является азартной. Кубики бросаются всего один раз, для определения очерёдности хода и в дальнейшем используются лишь в качестве фигур. Количество очков на верхней грани показывает число шагов, на которое может быть передвинут кубик. Так кубик с одним очком может быть перемещён на соседнее поле, в любом из шести направлений, с двумя очками - на два поля по прямой, с тремя - на три и т.д. Кубик должен перемещаться ровно на указанное число шагов, не больше и не меньше. В процессе перемещения, кубик не поворачивается другой стороной (количество очков на верхней грани не изменяется). Начальная расстановка показана ниже:

<img align="center" src="https://habrastorage.org/files/663/bd0/e5f/663bd0e5f8fe436e84f404e6503e7e94.PNG"/>
<spoiler title="Подробнее о правилах">
Для каждого из игроков, общее количество очков, на верхних гранях, составляет 25. Игрок обязан поддерживать эту сумму до конца игры. Игроки ходят по очереди и если один из них забирает одну (или две, такое тоже возможно) фигуры, его противник обязан добавить сумму очков, выбывших из игры, к своему кубику с минимальным количеством очков (в начале игры, это одна из единичек). Если после этого распределены не все очки, остаток распределяется далее, всегда начиная с кубика с наименьшим количеством очков. Игрок, у которого остаётся менее 5 кубиков - проигрывает, поскольку не может распределить необходимое количество очков по оставшимся на доске кубикам.

<img align="center" src="https://habrastorage.org/files/ad3/ba4/82c/ad3ba482cbbe477b944217be72bba230.jpg"/>
Границы доски не препятствуют движению фигур. Левая и правая границы доски "склеены" между собой, а от верхней и нижней границ фигуры отскакивают "рикошетом". Разумеется, это не означает, что фигуры движутся беспрепятственно. Фигуры не могут "перепрыгивать" друг друга, а также центральное поле "<b>Chamber</b>". Для взятия фигуры противника, фигура должна "встать" на неё (шахматное взятие), выполнив полное количество шагов по прямой. Ход может закончится и на фигуре своего цвета. В этом случае происходит "<b>bumping</b>" - фигура оказавшаяся на целевом поле смещается на один шаг, продолжая направление движения (с учётом склеенности доски и рикошетов). Если следующее поле также оказалось занято своей фигурой, "<b>bumping</b>" распространяется далее, до первого пустого поля или поля занятого фигурой противника (вражеская фигура забирается). Только одно препятствие может сделать такой ход невозможным - запрещено "задвигать" фигуры в центральную клетку, используя <b>bumping</b>. 

Можно заметить, что из начальной позиции, каждый из игроков может циклически сдвинуть все свои фигуры, сходив любой из единичек в сторону двойки. Подобный ход разрешён правилами. Также допускается "обмен" очками между фигурами одного цвета, находящимися на соседних полях. Так пара из 5 и 2 может превратиться в 4 и 3 или даже в 1 и 6. Такое действие считается ходом. Не рассмотренным остался всего лишь один тип хода. Ни одна из фигур не может пройти сквозь центральное поле доски (<b>Chamber</b>), но она может закончить своё движение на этом поле. Если это произошло, фигура "расщепляется" на две, с сохранением суммарного количества очков. Фигура всегда разделяется таким образом, чтобы очки одной из полученных фигур превышали очки другой не более чем на 1. Общее количество фигур, у каждого из игроков, не может превысить 10 (именно на этот случай, в начале игры, каждый из игроков имеет 1 кубик в резерве).

<img align="center" src="https://habrastorage.org/files/3b2/5c1/8d5/3b25c18d59b9458687b0f1407c1e0e09.PNG"/>
Направления "разлёта" осколков напоминают остриё стрелы. Кубик с большим числом очков (если такой есть) всегда уходит в левую сторону. В двух особых случаях "расщепление" невозможно. Во первых, как я уже сказал выше, количество кубиков одного цвета не может превышать 10. Кроме того, совершенно очевидно, что расщепить кубик с 1 очком не удастся. В обоих этих случаях, кубик, вошедший в <b>Chamber</b>, выходит неизменным, по левому направлению. Каждая из фигур, покинувших <b>Chamber</b>, может инициировать <b>bumping</b>, попав на свою фигуру или взять фигуру противника (только таким способом можно взять две вражеских фигуры одновременно).
</spoiler>
Должен сказать, что Tom Kruszewski и "TSR" сильно переоценили возможности своей потенциальной аудитории. Для массового потребителя, игра оказалась слишком сложной (шахматы не менее сложны, но к ним все привыкли). Производитель прекратил выпуск продукции и, в настоящее время, "Чейз" можно приобрести лишь с рук, на различных ярмарках, аукционах и распродажах. Тем не менее, эта игра по праву считается одной из лучших игр 20-го столетия.

<h4><b>Простая работа</b></h4>
Игра начинается с доски, а доска у Chase ... своеобразная. Ранее мне ещё не приходилось делать игры на гексагональных досках и это стало первым (очень небольшим) препятствием. Это интересный момент и я хочу рассказать о нём поподробнее. Механизм описания игровых досок в ZRF хорошо продуман и позволяет реализовывать практически любые доски, при условии того, что они отображаются на плоскость и не изменяются в процессе игры.

<spoiler title=" Вот как это выглядит">
<source>
(board
   (image "../Images/Chase/board.bmp")
   (grid
     (start-rectangle 48 32 108 82)
     (dimensions
         ("a/b/c/d/e/f/g/h/i/j/k/l/m" (60 0))
         ("1/2/3/4/5/6/7/8/9" (-30 52))
     )
     (directions (se 1 1) (w 1 0) (sw 0 1)
                 (nw -1 -1) (e -1 0) (ne 0 -1))
   )
   (kill-positions
      j1 k1 l1 m1 j2 k2 l2 m2 a3 k3 l3 m3 
      a4 k4 l4 m4 a5 b5 l5 m5 a6 b6 l6 m6 
      a7 b7 c7 m7 a8 b8 c8 m8 a9 b9 c9 d9
   )
)
</source>
Я не сторонник того, чтобы детали модели смешивались с вопросами визуализации, но до тех пор, пока не требуется отделить одно от другого (например отобразить доску в "честном" 3D, а не изометрии) такой подход вполне работает. Рассмотрим это описание подробнее:

<ul>
	<li>Неотъемлемой частью описания является файл, содержащий изображение доски. Все геометрические размеры и позиции фигур привязаны к нему (именно по этой причине, большую часть дистрибутива моей реализации "<a href="https://habrahabr.ru/post/268215/">Сокобана</a>" составляют чёрные прямоугольники различных форм и размеров). Файл содержащий изображение доски в BMP-формате (<a href="http://zillions-of-games.com/">ZoG</a> понимает только этот формат) определяется ключевым словом <b>image</b>. Здесь можно определить сразу несколько файлов (для обеспечения возможности переключения между скинами), но лишь с идентичными геометрическими пропорциями.</li>
	<li>Ключевое слово <b>grid</b> позволяет описать n-мерный массив позиций. В большинстве случаев, это привычная двумерная доска, но также можно определять и доски другой размерности (вплоть до пяти). Доска может состоять из нескольких <b>grid</b>-ов, при условии того, что обеспечивается уникальное именование отдельных позиций. При большом желании, можно даже размещать один <b>grid</b> поверх другого, наподобие того как это сделано в "<a href="https://habrahabr.ru/post/276329/">Квантовых крестиках-ноликах</a>".</li>
	<li>Размер "ячейки" и расположение сетки определяются ключевым словом <b>start-rectangle</b>. Две пары целых чисел задают экранные координаты (x, y) левого верхнего и правого нижнего угла самой первой (левой верхней) ячейки.</li>
	<li>Далее следует описание "измерений" (<b>dimensions</b>). Каждое описание содержит строку имён (из которых декартовым произведением комбинируются имена позиций), а также два целых числа. В этих числах и заключается "магия", позволяющая описывать гексагональные и изометрические доски. Это ни что иное как сдвиги, на которые смещаются очередные ячейки сетки. Обычно (для двумерных досок), в одном из измерений, ячейки смещаются на ширину ячейки по <b>x</b>, а в другом - на высоту ячейки по <b>y</b>, но дополнительно смещая эти ячейки на половину ширины по <b>x</b>, можно получить превосходную основу для гексагональной доски.</li>
	<li>Вторая составляющая "магии" <b>grid</b>-ов - направления (<b>directions</b>). Доска - это не только позиции, но и связи (именованные и однонаправленные) между ними. Конечно, никто не мешает определить каждую связь индивидуально, задав имя и пару позиций для каждого соединения, но при определении досок больших размеров, этот процесс не будет весел. Ключевое слово <b>directions</b> позволяет манипулировать не именами позиций, а направлениями внутри сетки.</li>
	<li>Чтобы получить доску требуемой формы, мы берём "прямоугольную" доску большего размера, а затем смещаем ряды на половину ячейки друг относительно друга. В результате остаются "лишние" позиции, которые необходимо "отрезать" от доски. Ключевое слово <b>kill-positions</b> позволяет объявить ранее определённое имя позиции недействительным. Разумеется, вместе с удаляемыми позициями разрываются и соответствующие им соединения.</li>
</ul>
</spoiler>
Использование ключевого слова <b>grid</b> позволяет существенно снизить объём ручной работы при описании "типовых" досок, но такой подход не лишён определённых недостатков. Во первых, если изображение доски не рисовалось под выбранные геометрические размеры специально, оперируя лишь целочисленными координатами и смещениями, бывает сложно выровнять расположение всех позиций доски идеально. Индивидуальное описание позиций менее лаконично, но позволяет корректировать их расположение независимо друг от друга. Вместе с тем, оно требует просто убийственного объёма ручной работы (с учётом необходимости исправления всех допущенных опечаток). Чтобы как-то облегчить этот процесс, я использую <b>grid</b> для "чернового" описания, после чего получаю индивидуальное описание позиций, при помощи небольшого <a href="https://github.com/GlukKazan/ZoG/blob/a6d47245691c9e1a7e291b016db675fb9abd49ad/utils/perl/grid.pl">скрипта</a>:

<spoiler title="Скрипт">
<source lang="perl">
my @grid;
my %kp;
my $sx, $sy, $dx, $dy;
my $dm = 0;

while (<>) {
  if (/\(start-rectangle\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\)/) {
     $sx = $1; 
     $sy = $2;
     $dx = $3 - $1;
     $dy = $4 - $2;
  }
  if (/\(\"([^\"]+)\"\s+\((-?\d+)\s+(-?\d+)\)\)/) {
     my @a = split(/\//, $1);
     $grid[$dm]->{ix} = \@a;
     $grid[$dm]->{x}  = $2;
     $grid[$dm]->{y}  = $3;
     $dm++;
  }
  if (/\(kill-positions/) {
     $fl = 1;
  }
  if ($fl) {
     if (/\s(([a-z0-9]{1,2}\s+)+)/i) {
        my @a = split(/\s+/, $1);
        foreach my $p (@a) {
           $kp{$p} = 1;
        }
     }
     if (/\)/) {
        $fl = 0;
     }
  }
}

sub try {
  my ($ix, $pos, $x, $y) = @_;
  if ($ix < $dm) {
     my $i = 0;
     foreach my $p (@{$grid[$ix]->{ix}}) {
        try($ix + 1, $pos . $p, $x + $i * $grid[$ix]->{x}, $y + $i * $grid[$ix]->{y});
        $i++;
     }
  } else {
     if (!$kp{$pos}) {
         my $a = $sx + $x;
         my $b = $sy + $y;
         my $c = $a + $dx;
         my $d = $b + $dy;
         print "             ";
         printf "($pos %3d %3d %3d %3d)\n", $a, $b, $c, $d;
     }
  }
}

try(0, '', 0, 0);
</source>
</spoiler>
<spoiler title="Результат">
<source lang="lisp">
      (positions  
             (a1  48  32 108  82)
             (a2  18  84  78 134)
             (b1 108  32 168  82)
             (b2  78  84 138 134)
             (b3  48 136 108 186)
             (b4  18 188  78 238)
             (c1 168  32 228  82)
             (c2 138  84 198 134)
             (c3 108 136 168 186)
             (c4  78 188 138 238)
             (c5  48 240 108 290)
             (c6  18 292  78 342)
             (d1 228  32 288  82)
             (d2 198  84 258 134)
             (d3 168 136 228 186)
             (d4 138 188 198 238)
             (d5 108 240 168 290)
             (d6  78 292 138 342)
             (d7  48 344 108 394)
             (d8  18 396  78 446)
             (e1 288  32 348  82)
             (e2 258  84 318 134)
             (e3 228 136 288 186)
             (e4 198 188 258 238)
             (e5 168 240 228 290)
             (e6 138 292 198 342)
             (e7 108 344 168 394)
             (e8  78 396 138 446)
             (e9  48 448 108 498)
             (f1 348  32 408  82)
             (f2 318  84 378 134)
             (f3 288 136 348 186)
             (f4 258 188 318 238)
             (f5 228 240 288 290)
             (f6 198 292 258 342)
             (f7 168 344 228 394)
             (f8 138 396 198 446)
             (f9 108 448 168 498)
             (g1 408  32 468  82)
             (g2 378  84 438 134)
             (g3 348 136 408 186)
             (g4 318 188 378 238)
             (g5 288 240 348 290)
             (g6 258 292 318 342)
             (g7 228 344 288 394)
             (g8 198 396 258 446)
             (g9 168 448 228 498)
             (h1 468  32 528  82)
             (h2 438  84 498 134)
             (h3 408 136 468 186)
             (h4 378 188 438 238)
             (h5 348 240 408 290)
             (h6 318 292 378 342)
             (h7 288 344 348 394)
             (h8 258 396 318 446)
             (h9 228 448 288 498)
             (i1 528  32 588  82)
             (i2 498  84 558 134)
             (i3 468 136 528 186)
             (i4 438 188 498 238)
             (i5 408 240 468 290)
             (i6 378 292 438 342)
             (i7 348 344 408 394)
             (i8 318 396 378 446)
             (i9 288 448 348 498)
             (j3 528 136 588 186)
             (j4 498 188 558 238)
             (j5 468 240 528 290)
             (j6 438 292 498 342)
             (j7 408 344 468 394)
             (j8 378 396 438 446)
             (j9 348 448 408 498)
             (k5 528 240 588 290)
             (k6 498 292 558 342)
             (k7 468 344 528 394)
             (k8 438 396 498 446)
             (k9 408 448 468 498)
             (l7 528 344 588 394)
             (l8 498 396 558 446)
             (l9 468 448 528 498)
             (m9 528 448 588 498)
      )
</source>
</spoiler>
Это лишь половина дела! Имена позиций доски необходимо поправить, чтобы привести их в соответствие с общепринятой нотацией. Кроме того, требуется связать пары позиций направлениями, не забыв "зациклить" доску по краям. Всё вместе вылилось в немаленький объём <a href="https://github.com/GlukKazan/ZoG/commit/b9a2c3fe4880fdf7f69eeecc80f2eed9b0cc15e5">ручной работы</a>, но я не стал писать под это дело скрипт (хотя возможно и стоило).

<h4><b>Сон разума</b></h4>
Хоть я и познакомился с "Чейзом" довольно давно, поиграть в него, до последнего времени, никак не удавалось. Очень уж причудливая для этого требуется доска. При некоторой сноровке, можно играть на доске <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> (9x9), но её у меня тоже не было. Обычная шахматная доска (8x8) для этой игры непригодна совершенно. Доску для "Чейза" удалось приобрести на прошлом "<a href="http://zilantkon.ru/">Зилантконе</a>", но кубики в комплект не входили. Своё приобретение я забросил на дальнюю полку и там бы оно вероятно и провалялось, если бы в дело не вмешался случай. 

<spoiler title="Случайности не случайны">
Мою дочку пригласила на день рожденья семья, с которой мы давно и крепко дружим. В качестве подарка, была выбрана <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D1%87%D0%BA%D0%B8%D0%BD_%28%D0%B8%D0%B3%D1%80%D0%B0%29">настольная игра</a>, а поскольку нескольким взрослым предстояло просидеть около трёх часов в детском кафе, их (и меня) тоже требовалось чем-то занять. В качестве возможного варианта, была предложена <a href="https://ru.wikipedia.org/wiki/Cluedo">другая игра</a>, но поскольку я предпочитаю игры более абстрактные, то решил с собой тоже что нибудь принести. Первоначально, я подумал об <a href="http://skyruk.livejournal.com/231444.html?thread=4494868">Уре</a>, но в имевшемся у меня комплекте, его D2 "кости", выполненные в форме полукруглых палочек (более характерных для <a href="http://skyruk.livejournal.com/183773.html">Сенета</a>), были довольно неудобны, при броске производили много шума и могли помешать окружающим.

Тут-то я и вспомнил про "Чейз". Предстояло пополнить его комплект двадцатью игральными кубиками, но поскольку я всё равно направлялся в магазин настольных игр (за подарком), это (как мне тогда казалось) не являлось проблемой. На сайте, я присмотрел себе замечательные полупрозрачные кубики (по 70 рублей за штуку), но жизнь внесла коррективы. В магазине выяснилось, что присмотренные мной кубики имеются лишь в <b>одном</b>  экземпляре. Что я могу сказать, Казань - не Москва, пришлось удовольствоваться бюджетным вариантом и набирать вожделенные кубики из предложенной продавцом россыпи ико-, доде- и прочих -аэдров. Красный или зелёный комплект собрать не удалось, но синие и белые (ладно, ладно, один <b>слегка</b> желтоватый) кубики в наличии имелись.
</spoiler>
Правила я, разумеется, переврал (рассказывал о памяти). В моём изложении, траектории разлёта "осколков", на выходе из "репликатора", напоминали не наконечник стрелы, а скорее латинскую букву '<b>Y</b>'. По всей видимости, определённую роль сыграло её сходство со схемами распада элементарных частиц. "Осколки" двигались не на одну клетку (как в оригинальном варианте правил), а в соответствии с их "номиналом". Кроме того, такой ход было гораздо легче заблокировать. Любые препятствия (будь то фигура, стоящая на пути разлёта "осколков" или наличие на доске десяти фигур) трактовались как <b>невозможность</b> выполнения хода. В оригинальной версии правил, заблокировать "<b>Chamber</b>" можно лишь установив фигуру на пути входа в него.

Другим звеном "<a href="https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BF%D0%BE%D1%80%D1%87%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%82%D0%B5%D0%BB%D0%B5%D1%84%D0%BE%D0%BD">испорченного телефона</a>" послужил сам <a href="http://skyruk.livejournal.com/334947.html">Дмитрий</a>. В своём описании "Чейза" он упомянул, что фигура, выполнившая взятие, имеет право на повторный ход (по аналогии с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашками</a>). В <a href="http://superdupergames.org/rules/chase.pdf">первоисточнике</a> не было ни слова об этом (о чём ему не преминул сообщить уважаемый <a href="http://gest.livejournal.com/">Гест</a>), но я, в тот момент, не обратил на это внимания. Надо сказать, идея скрестить "Чейз" с "Шашками" уже тогда вызывала много вопросов. Следовало ли распространять правило повторного хода на случай <b>bumping</b>-а? На "осколки", полученные при разделении фигуры? Что следовало делать если взятие выполнял каждый из осколков? А если то же с <b>bumping</b>-ом? Но, нет таких сложностей, которых мы не могли бы себе создать! Я с энтузиазмом принялся за работу...

<spoiler title="Закат Солнца вручную">
Разумеется, в первую очередь, я попытался использовать механизм частичных ходов, используемый в ZoG для игр, наподобие <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>. Совсем <a href="https://geektimes.ru/post/269152/">недавно</a> он мне здорово пригодился, в процессе создания очень <a href="https://en.wikipedia.org/wiki/Ko_shogi">непростой игры</a>. До сих пор, мне не приходилось использовать его в Axiom, но всё когда-то бывает в первый раз. Суть частичного хода в том, что сложный, составной ход разбивается на мелкие шажки. В шашках, взятие фигуры противника реализовано именно таким частичным ходом. При этом, используются ещё и, так называемые, "режимы" выполнения хода, позволяющие указать, что следующий частичный ход также <b>обязан</b> выполнить взятие.

Я не в восторге от реализации составных ходов в ZoG и вот почему. Прежде всего, в понимании ZoG частичные ходы - это именно <b>отдельные</b>, независимые действия. По сути, это просто набор ходов, выполняемых одним и тем же игроком, друг за другом. Мы не можем передавать какую либо промежуточную информацию между частичными ходами! Глобальные и позиционные флаги автоматически сбрасываются, в начале каждого хода. Это дьявольски неудобно, но это лишь часть беды! ZoG не может рассматривать составной ход как единую сущность (в частности, именно по этой причине пришлось вводить хардкодную опцию "<b>maximal captures</b>", для реализации "правила большинства". Какие-то другие идеи, не укладывающиеся в этот хардкод, реализовать уже не удастся!

<video>https://www.youtube.com/watch?v=vWPlWiLOGu8</video>

Это фрагмент партии из игры "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2462">Mana</a>", придуманной Клодом Лероем. Количество чёрточек, на каждой позиции, показывает, на сколько шагов может переместиться фигура. Должно быть выполнено точное число шагов и, при этом, в процессе движения нельзя поворачиваться назад. Тут-то нас и поджидает засада! Очень редко, но бывает так, что фигура, выполнив два шага, загоняет себя "в тупик". Она не может продолжить движение, поскольку ей мешают другие фигуры и обязана сделать ещё один шаг, поскольку должна завершить ход! А ZoG, в свою очередь, не предоставляет ровно никаких средств, чтобы решить эту проблему!

Другим ограничением является то, что составной ход может продолжать лишь та же самая фигура, которая перемещалась предыдущим частичным ходом. Именно так всё и происходит в шашках, но в "Чейзе" ситуация немного сложнее. Например, взятие может быть осуществлено при помощи <b>bumping</b>-а, то есть не той фигурой, которая выполняла ход! С <b>Chamber</b>-ходом всё ещё сложнее. Оба осколка могут взять фигуры противника и, по логике, имеют право выполнить следующий частичный ход. И обе они не являются той фигурой которая заходила в <b>Chamber</b> (той фигуры, на доске, вообще уже нет)!

<spoiler title="Меньше слов - больше кода">
<source lang="diff">
: val ( -- n )
	piece-type mark -
;

: mirror ( 'dir  -- 'dir )
	DUP ['] nw = IF
		DROP ['] sw
	ELSE
		DUP ['] ne = IF
			DROP ['] se
		ELSE
			DUP ['] sw = IF
				DROP ['] nw
			ELSE
				['] se = verify
				['] ne
			ENDIF
		ENDIF
	ENDIF
;

: step ( 'dir  -- 'dir )
	DUP EXECUTE NOT IF
		mirror
		DUP EXECUTE verify
	ENDIF
;

: bump ( 'dir -- )
	BEGIN
		here E5 <> verify
		friend? here from <> AND IF
			piece-type SWAP step SWAP
			create-piece-type
			FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;

: slide ( 'dir n -- )
	alloc-path !
	val SWAP BEGIN
		step
		SWAP 1- DUP 0= IF
			TRUE
		ELSE
			my-empty? verify
			SWAP FALSE
		ENDIF
	UNTIL DROP
	from here move
+	enemy? IF
+		cont-type partial-move-type
+	ENDIF
	bump enemy? IF
		alloc-all
	ELSE
		alloc-path @ 0= verify
	ENDIF
	add-move
;
</source>
</spoiler>
В конечном счёте, всё сводится к добавлению вызова <b>partial-move-type</b> при взятии вражеской фигуры (до выполнения <b>bumping</b>-а). Ограничения, о которых я говорил выше, остаются в силе. Мы не можем выполнить частичный ход, если взятие было осуществлено не той фигурой которая начала ход (в результате <b>bumping</b>-а или "расщепления" в <b>Chamber</b>), но даже в таком виде, этот код был бы неплохим решением. Если бы он заработал:

<img align="center" src="https://habrastorage.org/files/1da/1f7/b16/1da1f7b16b7d452ab2f4d31ba9c557c1.PNG"/>
Я так и не смог расшифровать этот ребус и просто отослал код разработчику Axiom. Грег пока не ответил, но вроде бы работает над выпуском патча, который, я надеюсь, решит проблему. Странно здесь то, что частичные ходы в Axiom действительно работают! Более того, они существенно расширяют функциональность ZRF. Всё это хорошо описано в документации и используется в нескольких приложениях. Видимо, мне просто не повезло.

Поскольку частичные ходы не работали, пришлось искать другой способ решения проблемы. Если не удаётся выполнить все действия в рамках одного хода, можно попробовать растянуть их на несколько ходов! Я уже делал так в других играх, создавая на доске специальную невидимую позицию, на которой размещалась фигура-флаг. Если фигура принадлежала противнику, игрок знал, что должен пропустить свой ход. Это <a href="https://github.com/GlukKazan/ZoG/commit/24cf406e66912648104de3fa86a78d6c6782bed2">небольшое изменение</a>, но оно потянуло за собой другие. Мне пришлось <a href="https://github.com/GlukKazan/ZoG/commit/3f1ead93abe1e031f9cb6e801fe44163a42d8dba">помечать фигуры</a>, продолжающие ход (теперь это могли быть не только фигуры, начавшие ход), а также <a href="https://github.com/GlukKazan/ZoG/commit/848e6a154103dc7621469017e94adda69d2a1f1f">усложнить</a> порядок передачи хода. В целом, это было довольно громоздкое и очень неуклюжее решение.
</spoiler>
Результатом моих усилий стала весьма оригинальная модификация игры, к сожалению имевшая слишком мало общего с оригиналом. Кроме того, использование "сложного" порядка передачи ходов (<b>turn-order</b>) наотмашь било по "интеллекту" AI. Используемый им <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BA%D1%81">минимаксный алгоритм</a> крайне негативно реагирует на подобные вольности, а в "иммунном" к ним <b>search-engine</b> (альтернативном варианте построения Axiom AI) невероятно сложно реализовать поиск в глубину.

<h4><b>По хлебным крошкам</b></h4>
Хорошо, допустим мы, своим ходом, забираем одну (или даже две фигуры) противника, после чего, распределяем полученные очки по оставшимся его фигурам, обязательно начиная с младших. Но как быть, если младших фигур несколько? Например, в самом начале игры, у каждого из игроков имеется по две "единички". Взяв любую фигуру номиналом от одного до пяти очков, мы получим два варианта распределения очков и ход игры может серьёзным образом измениться, в зависимости от того, какой из них мы выберем.

<spoiler title="Те же и комбинаторика">
Здесь, практически на ровном месте, возникает интересная комбинаторная задача. Для того, чтобы понять, какими способами (при взятии фигуры) могут распределяться очки, необходимо представлять себе все сочетания фигур (на стороне одного из игроков), способные появиться в игре. Есть всего три условия:

<ol>
	<li>Каждая фигура может иметь номинал от 1 до 6 очков</li>
	<li>Количество фигур не может превышать 10</li>
	<li>Суммарное количество очков всегда равно 25</li>
</ol>
Не сомневаюсь, что у этой задачи есть красивое аналитическое решение (возможно читатели мне его подскажут), но я не стал его искать. Я просто составил скрипт для генерации всех возможных наборов фигур, удовлетворяющих заданным условиям. Фигуры в наборах упорядочены по номиналу, поскольку именно в этом порядке распределяются взятые очки.

<spoiler title="Скрипт">
<source lang="perl">
my @d;
my %s;

sub out {
  my ($deep) = @_;
  for (my $i = 0; $i < $deep; $i++) {
      print "$d[$i]";
  }
  print "\n";
}

sub dice {
  my ($start, $deep, $sum) = @_;
  if ($sum == 25) {
      out($deep);
  }
  if ($deep < 10 && $sum < 25) {
     for (my $i = $start; $i <= 6; $i++) {
         $d[$deep] = $i;
         dice($i, $deep + 1, $sum + $i);
     }
  }
}

dice(1);
</source>
</spoiler>
<spoiler title="Результат">
<source>
1111111666
1111112566
1111113466
1111113556
1111114456
1111114555
1111122466
1111122556
1111123366
1111123456
1111123555
1111124446
1111124455
111112666
1111133356
1111133446
1111133455
1111134445
111113566
1111144444
111114466
111114556
111115555
1111222366
1111222456
1111222555
1111223356
1111223446
1111223455
1111224445
111122566
1111233346
1111233355
1111233445
1111234444
111123466
111123556
111124456
111124555
1111333336
1111333345
1111333444
111133366
111133456
111133555
111134446
111134455
11113666
111144445
11114566
11115556
1112222266
1112222356
1112222446
1112222455
1112223346
1112223355
1112223445
1112224444
111222466
111222556
1112233336
1112233345
1112233444
111223366
111223456
111223555
111224446
111224455
11122666
1112333335
1112333344
111233356
111233446
111233455
111234445
11123566
111244444
11124466
11124556
11125555
1113333334
111333346
111333355
111333445
111334444
11133466
11133556
11134456
11134555
11144446
11144455
1114666
1115566
1122222256
1122222346
1122222355
1122222445
1122223336
1122223345
1122223444
112222366
112222456
112222555
1122233335
1122233344
112223356
112223446
112223455
112224445
11222566
1122333334
112233346
112233355
112233445
112234444
11223466
11223556
11224456
11224555
1123333333
112333336
112333345
112333444
11233366
11233456
11233555
11234446
11234455
1123666
11244445
1124566
1125556
113333335
113333344
11333356
11333446
11333455
11334445
1133566
11344444
1134466
1134556
1135555
1144456
1144555
115666
1222222246
1222222255
1222222336
1222222345
1222222444
122222266
1222223335
1222223344
122222356
122222446
122222455
1222233334
122223346
122223355
122223445
122224444
12222466
12222556
1222333333
122233336
122233345
122233444
12223366
12223456
12223555
12224446
12224455
1222666
122333335
122333344
12233356
12233446
12233455
12234445
1223566
12244444
1224466
1224556
1225555
123333334
12333346
12333355
12333445
12334444
1233466
1233556
1234456
1234555
1244446
1244455
124666
125566
133333333
13333336
13333345
13333444
1333366
1333456
1333555
1334446
1334455
133666
1344445
134566
135556
1444444
144466
144556
145555
16666
2222222236
2222222245
2222222335
2222222344
222222256
2222223334
222222346
222222355
222222445
2222233333
222223336
222223345
222223444
22222366
22222456
22222555
222233335
222233344
22223356
22223446
22223455
22224445
2222566
222333334
22233346
22233355
22233445
22234444
2223466
2223556
2224456
2224555
223333333
22333336
22333345
22333444
2233366
2233456
2233555
2234446
2234455
223666
2244445
224566
225556
23333335
23333344
2333356
2333446
2333455
2334445
233566
2344444
234466
234556
235555
244456
244555
25666
33333334
3333346
3333355
3333445
3334444
333466
333556
334456
334555
344446
344455
34666
35566
444445
44566
45556
55555
</source>
</spoiler>
Всего 294 возможных варианта. Впрочем, это только половина дела. Нам более интересны не сами расклады, а то, какими способами мы сможем разместить очки взятой фигуры в каждом из них. Не буду утомлять читателя подробными рассуждениями, покажу лишь скрипт и окончательный результат его работы:

<spoiler title="Скрипт">
<source lang="perl">
my @d;
my %s;

sub out {
  my ($deep) = @_;
  for (my $i = 0; $i < $deep; $i++) {
      print "$d[$i]";
  }
  print "\n";
}

sub proc {
  my ($x, $r, $m) = @_;
  if ($x == 0) {
      $s{$r}++;
  } else {
     my $n = $x % 10;
     for (my $i = 0; $i < $n; $i++) {
        proc(int($x / 10), $r + $i * $m, $m * 10);
     }
  }
}

sub alloc {
  my ($x, $deep, $res) = @_;
  if ($x == 0) {
      proc($res, 0, 1);
  } else {
      my $vl = 6;
      for (my $i = 0; $i < $deep; $i++) {
         if ($d[$i] < $vl) {
             $vl = $d[$i];
         }
      }
      if ($vl < 6) {
         my $cn = 0;
         my $ix = 0;
         for (my $i = 0; $i < $deep; $i++) {
             if ($d[$i] == $vl) {
                $cn++;
                $ix = $i;
             }
         }
         my $y = $d[$ix]; $d[$ix] = 6;
         $x -= 6 - $vl;
         if ($x < 0) {
             $x = 0;
         }
         alloc($x, $deep, $res * 10 + $cn);
         $d[$ix] = $y;
      }
  }
}

sub dice {
  my ($start, $deep, $sum) = @_;
  if ($sum == 25) {
     for (my $i = 0; $i < $deep; $i++) {
         my $x = $d[$i]; $d[$i] = 6;
         alloc($x, $deep, 0);
         $d[$i] = $x;
     }
  }
  if ($deep < 10 && $sum < 25) {
     for (my $i = $start; $i <= 6; $i++) {
         $d[$deep] = $i;
         dice($i, $deep + 1, $sum + $i);
     }
  }
}

dice(1, 0, 0);

my $all;

foreach my $k (sort { $s{$a} <=> $s{$b} } keys %s) {
  $all += $s{$k};
  print "$k\t=> $s{$k}\n";
}

print "\n$all\n";</source></spoiler>
<spoiler title="Результат">
<source>
102	=> 1
331	=> 1
200	=> 1
...
22	=> 93
5	=> 106
21	=> 152
20	=> 152
11	=> 152
10	=> 220
4	=> 259
3	=> 584
2	=> 1061
1	=> 1677
0	=> 2407

7954
</source>
</spoiler>
Слева - цепочки цифр, управляющие порядком распределения взятых очков. Например, "20" означает, что мы начинаем распределение с первой попавшейся фигуры (мы начинаем их подсчёт с 0), затем, распределяем в третью из оставшихся фигур с минимальным номиналом. Очевидно, что такая схема распределения возможна лишь для раскладов, не менее чем с четырьмя "минимальными" фигурами, например "3333445" (причём, распределить таким образом получится только "четвёрку" или "пятёрку"). Результат работы скрипта показывает, что распределяя очки, каждый раз в первую попавшуюся "минимальную" фигуру, мы покроем 30% (2407/7954) всех возможных ситуаций, а используя всего лишь три схемы распределения, уже более 64%!
</spoiler>
Специально для таких случаев, <a href="http://zillions-of-games.com/">ZoG</a> предоставляет интересную интерфейсную возможность. Выполняя ход, игрок указывает два поля: начальное и конечное. В том случае, если существует несколько различных возможных ходов, соединяющих выбранную пару полей, игроку предоставляется возможность выбора (всплывающее меню). Простейший пример - превращение пешек в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>. Дойдя до последней горизонтали, пешка может превратиться в любую из фигур (от слона до ферзя) и выбор должен быть сделан игроком. Именно этой опцией я и решил воспользоваться.

<spoiler title="За Гензель и Гретель!">
Суть идеи проста - для того, чтобы ядро ZoG сочло ходы разными, достаточно, чтобы они имели разное ZSG-представление. Попросту говоря, эти ходы должны делать различные вещи. Добиться этого <abbr title="Да что там, даже ходы делающие одни и те же вещи зачастую имеют различное ZSG-представление!">не сложно</abbr>, необходимо, всего навсего управлять тем, к каким из фигур будут добавляться очки. Тот факт, что количество фигур (с каждой стороны) не может превышать 10, позволяет использовать удобную десятичную систему счисления. Мы уже встречались с этими числами в предыдущей врезке. Каждая отдельная цифра означает ту фигуру (с нуля, по порядку), к которой будут добавлены очки. После каждого использования, от числа отрезается один десятичный разряд. В конечном итоге остаётся 0, означающий использование первой попавшейся фигуры.

<spoiler title="Ещё немного кода">
<source>
VARIABLE	alloc-path
VARIABLE	alloc-val
VARIABLE	alloc-target
VARIABLE	alloc-pos

: alloc-to ( pos -- )
	DUP add-pos
	DUP val-at 6 SWAP -
	DUP alloc-val @ > IF
		DROP alloc-val @
		0 alloc-val !
	ELSE
		alloc-val @ OVER - alloc-val !
	ENDIF
	my-next-player ROT ROT
	OVER piece-type-at + SWAP
	create-player-piece-type-at
;

: alloc ( -- )
	6 0 BEGIN
		DUP enemy-at? OVER not-in-pos? AND IF
			SWAP OVER val-at MIN SWAP
		ENDIF
		1+ DUP A9 >
	UNTIL DROP
	DUP 6 < IF
		alloc-target !
		alloc-path @ 10 MOD alloc-pos !
		0 BEGIN
			DUP enemy-at? OVER not-in-pos? AND IF
				DUP val-at alloc-target @ = IF
					alloc-pos @ 0= IF
						DUP alloc-to
						0 alloc-target !
						DROP A9
					ELSE
						alloc-pos --
					ENDIF
				ENDIF
			ENDIF
			1+ DUP A9 >
		UNTIL DROP
		alloc-target @ 0= verify
		alloc-val @ 0> IF
			alloc-path @ 10 / alloc-path !
			RECURSE
		ENDIF
	ELSE
		DROP
	ENDIF
;

: alloc-all ( -- )
	0 pos-count !
	here add-pos
	alloc
;
</source>
</spoiler>
Переменная <b>alloc-path</b> содержит нашу последовательность "хлебных крошек". Разумеется, было бы совершенно слишком расточительно определять в коде все 105 возможных управляющих последовательностей, но мы уже выяснили, что они не равнозначны. Большинство из них будут использоваться крайне редко, а всего 4 из них покроют большую часть возможных случаев. К сожалению, даже этим воспользоваться не удалось:

<spoiler title="Хлебные крошки">
<source lang="diff">
: eat ( 'dir n -- )
	LITE-VERSION NOT IF
		check-pass
		check-neg
	ENDIF
+	alloc-path !
	val SWAP BEGIN
		step
		SWAP 1- DUP 0= IF
			TRUE
		ELSE
			my-empty? verify
			SWAP FALSE
		ENDIF
	UNTIL DROP
	from here move
	LITE-VERSION NOT enemy? AND IF
		from piece-type-at mark - ABS
		mark SWAP - create-piece-type
	ENDIF
	bump DROP
	here E5 <> verify
	enemy? verify
	LITE-VERSION NOT IF
		clear-neg
		set-pass
	ENDIF
+	val alloc-val !
+	alloc-all
	add-move
;

: eat-nw-0 ( -- ) ['] nw 0 eat ;
: eat-sw-0 ( -- ) ['] sw 0 eat ;
: eat-ne-0 ( -- ) ['] ne 0 eat ;
: eat-se-0 ( -- ) ['] se 0 eat ;
: eat-w-0  ( -- ) ['] w  0 eat ;
: eat-e-0  ( -- ) ['] e  0 eat ;

: eat-nw-1 ( -- ) ['] nw 1 eat ;
: eat-sw-1 ( -- ) ['] sw 1 eat ;
: eat-ne-1 ( -- ) ['] ne 1 eat ;
: eat-se-1 ( -- ) ['] se 1 eat ;
: eat-w-1  ( -- ) ['] w  1 eat ;
: eat-e-1  ( -- ) ['] e  1 eat ;

: eat-nw-2 ( -- ) ['] nw 2 eat ;
: eat-sw-2 ( -- ) ['] sw 2 eat ;
: eat-ne-2 ( -- ) ['] ne 2 eat ;
: eat-se-2 ( -- ) ['] se 2 eat ;
: eat-w-2  ( -- ) ['] w  2 eat ;
: eat-e-2  ( -- ) ['] e  2 eat ;

: eat-nw-3 ( -- ) ['] nw 3 eat ;
: eat-sw-3 ( -- ) ['] sw 3 eat ;
: eat-ne-3 ( -- ) ['] ne 3 eat ;
: eat-se-3 ( -- ) ['] se 3 eat ;
: eat-w-3  ( -- ) ['] w  3 eat ;
: eat-e-3  ( -- ) ['] e  3 eat ;

{moves p-moves
	{move} split-nw-0	{move-type} normal-priority
	{move} split-ne-0	{move-type} normal-priority
	{move} split-sw-0	{move-type} normal-priority
	{move} split-se-0	{move-type} normal-priority
	{move} split-w-0	{move-type} normal-priority
	{move} split-e-0	{move-type} normal-priority
	{move} split-nw-1	{move-type} normal-priority
	{move} split-ne-1	{move-type} normal-priority
	{move} split-sw-1	{move-type} normal-priority
	{move} split-se-1	{move-type} normal-priority
	{move} split-w-1	{move-type} normal-priority
	{move} split-e-1	{move-type} normal-priority
+	{move} eat-nw-0		{move-type} normal-priority
+	{move} eat-ne-0		{move-type} normal-priority
+	{move} eat-sw-0		{move-type} normal-priority
+	{move} eat-se-0		{move-type} normal-priority
+	{move} eat-w-0		{move-type} normal-priority
+	{move} eat-e-0		{move-type} normal-priority
+	{move} eat-nw-1		{move-type} normal-priority
+	{move} eat-ne-1		{move-type} normal-priority
+	{move} eat-sw-1		{move-type} normal-priority
+	{move} eat-se-1		{move-type} normal-priority
+	{move} eat-w-1		{move-type} normal-priority
+	{move} eat-e-1		{move-type} normal-priority
+	{move} eat-nw-2		{move-type} normal-priority
+	{move} eat-ne-2		{move-type} normal-priority
+	{move} eat-sw-2		{move-type} normal-priority
+	{move} eat-se-2		{move-type} normal-priority
+	{move} eat-w-2		{move-type} normal-priority
+	{move} eat-e-2		{move-type} normal-priority
+	{move} eat-nw-3		{move-type} normal-priority
+	{move} eat-ne-3		{move-type} normal-priority
+	{move} eat-sw-3		{move-type} normal-priority
+	{move} eat-se-3		{move-type} normal-priority
+	{move} eat-w-3		{move-type} normal-priority
+	{move} eat-e-3		{move-type} normal-priority
	{move} slide-nw		{move-type} normal-priority
	{move} slide-ne		{move-type} normal-priority
	{move} slide-sw		{move-type} normal-priority
	{move} slide-se		{move-type} normal-priority
	{move} slide-w		{move-type} normal-priority
	{move} slide-e		{move-type} normal-priority
-(	{move} exchange-1-nw	{move-type} normal-priority
-	{move} exchange-1-ne	{move-type} normal-priority
-	{move} exchange-1-sw	{move-type} normal-priority
-	{move} exchange-1-se	{move-type} normal-priority
-	{move} exchange-1-w	{move-type} normal-priority
-	{move} exchange-1-e	{move-type} normal-priority
-	{move} exchange-2-nw	{move-type} normal-priority
-	{move} exchange-2-ne	{move-type} normal-priority
-	{move} exchange-2-sw	{move-type} normal-priority
-	{move} exchange-2-se	{move-type} normal-priority
-	{move} exchange-2-w	{move-type} normal-priority
-	{move} exchange-2-e	{move-type} normal-priority
-	{move} exchange-3-nw	{move-type} normal-priority
-	{move} exchange-3-ne	{move-type} normal-priority
-	{move} exchange-3-sw	{move-type} normal-priority
-	{move} exchange-3-se	{move-type} normal-priority
-	{move} exchange-3-w	{move-type} normal-priority
-	{move} exchange-3-e	{move-type} normal-priority
-	{move} exchange-4-nw	{move-type} normal-priority
-	{move} exchange-4-ne	{move-type} normal-priority
-	{move} exchange-4-sw	{move-type} normal-priority
-	{move} exchange-4-se	{move-type} normal-priority
-	{move} exchange-4-w	{move-type} normal-priority
-	{move} exchange-4-e	{move-type} normal-priority
-	{move} exchange-5-nw	{move-type} normal-priority
-	{move} exchange-5-ne	{move-type} normal-priority
-	{move} exchange-5-sw	{move-type} normal-priority
-	{move} exchange-5-se	{move-type} normal-priority
-	{move} exchange-5-w	{move-type} normal-priority
-	{move} exchange-5-e	{move-type} normal-priority )
moves}
</source>
</spoiler>
По всей видимости, в Axiom имеется ограничение на количество определяемых ходов (никак не отражённое в документации). Как я это определил? Очень просто! Когда я добавляю в код все определения, программа крэшится при старте. Если я убираю часть определений (например <b>exchange</b>-ходы), всё работает нормально. К сожалению, от идеи вариативного распределения очков пришлось отказаться.
</spoiler>
Строго говоря, это не вполне корректное решение. По правилам "Чейза", распределять очки должен не тот игрок, который выполнил ход, а его противник. Я не имею ни малейшего представления, о том, как этого можно добиться, используя ZoG, но есть очень простой обходной путь. Интерфейс ZoG предоставляет удобную интерфейсную возможность редактирования доски. Используя команды всплывающего меню, игрок может удалить любую фигуру на доске или создать другую. Эта возможность незаменима при отладке и я часто ей пользуюсь. В общем, игрок которому не понравилось автоматическое распределение очков, может легко перераспределить их вручную (очерёдность хода, при этом, не нарушается). Необходимо соблюдать лишь минимальную осторожность. В процессе редактирования не следует допускать ситуации, когда у одного из игроков остаётся менее 5 фигур, поскольку в этом случае, ему будет немедленно засчитано поражение и игра будет остановлена.

<h4><b>... считай до одного!</b></h4>
Поскольку идея "вариативного" распределения съеденных очков провалилась, я вернулся к разработке игры, посредством ZRF. Axiom-реализация, в принципе, тоже работала, но ей всё ещё не хватало AI (штатным ZoG-овским Аксиома пользоваться не умеет). В целом, эта задача сводится к правильному кодированию оценочной функции (для эстетов есть ещё и "<a href="https://habrahabr.ru/post/227835/">Custom Engine</a>"), но и это - весьма не просто! Во всяком случае, стандартная оценочная функция, учитывающая мобильность и материальный баланс, в "Чейзе" проявила себя не лучшим образом.

<spoiler title="Немножко деталей">
Оценочная функция, о которой я говорю, выглядит так:
<source>
: OnEvaluate ( -- score ) 
	mobility
	current-player material-balance KOEFF * +
;
</source>
Самый хитрый зверь здесь - <b>mobility</b>. Фактически - это количество всех возможных ходов игрока, из которого вычитается количество всех возможных ходов противника. Все ходы игрока, на момент оценки позиции, <b>уже</b> сгенерированы - подсчитать их не сложно, а вот чтобы сгенерировать ходы противника, приходится использовать немножко аксиомовской магии:
<source>
: mobility ( -- score )
	move-count
	current-player TRUE 0 $GenerateMoves
	move-count -
	$DeallocateMoves
;
</source>
Далее, полученная "мобильность" складывается с "материальным балансом", умноженным на некоторый константный коэффициент. Материальный баланс - это просто суммарная стоимость всех своих фигур, за вычетом стоимости фигур противника. Кстати, это объясняет, почему для фигур в Axiom я выбрал такие странные числовые значения:
<source>
{pieces
	{piece}		p1	{moves} p-moves 6   {value}
	{piece}		p2	{moves} p-moves 5   {value}
	{piece}		p3	{moves} p-moves 4   {value}
	{piece}		p4	{moves} p-moves 3   {value}
	{piece}		p5	{moves} p-moves 2   {value}
	{piece}		p6	{moves} p-moves 1   {value}
pieces}
</source>
Я стремился сделать "мелкие" фигуры более значимыми, поскольку игроку действительно выгодно держать на доске как можно больше мелких фигур. В общем, в таком виде, всё это не сработало! AI вёл себя просто ужасно. Иногда складывалось впечатление, что он целенаправленно стремиться проиграть. Я думал о том как улучшить оценочную функцию, включив в неё бонусы/штрафы за взаимные угрозы фигур, образование кластеров (из фигур, стоящих вплотную друг к другу), достижимости <b>Chamber</b> и пр., но решил не тратить на это время, а просто переключиться на ZRF. Штатный AI ZoG-а традиционно показывает себя сильным, в подобных играх.
</spoiler>
Оставалась всего одна мелочь - в ZRF напрочь отсутствовала арифметика! "Чейз" - такая игра, в которой постоянно приходится считать! В некоторых случаях можно выкрутится. Например, при определении поражения игрока, вместо подсчёта очков (до 25-ти) на всех фигурах, можно ограничиться стандартной проверкой количества фигур. Поскольку 25 очков заведомо невозможно разместить на 4 фигурах, и всегда можно распределить по большему количеству фигур, следующих условий завершения игры вполне достаточно:

<source lang="lisp">
(loss-condition (Red White) (pieces-remaining 4) )
(loss-condition (Red White) (pieces-remaining 3) )
</source>
Вторая проверка необходима, поскольку в игре возможна ситуация, когда одним ходом забираются сразу две фигуры (после расщепления фигуры в <b>Chamber</b>). К сожалению, есть одна задача, в которой целочисленная арифметика необходима! Разумеется, это распределение "съеденных" очков. В ZRF я не пытаюсь предложить несколько возможных вариантов распределения, на выбор. Мне необходимо просто обойти все фигуры, начиная с младших, и правильно добавить к ним ещё не распределённые очки. Вот как я это делаю:

<spoiler title="В основном, из палок">
Целые числа будем делать из булевских флагов (просто потому что больше не из чего). В ZRF-приложении их можно создать не больше тридцати двух, но нам вполне хватит четырёх (чтобы уметь считать до десяти). Макросы обеспечат (более менее) комфортную работу. Для начала, совершенно необходимо уметь обнулять "число", а также прибавлять (и отнимать) единичку:

<spoiler title="Ноль плюс/минус один">
<source lang="lisp">
(define clear
   (set-flag $1-8 false) (set-flag $1-4 false)
   (set-flag $1-2 false) (set-flag $1-1 false)
)

(define inc
   (if (flag? $1-1)
       (set-flag $1-1 false)
       (if (flag? $1-2)
           (set-flag $1-2 false)
           (if (flag? $1-4)
               (set-flag $1-4 false)
               (if (flag? $1-8)
                   (set-flag $1-8 false)
                else
                   (set-flag $1-8 true)
               )
            else
               (set-flag $1-4 true)
           )
        else
           (set-flag $1-2 true)
       )
    else
       (set-flag $1-1 true)
   )
)

(define dec
   (if (not-flag? $1-1)
       (set-flag $1-1 true)
       (if (not-flag? $1-2)
           (set-flag $1-2 true)
           (if (not-flag? $1-4)
               (set-flag $1-4 true)
               (if (not-flag? $1-8)
                   (set-flag $1-8 true)
                else
                   (set-flag $1-8 false)
               )
            else
               (set-flag $1-4 false)
           )
        else
           (set-flag $1-2 false)
       )
    else
       (set-flag $1-1 false)
   )
)
</source>
</spoiler>
Пользоваться этим - совсем просто:

<spoiler title="Не больше десяти!">
<source lang="lisp">
(define not-10?
   (or (not-flag? $1-8)
       (flag? $1-4)
       (not-flag? $1-2)
       (flag? $1-1)
   )
)

(define calc
   (clear x)
   mark START
   (while (on-board? next) 
      next
      (if friend?
          (inc x)
      )
   )
   (verify (not-10? x))
   back
)
</source>
</spoiler>
Главный цирк, как и предполагалось, начинается когда дело доходит до распределения очков по фигурам. Для начала, эти очки необходимо получить из съедаемой фигуры. Здесь подход совершенно прямолинейный. ZRF - не знает чисел, но мы-то знаем!

<spoiler title="Инициализация">
<source lang="lisp">
(define init
   (clear $1)
   (if (or (piece? p1) (piece? p3) (piece? p5))
       (set-flag $1-1 true)
   )
   (if (or (piece? p2) (piece? p3) (piece? p6))
       (set-flag $1-2 true)
   )
   (if (or (piece? p4) (piece? p5) (piece? p6))
       (set-flag $1-4 true)
   )
)
</source>
</spoiler>
Здесь, нас подстерегает маленькая засада. Если съедаемых фигур две (такое редко, но бывает), такой код совершенно не подходит, поскольку, в самом начале, обнуляет "число". Надо научиться складывать числа! Это просто:

<spoiler title="Отнимаем от одного - добавляем к другому">
<source lang="lisp">
(define sum
   (while (not-0? $2)
       (inc $1)
       (dec $2)
   )
)
</source>
</spoiler>
Осталось немного, но главное. Как добавить часть "числа" к количеству очков на фигуре? Причём, не абы как, а начиная с младших фигур? 

<spoiler title="Здесь пришлось немного подумать">
<source lang="lisp">
(define try-alloc
   (if (is-0? x)
       (inc y)
    else
       (dec x)
   )
)

(define set-piece
   (if (am-i-red?)
       (create White $1)
    else
       (create Red $1)
   )
)

(define alloc-to
   (clear y)
   (if (piece? p1)
       (try-alloc) (try-alloc) (try-alloc) (try-alloc) (try-alloc)
   )
   (if (piece? p2)
       (try-alloc) (try-alloc) (try-alloc) (try-alloc)
   )
   (if (piece? p3)
       (try-alloc) (try-alloc) (try-alloc)
   )
   (if (piece? p4)
       (try-alloc) (try-alloc)
   )
   (if (piece? p5)
       (try-alloc)
   )
   (if (is-0? y)
       (set-piece p6)
    else
       (if (is-1? y)
           (set-piece p5)
        else
           (if (is-2? y)
               (set-piece p4)
            else
               (if (is-3? y)
                   (set-piece p3)
                else
                   (set-piece p2)
               )
           )
       )
   )
)

(define alloc
   (if (not-0? x)
       mark ST
       (while (on-board? next) 
           next
           (if (and enemy? (piece? $1) (not-0? x) 
                    (not-position-flag? is-captured?))
               (alloc-to)
           )
       )
       back
   )
)

(define alloc-all
   (alloc p1) (alloc p2) (alloc p3) (alloc p4) (alloc p5)
)
</source>
</spoiler>
При выполнении <b>alloc-all</b>, в <b>x</b> находится количество ещё не распределённых очков (максимум - 12, если съели две шестёрки). Пока в <b>x</b> не 0, пытаемся его распределить, начиная с <b>p1</b> и до <b>p5</b> (в шестёрки, очевидно, распределить уже ничего не удастся). Ищем фигуру требуемого номинала на доске и вызываем <b>alloc-to</b>. Здесь и начинается магия. Распределяем очки по одной единичке, в зависимости от типа фигуры (в <b>p1</b> лезет 5 единичек. в <b>p2</b> - 4 и т.д.). Не пытаемся анализировать, хватает ли в <b>x</b> единичек, а просто добавляем все распределяемые единички к ещё одной переменной - <b>y</b>. Это и есть переполнение (очевидно оно не может превышать 4), если оно не нулевое, просто корректируем тип фигуры.
</spoiler>

<video>http://www.youtube.com/watch?v=XT7oiKargnM</video>

В результате, вся наша "ненормальная арифметика" работает с вполне приемлемой производительностью и AI ничуть не страдает. Надо сказать, что не всегда подобные эксперименты бывают столь же удачны. Например, эту версию <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=244">калькулятора</a> (напомню, что никакой арифметики в ZRF нет) можно рассматривать исключительно как шутку. Его производительность просто ужасна! Но в нашем случае, "ненормальное программирование" показало себя лучшим из возможных решений.
</cut>

Квантовый Моррис

<img align="left" src="https://habrastorage.org/files/d43/8a3/ba4/d438a3ba4f5d4a139d1b0d9966b3cd66.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Круг танцующих извивался, как живое существо. Но среди них было свободное место и оно двигалось. Она знала, это место для нее. Мисс Тенета запретила ей. Но когда она это говорила? И потом, куда ей понять. Что она вообще понимает? Когда она танцевала в последний раз? Танец был в крови Тиффани, он манил ее. Шести танцующих недостаточно!&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...Танцоры не сводили с нее глаз, а она подпрыгивала и кружила между ними, каждый раз оказываясь там, где никого не было. &nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Пратчетт "<a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B8%D0%BC%D0%BD%D0%B8%D1%85_%D0%B4%D0%B5%D0%BB_%D0%BC%D0%B0%D1%81%D1%82%D0%B5%D1%80">Зимних дел мастер</a>"</i></b>&nbsp;

Несмотря на всю свою неказистость, "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B5%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%BD%D0%BE%D0%BB%D0%B8%D0%BA%D0%B8">Крестики-нолики</a>" являются краеугольным камнем мира настольных игр. Принцип "<abbr title="Выстраивание заданного количества фигур в непрерывную линию, по вертикали, горизонтали или диагонали">N в ряд</abbr>" настолько прост и естественен, что был независимо изобретён сразу несколькими древними народами. В Китае и Японии он лёг в основу таких игр как "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%8D%D0%BD%D0%B4%D0%B7%D1%8E">Рендзю</a>" и "<a href="https://en.wikipedia.org/wiki/Hasami_shogi">Хасами Сёги</a>", в древней Европе - породил "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельницу</a>" - прародительницу "<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%BA%D0%B5%D1%80%D0%BA">Алькуэрка</a>" и, в конечном итоге, всего разнообразия современных <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>.

В своём исходном виде, "Крестики-нолики" не кажутся игрой сколь нибудь интересной. В самом деле, беспроигрышная стратегия, для каждого из игроков, в этой игре, совершенно очевидна, а победить, при правильной игре, совершенно невозможно. Подобная игра может привлечь к себе младших школьников, но никак не серьёзных игроков. Впрочем, есть несколько способов всё исправить...
<cut>
<h4><b>Причём тут кот?</b></h4>
Когда речь заходит об улучшении "Крестиков-ноликов", первое, что приходит в голову - увеличение размеров (или размерности) игрового пространства. Действительно, игра на доске <a href="https://en.wikipedia.org/wiki/3-D_Tic-Tac-Toe">3x3x3</a> уже не столь тривиальна, а среди множества разновидностей игры на большой доске имеются дисциплины считающиеся профессиональными (правда, в этом случае, речь идёт о выстраивании пяти фигур в ряд). Существуют и менее очевидные возможности улучшения игры. Так, задействовав в качестве одного из игровых факторов гравитацию, мы получим очень занимательную игру "<a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D1%82%D1%8B%D1%80%D0%B5_%D0%B2_%D1%80%D1%8F%D0%B4">Четыре в ряд</a>", а простое изменение условия победы (игрок, вынужденно построивший ряд из трёх фигур - проигрывает) даёт нам "Losing Tic-Tac-Toe", победить в котором совсем не просто.

В 2006 году, Allan Goff <a href="qttt.googlecode.com/files/QT3-AJP%2010-20-06.pdf">придумал</a> ещё один способ радикального улучшения игры. Сделал он это не просто так, а с целью иллюстрации таких сложных понятий квантовой механики как "суперпозиция", "запутанность" и "свёртка". В предлагаемом им варианте игры, каждый игрок, вместо того чтобы поставить свой крестик или нолик, делает два полухода в разные позиции игрового поля. Добавленная на доску фигура равновероятно присутствует в двух позициях одновременно. В индексах сохраняется информация об очерёдности ходов игроков, в дальнейшем используемая при разрешении возникающих коллизий.

<img align="center" src="https://habrastorage.org/files/806/35c/8ef/80635c8efd254482925b1c09fecc0259.png"/>
До тех пор, пока фигуры присутствуют на доске лишь в форме полуходов, мы не можем сказать точно, в какой из позиций каждая из них находится. Возможно, это не самая удачная метафора квантовой механики, поскольку в рамках этой модели каждая фигура может быть "размазана" не более чем по двум возможным расположениям (также возможны некоторые сложности с определением победителя, о которых я скажу ниже). В 2010 году J. N. Leaw и S. A. Cheong <abbr title="J. N. Leaw and S. A. Cheong, Journal of Physics A: Mathematical and Theoretical, vol. 43, no. 45, 455304 (2010)">предложили</abbr> более сложный вариант игры, в котором каждый ход представляет собой вектор в девятимерном гильбертовом пространстве. Краткое описание можно посмотреть <a href="http://rotozeev.net/page/kvantovye-krestiki-noliki">здесь</a>.

<spoiler title="Разумеется, идея ''размазывания'' ходов не нова">
Так например, в <a href="http://www.chessvariants.com/other.dir/refusal.html">Refusal Chess</a> (Fred Galvin, 1958), каждый игрок предлагал два возможных хода, а его оппонент выбирал один ход из предложенных. Исключение делалось лишь для позиций с единственным возможным разрешённым ходом. Сходным образом игровой процесс построен в "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1484">Ambiguous Chess</a>" (Fabrice Liardet, 2005). В этой разновидности игры, игрок помечает поле на которое собирается сходить (оно может быть занято вражеской фигурой), а его противник выбирает фигуру, способную выполнить этот ход:

<video>http://www.youtube.com/watch?v=9lnQnnx68Gs</video>
</spoiler>
В любом случае, концепция показалась мне интересной. Настольные игры, в основе своей, просты. Фигуры ставятся на доску, перемещаются, превращаются, забирают другие фигуры - всё это очень легко реализовать. Но встречаются "изюминки", сложность которых буквально "зашкаливает". В <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>, это концепции <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мата</a>, в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашках</a> - "правило большинства", в <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> - взаимное влияние фигур. Концепции "суперпозиции" и связанной с ней "запутанности" - одна из таких "изюминок".

<h4><b>Распутываем запутанности</b></h4>
Если бы дело ограничивалось одними лишь полуходами, в "Квантовых крестиках-ноликах" не было бы ничего интересного. Для победы необходимо обеспечить стопроцентное присутствие фигур на заданных позициях! Каким образом полуходы превращаются в полноценные фигуры? Пришло время в этом разобраться. Если заполнять доску полуходами достаточно долго, рано или поздно возникнет ситуация, подобная следующей:

<img align="center" src="https://habrastorage.org/files/bca/0bc/e4a/bca0bce4aed04d979110dc4188a17629.png"/>
Возникла коллизия, своего рода парадокс - противоречие в исходных данных. В конечном итоге, расположение каждой фигуры должно быть точно определено. Все полуходы должны быть "свёрнуты", но существуют две принципиально различных возможности такой "свёртки". В одном из этих случаев, игра заканчивается.

<img align="center" src="https://habrastorage.org/files/b5a/e7c/359/b5ae7c359e9f4ec99eb369179e7c8fb0.PNG"/>
Игрок, замкнувший цикл взаимозависимостей, виновен в возникновении "парадокса". По этой причине, выбор варианта свёртки предоставляется его оппоненту. В нашем случае, цикл был замкнут "крестиками". Это означает, что "ноликам" удастся избежать поражения. Они просто выберут "из двух возможных миров" тот, в котором "крестики" ещё не победили. Но возможны ситуации, в которых от выбора варианта свёртки уже ничего не зависит:

<img align="center" src="https://habrastorage.org/files/650/455/5c7/6504555c74cf48db9e2f7104243f10db.PNG"/>
Что здесь не выбирай, конечный итог для "ноликов" одинаков - они проиграли. Возможна и вырожденная ситуация. Любой из игроков может сделать два полухода в одну и ту же область доски. Это самая короткая из возможных коллизий. Поскольку она подразумевает "выбор" из двух совершенно одинаковых вариантов, такая последовательность полуходов фактически равноценна полному ходу в это поле:

<img align="center" src="https://habrastorage.org/files/3ef/694/c88/3ef694c884734b2795c286e4194996c8.PNG"/>
Обратите внимание на то, как ход "крестиков" вытесняется с выбранного поля. Каждая ячейка доски может содержать результат не более чем одного "полного" хода. Такое "вытеснение" может распространяться далее, по цепочке (на самом деле, по дереву). На мой взгляд, подобные ходы находятся где-то на грани фола. Они слишком сильные. Такой "детерминированный" ход равносилен обычному ходу в "Крестиках-ноликах" и, кроме того, позволяет "вытеснить" противника с выбранной позиции. В большей части вариантов своей реализации "Квантовых крестиков-ноликов" (6 из 10) я запретил выполнение "детерминированных" ходов.

<video>http://www.youtube.com/watch?v=QVmppOuYUCE</video>

<spoiler title="Как это всё работает?">
Этот код - воплощение ночных кошмаров. Я трижды переписывал его! Теперь он как-то работает. Я не очень хорошо понимаю как, поскольку, в настоящий момент, он, в основном, состоит из заплаток. Сам процесс отладки Axiom-приложений непрост. Если в коде есть ошибки - он падает. В большинстве случаев. Но если всё работает - это вовсе не означает, что ошибок нет. Просто сами ошибки становятся причудливее. И да, без рекурсии дело не обошлось.

<source>
: in-collision? ( -- ? )
	FALSE 0 BEGIN
		DUP curr-size @ < IF
			DUP pos[] @ here = IF
				2DROP TRUE 0
				TRUE
			ELSE
				1+ FALSE
			ENDIF
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;

: pair-found? ( -- ? )
	FALSE 0 BEGIN
		DUP empty-at? NOT OVER piece-type-at piece-type = AND IF
			DUP here <> IF
				DUP 0 pos[] @ = IF
					collision-size @ 0= IF
						curr-size @
						collision-size !
					ENDIF
					DROP ALL
				ELSE
					DUP to
					here curr-size @ pos[] !
					curr-size ++
					2DROP TRUE ALL
				ENDIF
			ENDIF
		ENDIF
		1+ DUP ALL >=
	UNTIL DROP
;

: not-prev? ( -- ? )
	curr-size @ 0> IF
		curr-size @ 1- pos[] @ here <>
	ELSE
		TRUE
	ENDIF
;

: try-pos ( -- )
	down DROP
	BEGIN	here
		my-empty? NOT not-prev? AND IF
			here curr-size @ pos[] !
			curr-size ++
			pair-found? curr-size @ TOTAL < AND IF
				RECURSE
				curr-size --
			ENDIF
			curr-size --
		ENDIF
		to up NOT my-empty? OR collision-size @ 0> OR
	UNTIL
;

: check-collision ( -- )
	find-mark
	try-pos
	collision-size @ 
	DUP 2 > verify
	curr-size !
	from to
	in-collision? verify
;
</source>
Как бы там ни было, это сердце всего <a href="https://github.com/GlukKazan/ZoG/tree/master/Axiom/QXO">проекта</a>. Самым сложным оказалось само определение факта наличия коллизии, а также поиск всех фигур входящих в неё. Процесс "распутывания" можно начинать только с этих фигур. И пока есть коллизия, а она может быть только одна, нельзя разрешать никакие другие ходы кроме "распутывания". В противном случае, есть шанс окончательно всё запутать. Это не сложно. Помогают приоритеты. Если имеется хотя бы один приоритетный ход, никакие другие ходы выполняться не могут. Это не самый универсальный механизм, но он работает:

<source>
{move-priorities
	{move-priority} high-priority
	{move-priority} normal-priority
	{move-priority} low-priority
move-priorities}

{moves p-drop
	{move} select-piece	{move-type} high-priority
	{move} drop-half 	{move-type} normal-priority
	{move} drop-piece	{move-type} normal-priority
	{move} Pass		{move-type} low-priority
moves}

{pieces
	{piece}		M	{drops} p-drop
	{piece}		x1
	{piece}		o1
	{piece}		x2
	{piece}		o2
	{piece}		x3
	{piece}		o3
	{piece}		x4
	{piece}		o4
	{piece}		x5
	{piece}		X1	1 {value}
	{piece}		O1	1 {value}
	{piece}		X2	2 {value}
	{piece}		O2	2 {value}
	{piece}		X3	3 {value}
	{piece}		O3	3 {value}
	{piece}		X4	4 {value}
	{piece}		O4	4 {value}
	{piece}		X5	5 {value}
pieces}
</source>
Оставшаяся часть проста. Даже корректное выполнение свёртки не столь сложно. Грег придумал специальные функции для работы с кольцевым буфером, но я, к стыду своему, так ни разу ими и не воспользовался. Старый добрый трюк с добавлением в конец массива, по которому идут итерации, всё ещё работает:

<source>
: add-position ( -- )
	0 BEGIN
		DUP here <> OVER empty-at? NOT AND IF
			DUP piece-type-at piece-type = OVER not-in-position? AND curr-size @ ALL < AND IF
				DUP curr-size @ pos[] !
				curr-size ++
			ENDIF
		ENDIF
		1+ DUP ALL >=
	UNTIL DROP
;

: mark-all ( player -- )
	marked-player !
	here curr-pos !
	down DROP
	mr   verify marked-player @ mark create-player-piece-type
	down DROP
	BEGIN
		empty? NOT here curr-pos @ <> AND piece-type mark > AND IF
			add-position
		ENDIF
		marked-player @ mark create-player-piece-type
		up NOT
	UNTIL
;

: untangle ( -- )
	0 BEGIN
		DUP curr-size @ < IF
			DUP pos[] @
			to player piece-type OVER mark-all
			down DROP
			bg   verify
			DIM + create-player-piece-type
			1+ FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;
</source></spoiler>
Остался ещё один не рассмотренный вопрос. Игра завершается, когда одному из игроков удаётся построить линию из крестиков или ноликов (конечно, в обычных "Крестиках-ноликах" такое происходит крайне редко), но в нашем безумном квантовом мире крестики и нолики могут построить свои линии одновременно! Кого считать победителем?

<img align="center" src="https://habrastorage.org/files/fb7/1db/dba/fb71dbdba9d14103bf6834413723bbd8.PNG"/>
Allan Goff предлагает вновь задействовать индексы, использованные для нумерации ходов. Для каждой построенной линии должен быть найден максимальный индекс. Тот, у кого этот индекс оказался меньше, побеждает. Поскольку, в своей работе, он использует сквозную нумерацию ходов (X1, O2, X3,...), при наличии линии, победитель будет всегда. Легко заметить, что я использую другую схему нумерации и, в моём случае, вновь получается ничья.

Что заставило меня отойти от канонов? Два соображения. Во первых, сквозная схема нумерации даёт очень серьёзное преимущество первому игроку. На мой взгляд, игровой баланс гораздо важнее гипотетической возможности получения ничьей (серьёзно, в "Квантовых крестиках-ноликах", ничья - редкая ситуация). Что ещё важнее, сквозная нумерация (и связанная с ней методика определения победителя) совершенно неприемлема для "Квантового Морриса", речь о котором пойдёт ниже. Там, у каждого из игроков, всего по три фигуры.

<h4><b>Танцуют все!</b></h4>
<a href="https://en.wikipedia.org/wiki/Morris_dance">Танец Морриса</a> - древнейший английский обычай, связанный с ритуалами плодородия. Желающим проникнуться духом этого действа с удовольствием рекомендую "Зимних дел мастера" за авторством Терри Пратчетта. Про сам танец там рассказано вскользь, но зато от души! В рамках нашего повествования, более важна связь этого обычая с целым <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">семейством</a> настольных игр, невероятно популярным в средневековой Европе. Младшая игра семейства ("<a href="https://en.wikipedia.org/wiki/Three_Men%27s_Morris">Танец трёх мужчин</a>") - ещё один способ "улучшения" крестиков-ноликов. Фактически, это связующее звено между ними и более поздними играми с подвижными фигурами, такими как "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%B0_%D0%B8_%D0%B3%D1%83%D1%81%D0%B8">Лиса и гуси</a>" или "<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D0%BA%D0%B5%D1%80%D0%BA">Алькуэрк</a>".

В основе игры лежит очень простая идея: если не удалось построить ряд сразу, то всё ещё можно победить, двигая уже выложенные фишки по очереди! Чтобы было куда двигаться, каждый игрок использует всего по три фигуры (этого достаточно для построения линии). В старших играх семейства, таких как "<a href="https://en.wikipedia.org/wiki/Nine_Men%27s_Morris">Танец девяти мужчин</a>", игрок, построивший ряд ("мельницу"), имеет право безвозвратно "смолоть" любую фигуру противника, уже поставленную на доску. В нашем случае, поскольку фигур с каждой стороны всего по три, потеря любой из них означает безусловное поражение. Двух фигур недостаточно для построения ряда!

Отсюда до "Квантового Морриса" всего один шаг! Хотя проблема "ничейной смерти" уже не стоит в "Квантовых крестиках-ноликах" столь остро, сама игра остаётся слишком быстротечной. Ограничение количества фигур до трёх (с каждой стороны) и их перемещение после выставления на доску, помогут "растянуть" игру, добавив в неё зрелищности и неожиданности.

<video>http://www.youtube.com/watch?v=hkw6GfmUqyQ</video>

Легко заметить, что перемещаются лишь малые "полуфигуры". Также возможно "расщепление" полной фигуры на две полуфигуры, с перемещением одной из них на другую позицию. Большую фигуру перемещать нельзя. Как и в "Квантовых крестиках-ноликах", существует возможность "детерминированных" ходов. Помимо "сброса" двух полуходов в одну ячейку, мы можем "слить" полуфигуры, перемещая одну из них к другой. Я по-прежнему считаю такие ходы излишне сильными и запрещаю их в части вариантов игры.

<spoiler title="Срываем покровы">
Рассмотрим один из предыдущих скриншотов, используя слегка изменённый набор графических ресурсов. Всё тайное немедленно становится явным:

<img align="center" src="https://habrastorage.org/files/2f9/e07/ad3/2f9e07ad3c9f419ba4bdbf05daec8c65.PNG"/>
Эти тёмно-зелёные кружочки - вспомогательные фигуры, невидимые при нормальной работе приложения. Для чего они? Начнём с ячейки содержащей два кружочка. Вспомогательная фигура, расположенная в правом нижнем углу - маркер. Им отмечается область доски, в которой выполнялся последний ход. С этой позиции можно начинать поиск коллизии. Если коллизия есть, одна из областей входящих в неё обязательно будет помечена. В принципе, можно было бы обойтись и без маркеров, но мне не хотелось усложнять и без того сложный алгоритм поиска коллизий. Очевидно, что эту ячейку можно использовать совершенно безопасно. Каждая область доски может содержать не более восьми малых фигур.

Кружочек по центру - более интересный объект. Дело в том, что малые фигуры добавляются в ячейки доски по порядку, а не в то место куда выполняется сброс (<b>drop</b>) фигуры через пользовательский интерфейс. Соответственно, и сбрасывается не сама фигура, а вспомогательный невидимый маркер. Почему он не удаляется? Игра использует две доски (<b>grid</b>), наложенные одна поверх другой. В 9x9 хранятся малые фигуры, а в 3x3 - большие. Если я буду удалять сбрасываемый маркер, то разрушу изображение на укрупнённой доске. На видео заметно, что изображение всё равно разрушается (при расщеплении больших фигур), но этот эффект кратковременен. Кроме того, с ним я ничего поделать не могу.

Забавнее всего назначение девяти кружочков, расположенных в одной области с крупной фигурой. Здесь мы вновь имеем дело с издержками пользовательского интерфейса. Ячейки доски 9x9 расположены поверх крупной сетки и практически полностью перекрывают её фигуры. В игре Морриса, фигуры необходимо двигать. В том числе и крупные (при этом происходит их расщепление). Но для того, чтобы подвинуть фигуру, необходимо иметь возможность "зацепить" её мышью, а для фигур на сетке 3x3 сделать это довольно проблематично (даже если над ними нет никаких фигур). Пришлось добавить "рукоятки", дёргая за которые можно расщеплять крупные фигуры.
</spoiler>
"Квантовые крестики-нолики" являются, возможно не идеальной, но весьма удачной иллюстрацией идей квантовой механики. Эта игра привлекает к себе внимание. Она используется при проведении <a href="http://www.codecup.nl/rules_quantum%20tic-tac-toe.php">соревнований</a> по программированию, вопросы на эту тему периодически появляются на <a href="http://boardgames.stackexchange.com/questions/7085/what-is-the-optimal-strategy-in-quantum-tic-tac-toe">StackExchange</a>. В настоящее время, не составляет труда найти её программную реализацию. Она разработана как для <a href="https://play.google.com/store/apps/details?id=com.nithokian.qttt&hl=ru">Android</a> так и для <a href="https://itunes.apple.com/ru/app/quantum-ttt/id669264957?mt=8">iOS</a>. Особо нетерпеливые могут играть непосредственно через <a href="http://countergram.com/qtic/">Web-интерфейс</a>. Одними лишь "Крестиками-ноликами" набор "квантовых" игр не ограничивается. В качестве бонуса, могу порекомендовать еще и <a href="https://play.google.com/store/apps/details?id=weizmann.qms.lite&hl=ru">эту игру</a>.

Всех с пятницей, Господа!
</cut>

Королевская битва

<img align="left" src="https://habrastorage.org/files/674/0c6/d0a/6740c6d0ae2940dab7cb11d5317a3c63.PNG"/><b><i>— Что это? — вытянул шею Гмык, хмуро глядя на мои карты. — Но тут же только…
— Минутку, — вмешался игрок слева от него. — Сегодня вторник. Выходит, его единороги дикие.
— Но в названии месяца есть «М»! — вякнул еще кто-то. — Значит, его великан идет за половину номинальной стоимости!
— Но у нас четное число игроков…
Я вам говорил, что игра эта сложная.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Роберт Асприн "Маленький мифо-заклад"</i></b>&nbsp;

То был славный день. День, когда генералы Севера и Юга могли решить все свои проблемы. Две армии изготовились к бою. Впереди, прикрываемые щитами, двигались колесницы. Сразу вслед за ними, шла пехота и кавалерия. Стрелки, артиллерия и боевые слоны замыкали строй. Элитные бойцы шагали рядом с генералом.
<cut>
<h4><b>Millenary 5J x 11D = Dragon ascending</b></h4>
<img align="center" src="https://habrastorage.org/files/96d/823/23e/96d82323eba94af1b40f389738b17fd2.PNG"/>
После нескольких часов боя, войска смешались. Многие бойцы пали. Тысячелетний воин обнаружил брешь в обороне северян. Одним ударом он мог захватить знамя, а это - половина победы! Не раздумывая, воин бросился вперёд. Знаменосец пал. Огромный чёрный дракон взметнулся в поднебесье. Только маленький барабанщик стоял между ним и генералом.

<h4><b>Drum 10C x 11D = Thunderclap</b></h4>
Барабанщик не мог отступить. Всё войско смотрело на него. Он должен был защитить генерала! Смело бросился он на врага. В небе сверкнула молния. Дракон был повержен.

<h4><b>Advance guard 19O - 19N</b></h4>
Гвардейцы всегда работали в паре. Медленно двигаясь по левому флангу и прикрывая друг друга, шаг за шагом, приближались они к лагерю противника. Впрочем, никто не обращал на них никакого внимания. Это было неплохо.

<h4><b>Sumo wrestler 7K x 6L x 7M</b></h4>
Борец сумо в чём-то подобен <abbr title="Sumo wrestler слабее фигуры Lion из Chu Shogi, поскольку не умеет перепрыгивать через дружественные фигуры">льву</abbr>. Хотя он и не очень быстр, но может бить по два противника за раз. Он способен убить врага, даже оставаясь на месте! Главное, чтобы враг находился неподалёку. Продвигаясь вперёд, сумоист разрушил имперскую базу южан и уничтожил пушечный расчёт. Неплохо, для такого увальня!

<h4><b>Banner 8N x 7M = Roaming assault</b></h4>
Враг был ужасен, но знаменосец смело бросился вперёд. Здесь всё решала скорость! Неповоротливый борец сумо мог мало что ему противопоставить. Исход оказался вполне предсказуем. За свои заслуги, знаменосец был повышен в звании и отныне мог разъезжать на боевой колеснице.

<h4><b>Engineer 16M - 15N = Poison flame x 15O x 14O</b></h4>
<img align="center" src="https://habrastorage.org/files/252/23a/79e/25223a79e063485886965ec4dd7c0518.PNG"/>
Инженер двинулся вперёд. В бою он был не сильнее любого другого пехотинца. Его сила заключалась в ином. Сделав ещё один шаг, он оказался в лагере противника. Вспыхнуло пламя. Двое южан, оказавшихся рядом, вспыхнули как порох!

<h4><b>Taoist priest 13H - 13F = Twelve-mile fog x 14F</b></h4>
Пришёл черёд древнего даоса вступить в бой. Одним прыжком он оказался на территории северян. На двенадцать миль вокруг расползся удушливый тёмный туман. Оказавшийся неподалёку солдат даже не понял, что его убило.

<h4><b>Poison flame 15N - 15O x 16P x 14P</b></h4>
Подобно <abbr title="Fire demon - главная действующая фигура в Tenjiku shogi. Все вражеские фигуры, оказавшиеся с ним поблизости, сгорают">огненному демону</abbr>, инженер шёл вперёд и огонь следовал за ним. Земля горела у него под ногами, а вместе с ней горело всё, что на ней находилось. Заместителю командующего не повезло. Его смерть приблизила армию северян к победе.

<h4><b>Elephant 10J - 15O x 15O</b></h4>
Кто-то должен был погасить это пламя! Боевой слон ринулся в самую середину пожара, презрев смерть. Сгорев в огне, он спас свою армию от неминуемого поражения.

<h4><b>Middle troop 4M - 4N Governor</b></h4>
Порой, всего один шажок отделяет заместителя командующего от губернатора. Один маленький шажок для губернатора и огромный шаг для всей его армии!

<h4><b>Roaming assault 7M - 8N x 9M - 10M x 11M - 12M</b></h4>
Боевая колесница катилась вперёд, давя врагов. Знаменосец не мог скрыть своего ликования. Патрульные или кавалеристы - неважно, он давил всех, без разбора!

<h4><b>European cannon 11E - 12F x 12M x 8J</b></h4>
Дабы прекратить этот безумие, пушечный расчёт выдвинулся на позицию. Пушка, сверкающая в лучах Солнца, совсем недавно была приобретена у заезжих гайдзинов. Уж что-что, а пушки они делать умели! Боевая колесница рассыпалась на кусочки. Вторым залпом убило всадника, оказавшегося неподалёку.

<h4><b>Clerk 17H - 17F = Master at arms 19J 1F = Earth's vengeance 19N 1P = Heaven's vengeance</b></h4>
<img align="center" src="https://habrastorage.org/files/0b9/7b1/6f6/0b97b16f68d14cf09ee9844646d1de38.PNG"/>
Продвинувшись вперёд, скромный клерк стал мастером-оружейником. Это, казалось бы, рядовое событие имело далеко идущие последствия. В ту же секунду, гвардейцы обернулись мстителями и ярость их мщения затопила всё вокруг!

<h4><b>European cannon 12F - 11G x 11L</b></h4>
Предчувствуя беду, расчёт пушки бросился вперёд. Щиты не спасли бойца, оказавшегося на линии выстрела.

<h4><b>Heaven's vengeance 19N x 4N</b></h4>
Небесный мститель набросился на губернатора. Север погрузился в траур.

<h4><b>European cannon 11G - 10H x 4N</b></h4>
Хоть пушкари и не успели предотвратить катастрофу, они достойно отомстили за смерть губернатора! 
Увы, их радость была не долгой.

<h4><b>Twelve-mile fog 13F - 11F x 10G - 9H x 10H</b></h4>
Надёжно укрытый туманом, даос быстро перемещался от одного дерева к другому. Невидимый и неслышимый никем, он убивал одного солдата за другим. Пушечный расчёт не мог оказать ему достойного сопротивления. Силы были слишком не равны.

<h4><b>Spiritual monk 15L - 13N = Immaculate light</b></h4>
С подобным должно бороться при помощи подобного. Только юный буддистский монах знал, как справиться с даосом, но сперва он должен был пройти посвящение. Сделав последний шаг, монах вошёл в лагерь врага. И стал <abbr title="Spiritual monk во всём подобен Taoist priest, но в отличии от последнего, превращается не в Twelve-mile fog, хорошо защищённый от ближних атак стрелков, а в Immaculate light. Эта фигура вызывает обратное превращение Twelve-mile fog если оказывается с ним на одной прямой, на расстоянии не более пяти пунктов">свет</abbr>...

<h4><b>Twelve-mile fog 9H - 7H x 7G - 5H x 4G</b></h4>
Не ведая о нависшей над ним угрозе, даос двигался дальше. Северяне гибли один за другим.

<h4><b>Immaculate light 13N - 11N - 9L 5H = Taoist priest</b></h4>
<img align="center" src="https://habrastorage.org/files/fba/626/9d9/fba6269d94484c659c07326cdb425a1b.PNG"/>
Окутанный светом, монах догонял даоса. Когда он увидел своего противника, свет пронзил тьму мрачного тумана. Туман сгинул, растаяв без следа. 

<h4><b>Patrol unit 9J x 9L</b></h4>
Увлёкшись своей погоней, монах не заметил вражеского патруля, случайно оказавшегося поблизости. Он погиб не убив ни одного врага, но смерть его была не напрасной.

<h4><b>Crossbow 4D - 5E x 5H</b></h4>
Вновь видимый всеми, даос оказался в ловушке. Он не мог укрыться, не мог убежать! Сделав всего один шаг, арбалетчик встал на линию огня. Древний даос пал.

<h4><b>Heaven's vengeance 1P - 13D!</b></h4>
<img align="center" src="https://habrastorage.org/files/3a2/256/911/3a22569118664b05af010b7202a163b2.PNG"/>
Ослеплённый яростью, небесный мститель напал на генерала армии северян. Это было безрассудно. Генерал знал, как себя защитить.

<h4><b>Thunderclap 11D - 12D x 13D x 13C - 13B x 12B</b></h4>
Освещённый вспышками молний, барабанщик метался по полю боя. Он разил одного врага за другим и не мог остановиться!

<h4><b>Chariot unit 12R x 12B = Millenary</b></h4>
В мгновение ока, боевая повозка пересекла поле боя, прервав танец смерти! Смолк барабан и войско северян <abbr title="Пешки в Ko Shogi не могут двигаться вперёд после потери фигуры Drum">остановилось</abbr>.

<h4><b>Crossbow 5E - 4F x 1F</b></h4>
Тысячелетний воин восстал перед северным генералом. Это был конец. У северян  не оставалось другого выхода, кроме как продать свою жизнь подороже. Арбалетчики обстреляли взвод мстителей. Северяне победили в схватке, но это была их последняя победа.

<h4><b>Patrol unit 9L - 9B = Commissar!</b></h4>
<img align="center" src="https://habrastorage.org/files/f17/208/65d/f1720865d93b4171af528561211cc3cc.PNG"/>
Взвод патрульных завершил окружение вражеского генерала. Комиссар бросился вперёд. За Императора!

<h4><b>General 10A x 9B</b></h4>
Пытаясь "сохранить лицо", генерал сразил комиссара, встав на линию огня.

<h4><b>Millenary 12B x 9B</b></h4>
Тысячелетний воин не заставил себя ждать. Генерал пал, а вместе с ним и всё его войско! 
То был славный день. В небе сияло Солнышко, щебетали птички. В тот день, многие получили своё.

<video>http://www.youtube.com/watch?v=JRS8VuqbUqQ</video>

<h4><b>Послесловие</b></h4>
Я уже давно хотел вплотную заняться <a href="https://en.wikipedia.org/wiki/Ko_shogi">Ko Shogi</a>, а посленовогодние выходные предоставили мне такую возможность. Игра оправдала мои ожидания! Было много рутинной работы, такой как подготовка большого количества графических ресурсов, но случались и неожиданности. В Ko Shogi есть всё, что мне нравится. Здесь и оригинальные стреляющие фигуры и сложные, взаимозависимые правила их превращения. Победить в игре можно различными способами. Обязательным условием победы является захват вражеской фигуры <b>General</b>, но одного этого недостаточно! Вместе с ним, на выбор, необходимо захватить фигуру <b>Banner</b> или <b>Middle troop</b>. Если последний успел превратиться в <b>Governor</b>, необходимо захватить и его.

<spoiler title="Разумеется, не обошлось без купюр">
Кое что я не смог реализовать чисто технически. Речь идёт о мелочах. Например, фигура <b>Thunderclap</b> (улучшенный <b>Drum</b>) должна иметь возможность выполнения пяти ортогональных шагов за ход, с произвольным изменением направления и "поеданием" врагов, попадающихся на пути. Важным является то, что она должна сделать <b>ровно</b> пять шагов и именно этого я обеспечить не в состоянии, поскольку другие фигуры (такие как <b>Roaming assault</b> или лучники, должны уметь останавливаться на любом этапе выполнения "сложного" хода). Помимо этого, существует очень маленькая (но не нулевая) вероятность того, что <b>Thunderclap</b>, в процессе выполнения своего хода, загонит себя в тупик (менять направление движения на противоположное я ему запретил, а дружественные фигуры могут оказаться непреодолимым препятствием на пути). С аналогичной проблемой я уже сталкивался, при разработке <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2462">другой игры</a> и в тот раз я также не смог решить её адекватно.

Другая большая тема - превращение фигур. Здесь в Ko Shogi всё сложно. Помимо традиционного превращения при перемещении в лагере противника (6 дальних линий доски), фигура может быть "повышена в звании" при уничтожении ей любой из "генеральских" фигур (<b>General</b>, <b>Governor</b>, <b>Middle troop</b> или <b>Banner</b>). Кроме того, фигуры перемещающиеся не более чем на один пункт, могут быть "повышены" в случае атаки ими "сильных" фигур, таких как <b>Sumo wrestler</b>, <b>Dragon ascending</b>, <b>Thunderclap</b> или <b>Roaming assault</b>. Имеются и более сложные схемы превращений (в том числе обратных). Например, потеря <b>Taoist priest</b> влечёт за собой обратное превращение дружественных фигур <b>Thunderclap</b> (в <b>Drum</b>) и <b>Roaming assault</b> (в <b>Banner</b>). К сожалению, у меня нет уверенности в том, что я понял все нюансы правил превращения правильно. Большие вопросы, например, вызвает следующий пункт:
<blockquote>When the clerk 記室 promotes to master at arms 軍師, the allied advance and rear guards 前衛, 後衛 promote as well, while any enemy poison flame 毒火 dies. However, while the clerk promotes as usual upon capturing a commanding piece, it cannot promote by entering or moving within the promotion zone unless the advance and rear guards have already entered the zone.</blockquote>Превращение в Ko Shogi (в отличии от привычных нам <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахмат</a>) не является обязательным, но я не везде смог оставить его таковым. По чисто техническим причинам, я не могу допустить отказ от превращения в тех случаях, когда оно влияет на другие фигуры, находящиеся на доске (например, <b>Engineer</b>, превращаясь в <b>Poison flame</b>, может "сжечь" фигуры оказавшиеся поблизости). По аналогичным причинам, запрещён отказ от превращения "стреляющих" фигур, убивающих своим выстрелом одну из "генеральских" фигур противника. К сожалению, "выстрел" в ZRF может быть реализован лишь способом, не допускающим никаких альтернатив в вопросе "превращения" стреляющей фигуры.
</spoiler>
В целом, игра <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2463">получилась</a>. Конечно, AI в ней ожидаемо не блещет интеллектом (просто не хватает времени на адекватный перебор всех вариантов на такой большой доске), но играет вполне адекватно. Игра более "казуальна" чем <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> или <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>. При таком разнообразии возможных ходов, действия игрока смещаются в сторону достижения "сиюминутных" целей, в ущерб сложной комбинационной игре. Малые <a href="http://geektimes.ru/post/246506/">варианты сёги</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8">Сянцы</a>, ограничивающие свободу игрока, в свою очередь, более похожи на головоломки. 

Единственный, на мой взгляд, отрицательный момент, в Ko Shogi, заключается в том, что большая часть её оригинальных фигур лишена возможности проявить весь свой потенциал. Партия, описанная в этой статье, вряд ли возможна в действительности. В реальной игре, такие тихоходные фигуры как <b>Engineer</b> или <b>Clerk</b> будут расстреляны артиллерией противника задолго до их превращения. Я попытался сгладить этот недостаток, создав вариант игры с незначительно изменёнными правилами. Основу изменений составило расширение "зоны превращения" и уменьшение общего количества "стреляющих" фигур. Кроме того, "инженерам" была предоставлена возможность апгрейда "технических юнитов". Игрок может выбирать, развивать ли ему позицию или улучшать собственные фигуры. Надеюсь, что "улучшенный" вариант получился не хуже оригинального.
</cut>

Больше чем Го

<img align="left" src="https://habrastorage.org/files/2a4/61e/ed7/2a461eed7238486cb288a6666020cb5e.PNG"/><b><i>Бросая в воду камешки, смотри на круги,  ими  образуемые;  
иначе  такое бросание будет пустою забавою.</i>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B7%D1%8C%D0%BC%D0%B0_%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2">Козьма Прутков</a> "<a href="http://az.lib.ru/p/prutkow_k_p/text_0080.shtml">Плоды раздумья</a>"&nbsp;
&nbsp;
</b>
Эта игра - самый настоящий <a href="https://github.com/GlukKazan/ZoG/commits/master/Axiom/Margo">долгострой</a>. Я начал работать над ней ещё в <a href="http://habrahabr.ru/post/259611/">июне</a>! Нельзя сказать, чтобы я каждый день надрывался, но крови она мне попортила немало. На сегодняшний день, это мой самый сложный проект в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>. По объёму (весьма нетривиального) кода, <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">MarGo</a> сопоставима, разве что, с <a href="http://habrahabr.ru/post/234587/">Ритмомахией</a>. 

Что особенного в этой игре? Стоило ли из за неё так мучиться? Я расскажу, а вы сами судите.
<cut>
<h4><b>Поверхностное сходство</b></h4>
Попытки "усовершенствовать" <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> предпринимались неоднократно, но они редко бывали удачными. MarGo, на мой взгляд, именно такая редкость! Главное, что подкупает в этой игре, так это тот факт, что она является <b>над</b>множеством Го. Я уже <a href="http://geektimes.ru/post/240456/">писал</a> о том, как казалось бы простые правила Го приводят к неожиданно сложным тактическим построениям. Не стану повторяться, скажу лишь, что всё что я писал о Го, справедливо и для MarGo тоже (до тех пор, пока мы не выходим за пределы плоскости). Вот так, например, выглядит знаменитая "<a href="http://www.e-reading.club/chapter.php/112811/39/Stepanov,_Grishin,_Emel'yanov_-_Myslit'_i_pobezhdat'__igra_Go_dlya_nachinayushchih.html">защёлка</a>" - простейшая жертва одного камня, с целью получения трёх:

<img src="https://habrastorage.org/files/a27/022/021/a270220215884ea9aadbd5873819c1f8.PNG"/>

<spoiler title="К слову сказать">
Использование каких либо "защёлок", на позиции выше, совершенно излишне! Чёрные уже обречены, "доедать" их нет необходимости. Но почему в MarGo используются такие маленькие доски? Главная причина заключается в том, что игра идёт не на плоскости, а в объёме. Игроки строят пирамиды и вряд ли у кого-то хватит терпения заниматься этим на доске 19x19. Стандартная для MarGo доска 9x9, в Го используется, в основном, для обучения новичков!

Для меня это стало большим облегчением, поскольку уже при использовании доски 9x9, я столкнулся с проблемами нехватки памяти. Мне пришлось <a href="http://habrahabr.ru/post/260599/">оптимизировать</a> её использование, убрав из массива лишние строки. Этот момент достаточно очевиден - строя пирамиду, мы никогда не сможем разместить фигуры на большей части полей трёхмерной доски.
</spoiler>
При определении статуса групп, значение имеют лишь пустые пункты, расположенные в плоскости доски. Каждый камень "живой" группы должен быть связан (непосредственно или через другие камни) хотя бы с одним из таких пунктов (называемых "<b>дамэ</b>"). Как только последнее из <b>дамэ</b> будет закрыто, группа становится мёртвой и снимается с доски.

<spoiler title="Как это работает?">
Основа функциональности Го - механизм удаления камней, попавших в окружение. Он работает довольно просто. Для начала, необходимо определить камни, являющиеся живыми безусловно (они соседствуют с пустыми пунктами на доске). Затем, следует добавлять в группу "живых" камней все камни (того же цвета), соседствующие с любыми из добавленных ранее. 

Всё бы ничего, если бы не дурацкая семантика выполнения хода в ZoG/Axiom. На всём протяжении построения хода, содержимое доски выглядит так, как и на момент начала расчёта (все изменения, выполненные ходом станут видимы лишь по его завершении). В простых случаях, с этим можно бороться, но наша то игра никогда простой не была! В силу того, что мы создаём иллюзию трёхмерности, добавление на доску всего одной фигуры может приводить к перемещению большого количества фигур-тайлов. Обрабатывать все эти "особые случаи" специальным образом - совершенно нереально! Мне пришлось разделить добавление новой фигуры на доску и последующее удаление "убитых" фигур:

<source>
{players
	{player}	W
	{player}	B
	{player}	?C	{random}
players}

{turn-order
	{turn}	W	{of-type} normal
	{turn}	?C	{for-player} W	{of-type} clean
	{turn}	B	{of-type} normal
	{turn}	?C	{for-player} B	{of-type} clean
turn-order}
</source>
Чтобы "очистка" выполнялась автоматически, пришлось создать ещё одного игрока, действующего от имени владельцев фигур. Его ход заключается в размещении на одном из неиспользуемых полей доски (таких полей осталось много, не смотря на <a href="http://habrahabr.ru/post/260599/">оптимизацию</a>) специальной (невидимой) фигуры. Все действия по удалению "мёртвых" групп выполняются в качестве "побочного эффекта" этого хода:

<source>
: drop-m ( -- )
	here a1 = verify	( Это целевое поле? )
	drop			( Ставим фигуру )
	['] my-enemy? 		( Обрабатываем фигуры противника )
	init-alive 		( Добавляем в массив безусловно живые фигуры )
	proceed-alive 		( и всех их соседей )
	capture-all		( Удаляем все фигуры не оказавшиеся в построенном массиве )
	captured-tiles @ 0= IF  ( Если не удалено ни одной фигуры )
		['] my-friend? 	( Повторяем те же действия для дружественных фигур )
		init-alive 
		proceed-alive 
		capture-all
	ENDIF
	add-move		( Завершаем генерацию хода )
;
</source>
Этот код решает сразу две задачи:

<ol>
	<li>Удаление всех вражеских групп, убитых последним ходом</li>
	<li>Самоубийство дружественной группы, если ход был самоубийственным и никого из врагов убить не удалось</li>
</ol>
<spoiler title="Больше подробностей">
<source>
TOTAL []	alive[]				( Массив живых камней )
VARIABLE	alive-count			( и его размер )

: not-alive? ( -- ? )				( Поиск в массиве )
	TRUE
	0 BEGIN
		DUP alive-count @ < IF
			DUP alive[] @ here = IF
				SWAP DROP FALSE SWAP
				TRUE
			ELSE
				1+
				FALSE
			ENDIF
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;

: add-alive ( -- )				( Добавление в массив )
	not-alive? alive-count @ TOTAL < AND IF	( не забываем проверять повторы! )
		here alive-count @ alive[] !
		alive-count ++
	ENDIF
;

: check-alive ( 'op 'dir -- )			( Проверка дружественности соседнего камня )
	EXECUTE IF
		EXECUTE IF
			add-alive
		ENDIF
	ELSE
		DROP
	ENDIF
;

: init-alive ( 'op -- 'op )			( Инициализация массива )
	0 alive-count !
	0 BEGIN					( Все искомые камни расположены в плоскости доски! )
		DUP empty-at? IF
			DUP to OVER ['] n check-alive
			DUP to OVER ['] s check-alive
			DUP to OVER ['] w check-alive
			DUP to OVER ['] e check-alive 
		ENDIF
		1+ DUP PLANE >=
	UNTIL DROP
;

: proceed-alive ( 'op -- 'op )			( Добавление соседей "живых" камней )
	0 BEGIN					( и их соседей тоже )
		DUP alive-count @ < IF
			DUP alive[] @ to OVER ['] n check-alive
			DUP alive[] @ to OVER ['] s check-alive
			DUP alive[] @ to OVER ['] w check-alive
			DUP alive[] @ to OVER ['] e check-alive
			1+ FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;
</source>
</spoiler>
</spoiler>
Небольшой размер доски приводит к высокой конкуренции за <b>дамэ</b>. Те из вас, кто играет в Го, должны знать, что схватки на малой доске (9x9) могут быть гораздо более ожесточёнными, чем игра на стандартной доске (19x19). С самого первого хода, игроки входят в плотное соприкосновение и вынуждены непрерывно решать задачи "жизни и смерти". Такова игра в MarGo, но если бы этим дело и ограничивалось, я не стал бы о ней рассказывать.

<h4><b>Основное отличие</b></h4>
Название игры состоит из двух слов: "marbles" (шарики) и "Go". Вместе получается - "игра в Го шариками". В чём отличие от традиционной игры? В её трёхмерности! Попытки игры в Го на трёхмерных досках предпринимались неоднократно (я <a href="http://geektimes.ru/post/252036/">писал</a> о программе, позволяющей играть на произвольных графах), но, в большинстве таких случаев, серьёзно страдал игровой баланс. Исключением, пожалуй, является лишь доска, имитирующая кристаллическую решётку алмаза. Она во многом подобна классической плоской доске. Каждый узел имеет от 2 до 4 соседей:

<img align="center" src="https://habrastorage.org/files/727/85d/b06/72785db068954845af18145fffe78e3f.png"/>
Подход MarGo совершенно отличен. Шарик не может просто так "висеть в воздухе". Чтобы "подняться над доской" он должен опираться на четыре других шарика (свои или противника). Разумеется, для того, чтобы этот шарик оставался живым, он должен контактировать с группой, имеющей выход хотя бы на одно <b>дамэ</b>. К ортогональным соединениям, лежащим в плоскости доски, добавляются вертикальные направления, соединяющие шарики находящиеся в основании пирамиды с её вершиной.

Эта связь работают в обе стороны. Доступ к <b>дамэ</b> не только даёт жизнь "верхушке" пирамиды, но и может двигаться дальше, в нижние слои, огибая фигуры противника лежащие в плоскости доски. Одно это может сделать игру более интересной, но есть ещё один, гораздо менее очевидный момент. Пока камень на вершине пирамиды остаётся "живым", камни из её основания не могут быть убраны, даже если они принадлежат "мёртвой" группе!

<img src="https://habrastorage.org/files/b92/76e/719/b9276e71990744548dad97f64882363d.PNG"/>

Такие камни, лишённые доступа к <b>дамэ</b> и придавленные фигурами другого цвета, называются "зомби" и они остаются на доске, когда остальная часть "убитой" группы её покидает. Зомби приравниваются к захваченным камням (снятым с доски), но пока они остаются на доске, они могут "передавать" доступ к <b>дамэ</b> другим камням (если он вдруг появится). Кроме того, зомби можно вернуть к жизни, сняв верхушку пирамиды.

<spoiler title="Вторжение в трёхмерность">
Я уже <a href="http://habrahabr.ru/post/259611/">писал</a> о том, что для создания эффекта трёхмерности, мне пришлось разделить каждую фигуру на 4 тайла. Это работает, но загвоздка заключается в том, что фигуры-тайлы приходится располагать на "трёхмерной" доске весьма причудливым образом. Избежать этого никак нельзя. Все тайлы, видимые "сверху", должны находиться в одной плоскости. У этой схемы размещения фигур есть и свои дополнительные плюсы, но навигация в ней уж слишком заковыриста. Для начала, мне понадобилась <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%B4%D0%B0%D0%BB%D0%B0">мандала</a> для медитаций:

<source>
4       A A
3     8 8|9 9
2   5 5|6 6|7 7
1 1 1|2 2|3 3|4 4
+ A B C D E F G H
1 1|5|8|A A|9|7|4
2   1|2 2|3 3|4
3     5|6 6|7
4       8|9
</source>
Согласен, картинка - так себе, но она позволила мне худо-бедно ориентироваться. Мне были нужны направления для естественного перемещения внутри этой схемы. К счастью, с точки зрения Axiom, направления - это всего лишь функции, изменяющие положение маркера текущей позиции в качестве побочного эффекта своего вызова (основным результатом вызова такой функции является возврат булевского значения, означающего успешность перемещения). В общем, направления можно было переопределять и, вскоре, у меня возникла целая их иерархия:

<img src="https://habrastorage.org/files/aa5/2d5/016/aa52d5016b3349de95e0721e0ae43d79.PNG"/>

На схеме показаны лишь функции, ведущие строго на "север" (в каком-то смысле). Часть из них я уже использовал ранее. Направление '<b>n</b>', например, мне пришлось ввести когда я выкидывал из массива "доски" лишние строки, с целью оптимизации использования памяти. Главная часть "ракетной науки" - функция, позволяющая перемещаться в плоскости, параллельной плоскости доски:

<spoiler title="Даже не буду пытаться это комментировать">
<source>
: common-internal ( 'dir -- ? )
	here is-plane? IF
		get-height SWAP EXECUTE IF
			get-height -
			DUP 0= IF
				DROP TRUE
			ELSE
				0> IF
					FALSE
				ELSE
					BEGIN d NOT empty? OR UNTIL
					empty? IF u verify ENDIF
					TRUE
				ENDIF			
			ENDIF
		ELSE
			DROP FALSE
		ENDIF
	ELSE
		here OVER EXECUTE NOT empty? OR IF
			to BEGIN u NOT UNTIL
			EXECUTE
		ELSE
			2DROP TRUE
		ENDIF
	ENDIF
;
</source>
</spoiler>
Большая часть впоследствии найденных ошибок была связана именно с этой функцией (и я до сих пор не уверен, что исправил их все). На её основе, конструируются такие перемещения как north-internal, south-internal и т.д.:

<source>
: north-internal ( -- ? ) ['] n common-internal ;
: south-internal ( -- ? ) ['] s common-internal ;
: west-internal  ( -- ? ) ['] w common-internal ;
: east-internal  ( -- ? ) ['] e common-internal ;
</source>
Это уже практически полноценные функции перемещения, обладающие лишь одним недостатком. При неуспешном перемещении, положение маркера текущей позиции становится неопределённым. Это легко исправить. Достаточно запомнить расположение маркера <b>до</b> перемещения и восстановить его, если переместиться по какой либо причине не удалось:

<source>
: wrap-direction ( 'dir -- ? )
	here 			( Запоминаем положение "маркера" )
	SWAP EXECUTE IF		( и вызываем базовую функцию перемещения )
		DROP TRUE	( если всё прошло успешно, отбрасываем сохранённое значение )
	ELSE
		to FALSE	( в противном случае, возвращаем "маркер" в исходную позицию )
	ENDIF
;

: north ( -- ? ) ['] north-internal wrap-direction ;
: south ( -- ? ) ['] south-internal wrap-direction ;
: west  ( -- ? ) ['] west-internal  wrap-direction ;
: east  ( -- ? ) ['] east-internal  wrap-direction ;
</source>
Осталось совсем немного. Помимо "горизонтальных" перемещений, лежащих в плоскости доски, необходимы направления, ведущие из одной плоскости в другую ("вверх" и "вниз"):

<spoiler title="Ещё немного странного кода без комментариев">
<source>
: up-internal ( -- ? ) 
	here is-plane? IF
		FALSE
	ELSE
		d NOT empty? OR IF
			BEGIN u NOT UNTIL
		ENDIF
		TRUE
	ENDIF
;

: down-internal ( -- ? ) 
	here is-plane? IF
		d NOT empty? OR IF
			FALSE
		ELSE
			BEGIN d NOT empty? OR UNTIL
			empty? IF
				u verify
			ENDIF
			TRUE
		ENDIF
	ELSE
		u verify
		here is-plane? NOT
	ENDIF
;

: up 	( -- ? ) ['] up-internal	wrap-direction ;
: down	( -- ? ) ['] down-internal	wrap-direction ;
</source>
</spoiler>
На этом всё! Теперь у нас есть полный комплект направлений, необходимых для обнаружения "связных" групп.
</spoiler>
Зомби - интересная новая сущность, порождённая простыми и логичными правилами игры. Интересная, но не единственная! MarGo припасла другие сюрпризы.

<h4><b>Мосты и ущелья</b></h4>
Камни на вершине пирамиды "передают" доступ к <b>дамэ</b> дружественным камням, возможно оказавшимся бы в окружении, происходи всё на плоскости. Появляется ещё один способ избежать окружения! Но, постойте, это именно та причина, по которой играть в Го в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=431">трёх измерениях</a> не очень-то интересно. Группы становится слишком тяжело убить! Есть способ всё исправить.

<img src="https://habrastorage.org/files/8d6/60a/ebf/8d660aebfb1f4e01a2010aea8015faf1.PNG"/>

В Го такое соединение считается принципиально не разрезаемым, независимо от возможных ошибок построившего его игрока. Камни, стоящие рядом, живут и умирают вместе. Их невозможно разделить, но только не в MarGo! В этой игре, стоящие вплотную камни можно "разрезать", соорудив над ними мост. Камни, оказавшиеся внизу, по разные стороны моста, превращаются в две разделённые группы.

<spoiler title="По ту сторону моста">
Суть "разрезания" заключается в том, что мы не можем двигаться в выбранном направлении. Это означает, что нам придётся расширить иерархию направлений, о которой я писал выше, добавив новое направление, контролирующее наличие "над головой" моста, построенного из чужих фигур. Поскольку правило "разрезания мостами" очень похоже на опцию (игра может быть интересной и без него), определим флаг-константу, управляющий её работой:

<source>
TRUE	CONSTANT	BRIDGE-CUTTING
</source>
<spoiler title="Далее всё просто">
<source>
: is-covered? ( -- ? )
	player up empty? NOT AND IF
		player <>
	ELSE
		DROP FALSE
	ENDIF
;

: check-bridge? ( 'dir piece-type -- ? )
	piece-type SWAP equal-types? IF
		here
		is-covered? IF
			SWAP OVER to
			EXECUTE IF
				is-covered?
				SWAP to
			ELSE
				to FALSE
			ENDIF
		ELSE
			to DROP FALSE
		ENDIF
	ELSE
		DROP FALSE
	ENDIF
;

: common-cutting ( 'dir 'dir piece-type 'dir piece-type -- ? )
	BRIDGE-CUTTING IF
		check-bridge? IF
			2DROP TRUE
		ELSE
			check-bridge?
		ENDIF
	ELSE
		2DROP 2DROP
		FALSE
	ENDIF
	IF DROP FALSE ELSE EXECUTE ENDIF
;

: north-cutting ( -- ) ['] north ['] east  nw-piece ['] west  ne-piece common-cutting ;
: south-cutting ( -- ) ['] south ['] east  sw-piece ['] west  se-piece common-cutting ;
: west-cutting  ( -- ) ['] west  ['] south nw-piece ['] north sw-piece common-cutting ;
: east-cutting  ( -- ) ['] east  ['] south ne-piece ['] north se-piece common-cutting ;
</source>
</spoiler>
Вся магия скрыта в <b>check-bridge?</b>. Для определения "моста" над головой, "смотрим" наверх, в поисках чужого тайла. То же делаем и на соседнем тайле. Если оба тайла "покрыты" фигурами чужого цвета (разными), "перерубаем" соответствующее направление, заменяя возвращаемое им значение ложным.
</spoiler>
Думаете, что на этом сюрпризы кончились? Как бы не так!

<h4><b>Самый сложный кейс</b></h4>
Самоубийственные ходы запрещены (и по большей части бесполезны). Игрок не может поместить свой камень "в окружение", если при этом не берёт ни одного камня противника. В Го, с этим всё просто. Если мы берём какую-то группу камней, она должна контактировать с только что добавленным камнем и её "убийство" откроет <b>дамэ</b>, необходимые нам для выживания. Но в MarGo есть зомби!

<img src="https://habrastorage.org/files/908/dea/d0a/908dead0a36141dab90a6cc573e3833d.PNG"/>

Даже взяв камень на вершине пирамиды, белый камень всё равно окажется "в окружении", создав тем самым недопустимую позицию! Два чёрных камня составляют "виртуальную группу", защищённую "зомби" лежащим в её основании. Забавно, что это защита очень эфемерна. Если белому, по какой-то причине, удастся взять любой из соседствующих с ним четырёх камней, защита "виртуальной группы" перестанет действовать. Это не просто искусственное построение. Виртуальные группы - важная тактическая составляющая игры MarGo! Что вы скажете, например, о статусе этой позиции? 

<img src="https://habrastorage.org/files/57e/f4d/58b/57ef4d58b2014921bc603ec4cd3b49ae.png"/>

Выглядит как полностью окружённая группа (с одним "глазом"), которую начал поедать белый. В принципе, так оно и есть, но "доесть" группу чёрных не так просто. Белый не может просто сходить в левый нижний угол. Поскольку два белых камня окружают лишь "зомби", такой ход будет считаться самоубийственным. Но и чёрным не стоит спешить с поеданием вторгшегося белого камня:

<img src="https://habrastorage.org/files/629/526/994/6295269949904ec7803604fcf41fa4c7.png"/>

Чёрный добавляет на доску камень, не являющийся "зомби", разрушая тем самым защиту "виртуальной группы". Белый получает право сходить в тот же пункт, где находился его только что съеденный камень, забирая пять чёрных камней. Получается, что лучшее решение для чёрных - не делать ничего? Конечно же, это не так. Белый имеет ещё одну возможность для убийства группы.

<img src="https://habrastorage.org/files/523/48a/38f/52348a38fe9b4a9ab554fb485a220be9.PNG"/>

Если чёрный проигнорирует эту угрозу - его группа обречена!  Соединив свои группы, белый игрок получит возможность безопасно занять последнее <b>дамэ</b>. Защита от такого вторжения очевидна. Лучший ход противника - это и твой лучший ход!

<spoiler title="Действительно сложно">
Как я уже писал выше, добавление игроком камня и удаление "мёртвых" групп мне пришлось разделить на два следующих друг за другом хода (иначе всё получалось совсем сложно). Помимо прочих неудобств, это означает, что я не могу запретить игроку сделать ход, просто на основании того, что он "самоубийственен". В принципе, это не очень большая беда. Разрешим сделать ход и пусть добавленный камень просто умрёт (возможно с группой других камней своего цвета), но это только часть проблемы! Помните, я писал что-то вроде такого кода?

<source>
: drop-m ( -- )
	here a1 = verify
	drop
	['] my-enemy? init-alive proceed-alive check-zombies capture-all
	captured-tiles @ 0= IF
		['] my-friend? init-alive proceed-alive check-zombies capture-all
		captured-tiles @ NEGATE
		update-variables
	ELSE
		captured-tiles @
		update-variables
	ENDIF
	add-move
;
</source>
Пытаемся убрать камни противника и, если это не удалось, пытаемся убрать свои (попутно подсчитывая взятые камни). Так вот, этот код не работает! Действительно, если рассмотреть наш хитрый кейс, то можно заметить, что камни противника снимаются, но добавленный камень всё равно остаётся в окружении! Это действительно проблема. Для того чтобы всё работало нормально, мы должны снять мёртвые камни противника, затем свои и, если это удалось, вернуть камни противника на своё место. Да, в Axiom есть функции, позволяющие создать копию доски, внести в неё какие-то изменения, а потом всё откатить назад, но мне не хотелось бы их здесь использовать! К счастью, есть другой, прекрасно функционирующий механизм отката изменений.

<spoiler title="Разделим код удаления ''мёртвых'' групп на две части">
<source>
{players
	{player}	W
	{player}	B
	{player}	?C	{random}
players}

{turn-order
	{turn}	W	{of-type} high-priority
	{turn}	?C	{for-player} W
	{turn}	B	{of-type} high-priority
	{turn}	?C	{for-player} B
turn-order}

{move-priorities
	{move-priority} normal-priority
	{move-priority} low-priority
move-priorities}

{moves w-drop
	{move} drop-w	{move-type} high-priority
	{move} drop-nw	{move-type} high-priority
moves}

{moves n-drop
	{move} drop-n	{move-type} high-priority
	{move} drop-ne	{move-type} high-priority
moves}

{moves e-drop
	{move} drop-e	{move-type} high-priority
	{move} drop-se	{move-type} high-priority
moves}

{moves s-drop
	{move} drop-s	{move-type} high-priority
	{move} drop-sw	{move-type} high-priority
moves}

{moves m-drop
	{move} clear-e	{move-type} normal-priority
	{move} clear-f	{move-type} low-priority
moves}

{pieces
	{piece}		M	{drops} m-drop
	{piece}		tw	{drops} w-drop
	{piece}		zw
	{piece}		ww
	{piece}		bw
	{piece}		tn	{drops} n-drop
	{piece}		zn
	{piece}		wn
	{piece}		bn
	{piece}		te	{drops} e-drop
	{piece}		ze
	{piece}		we
	{piece}		be
	{piece}		ts	{drops} s-drop
	{piece}		zs
	{piece}		ws
	{piece}		bs
pieces}
</source>
</spoiler>
С более высоким (<b>normal</b>) приоритетом будет выполняться код удаления мёртвых групп противника (clear-e), а с низким (<b>low</b>) - удаления своих мёртвых групп (уровень <b>high</b>, вне списка приоритетов, резервируем для обычного добавления камней на доску). Теперь всё работает как надо. Сначала генератор ходов пытается выполнить более приоритетный <b>clear-e</b>, в конце которого мы проверяем, не попал ли добавленный камень в окружение (запрещая ход, если это произошло). Если приоритетный ход провалил какую-то из проверок, генератор ходов <b>сам</b> откатывает все изменения, и отрабатывает низкоприоритетный <b>clear-f</b>. Этот код всегда выполняется успешно. Иногда побочным эффектом его выполнения является удаление "самоубитых" групп.

<spoiler title="Код очистки тоже усложнился">
<source>
: clear-e ( -- )
	0 captured-count !
	here a1 = verify
	drop
	['] my-enemy? init-alive proceed-alive check-zombies capture-all
	captured-tiles @ 0> verify
	captured-tiles @ update-variables
	['] my-friend? init-alive proceed-alive check-zombies check-not-captured
	add-move
;

: clear-f ( -- )
	0 captured-count !
	here a1 = verify
	drop
	['] my-friend? init-alive proceed-alive check-zombies capture-all
	captured-tiles @ 0> IF
		captured-tiles @ NEGATE
		update-variables
	ELSE
		DROP
	ENDIF
	add-move
;
</source>
</spoiler>
В целом, немножко замороченно, но это работает.
</spoiler>
<h4><b>Без Ко нет Го</b></h4>
Ну ладно, есть ещё один <a href="http://geektimes.ru/post/240680/">непростой кейс</a>, благополучно унаследованный от более традиционной версии игры. Поскольку, как я уже говорил, в плоскости доски все правила Го остаются в силе, вполне можно проделать следующий фокус:

<img src="https://habrastorage.org/files/aad/fb3/956/aadfb3956bbf40d2a163f1915af08773.PNG"/>

Если как-то не обломать всю эту веселуху, игроки получат возможность пожирать камни друг друга до бесконечности. Разумеется, MarGo допустить такого не может и запрещает ходы, ведущие к повторению предыдущей позиции. В <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">правилах игры</a>, речь идёт о <a href="http://senseis.xmp.net/?Superko">ситуационном суперко</a>.

<img src="https://habrastorage.org/files/29e/543/f66/29e543f6689146af8bde5ca651b19220.PNG"/>

Чёрный не может съесть белый камень немедленно и вынужден ходить в другой части доски. Следующим ходом, белый может соединиться.

<spoiler title="Из жизни невидимок">
Увы, мне не реализовать обнаружение ни позиционного ни ситуационного суперко. Для этого необходима информация о предыдущих позициях (хотя бы хэши), а у меня её нет! К счастью, все эти "<a href="http://www.gameofgo.ru/7.htm">циклические ко</a>", "<a href="http://www.gameofgo.ru/8.htm">вечные жизни</a>" и прочие экзотические позиции не делают погоды. В реальной Ко-борьбе, практически всегда, фигурирует <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE">простое Ко</a>. Его и будем ловить.

<spoiler title="Чтобы запретить ход в ''пустой'' пункт, надо сделать его не пустым">
<source>
: drop-marks ( -- )
	0 BEGIN
		DUP captured-count @ < IF
			mark OVER captured[] @ create-piece-type-at
			1+ FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL DROP
;

: clear-marks ( -- )
	0 BEGIN
		DUP empty-at? NOT IF
			DUP piece-type-at mark = IF
				DUP capture-at
			ENDIF
		ENDIF
		1+ DUP PLANE >=
	UNTIL DROP
;
</source>
</spoiler>
Мы можем помещать на доску невидимые тайлы, чтобы сделать невозможным ход в выбранную позицию. При выполнении хода в любой разрешённый пункт, будем просто удалять эти помехи. Здесь нам на руку играет одно из важных свойств MarGo. Любая Ко-борьба всегда будет происходить в плоскости основания доски! Чтобы добавленные "пустые" тайлы не мешали определению статуса групп, изменим функцию определения пустоты узла:

<source lang="diff">
: my-empty-at? ( pos -- ? )
	DUP curr-pos !
-	empty-at? IF
+	DUP empty-at? SWAP piece-type-at mark = OR IF
		TRUE
	ELSE
	...
	ENDIF
;
</source>
Осталось добавить Ко-пометку на доску. Мы делаем это, на месте снятого камня противника, при условии, что, если бы этот камень не был снят, "самоубившаяся" группа состояла бы ровно из одного, только что добавленного камня. Звучит сложно? В общем-то да, так оно и есть.
</spoiler>
<h4><b>Что за кадром?</b></h4>
Разумеется, не всё пошло гладко. Некоторые правила реализовать я просто не смог. Самоубийственные ходы, например, в MarGo безусловно запрещены. Это означает, что игрок не имеет права сделать ход лишающий группу (возможно состоящую лишь из одного, только что добавленного камня) последнего <b>дамэ</b>, при условии, что не берёт этим ходом камни противника.

Я был вынужден разделить ходы выполняющие добавление камня и удаление взятых камней, что лишило меня всякой возможности запрета "самоубийственных" ходов. Это может показаться мелочью. В конце концов, хотя "самоубийственные" ходы и запрещены в большинстве вариантов правил Го, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%98%D0%BD%D0%B3%D0%B0">правила Инга</a> их допускают. На то имеется веская причина. Существуют (очень редкие) позиции, в которых убийство собственной группы позволяет игроку спастись в совершенно <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%98%D0%BD%D0%B3%D0%B0#.D0.9F.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA_.D0.B8.D0.B3.D1.80.D1.8B">безнадёжной ситуации</a>.

<img align="center" src="https://habrastorage.org/files/ef8/f2c/dc3/ef8f2cdc3208428eb915d51e08d6e87c.png"/>

<a href="http://www.gameofgo.ru/5.htm">Секи</a> не принесёт очков, но по сравнению с полной потерей группы, это серьёзное подспорье, ведь противник не получит очков тоже! К сожалению, одно тянет за собой другое. В MarGo (в отличии от Го) игрокам запрещается пропускать ход. Но, попав в безвыходную ситуацию, игрок, практически всегда, будет иметь возможность сделать ход, приводящий к самоубийству только что добавленного камня. Что это как не <abbr title="Только при использовании китайского варианта правил для подсчёта очков!">пропуск хода</abbr>? И это то, что я также не могу запретить.

В любом случае, эти отличия не столь значимы, чтобы о них стоило переживать. С AI дело обстоит <b>гораздо</b> хуже. В текущей реализации его попросту нет! Приложение можно использовать как "интеллектуальную" доску для игры двух человек или для разбора этюдов, но поиграть с ней не получится. Дело даже не в самой сложности AI для Го (разработчикам ZoG пришлось использовать DLL-engine и играет он не слишком хорошо). Прежде чем думать об AI, необходимо реализовать, по крайней мере, логику подсчёта очков.

Целью игры Го является не "поедание" камней противника (хотя они тоже идут в зачёт), а <abbr title="Здесь и далее я буду говорить о японском варианте правил">захват территории</abbr> (о том, чем это отличается от китайских правил, я писал <a href="http://geektimes.ru/post/241844/">здесь</a>). Территорией игрока считаются все пустые пункты, добраться от которых можно лишь до фигур своего цвета. MarGo расширяет и это понятие. К традиционным пунктам территории, расположенным в плоскости доски, добавляются пункты на "площадках", состоящих из четырёх камней своего цвета. Если подумать, это тоже территория. На этих пунктах можно разместить камни и "добраться" от них можно лишь до своих камней. Подчеркну, что <b>дамэ</b> такие пункты не являются! Жизнь группы обеспечивают лишь свободные пункты, расположенные в плоскости доски.

<img align="center" src="https://habrastorage.org/files/c8d/0d9/08c/c8d0d908cabd41e7b044c8c4a50c4e71.PNG"/>

Подсчёт территории, определённой таким образом, дело сложное, но вполне решаемое. К сожалению, этим дело не ограничивается. MarGo добавляет к территории те пункты, которые игрок может заполнить "потенциально". Например, если у игрока есть квадрат 4x4, состоящий из 16 фигур своего цвета, то на его "площадках" он сможет разместить 4 камня (в свою очередь образующих новую площадку, для ещё одного камня). Помимо этого, если начальный квадрат 4x4 не заполнен, внутренние его пункты также добавляются к территории. Всё это звучит логично, но пока я боюсь даже браться за такую задачку на ForthScript.

<img align="center" src="https://habrastorage.org/files/8a6/441/4a2/8a64414a2ad843d2996f77b6628f9f34.PNG"/>

Подсчёт захваченных камней - тоже дело хитрое. Кроме камней, захваченных в процессе игры, к ним, понятное дело, добавляются "зомби" (ладно, их можно сосчитать), а также камни, составляющие группы, оказавшиеся, к концу игры, в безнадёжной ситуации (а вот тут - всё плохо). Обычно, перед подсчётом очков, игрокам предоставляется возможность ручного удаления "мёртвых" групп, но в ZoG это та ещё задачка! 

Даже если мне удастся решить все эти проблемы, то это вовсе не означает, что я смогу реализовать хоть сколь нибудь сильный AI для этой игры. Хотя попробовать, наверное, стоит.
</cut>

Несколько хороших манкал

<img align="left" src="https://habrastorage.org/files/e3d/abe/1a2/e3dabe1a22cd4305862ca499fbb336b9.jpg"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Хотя этикетка была не того цвета и содержала немало орфографических ошибок, большая ее часть находилась на месте, включая сделанную крошечным шрифтом надпись «<abbr title="Лорд Витинари не принял вариант «Возможно, не содержит орехи», так как счел его бесполезным.">Может содержать орехи</abbr>».
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Пратчетт&nbsp;
</i></b>
<a href="http://geektimes.ru/post/241844/">Го</a> или <a href="http://habrahabr.ru/post/224661/">Ур</a>? Можно долго спорить, какая из игр древнее, но победит, в этом противостоянии, скорее всего, <a href="http://geektimes.ru/post/253456/">Манкала</a>. Археологи предпочитают иметь дело с материальными свидетельствами, но как только речь заходит о настольных играх, всё быстро уходит в область предположений. Было найдено немало досок, но гораздо меньше сведений о том, как на них играть. Древние не утруждали себя детальным описанием правил.

С Манкалой ситуация прямо противоположная. Это не одна игра, а весьма многочисленное семейство. В одной только <a href="http://skyruk.livejournal.com/410114.html">Западной Африке</a>, счёт идёт на десятки (если не на сотни) разновидностей. Доска (как материальный артефакт) для таких игр не обязательна. Достаточно взять пригоршню камушков и выкопать несколько ямок в песке. Не удивительно, что археологи испытывают затруднения с определением возраста этих игр. Им попросту нечего искать! Но для внимательного исследователя "настольных игр", манкалы не менее интересны, чем птицы семейства <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D1%81%D0%BC%D0%B5%D1%88%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5">пересмешниковых</a> для <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D1%80%D0%B2%D0%B8%D0%BD,_%D0%A7%D0%B0%D1%80%D0%BB%D0%B7#.D0.9F.D1.83.D1.82.D0.B5.D1.88.D0.B5.D1.81.D1.82.D0.B2.D0.B8.D0.B5_.D0.BD.D0.B0.D1.82.D1.83.D1.80.D0.B0.D0.BB.D0.B8.D1.81.D1.82.D0.B0_.D0.BD.D0.B0_.D0.BA.D0.BE.D1.80.D0.B0.D0.B1.D0.BB.D0.B5_.C2.AB.D0.91.D0.B8.D0.B3.D0.BB.D1.8C.C2.BB_.281831.E2.80.941836.29">Чарлза Дарвина</a>.
<cut>
На сегодняшний день, в каталоге <a href="http://www.zillions-of-games.com/">Zillions of Games</a> содержится более двух тысяч <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi">приложений</a>. Нельзя сказать, чтобы среди них совсем не было манкал. Во всяком случае, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=227">двурядные</a> и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1004">четырёхрядные</a> варианты игр представлены весьма основательно. Вот такой набор игр предоставляется всего лишь одним из приложений:

<img align="center" src="https://habrastorage.org/files/3bd/06d/319/3bd06d3199434f77b9d448033d68f129.PNG"/>
Это действительно достойный список, но, как я уже писал выше, количество манкал исчисляется сотнями, а здесь представлены, скажем так, наиболее привычные из них. Существуют куда более удивительные и замечательные разновидности этой игры. И сейчас я хочу ими заняться! Но для начала, стоит составить небольшой словарик терминов, для того, чтобы люди, не знакомые с предметом, имели хоть какие-то шансы в нём разобраться.

<spoiler title="Словарик">
<ul>
	<li><b>посев</b> - У большинства народов, практикующих их, манкалы символизируют привычную сельскохозяйственную деятельность. Метафора "посева" объединяет все эти игры. Выполняя ход, игрок забирает <b>все</b> камни из одной из своих лунок и начинает раскладывать их <b>по одному</b>, по всем следующим лункам, в одном из направлений, разрешённых правилами. Существуют различные пословицы и поговорки, связывающие тактику игры с сельскохозяйственными понятиями, аналогичные русскому варианту "что посеешь, то и пожнёшь".</li>
	<li><b>однократный посев</b> - В большом количестве вариантов игры, "посев" выполняется "однократно". После того как игрок раскладывает последний из взятых камней (не важно, в пустую или заполненную лунку), ход переходит другому игроку. Существуют различные варианты "посева", затрудняющие расчёт в игре. Например, посев может начинаться не со следующей лунки, а с текущей (то есть, один камень просто остаётся в лунке) или стартовая лунка может пропускаться при посеве, если взятое число камней достаточно для того, чтобы сделать один или несколько кругов, обойдя все лунки.</li>
	<li><b>циклический посев</b> - Более сложная разновидность хода. Ход начинается также как и "однократный посев", но, если игрок выкладывает последний камень в заполненную лунку, он немедленно забирает из неё все камни (включая добавленный последним) и продолжает посев со следующей лунки. Ход заканчивается когда последний камень падает в пустую лунку.</li>
	<li><b>бесконечный посев</b> - Как легко догадаться, выполняя "циклический посев", игрок вполне может "зациклиться". Игрок не сможет завершить ход, поскольку последний камень никогда не будет попадать в пустую лунку. Такая ситуация называется "бесконечным посевом" и реакция на неё регламентируется правилами конкретной игры. Обычно, при возникновении "бесконечного посева", партия считается не сыгранной либо переигрывается.</li>
	<li><b>захват</b> - Цель почти любой манкалы (есть несколько исключений) - захват максимального количества камней. Правила, позволяющие перекладывать камни с доски в свой "амбар", существенно различаются, в зависимости от варианта игры. В двурядных манкалах, правила захвата часто связаны с количеством камней в финальной лунке (например, в "<a href="http://www.iggamecenter.com/info/ru/toguzkumalak.html">Тогыз Кумалак</a>", захват выполняется, если после добавления последнего камня посева число камней в лунке стало чётным). В четырёхрядных манкалах, поскольку посев идёт лишь по своей территории, захват "позиционный" (в <a href="http://mancala.wikia.com/wiki/Chuba">Chuba</a>, если последний камень упал в пустую лунку внутреннего ряда, захватываются все камни из противостоящей лунки во внутреннем ряду противника, а также камни из следующей за ней лунки внешнего ряда, если они там есть).</li>
	<li><b>серийный захват</b> - Часто, захват осуществляется сразу из нескольких лунок. Так например, в <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%80%D0%B8_(%D0%B8%D0%B3%D1%80%D0%B0)">Вари</a>, игрок захватывает камни, если в последней лунке посева оказалось 2 или 3 камня. Если в предыдущих (по направлению посева) лунках противника также оказалось по 2 или 3 камня, они захватываются тоже!</li>
	<li><b>полный захват</b> - В большинстве манкал, игрок не сможет выполнить ход, оставшись без камней. Часто, в таких случаях, игра завершается. Все камни, оставшиеся на территории противника, перекладываются в его амбар, после чего подсчитываются. Это вполне нормальное завершение игры, но, чтобы игра была более интересной, вводятся правила, целью которых является увеличение продолжительности игры. Например, правилами может быть запрещено выполнение ходов, приводящих к захвату всех оставшихся камней на территории противника, так называемому "полному захвату".</li>
	<li><b>правило "голода"</b> - Другая сторона той же монеты. Если противник остался без камней на своей стороне, игрок обязан "подкормить" его, подкинув на чужую территорию хотя бы один камень. Если такой ход невозможен - игра заканчивается. Это один из примеров очень редкой для манкал разновидности <b>форсированных</b> ходов, аналогичных обязательному взятию в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашках</a> или уходу из под <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>.</li>
	<li><b>нулевой посев</b> - Во многих случаях, первый игрок имеет преимущество. Чтобы решить эту проблему (а также сломать всевозможные дебютные "домашние заготовки"), в некоторых манкалах, при выполнении первого хода захват не выполняется. Цель этого "нулевого" прогона - рандомизация позиции на доске. Часто, для экономии времени, игроки выполняют "нулевой посев" одновременно. В этих случаях он служит и для определения очерёдности хода. Игрок, завершивший посев первым, делает первый ход.</li>
	<li><b>коми</b> - Этот термин пришёл из <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> и является ещё одним способом компенсации преимущества первого игрока. Второй игрок, ещё до начала игры, получает некоторое оговоренное количество очков (как правило дробное, чтобы исключить возможность ничьих). В Го и некоторых современных манкалах такой подход активно используется.</li>
	<li><b>сэнтэ и готэ</b> - Ещё два понятия из Го. Сэнтэ - это ход, на который противник вынужден ответить, а готэ - напротив, вынужденный ход. Некоторые современные манкалы оперируют этими терминами, хотя и понимают их несколько по своему.</li>
	<li><b>правило "пинг-понга"</b> - В <a href="http://skyruk.livejournal.com/390575.html">Алемунгула</a> возможна ситуация, при которой игроки будут иметь возможность, ход за ходом, перекидывать друг другу один и тот же камень. Правило "пинг-понга" запрещает подобное повторение позиции. По аналогии с предыдущими терминами, его следовало бы назвать "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE">Правилом Ко</a>", но, по всей видимости, жители Эфиопии были слабо знакомы с японской игрой.</li>
</ul>
</spoiler>
<h4><b>Tchuka Ruma</b></h4>
Начать я решил с простого. <a href="http://skyruk.livejournal.com/311958.html">Чука Рума</a> не является традиционной игрой (в том смысле, что лет ей не 5000, а всего 120), но по правилам весьма сходна с <a href="http://skyruk.livejournal.com/342579.html">Даконом</a>, широко распространённым на территории Индонезии. За исключением того что Чука Рума рассчитана на игру <b>одного</b> человека. Да, это единственная известная мне манкала-пасьянс. Вот как она выглядит:

<img align="center" src="https://habrastorage.org/files/b54/772/aba/b54772aba8214239adac7cb9e71d842a.png"/>
Требуется перенести все камни в "амбар" (крайнюю правую лунку), соблюдая следующие правила:

<ul>
	<li>В начале игры, можно взять <b>все</b> камни из любой лунки (кроме "амбара") и выполнить <b>циклический посев</b>, раскладывая камни слева-направо и переходя от "амбара" к крайней левой лунке.</li>
	<li>Если последний камень падает в "амбар", игрок получает право повторить ход, вновь выбрав любую не пустую лунку, кроме "амбара" (именно это правило роднит "Чука Руму" с манкалами семейства "Чонгкак" и "Дакон").</li>
	<li>Если <b>циклический посев</b> завершён в любой другой лунке - игрок проигрывает (пасьянс не сошёлся).</li>
</ul>
Эта замечательная "гимнастика для ума" впервые (в 1895 году) была описана французским математиком Анри-Огюстом Деланнуа в переписке с его коллегой Эдуардом Лукасом. Любое сходство с "Даконом" не случайно, так как, по всей видимости, именно эту игру Анри-Огюст использовал в качестве прототипа.

<spoiler title="Самый ''простой'' посев">
В принципе, никто не мешает использовать для разработки манкал "штатный" ZRF. Кучки камней представляются отдельными фигурами (по числу камней) и вся задача "посева" заключается в правильном изменении типа нескольких фигур, за один ход (ZSG-нотация становится совершенно нечитаемой, но читать её никто и не собирается). Это было бы почти так же просто как <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>, если бы не один <abbr title="не тот, о котором вы подумали">фатальный недостаток ZRF</abbr>. В нём напрочь отсутствует какая либо арифметика!

<spoiler title="Код на нём действительно кошмарен">
<source lang="lisp">
(define AB if (piece? $1) (change-type $2) else)

(define OC (set-position-flag occ true))

(define ABC
	((AB $1 $2)   ((AB $3 $4)   ((AB $5 $6)   ((AB $7 $8)
	((AB $9 $10)  ((AB $11 $12) ((AB $13 $14) ((AB $15 $16)
	((AB $17 $18) ((AB $19 $20) ((AB $21 $22) ((AB $23 $24)
	((AB $25 $26) ((AB $27 $28) ((AB $29 $30) ((AB $31 $32)
	((AB $33 $34) ((AB $35 $36) ((AB $37 $38) ((AB $39 $40) 
	((AB $41 $42) ((AB $43 $44) ((AB $45 $46) ((AB $47 $48)
	((AB $49 $50) ((AB $51 $52) ((AB $53 $54) ((AB $55 $56)
	((AB $57 $58) ((AB $59 $60) ((AB $61 $62) ((AB $63 $64)
	((AB $65 $66) ((AB $67 $68) ((AB $69 $70) ((AB $71 $72)
	(set-flag emu true)))))))))))))))))))))))))))))))))))))
)

(define sow-in-store cascade (while not-empty? e) to (OC) (go from))

(define sow-in-store2 
	cascade (while not-empty? e) 
	cascade e to (while (not-in-zone? store) (opposite e))
)

(define sow-in-store3 
	cascade (while not-empty? e) 
	cascade e cascade e to (while (not-in-zone? store) (opposite e))
)
...
</source>
</spoiler>
Это часть реализации <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=226">Калаха</a> и продраться через все её макросы действительно не просто. Я решил не мучать свой мозг и задействовать <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>. Используемый ей, в качестве скриптового языка, <b>ForthScript</b> конечно придаёт процессу программирования некоторую <abbr title="Всегда следите за стеком!">пикантность</abbr>. Но в нём можно складывать числа!

<spoiler title="Начнём с определения фигур">
<source>
DEFER		MARK
...
{pieces
	{piece}		m
	{piece}		p1	1	{value}
	{piece}		p2	2	{value}
	...
pieces}
...
' m	IS MARK
</source>
</spoiler>
Фигура <b>m</b> - фиктивная. От неё будет выполняться "отсчёт" при построении всех остальных фигур. Псевдоним <b>MARK</b> позволит на неё ссылаться из вышележащего кода. Числовое значение - количество камней в "кучке" и, по совместительству, вес "фигуры", используемый AI Axiom (для "Чука Румы" этот вопрос не особенно актуален, но в играх двух игроков будет иметь первостепенную важность).

<spoiler title="Добавим движущиеся фигуры">
<source>
: get-value ( -- value )
	empty? IF			( Если поле пусто )
		0			( Возвращаем 0 )
	ELSE				( иначе )
		piece piece-value	( Достаём значение value из описания фигуры )
	ENDIF
;

: move-q ( -- )
	get-value stone-count !		( Сохраняем количество камней в переменную )
	next verify			( Перемещаемся в следующую лунку )
	from here move			( Переносим фигуру с её начального положения в текущее )
	build-trace			( Рассчитываем изменения всех фигур )
	from to 			( Возвращаемся в исходную точку )
	use-trace			( Применяем все рассчитанные изменения ... )
	add-move			( и завершаем генерацию хода )
;

{moves q-moves
	{move} move-q
moves}

{pieces
	...
	{piece}		q1	{moves}	q-moves	1	{value}
	{piece}		q2	{moves}	q-moves	2	{value}
	{piece}		q3	{moves}	q-moves	3	{value}
	...
pieces}
</source>
</spoiler>
Здесь есть две "тёмных лошадки" - <b>build-trace</b> и <b>use-trace</b>, далее мы рассмотрим их базовую реализацию. Оставшаяся часть <b>move-q</b> связана с "перемещением" фигуры. Дело в том, что любой ход в ZoG должен быть связан с одним из двух возможных действий: перемещением фигуры с одной позиции доски на другую (<b>move</b>) или добавлением новой фигуры на доску (<b>drop</b>). Соответственно, одно из этих управляющих слов должно быть задействовано и в описании хода. Все остальные (побочные) действия <b>должны</b> выполняться после этого (основного) действия.

<spoiler title="Рассчитаем ''трассу''">
<source>
COLS []		trace[]
VARIABLE	trace-count
VARIABLE	stone-count

: build-trace ( -- )
	0 trace-count !				( На всякий случай, "очищаем" массив )
	0 BEGIN					( и начинаем цикл )
		DUP COLS >= IF			( Если оказалось, что мы обошли вокруг доски )
			DROP 0			( Зацикливаем массив, его длина не должна превышать количества лунок )
		ENDIF
		DUP trace-count @ < IF		( Если мы уже вычисляли число камней в этой лунке )
			DUP trace[] @		( Достаём ранее вычисленное значение )
		ELSE				( иначе )
			trace-count ++		( Увеличиваем размер массива )
			from here <> IF		( и если это не исходная лунка )
				get-value	( Достаём из неё количество камней )
			ELSE
				0		( Исходная лунка первоначально пуста, мы "вынули" из неё камни )
			ENDIF
		ENDIF
		1+ OVER trace[] !		( Добавляем один камень )
		stone-count --			( Уменьшаем количество оставшихся камней )
		stone-count @ 0= IF		( И если камни кончились ... )
			TRUE			( Завершаем цикл )
		ELSE				( иначе )
			1+ next verify		( Двигаемся по доске дальше )
			FALSE			( и НЕ завершаем цикл )
		ENDIF
	UNTIL					( Цикл завершается, если на верхушке стека TRUE )
	...					( Здесь удобное место для всякой "магии" )
	DROP
;
</source>
</spoiler>
Все изменения рассчитаны, осталось их применить!

<spoiler title="И изменим все фигуры, попавшие под раздачу">
<source>
: use-trace ( -- )
	0 BEGIN					( Перебираем все элементы массива )
		next verify			( Двигаясь в направлении посева )
		DUP trace[] @                   ( Вынимаем из массива количество камней )
		MARK + create-piece-type	( И создаём фигуру соответвующего типа, добавляя его к MARK )
		1+ DUP trace-count @ >=		( Если конец массива - завершаем цикл )
	UNTIL DROP				( Не забываем следить за стеком ! )
;
</source>
</spoiler>
Ну вот, мы научились брать камни из лунки и раскладывать их по одному, в направлении посева. В том или ином виде, этот код будет использован во всех сегодняшних манкалах. Разумеется, реальный код <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/TchukaRuma/Pieces.4th">немного сложнее</a>. Например, приходится "подсвечивать" те группы камней, ходить которыми разрешено (иначе сходить ими не удастся) и снимать подсветку с остальных групп. При попадании в "амбар", необходимо помечать все группы, оставшиеся на доске. И разумеется, необходимо написать <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/TchukaRuma/AI.4th">код</a>, определяющий условия завершения игры. Куча мелочей, без которых ничего работать не будет!
</spoiler>
Вот что получилось в итоге:

<video>http://www.youtube.com/watch?v=0NRdY6p7xic</video>

Надо сказать, что AI <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> щелкает такие задачки "как орешки". Исходный расклад (по два камня в четырёх лунках) <a href="http://www.zillions-of-games.com/">ZoG</a> решила на минимальных настройках "продолжительности хода". Для более сложных раскладов, настройки пришлось "подкрутить", поскольку, в противном случае, программа попадала в тупик. В процессе тестирования, был найден ещё один "решаемый" расклад, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2443">для любителей "поломать голову"</a>.

<h4><b>Ohojitxi</b></h4>
В <a href="http://skyruk.livejournal.com/396880.html">эту</a> весьма оригинальную манкалу играют в республике Кот-д’Ивуар. Внешне, она выглядит как обычная двурядная манкала, с шестью лунками на каждой стороне, но поскольку при игре доска располагается "вертикально", её более уместно причислять не к двурядным, а к "шестирядным" манкалам. <b>Посев однократный</b>, против часовой стрелки и только на своей территории - в трёх рядах, обращённых к игроку.

На этом неожиданности не заканчиваются! Цель игры - не захват камней противника, а избавление от своих собственных. Захваченные камни передаются противнику (помещаются в одну из его лунок). Кто первый избавится от всех своих камней - тот и победил. <b>Захват серийный</b>, если последний камень падает в лунку с тремя камнями (дополняя их до четырёх) - камни захватываются. Вместе с ними захватываются камни из всех предыдущих (против направления посева) лунок, содержащих четыре камня. Если бы первоначально все 24 камня находились в одной лунке, игру можно было бы завершить за один ход!

<video>http://www.youtube.com/watch?v=yrcp6lAcFMo</video>

В общем, игра довольно забавная. На первый взгляд, она не сильно отличается от предыдущего пасьянса (поскольку посев всегда ведётся лишь на своей территории), но если противник успеет "собрать четвёрку" раньше вас, будьте уверены, он постарается выбрать лунку таким образом, чтобы максимально расстроить все ваши планы (и всё придётся начинать сначала). Единственное ограничение заключается в том, что он не может каждый раз выбирать одну и ту же лунку.

<spoiler title="Как важно быть внимательным">
Доска в Axiom - это один большой линейный массив. Серьёзно, мы можем просто начать с нуля и перебрать все позиции, добавляя к индексу единичку. Поскольку, в реальной жизни, редко встречаются одномерные доски (редко, но <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1525">встречаются</a>), Axiom заботится о нас, предоставляя средство для определения досок "двумерных":

<source>
2	CONSTANT	COLS
6	CONSTANT	ROWS

{board
	ROWS COLS	{grid}
board}
</source>
На самом деле, это всё тот же одномерный массив, ячейки которого поименованы забавным образом (ещё он позволяет определять "направления", оперируя приращениями координат, а не парами позиций, но это нам сейчас не понадобится):

<img align="center" src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"/>
В ZRF-описании, мы должны разметить доску аналогичным образом, чтобы ZoG понимала, с чем имеет дело:

<source lang="lisp">
  (board 
    (image "Images/Ohojitxi/6x2.bmp")
    (grid
      (start-rectangle 6 4 73 89)
      (dimensions
        ("a/b" (67 0)) ; files
        ("6/5/4/3/2/1" (0 85)) ; ranks
      )
    )
  )
</source>
Вот с этого места и начинается веселье. Мы пишем <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/Ohojitxi/Pieces.4th">много кода</a>, кодируя посевы и захваты, постепенно забывая об унылом и отсталом ZRF. В какой то момент, нам становится позарез необходимо закодировать новое правило - "выполняя захват, игрок не может каждый раз выбирать одну и ту же лунку противника". Очевидно, пометки лунок необходимо где то хранить! А где ещё, если не на доске?

<source>
4	CONSTANT	COLS
</source>
Смело расширяем доску вдвое! Нет, это даже работает. Некоторое время. Сразу вслед за этим, мы получаем от программы загадочное послание:

<img align="center" src="https://habrastorage.org/files/7fd/d17/726/7fdd17726bf145a48640cf64783053cf.png"/>
Ясно, что кто-то кого-то не понимает, но чтобы вспомнить о ZRF требуется ещё полчаса нервных поисков! И уже после того как игра сделана, отлажена и даже отправлена для публикации, всплывает тот факт, что вариантов досок мы делали <a href="https://github.com/GlukKazan/ZoG/commit/d148258a0477455aa9824aaee50b786d1b2460f8">два</a>.
</spoiler>
Играть в Охочичи приятно при наличии большого количества свободного времени. Партия равных соперников может продолжаться очень долго. Для того, чтобы собрать последние камни, приходится потратить немало ходов. Как правило, противник успевает раньше и всё начинается с начала. Серийный захват помогает разорвать порочный круг, но его ещё надо сложить. Когда <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2442">программа</a> играет "сама с собой", средняя продолжительность партии составляет порядка 500 ходов (впрочем, меня она обыгрывает так быстро, что я не успеваю сообразить, что произошло).

<h4><b>Afrika</b></h4>
Да-да, именно через эту букву! Слово-то немецкое. Я имею в виду, что придумал <a href="http://mancala.wikia.com/wiki/Afrika_(game)">игру</a> немец - Ralf Gering. И произошло это в 2004 году. Это скандальная манкала! Во-первых, ей меньше 120 лет. Помимо этого, она собрала 5 "рейтингов ненависти" на <a href="http://www.boardgamegeek.com/">BoardGameGeek</a>. Впоследствии выяснилось, что все они от "виртуалов" одного и того же человека (подозреваю, что это было что-то личное) и из пяти был оставлен один, самый первый.

Если говорить серьёзно, то эта игра слишком не похожа на все другие манкалы. По "геймплею" она гораздо ближе к <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашкам</a>. Всё дело в механизме захвата. В "Африке" он обязательный! В других манкалах тоже есть "форсированные" ходы (<b>правило "голода"</b> - в большинстве африканских манкал), но там они не имеют столь первостепенного значения! Если есть возможность захвата - игрок должен брать! И это то, что делает игру уникальной.

<img align="center" src="https://habrastorage.org/files/65e/726/176/65e7261764674a5887379abe54f18ce6.PNG"/>
Правила просты. <b>Посев однократный</b>, всегда из своего ряда, против часовой стрелки, без захода в "амбары". Захват осуществляется из не пустой лунки противника, расположенной напротив пустой лунки игрока и может выполняться лишь из лунок, содержащих минимальное количество камней (если в одной лунке два камня, а в другой три - брать можно только из той, где два). Захват считается отдельным ходом и имеет приоритет по отношению к "посеву". Такие правила закономерно приводят к тактике "отдай меньше, чтобы забрать больше":

<img align="center" src="https://habrastorage.org/files/654/52f/095/65452f0956b841e3abdae7e8dab4ef9f.PNG"/>
Диаграмма великолепно иллюстрирует концепцию. Мы отдаём один камень, чтобы взамен забрать четыре (сразу скажу, что столь очевидный ход впоследствии заводит в тупик, у задачки есть лучшее решение). Самое замечательное в этом то, что противник не может игнорировать нашу жертву. Он обязан взять камень и, теряя ход, не может защитить свои. Это в гораздо большей степени "сэнтэ" чем смысл, вкладываемый в это <a href="http://go-igo.ru/dictionary-go/sente.html">понятие</a> в Го. Как и в <a href="http://habrahabr.ru/post/258437/">Шашках</a>, отказ от форсированных ходов сделает игру куда менее интересной.

Как правило, в играх с "обязательным взятием", "обратная игра" представляет определённый интерес (возможно для многих будет сюрпризом, но "<a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Поддавки</a>", в тактическом плане, гораздо более сложная игра, чем обычные шашки). В ноябре 2010 года, Benedikt Rosenau предложил "обратный" вариант игры, на основе правил "Африки". Разумеется, я <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2450">реализовал</a> оба варианта игры.

<spoiler title="Чьи камни?">
В Охочичи посев вёлся на своей территории, а в "Чука Руме" игрок вообще был один. "Африка" - первая игра, в которой мы заходим на территорию противника. Немедленно возникает проблема. Дело в том, что в ZoG игрок может перемещать только свои фигуры! Отчасти, это ограничение связано с вопросами производительности и оно может даже казаться разумным, до тех пор, пока мы не сталкиваемся с чем-то вроде <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2247">этого</a>. В нашем случае, важно, что мы должны следить не только за типом фигур (количество камней и пометка), но и за их принадлежностью.

<spoiler title="К счастью, это просто">
<source>
: get-player ( -- )
	here COLS < IF				( Если текущая позиция в верхней половине доски )
		Second				( Фигура принадлежит игроку Second )
	ELSE					( иначе ... )
		First				( Это First )
	ENDIF
;
</source>
</spoiler>
Это почти всё, о чем приходится заботится, за исключением одного нюанса. Если после хода игрока, на его территории остаются группы, расположенные напротив пустых лунок, мы должны найти наименьшую из них и пометить её (а также, возможно, ещё несколько групп, содержащих равное количество камней) для того, чтобы одну из них смог взять противник (это будет его обязательный ход). Разумеется, взять он их сможет только при условии того, что помеченные фигуры будут принадлежать ему, следовательно эту ситуацию придётся обработать особым образом:

<spoiler title="Помечаем фигуры">
<source>
: use-trace ( -- )
	0 BEGIN
		next verify
		get-player				( Определяем, на чьей мы стороне )
		OVER trace[] @				( и количество камней )
		DUP min-target @ = IF			( Если оно совпадает с целью захвата )
			OVER current-player = IF	( и расположено на нашей стороне )
				check-target		( Помечаем группу камней, подлежащую захвату )
			ENDIF
		ENDIF					
		DUP 0< IF				( Если группа камней помечена )
			SWAP DROP next-player SWAP	( Ей должен владеть противник )
		ENDIF
		MARK + create-player-piece-type		( Вычисляем тип фигуры и создаём её с правильным владельцем )
		1+ DUP trace-count @ >=			( Перебираем элементы массива, пока они не кончатся )
	UNTIL DROP
	...
;
</source>
</spoiler>
Поскольку, с нашей точки зрения, ход циклического посева представляет собой последовательность однократных посевов, аналогичным образом придётся вычислять владельца "помеченной" фигуры, оказавшейся на территории противника. В "Чука Рума" циклический посев тоже был, но эта проблема была не актуальна, поскольку игрок был всего один.
</spoiler>
<a href="http://mancala.wikia.com/wiki/Afrika_(game)">Статистически</a>, первый игрок имеет небольшое преимущество, но я не стал вводить <b>коми</b> (2.5 очка) для второго игрока. Первым ходит человек и небольшое преимущество в борьбе с машиной не будет лишним.

<h4><b>Gabata</b></h4>
Закончив "разминку", я приступил к двум наиболее интересным для себя играм. Обе играются на уникальной трёхрядной доске и распространены на восточном побережье Сомалийского полуострова. Собственно, доска и даёт название первой из них. <a href="http://www.cyningstan.com/game/147/gabata">Габата</a> - очень архаичная игровая система. Некоторые исследователи считают её родоначальницей всех манкал. Форма доски диктует непривычную схему посева. Это проще показать, чем объяснить:

<img align="center" src="https://habrastorage.org/files/f65/37a/ff0/f6537aff04254006a1a6be27fa55cb95.JPG"/>
Стрелки показывают направление посева. <b>Посев циклический</b> и начинать ход можно только из своих лунок (нижний ряд и три правых лунки во втором ряду). В принципе, в большинство игр, традиционно играемых на доске "Габаты", можно было бы играть на обычной, двурядной доске, но в самой "Габате" трёхрядность используется при выполнении захвата. Если последний камень падает в пустую лунку, игрок захватывает все камни противника, расположенные в том же <b>столбце</b> доски.

<spoiler title="Тонкости захвата">
Семантика перемещения фигур в ZoG причудлива. Изначально имеется две возможности: перемещение фигуры с одного поля доски на другое (<b>move</b>) и создание фигуры заданного типа на выбранном поле (<b>drop</b>). Самое главное, о чём приходится помнить, это то, что на всём протяжении расчёта хода, позиция на доске остаётся в том же состоянии, в котором она была в момент начала расчёта. Это кажется логичным, но на практике портит немало крови.

<img align="center" src="https://habrastorage.org/files/2c6/2d1/d5a/2c62d1d5a9d54c959dc2da8c0d44a171.PNG"/>
На диаграмме представлен кейс, с которым я столкнулся довольно поздно, когда игра, в основном, была уже готова. Второй игрок (тот что сверху) должен взять один камень (из своего же посева) и продолжить захват. Так это должно было выглядеть. А вот как это выглядело:

<img align="center" src="https://habrastorage.org/files/715/bad/3eb/715bad3ebd3346c7b732231fe4f2d85f.PNG"/>
В какой то момент, я заметил, что у игрока оказалось <b>две</b> выделенных группы камней! Попробуем разобраться, что произошло. Выполняя посев, мы "переместили" группу из 4 камней на одну лунку вправо (там же она и осталась). Если бы не выполнялось взятий, мы должны были бы заменить содержимое этой лунки одним камнем, но так как мы взяли этот камень, то обнулили его в <b>trace</b>:

<source>
: use-trace ( -- )
	0 BEGIN
		next verify
		DUP trace[] @
		DUP 0 <> IF
			...
		ELSE					( Если посеянные камни необходимо удалить )
			DROP				( Следим за стеком !!! )
			empty? NOT IF capture ENDIF	( Удаляем камни из лунки, если она не пуста )
		ENDIF
		1+ DUP trace-count @ >=
	UNTIL DROP
;
</source>
Мы удаляем взятые камни из <b>не пустых</b> лунок, но в нашем случае, лунка была пуста! Мы не пытались заполнить её камнем из посева (поскольку он был взят), но и не удалили камни из неё (поскольку при попытке удаления из пустой лунки могут возникнуть проблемы). Чего мы не учли, так это того, что лунка, пустая в начале хода, вполне может перестать быть таковой по его завершении. Лунка была заполнена "основным" действием по переносу камней в соседнюю лунку. Мораль этой истории в том, что не только начальное поле хода следует обрабатывать <a href="https://github.com/GlukKazan/ZoG/commit/4fb73e18ee02192f6b33058bc2d3342d57265293">особым образом</a>.
</spoiler>
Легко видеть, что захваты, выполняемые в различных столбцах, не равноценны. Возможны захваты сразу из двух лунок, также как и ситуации, при которых захватить не удастся вообще ничего (например, при завершении хода в одной из трёх начальных лунок противника). Игрок получает право на выполнение ещё одного хода, камнем осуществившим захват (неограниченное количество раз) и это правило вносит в игру ещё большее тактическое разнообразие. Габату часто называют "пиратской манкалой" и с тем, что играют в неё на территории <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BC%D0%B0%D0%BB%D0%B8">Сомали</a> это связано лишь отчасти: 

<video>http://www.youtube.com/watch?v=74fIZO-qBkI</video>

Когда один из игроков не может выполнить очередной ход, его оппонент захватывает все оставшиеся на доске камни. Игра продолжается несколько раундов (это характерно для всех игр на доске "Габаты"). Начиная очередной раунд, игроки раскладывают камни, захваченные в предыдущем раунде, по своим лункам, по три, начиная с левой, в нижнем ряду. Если в последней лунке оказывается меньше трёх камней, более сильный игрок, дополняет её до трёх, из своих камней. Оставшиеся камни более сильного игрока сразу уходят в его "амбар". Выигрывает тот, кто соберёт <b>все</b> камни.

<h4><b>Selus</b></h4>
Эта <a href="http://mancala.wikia.com/wiki/Selus">игра</a> - моя любимая! Играется на той же доске, что и Габата (и также, с использованием <b>циклического посева</b>), но с совершенно иным механизмом захвата. В ней, игроки строят ловушки ("wegue"). Ходить из <b>wegue</b> нельзя, но любой камень, попавший в них, становится собственностью создавшего их игрока. Построить ловушку просто - если последний камень посева попадает в лунку с тремя камнями (дополняя её до четырёх), лунка становится <b>wegue</b>. Количество <b>wegue</b> не ограничено!

Нельзя назвать такой механизм захвата уникальным. Есть несколько родственных Селусу игр с аналогичным взятием камней. В казахской манкале "<a href="http://www.iggamecenter.com/info/ru/toguzkumalak.html">Тогыз Кумалак</a>" игрок может построить "туздык" (но только один за игру), собрав три камня в лунке. Уникальность Селуса в том, что камни, попавшие в лунку, можно захватывать (в том числе, "отбирая" их у противника). Если последний камень посева падает в <b>wegue</b>, он захватывается в "амбар" игрока, забирая с собой ещё один камень из ловушки.

<video>http://www.youtube.com/watch?v=QJam0ckrvzo</video>

Если захват выполняется из своей <b>wegue</b>, игрок получает ещё один ход, но есть одно исключение. Крайняя левая лунка, в нижнем ряду, называется "ayemi" ("глаз"). Игрок не может захватывать камни из <b>ayemi</b> на своей стороне, а захватив камень из <b>ayemi</b> на стороне противника, <b>всегда</b> получает право на дополнительный ход (независимо от того, кем была построена <b>wegue</b>). Очевидно, что строить <b>wegue</b> в своём <b>ayemi</b> крайне нежелательно!

Из первоначального расклада, <b>wegue</b> могли бы быть созданы самыми первыми ходами. Чтобы этого не происходило, <b>wegue</b> запрещается создавать первым ходом каждому из игроков. Попав в лунку с тремя камнями (на первом ходу), игрок просто продолжает <b>циклический посев</b> дальше. В этой игре нет одновременного <b>нулевого посева</b>, как в Габате, но итоговый результат ничуть не хуже. Камни в лунках "перемешиваются" просто замечательно.

Также как Габата, Селус играется в несколько раундов, до полного отъёма камней, но здесь игрок может пропускать ход (только в том случае, если ходить ему нечем). Его противник, просто продолжает ходить по обычным правилам. Лишь когда оба игрока не могут выполнить ход, игра заканчивается. Игроки подсчитывают камни в своих "ловушках" и "амбарах" и тот, кто набрал больше, считается победителем.

<spoiler title="Сюрприз от Axiom">
Пропуск хода - особенно болезненная тема! Фактически, это такой специальный ход, который не изменяет на доске <b>ничего</b> и не связан с какой либо фигурой. В Axiom возможность пропуска хода описывается явно:

<source>
{move-priorities
	{move-priority} normal-type
	{move-priority} pass-type
move-priorities}

{moves p-moves
	{move} move-p	{move-type} normal-type
	{move} Pass	{move-type} pass-type
moves}

{pieces
	...
	{piece}		m
	{piece}		p1	{moves}	p-moves	1	{value}
	...
pieces}
</source>
Если ZRF сконфигурирован правильно (опция "<b>pass turn</b>" = <b>forced</b>), ход пропускается автоматически (при отсутствии возможности какого либо другого хода). Но не всё так просто. Допустим, у игрока есть <b>wegue</b> и, кроме них, нет никаких других фигур на его стороне. Это может показаться неожиданным, но вместо <b>Pass</b>, мы получаем следующее сообщение:

<img align="center" src="https://habrastorage.org/files/00c/c6c/9d8/00cc6c9d8f5340178a2d2406494fc4cf.PNG"/> 
Дело в том, что <b>Pass</b> ход был связан с <b>p-moves</b>, а поскольку фигур с этим обработчиком у игрока нет, Axiom даже не пытается их "двигать"! Чтобы всё работало правильно, обработчик ходов необходимо <a href="https://github.com/GlukKazan/ZoG/commit/685b3eead23076af3fab679453472effcf8a38a5">назначить</a> и ловушкам тоже (не важно, что он будет состоять только из <b>Pass</b>-хода). Другим способом могло бы стать создание фиктивного типа фигур с обработчиком <b>drop</b> ходов, аналогично тому, как сама Axiom обманывает ZoG:

<source lang="lisp">
  ; The following dummy piece is required in order to placate the Zillions engine.
  ; It appears as though Zillions must find at least one "moves" keyword somewhere
  ; in the zrf in order for it to be happy and thus allow "moves" to work correctly.
  (piece 
     (name Dummy)
     (dummy) (moves (from))
  )
</source>
Этот комментарий можно отливать из бронзы.
</spoiler>
С ловушками в Селус вышло небольшое разночтение. <a href="http://skyruk.livejournal.com/470951.html">Дмитрий Скирюк</a> утверждает, что при захвате последнего камня, ловушка ликвидируется, но <a href="http://vignette3.wikia.nocookie.net/mancala/images/4/40/Selus-prob.jpg/revision/latest?cb=20090904172936">задачка</a>, встречающаяся в ряде источников, намекает, что это не так. Я <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2449">сделал</a> оба варианта (и задачку). Габату можно найти в том же архиве.

<h4><b>К чему я это всё?</b></h4>
Манкалы - это весело! А их разработка при помощи Axiom - так и вовсе превращает жизнь в одно сплошное приключение.
</cut>

Dagaz: На полпути

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Чуть правее наклон - упадет, пропадет!
Чуть левее наклон - все равно не спасти!
Но спокойно, ему остается пройти
Всего две четверти пути!

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Владимир Высоцкий "<a href="http://www.bards.ru/archives/part.php?id=18158">Натянутый канат</a>"</i></b>&nbsp;
&nbsp;
Когда фронт работ выглядит совершенно необозримым, его волей-неволей, приходится делить на мелкие куски. Кусочек, для первой итерации, я выбрал совсем <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/drf/simple-checkers.drf">небольшой</a>:

<spoiler title="Очень простые шашки">
<source lang="lisp">
(board
   (name chess-board-10x10)
   (dim "a-j")
   (dim "10-1")
   (dir (name nw) -1 -1)
   (dir (name ne)  1 -1)
   (dir (name se)  1  1)
   (dir (name sw) -1  1)
)

(piece
   (name Man)
   (pre
      (check is-friend?)
      (take)
      (log position)
      (let captured 0)
   )
   (post
      (check (<= max-captured captured))
      (set! max-captured captured)
      (log " - " position)
      (drop)
   )
   (move
      (check (any nw ne))
      (check is-empty?)
   )
   (move
      (while true
         (let dir (any nw ne sw se))
         (check dir)
         (check is-enemy?)
         (capture)
         (inc! captured)
         (check dir)
         (check is-empty?)
         (end-move)
      )
   )
)

(game
   (name "Simple Checkers")
   (board chess-board-10x10)
   (players 
      (White (Man a1 c1 e1 g1 i1 b2 d2 f2 h2 j2 a3 c3 e3 g3 i3)) 
      (Black (Man b8 d8 f8 h8 j8 a7 c7 e7 g7 i7 b6 d6 f6 h6 j6))
   )
)
</source>
</spoiler>
Даже без дамок! Фигуры двигаются вперёд и могут "бить" противника, по привычным нам правилам "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашек</a>" (перепрыгивая через фигуру). Дойдя до последней линии доски, они ни во что не превращаются, но могут брать фигуры противника, поскольку взятия "назад" разрешены. В этом отношении, разрабатываемая игра похожа на "Осетинские шашки", описанные в одной из предыдущих <a href="http://habrahabr.ru/post/253397/">статей</a>. Взятие обязательно и, из всех возможных ходов, игрок должен выбрать ход, берущий максимальное количество фигур. Игра завершается, когда один из игроков не может выполнить очередной ход (заперт или потерял все фигуры).

Разумеется, речь идёт не о том, чтобы "закодить очередные шашки" (это можно было бы сделать и с меньшими усилиями). Я хочу разработать "метаигровую" систему, позволяющую описывать достаточно сложные логические игры, используя простой <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a> и, в идеале, не обладая продвинутыми навыками программирования (то есть, ровно то, что делает <a href="http://www.zillions-of-games.com/">Zillions of Games</a>, но в полностью открытом и кроссплатформенном проекте).
<cut>
<h4><b>Crazy Russian Stack Machine</b></h4>
Над одним вопросом я думал очень долго. Фактически, для того чтобы сделать описания игр максимально декларативными, мне необходимо <a href="http://icem-www.folkwang-hochschule.de/~finnendahl/cm_kurse/doc/t-y-scheme/t-y-scheme-Z-H-15.html">недетерминированное программирование</a>! Просто посмотрите на этот фрагмент кода:

<source lang="lisp">
(move
   (check (any nw ne))
   (check is-empty?)
)
</source>
Это описание "тихого" хода фигуры. И оно говорит о том, что <b>любая</b> фигура может двигаться на "северо-запад" <b>или</b> "северо-восток", при условии, что целевая клетка пуста. Речь не идёт о параллельном выполнении (подобного рода "оптимизации", на текущем этапе разработки преждевременны)! Просто-напросто, для каждой из фигур есть (как минимум) два возможных варианта хода, каждый из которых должен быть рассмотрен.

Очень важно, что момент выбора направления (назовём его точкой недетерминизма), предшествует последующим проверкам корректности хода. Если какая-то из проверок не выполняется (например, происходит выход за пределы доски), разбор выбранного варианта немедленно прекращается. Мы откатываемся к "точке недетерминизма" и выбираем следующий возможный вариант. Фактически, это всем известный алгоритм "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D1%81_%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%BE%D0%BC">поиска с возвратом</a>" выраженный в максимально декларативной форме. Подобным образом, например, можно интерпретировать <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">регулярные выражения</a>.

Форма <b>any</b> - не единственный источник недетерминизма в описании игры. В шашках, несколько взятий могут выполняться "по цепочке" (более того, если продолжение взятия возможно, оно должно быть выполнено). Вот как это выглядит в коде:

<source lang="lisp">
(move
   (while true
      (let dir (any nw ne sw se))
      (check dir)
      (check is-enemy?)
      (capture)
      (check dir)
      (check is-empty?)
      (end-move)
   )
)
</source>
Пусть вас не смущает "бесконечный" цикл! Он будет прерван любой из check-проверок (вместе с разбором соответствующего варианта хода), при нарушении соответствующих условий. Этот код немного сложнее чем предыдущий, но разобраться в нём вполне реально. Вот что делается (по шагам) в каждой итерации цикла:

<ol>
	<li>Мы выбираем одно из четырёх направлений (уже знакомым нам оператором <b>any</b>) и сохраняем его в переменную</li>
	<li>Двигаемся в выбранном направлении (при условии, что это возможно)</li>
	<li>На том поле, куда мы переместились, должна находиться вражеская фигура (иначе всё прерываем)!</li>
	<li>Берём фигуру (сейчас мы не рассматриваем меры по противодействию "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D1%83%D0%B4%D0%B0%D1%80">Турецкому удару</a>")</li>
	<li>И продолжаем двигаться в том же направлении (проверяя, что есть куда двигаться)</li>
	<li>Целевая клетка должна быть пустой!</li>
	<li>...</li>
</ol>
Дальше начинается магия. Форма <b>end-move</b> говорит о том, что в этом месте ход <b>может быть</b> завершён, а (бесконечный) цикл требует двигаться дальше! Фактически, это равносильно выполнению следующего псевдокода, в котором на арену вновь выходит уже знакомый нам <b>any</b>:

<source lang="lisp">
(if (any true false)
    (execute post-actions)
    (generate-move)
)
</source>
Более того, <b>any</b> настолько универсален, что, с его помощью, можно переписать ещё одного участника спектакля, до сих пор остававшегося в тени. Вот как выглядит псевдокод эквивалентный оператору <b>check</b>:

<source lang="lisp">
(if (not <condition>)
    (any)
)
</source>
Выбор варианта, без возможности выбора - превосходная метафора для завершения любого перебора. Разумеется, это не означает, что <b>check</b> будет реализован именно таким образом, но мы <b>можем</b> его так реализовать!

<spoiler title="Out of scope">
У оператора <b>any</b> есть и другие полезные возможности применения, которые мы не будем рассматривать на текущем этапе разработки проекта. Вот как, например, будет выглядеть условие завершения игры в <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/drf/chess-common.drf">шахматах</a>:

<source lang="lisp">
(game 
   (name chess-game)
   (loss 
      (exists?
         (any King)
         (if is-friend?
             (check is-attacked?)
         )
         (check no-moves?)
      )
   )
)
</source>
Интуитивно, эта запись понятна, а по поводу деталей её реализации, пока не будем забивать себе голову. Когда мы доберёмся до шахмат, то займёмся и этим тоже. 
</spoiler>
В общем, <b>что</b> делать было понятно, но <b>как</b> это сделать? Оператор <b>any</b> (как, впрочем, и многое другое) может быть реализован при помощи <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)">продолжений</a>, но в Java нет продолжений! Некоторое время я всерьёз раздумывал о том, чтобы перевести разработку ядра на <a href="https://ru.wikipedia.org/wiki/Scheme">Scheme</a> (в которой продолжения не только есть, но и на них всё построено). Когда (после продолжительных экспериментов с прикручиванием "продолжений" к синтаксическим деревьям выражений) я уже находился на максимальной глубине отчаянья и вовсю читал "<a href="http://habrahabr.ru/post/204442/">Лисп маленькими кусочками</a>" (спасибо, @ilammy), я понял, что есть другой способ.

<spoiler title="Немного о дварфийском хлебе">
Не знаю, кому как, а мне Scheme очень сильно напоминает "дварфийский хлеб", неоднократно упоминаемый в произведениях <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D1%82%D1%87%D0%B5%D1%82%D1%82,_%D0%A2%D0%B5%D1%80%D1%80%D0%B8">Терри Пратчетта</a>. Вот как его <a href="https://ru.wikipedia.org/wiki/Nanny_Ogg%E2%80%99s_Cookbook">описывает</a> автор:
<blockquote>Дварфийский хлеб можно использовать для купли-продажи, для проведения церемоний – зачастую дварфы скрепляют заключаемые сделки, «переламыванием хлеба» и некоторые железные молоты, с помощью которых его переламывали, являются ценными произведениями искусства. И, конечно же, хлеб применяют в качестве оружия, что является его основным предназначением. Плоская круглая буханка дварфийского хлеба с песочной корочкой, запущенная на манер метательного диска, запросто обезглавит противника и более того, если правильно ее бросить, вернется к своему владельцу. Менее распространенные длинные батоны, называемые багетами, традиционно применяются в рукопашном бою. Уронительные лепешки первоначально применялись в защитных целях, например, при обороне крепостных стен. Дварфийский хлеб может быть съеден, по крайней мере, дварфами.</blockquote>
<img align="center" src="https://habrastorage.org/files/238/833/906/238833906cac45e683d48e1a1dc5e753.jpg"/>
Я хочу, чтобы меня поняли правильно. Я <b>безмерно</b> уважаю язык Scheme (также как дварфы свой хлеб). Я <b>люблю</b> этот язык! Но всякий раз, когда я (от безысходности) уже совсем всерьёз собираюсь применить его в реальном проекте, мне в голову <b>внезапно</b> приходит способ, позволяющий решить проблему <b>по другому</b> на любом другом языке программирования, который я использую на тот момент. Пожалуй, для меня лично, это самое ценное свойство Scheme. Этот язык пробуждает воображение!
</spoiler>
В общем, секрет прост. Если рассматривать программу как цепочку команд (с возможностью произвольной передачи на них управления) - реализация продолжений становится очевидной. В самом деле, продолжение - это не более чем адрес команды, в совокупности с сохранённым состоянием всех переменных. Это гораздо проще чем то, с чем приходится иметь дело, при использовании <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">AST-выражений</a>.

С самим "процессором", вопросов не возникало. <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Стековые машины</a> уже не раз доказали свою полезность, кроме того, мне приходилось иметь с ними <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/Margo/Pieces.4th">дело</a>. Единственный их недостаток заключается в том, что требуется очень высокая квалификация программиста, для того, чтобы <b>постоянно</b> следить за правильным порядком операндов на стеке. Для меня, это не является проблемой, поскольку я не планирую открывать доступ к командам на уровне DSL. Команды стековой машины будут использоваться исключительно для <b>внутреннего</b> представления.

<spoiler title="Ещё одна прекрасная возможность">
Использование команд стековой машины открывает ещё одну интересную возможность. Я уже <a href="http://habrahabr.ru/post/245849/">писал</a> о том, что мне хотелось бы обеспечить совместимость с описаниями игр в форматах ZRF (Zillions of Games) и GDL (<a href="http://www.cameronius.com/cv/publications/ciaig-browne-maire-19.pdf">Ludi Project</a>). Оба эти языка лиспоподобны и я планирую использовать <a href="https://ru.wikipedia.org/wiki/XSLT">XSLT</a> для преобразования описаний на них в свой формат "на лету". Это сложно, но вполне возможно.

Увы, для <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> этот способ не подходит. ForthScript-машину вряд ли удастся "засунуть" в XSLT-скрипт. Но, коль скоро я использую стековую машину, что мешает мне продублировать (хорошо документированную) систему команд Axiom, чтобы загружать описания непосредственно во внутреннее представление, минуя DSL? Думаю, автор не будет против (впрочем, я у него спрошу).
</spoiler>
Дальше - всё просто. Выполнение цепочки команд - это, по большей части, последовательный проход по ней в <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/AbstractProcessor.java">AbstractPorocessor</a>. Команды <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/IfCommand.java">If</a> и <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/JumpCommand.java">Jump</a> обеспечивают возможность ветвлений и циклов. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/AnyCommand.java">Any</a> - полна магией, но реализация <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/CheckCommand.java">Check</a> довольно тривиальна. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/CommandFactory.java">CommandFactory</a> обеспечивает удобный интерфейс, для создания команд по имени. Лишь одна вещь способна омрачить настроение. Для реализации откатов к "точкам недетерминизма" необходимо научиться запоминать и восстанавливать состояние всех переменных, изменяемых при выполнении программы. Давайте, займёмся этим!

<h4><b>Не ACID</b></h4>
Прежде чем двигаться дальше, определимся с тем, что мы собираемся хранить в памяти. Список большой, но всё это действительно мне понадобится! В скобках, указан признак хранения данных, значение которого я расшифрую позже:

<ol>
	<li>Размещение фигур (часть состояния)</li>
	<li>Значения атрибутов фигур (часть состояния)</li>
	<li>Значения атрибутов позиции (часть состояния)</li>
	<li>Позиционные значения (временные)</li>
	<li>Значения локальных переменных (временные)</li>
</ol>
Информация о размещении фигуры не является значением (она состоит из нескольких связанных скалярных значений). Остальные значения будут типизированы, но их имена не будут связаны с каким либо определённым типом постоянно. Кроме того, будет действовать неявное преобразование типов, в тех случаях, когда это возможно. В настоящее время поддерживаются три типа значений:

<ul>
	<li>Строка</li>
	<li>Целое число</li>
	<li>Булевское значение</li>
</ul>
<spoiler title="На самом деле, есть ещё и ссылки">
<source lang="lisp">
(while true
   (let dir (any ...))
   (check dir)
   ...
)
</source>
Здесь <b>any</b> возвращает строку, впоследствии используемую для выполнения команды навигации (о том, как выполняется навигация, я расскажу ниже). Если значение, сохранённое в <b>dir</b>, не будет помечено как ссылка, <b>check</b> интерпретирует его как булевское (это будет 'истина', поскольку строка не пуста и не равна "0"), не пытаясь выполнить какие либо побочные действия, связанные с позиционированием.
</spoiler>
Скорее всего, я добавлю поддержку списковых типов (они <a href="http://habrahabr.ru/post/256701/">понадобятся</a> для реализации таких игр как <a href="http://www.iggamecenter.com/info/ru/ordo.html">Ордо</a> и <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>). Кроме того, сейчас, я не рассматриваю вопросы, связанные с оптимизацией производительности и использования оперативной памяти. Если прототип будет работать так, как я планирую, можно будет подумать, например, об использовании битовых масок, для хранения большого количества булевских значений.

<spoiler title="Что означают пометки в скобках? ">
Важно понимать, что под "состоянием" я понимаю информацию, необходимую для точного восстановления соответствующей позиции на доске. Например, размещение фигур на доске, безусловно, является частью состояния. Более сложный пример - атрибуты фигур. Одно из условий выполнения <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировки</a> - неподвижность задействованных в ней фигур в течение всех предыдущих ходов. Подобный признак удобно хранить в атрибуте фигуры, содержащем булевское значение. При выполнении любого хода фигурой, мы изменяем это значение, делая невозможной последующую рокировку. Поскольку эта информация передаётся между различными позициями, она является частью состояния. Аналогичным образом могут определяться атрибуты, связанные со всей позицией, а не с какой либо конкретной фигурой. Я не буду использовать атрибуты в текущей итерации, но поскольку это очень важный элемент архитектуры - реализую их.

Временные значения не являются частью состояния и, таким образом, не передаются между позициями, соответствующими различным ходам. Самый простой пример - локальные переменные. Мы можем связать некоторое значение с каким либо именем для того, чтобы в последствии его использовать. Область действия локальной переменной - от места её определения командой <b>let</b>, до завершения цепочки команд. Этим объясняется отличие синтаксиса команды <b>let</b>, от используемого в Scheme.

<source lang="lisp">
(seq
   (let <переменная> <выражение>)
   ...
   <область действия переменной>
   ...
)
</source>
Это очень важный момент, поскольку, при расчёте хода в фразе <b>move</b>, должна иметься возможность использования переменных, объявленных в одной из фраз предварительных действий (фраза <b>pre</b>). Также, объявленные переменные должны оставаться доступными и при выполнении завершающих действий (фраза <b>post</b>). Переменные могут перекрываться, повторными объявлениями <b>let</b>. Кроме того, значение локальной переменной может быть изменено, при помощи команды <b>set!</b>. Возможность удаления переменной (закрытия её области действия), <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/DelCommand.java">реализована</a> на уровне команд стековой машины (для определения "гигиенических" переменных), но, пока не поддерживается на уровне DSL.

Более сложным примером временных данных являются "позиционные значения". В некоторых случаях, бывает необходимо связать значение не просто с каким-то именем, а с определённым местом на доске. Например, в играх семейства "<a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BB%D0%BC%D0%B0">Халма</a>", при расчёте хода, необходимо помечать посещённые поля доски, чтобы избежать зацикливания. По завершении расчёта хода, эта информация становится ненужной (да и хранить её как часть состояния было бы слишком накладно). Также как и атрибуты, я не буду использовать позиционные значения в текущей итерации (просто, чтобы не усложнять себе жизнь). С их помощью, можно было бы реализовать правило "Турецкого удара", но, в отсутствии дальнобойных дамок, оно не актуально.
</spoiler>

<img align="center" src="https://habrastorage.org/files/eb1/bd7/8cd/eb1bd78cdf874089bfc37ce1cbf8848d.PNG"/>

На этой схеме изображены все типы хранилищ, используемых при расчёте хода. Здесь не рассматриваются данные о загруженной игре (такие как, топология доски). Они могут быть довольно сложными, но с точки зрения генератора ходов, они постоянны. Вся информация о размещении фигур, а также все ранее перечисленные значения, кроме локальных переменных, хранятся в <b>State</b>. Объекты типа <b>State</b> могут клонироваться, но в клонированный объект попадает лишь информация об элементах состояния (позиционные значения отбрасываются).

Основная задача <b>LocalEnvironment</b> - управление локальными переменными. Интерфейс <b>IEnvironment</b> предоставляет все необходимые для этого методы. Кроме того, метод <b>get</b> возвращает соответствующее значение, если, вместо имени переменной, в него передаётся константа (число, строка в кавычках, а также литералы <b>true</b> и <b>false</b>). Значения, соответствующие этим строкам, не могут быть изменены командой <b>set!</b> или переопределены при помощи <b>let</b>. 

С точки зрения DSL, любое упоминание "голого" имени (строки без кавычек) приводит к выполнению команды <b>get</b>. Последствия выполнения этой команды зависят от того, каким окружением она обрабатывается. Все окружения связаны "по цепочке" и если <b>LocalEnvironment</b> не знает какого-то имени, он обращается к <b>StateEnvironment</b>. Здесь и начинается самое интересное. Этот модуль обеспечивает доступ к "псевдопеременным", управляющим навигацией и предоставляющим доступ к информации о размещении фигур на доске.

Вот как это выглядит. Допустим, модель определяет позиции обычной шахматной доски. В этом случае, мы можем использовать имя любой позиции в DSL так, как если бы это было имя переменной. Значение "переменной" (например '<b>a1</b>') запрашивается в <b>LocalEnvironment</b>, а затем в <b>StateEnvironment</b>. Это окружение связано со <b>State</b> и имеет полную информацию о всех позициях, определяемых моделью. Если запрошенная позиция существует, возвращается значение <b>true</b>, а, в качестве побочного эффекта, в переменной, определяющей текущую позицию в <b>State</b>, сохраняется имя полученной позиции. В противном случае, возвращается <b>false</b> и никакие побочные действия не выполняются. Аналогичным образом обрабатываются имена направлений (с той разницей, что на момент запроса, "текущая позиция" в <b>State</b> должна быть определена). Помимо псевдопеременных навигации, <b>StateEnvironment</b> определяет ещё несколько имён, предоставляющих доступ к исключительно полезной информации:

<ul>
	<li><b>position</b> - имя текущей позиции</li>
	<li><b>is-empty?</b> - истинно если текущая позиция пуста</li>
	<li><b>not-empty?</b> - ложно если текущая позиция пуста</li>
	<li><b>is-friend?</b> - истинно если на поле расположена дружественная фигура</li>
	<li><b>not-friend?</b> - истинно если на поле не расположена дружественная фигура</li>
	<li><b>is-enemy?</b> - истинно если на поле расположена враждебная фигура</li>
	<li><b>not-enemy?</b> - истинно если на поле не расположена враждебная фигура</li>
	<li><b>player</b> - имя игрока, владеющего фигурой, расположенной на текущей позиции</li>
	<li><b>piece</b> - тип фигуры, расположенной на текущей позиции</li>
</ul>
<spoiler title="Формы - обычные и специальные">
Из того, что я говорил выше, уже можно было заметить, что существует некий "концептуальный" разрыв между описываемым мной DSL и цепочками команд стековой машины. Это вотчина классов <a href="https://github.com/GlukKazan/Dagaz/tree/master/src/java/model/src/main/java/com/gluk/dagaz/statements">statements</a>. Задача каждого из этих классов - преобразование последовательности лексем, составляющих известную ему форму, в правильную цепочку команд стековой машины (то есть кодогенерация). Например, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/ExpressionStatement.java">ExpressionStatement</a> обрабатывает все "обычные" формы (то есть формы, не являющиеся специальными). Так работают все арифметические выражения (кстати, поскольку арность определена скобками, такие функции как сложение и умножения не ограничены лишь двумя операндами, а минус вполне может быть унарным).

Специальные формы реализуют особый порядок обработки операндов. Типичными их представителями являются <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/IfStatement.java">IfStatement</a> (фраза <b>else</b> поддерживается) и <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/WhileStatement.java">WhileStatement</a>. Формы <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/OrStatement.java">OrStatement</a> и <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/AndStatement.java">AndStatement</a> также являются специальными, поскольку реализуют "сокращённое вычисление" логических выражений. Это важно, поскольку в выражениях могут использоваться псевдопеременные, обращение к которым связано с побочными эффектами.

Один из обработчиков специальных форм (<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/statements/StateStatement.java">StateStatement</a>) создаёт очень удобные обёртки для псевдопеременных, перечисленных для уровня <b>State</b>. Иногда, бывает удобно смотреть содержимое не текущей позиции, а позиции, расположенной по указанному направлению (или последовательности направлений). Например, мы можем проверить пустоту всех позиций, достижимых "ходом коня", не сходя с места:

<source lang="lisp">
(check
   (and (is-empty? n nw)
        (is-empty? n ne)
        (is-empty? e ne)
        (is-empty? e se)
        (is-empty? s se)
        (is-empty? s sw)
        (is-empty? w sw)
        (is-empty? w nw)
   )
)
</source>
В этом коде, <b>is-empty?</b> уже не псевдопеременная, а форма. Конечно, такие обёртки можно было бы определять при помощи макросов (возможность переопределять формы, при помощи макросов, тоже будет), но почему бы не предоставить удобную альтернативу, тем более, что её реализация почти ничего мне не стоит?
</spoiler>
Если <b>StateEnvironment</b> не знает какого-то имени, он обращается вниз по цепочке, к <b>PlayersEnvironment</b>. Задача этого окружения - выяснение взаимоотношений игроков. В текущей итерации, всё просто - если запрашиваемое имя игрока не совпадает с именем игрока, выполняющего текущий ход, то он враг. Впоследствии, логика проверок может усложниться (например добавятся коалиции игроков). Принимая имя, определённое в списке игроков, <b>PlayerEnvironment</b> сравнивает его с именем текущего игрока и возвращает <b>false</b> при несовпадении (этим пользуется <b>StateEnvironment</b>, при вычислении <b>is-friend?</b> и <b>is-enemy?</b>). Другие имена обрабатываемые этим окружением:

<ul>
	<li><b>current-player</b> - имя игрока, выполняющего текущий ход</li>
	<li><b>next-player</b> - имя игрока, выполняющего следующий ход</li>
	<li><b>turn-number</b> - номер 'большого' хода (для рассматриваемой игры - пары полуходов)</li>
	<li><b>turn-order</b> - номер полухода в рамках 'большого' хода</li>
</ul>
Если запрошенное имя неизвестно <b>PlayersEnvironment</b>, оно опускается ещё ниже, но о том, зачем нужен <b>GlobalEnvironment</b> и как он работает, я буду рассказывать в следующем разделе (это действительно сложная тема). Теперь главное, причём тут <a href="https://ru.wikipedia.org/wiki/ACID">ACID</a>? В общем-то совершенно не причём, но я не смог придумать более подходящего имени для интерфейса <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/api/state/ITransactional.java">ITransactional</a>. Мне даже не нужны <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_%28%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29">транзакции</a>, как таковые. Всё что требуется - уметь определять точки сохранения и выполнять полный откат состояния к ним. Откатывать, таким образом, придётся <b>LocalEnvironment</b> (состояние локальных переменных) и <b>State</b> (состояние доски). <b>StateEnvironment</b> - всего лишь обёртка над <b>State</b> и не владеет какими либо данными, а состояние <b>PlayersEnvironment</b> не изменяется в процессе расчёта  хода. Помимо этого, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/runtime/Processor.java">Processor</a> должен уметь откатывать состояние стека данных, но это его внутреннее дело. 

<h4><b>За пределами "транзакционности"</b></h4>
Выше, я уже говорил о том, что, по правилам большинства разновидностей <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>, если взятие возможно - оно должно быть выполнено (это называется приоритетом взятия). В некоторых вариантах игры, например в "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Международных шашках</a>" действует ещё более жёсткое правило (обычно называемое "правилом большинства"). Согласно нему, из всех возможных ходов, игрок должен выбрать ход, берущий максимальное количество фигур противника. Именно "приоритет взятия" превращает шашки в позиционную, стратегическую игру. Без него, игра <a href="http://habrahabr.ru/post/258437/">была бы</a> гораздо менее интересной! Но как это правило отражено в DSL?

 <source lang="lisp">
(piece
   (name Man)
   (pre
      ...
      (let captured 0)
   )
   (post
      (check (<= max-captured captured))
      (set! max-captured captured)
      ...
   )
   ...
   (move
      (while true
         (let dir (any nw ne sw se))
         ...
         (check is-enemy?)
         (capture)
         (inc! captured)
         ...
      )
   )
)
</source>
Хитрую проверку в <b>post</b> я называю "нарушаемым инвариантом". Как он работает? Допустим, в процессе разбора был сгенерирован ход, берущий одну фигуру. Проверка в <b>post</b> прошла успешно и в переменную <b>max-captured</b> была сохранена единичка. Теперь все ходы, не выполняющие взятий, будут отвергаться, поскольку условие в <b>check</b> будет нарушено. Понятно, что переменная <b>max-captured</b> должна храниться в совершенно особом месте. На неё не должны действовать какие либо откаты состояния и, самое главное, она должна быть доступна <b>всем</b> вариантам рассчитываемых ходов (почти что разным реальностям). <b>GlobalEnvironment</b> - то самое место. Это окружение не умеет создавать локальные переменные по команде <b>let</b>, но создаёт переменные глобальные по любому <b>set!</b> или <b>get</b>-запросу! Если имя переменной не объявлено конструкцией <b>attribute</b> или <b>let</b>, переменная создаётся автоматически, при первом использовании и её значение разделяется <b>между</b> различными вариантами расчёта хода.

Но, сами по себе, глобальные переменные - только часть дела! Обычно, действует совсем другой кейс. Мы находим какой-то ход, берущий одну фигуру, а затем, например продолжая цепочку взятий, берём вторую, третью, четвёртую... Простая проверка здесь не поможет! Мы должны <b>повторять</b> все выполненные ранее проверки, при каждом изменении глобальной переменной <b>max-captured</b>, и отвергать соответствующие им ходы, при обнаружении нарушений. Инвариант для этих ходов <b>выполнялся</b>, на момент их генерации, но был <b>сломан</b> изменением <b>max-captured</b>! Это действительно сложное место и я пока не уверен, что оно работает. Управлять всей этой "магией" должен <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/state/MoveGenerator.java">MoveGenerator</a>.

<spoiler title="Ходы - частичные и не очень">
Коль скоро речь зашла о генерации ходов, стоит упомянуть о нескольких моментах, которые я хочу улучшить по сравнению с ZoG. Во первых, мне никогда не нравилась ZSG-нотация. В ней, по замыслу разработчиков, должны быть отражены <b>все</b> изменения состояния, выполняемые ходом. Конечно, это удобно. Запись хода можно просто распарсить, чтобы понять, что происходит в результате хода. К сожалению, это не работает. Axiom или любые другие <a href="http://www.zillions-of-games.com/progsample.html">DLL Engine</a> могут запросто изменять состояние таким образом, что это никак не будет отражаться в ZSG. Еще хуже то, что, в играх, где, за один ход, может изменяться или удаляться большое количество фигур (таких как Го), такой подход может привести к переполнению буфера, выделяемого для записи хода. Программа в этом случае просто падает.

Другой невнятный момент ZoG - частичные ходы. Шашки сделаны таким образом, что каждое взятие (в цепочке), представляет собой отдельный "частичный" ход. Игрок может выполнить несколько таких ходов подряд. На первый взгляд, идея выглядит интересной. Визуализация ходов становится совершенно элементарной. Увы, всё это (а ещё крайне неудачная семантика перемещения фигур, которую я тоже хочу изменить) начинает <a href="http://habrahabr.ru/post/254947/">пробуксовывать</a> как только мы пытаемся сделать что нибудь сложное. Затрачиваемые усилия множатся и, всё равно, не решают всех проблем.

В Dagaz всё будет по другому! Во первых, я не считаю необходимым отражать в нотации хода <b>все</b> изменения состояния. Расширениям незачем заниматься парсингом, поскольку, вместе с записью хода, им будет передаваться <b>IState</b>, через который будет доступна вся информация о состоянии после выполнения хода. От нотации требуется лишь уникальность. Фактически, это просто <b>имя</b> хода из текущей позиции. Содержимое этой записи будет полностью определяться кодом DSL. Команда <b>log</b> формирует запись выполняемого хода (а в тех случаях, когда она не будет использована, можно генерировать имя хода автоматически). Кстати <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/main/java/com/gluk/dagaz/state/MoveLogger.java">MoveLogger</a> это ещё один класс, реализующий интерфейс <b>ITransactional</b>.

Я решил отказаться от частичных ходов. Ход, со всеми выполняемыми им взятиями, будет один (с указанием в нём всех промежуточных позиций, по цепочке). Собственно взятые фигуры, в нём указываться не будут (эту информацию можно восстановить, зная все промежуточные позиции и правила выполнения ходов). Да, такой подход усложнит модули визуализации и управления, но избавит от очень многих проблем (на эту тему можно было бы написать статью такого же размера, как эта). Кроме того, для модуля AI такое представление хода удобнее.

Разумеется, будет изменена семантика перемещения фигур. В ZoG, на всём протяжении расчёта хода, доступно лишь состояние на момент начала хода. Фигура, которую мы перемещаем, как бы остаётся на начальной позиции, пока ход не завершён. Звучит логично, но, на практике, портит невероятное количество крови и нервов. В Dagaz фигура будет явно сниматься с доски командой <b>take</b>, проноситься <b>над</b> доской "в руке" и возвращаться на доску, при помощи команды <b>drop</b>. После этого, без всяких дурацких <b>cascade</b>, <b>from</b> и <b>to</b>, можно будет взять и перенести другую фигуру, если этого требуют правила выполнения хода (например, при выполнении рокировки). Также (не в этой итерации), можно будет переносить несколько фигур одновременно "по одной траектории" (это требуется в таких играх как <a href="http://www.iggamecenter.com/info/ru/ordo.html">Ордо</a>, <a href="http://www.iggamecenter.com/info/ru/bashni.html">Столбовые шашки</a>, <a href="http://www.iggamecenter.com/info/ru/tavreli.html">Таврели</a> и пр.).
</spoiler>
Ну хорошо, с "правилом большинства" разобрались (надеюсь, что всё это действительно будет работать), но как быть с другими вариантами игр? В некоторых из них, не требуется брать максимальное количество фигур, лишь само взятие является обязательным (исключение - "Осетинские шашки", в которых приоритет взятия не действует). Само "правило большинства" также понимается очень <a href="http://habrahabr.ru/post/253397/">по разному</a>. Иногда требуется взять наибольшее количество дамок (если есть такая возможность), в других случаях, само взятие дамкой является приоритетным. Всё это можно описать через "нарушаемые инварианты", но есть более тонкий момент.

Практически во всех играх семейства шашек (из числа традиционных игр, исключением является лишь "<a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанорона</a>"), начав цепочку взятий, игрок обязан пройти её до конца! При этом, например в "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Русских шашках</a>", не требуется брать максимальное количество фигур. Это более сложное ограничение чем простое "правило большинства" (во всяком случае, пока я не придумал как его выразить через "нарушаемый инвариант") и для него будет использоваться другой вид отложенной проверки. Предикат <b>no-moves?</b> будет проверять отсутствие у хода возможных продолжений. Если продолжение будет обнаружено, предыдущий (более короткий) вариант хода будет аннулирован. Я не буду заниматься реализацией этого предиката в текущей итерации.

<h4><b>О unit-тестах</b></h4>
Главное, что необходимо знать о unit-тестах, это то, что unit-тесты помогают! Нет, серьёзно, я не являюсь сторонником методики <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">TDD</a>, но полезность самих unit-тестов, именно в этом проекте, сложно переоценить! Здесь (пока) нет БД или каких либо сетевых компонентов (соответственно, не приходится ломать голову над mock-обёртками для них), но зато сам проект довольно сложен. Мысль о том, что его можно просто написать с нуля, запустить <b>целиком</b> и в таком виде отладить - меня пугает. Unit-тесты помогают выполнить эту отладку по частям, начиная с простых вещей, вроде системы <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/test/java/com/gluk/dagaz/test/RuntimeTests.java">команд</a>, поднимаясь все выше, к более сложным <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/model/src/test/java/com/gluk/dagaz/test/ParserTests.java">концепциям</a>. Этот подход действительно работает! В процессе написания тестов, я уже нашёл и исправил несколько серьёзных ошибок. Аналогичные исправления, на этапе отладки всего проекта, обошлись бы мне гораздо дороже.

При переходе к более высокому слою, unit-тесты дают уверенность (иногда ложную, но тут уж всё от покрытия зависит) в том, что все нижележащие слои работают так, как было задумано. Более того, если в проекте что-то всерьёз меняется (а такое бывает), unit-тесты немедленно сигнализируют о том, что и как развалилось. В каком-то смысле, unit-тесты документируют API проекта (это конечно не отменяет обычную документацию), причем, сосредотачиваясь на наиболее тонких и сложных случаях. В общем, в настоящий момент, я работаю над unit-тестами и намерен продолжать двигаться в этом направлении до тех пор, пока это возможно (вплоть до того момента, пока сама цель первой итерации проекта не станет одним из тестов). Это половина пути и я надеюсь пройти весь путь целиком.

Хороший день для кодогенерации

<img align="left" src="https://habrastorage.org/files/c5b/26c/6a6/c5b26c6a6f2f43a5924f256d62abe911.png"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Давным-давно, еще на заре существования Вечности, где-то в 300-х Столетиях был изобретен дубликатор массы...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вечность приспособила дубликатор для своих нужд. В то время у нас  было построено всего шестьсот или семьсот Секторов. Перед нами стояли грандиозные задачи по расширению зоны нашего влияния. "Десять новых Секторов за один биогод" - таков был ведущий лозунг тех лет.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Дубликатор сделал эти огромные усилия ненужными. Мы построили один Сектор, снабдили его запасами продовольствия, воды, энергии, начинили  самой совершенной автоматикой и запустили дубликатор. И вот сейчас мы имеем по Сектору на каждое Столетие.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Айзек Азимов "<a href="http://www.lib.ru/FOUNDATION/wechnost.txt">Конец Вечности</a>"</b></i>

То, что день случился не самый лучший, было понятно уже с утра. Ставшая привычной, дождливая серая погода и, похоже, начинавшаяся простуда никак не улучшали настроения. В теле наблюдалась разбитость и, больше всего, хотелось спать. Было совершенно очевидно, что необходимо как-то отвлечься...
<cut>
Сделать <a href="https://ru.wikipedia.org/wiki/Sokoban">Sokoban</a> я хотел давно. Вернее, (как и многие другие) я уже делал его несколько раз, но это было задолго до моего знакомства с <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Что меня всегда напрягало - так это разработка уровней. Придумать хороший уровень, для игры-головоломки, совсем не просто, а ведь их надо ещё и закодировать! Поскольку в Sokoban-е количество уровней не менее важно чем их качество, работа грозила затянуться надолго.

С другой стороны, возможно уровни и не стоило придумывать. В самом деле, ностальгировать всего лучше на старых уровнях, привычных с детства. Здраво рассудив, что за время, прошедшее с 80-ых годов прошлого века, кто нибудь обязательно должен был озадачиться той же проблемой (и не один раз, скорее всего), я решил поискать описание оригинальных уровней в Интернете. Искомое я быстро обнаружил на <a href="http://habrahabr.ru/post/150882/">Хабре</a>, за что, безусловно, хочу поблагодарить уважаемого @begoon. Выдранный им, ещё из DOS-овой версии программы, листинг выглядит следующим образом:

<source>
*************************************
Maze: 1
File offset: 148C, DS:00FC, table offset: 0000
Size X: 22
Size Y: 11
End: 14BD
Length: 50

    XXXXX             
    X   X             
    X*  X             
  XXX  *XXX           
  X  *  * X           
XXX X XXX X     XXXXXX
X   X XXX XXXXXXX  ..X
X *  *             ..X
XXXXX XXXX X@XXXX  ..X
    X      XXX  XXXXXX
    XXXXXXXX          
</source>
Всё просто и понятно! Осталось перевести это в форму, понятную Zillions of Games. Все шестьдесят уровней. Не знаю, кто как, но лично я, не настолько люблю работать руками. Проблема даже не в том, чтобы всё это набить, потом ведь придётся ещё и исправлять неизбежные ошибки! В общем, если кто-то искал подходящую задачу для кодогенерации, то это она и есть. Напомню, что кодогенерация - это такая "домашняя" разновидность <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">метапрограммирования</a>, чуть более дружественная к головному мозгу разработчика, чем <a href="http://habrahabr.ru/post/214713/">другие</a> <a href="http://habrahabr.ru/post/179089/">разновидности</a>.

<spoiler title="Сказано - сделано!">
<source lang="perl">
open(my $f, '>', 'levels_1_10.zrf');

my $n = 0;
my $k = 0;
my $x = 0;
my $y = 0;
my %p;
my %b;

while (<>) {
  chomp;
  my $s = $_;
  if (/^\s*X/) {
     $y++;
     my $i = 0;
     my @a = split(//, $s);
     foreach $c (@a) {
         $i++;
         if ($c ne ' ') {
             my $p;
             if ($i > 26) {
                 $p = chr(ord('A') + $i - 27);
             } else {
                 $p = chr(ord('a') + $i - 1);
             }
             my $key = $p . $y;
             $c =~ tr/X*.@/WBTY/;
             $p{$key} = $c;
             if ($i > $x) {
                 $x = $i;
             }
         }
     }
  } else {
     if ($y) {
         $n++;
         if ($n > 10) {
             $k++;
             $n = 1;
             close($f);
             my $a = $k * 10 + 1;
             my $b = ($k + 1) * 10;
             open($f, '>', "levels_${a}_${b}.zrf");
         }
         my $l = $k * 10 + $n;
         if ($n > 1) {
             printf $f "(variant\n";
         } else {
             printf $f "(include \"sokoban.inc\")\n\n";
             printf $f "(game\n";
         }
         printf $f "   (title \"Sokoban (Level $l)\")\n";
         if ($n == 1) {
             printf $f "   (common-level)\n";
         }
         printf $f "   (board\n";
         printf $f "      (image \"images/sokoban/black-${x}x${y}.bmp\")\n";
         printf $f "      (grid\n";
         printf $f "         (common-grid)\n";
         printf $f "         (dimensions\n";
         printf $f "              (\"";
         for (my $i = 1; $i <= $x; $i++) {
             if ($i > 1) {
                 printf $f "/";
             }
             my $p;
             if ($i > 26) {
                 $p = chr(ord('A') + $i - 27);
             } else {
                 $p = chr(ord('a') + $i - 1);
             }
             printf $f "$p";
         }
         printf $f "\" (25 0)) ; files\n";
         printf $f "              (\"";
         for (my $i = 1; $i <= $y; $i++) {
             if ($i > 1) {
                 printf $f "/";
             }
             printf $f "$i";
         }
         printf $f "\" (0 25)) ; ranks\n";
         printf $f "         )\n";
         printf $f "      )\n";
         printf $f "   )\n";
         printf $f "   (board-setup\n";
         printf $f "      (You\n";
         printf $f "         (W";
         foreach $pos (keys %p) {
             if ($p{$pos} eq 'W') {
                 printf $f " $pos";
             }
         }
         printf $f ")\n";
         printf $f "         (B";
         foreach $pos (keys %p) {
             if ($p{$pos} eq 'B') {
                 printf $f " $pos";
             }
         }
         printf $f ")\n";
         printf $f "         (T";
         foreach $pos (keys %p) {
             if ($p{$pos} eq 'T') {
                 printf $f " $pos";
             }
         }
         printf $f ")\n";
         printf $f "         (Y";
         foreach $pos (keys %p) {
             if ($p{$pos} eq 'Y') {
                 printf $f " $pos";
             }
         }
         printf $f ")\n";
         printf $f "      )\n";
         printf $f "   )\n";
         printf $f ")\n\n";
         $b{"black-${x}x${y}.bmp"}->{x} = $x * 25;
         $b{"black-${x}x${y}.bmp"}->{y} = $y * 25;
         $x = 0;
         $y = 0;
         %p = ();
     }
  }
}

close($f);

foreach $b (keys %b) {
  printf "$b - $b{$b}->{x} $b{$b}->{y}\n";
}
</source>
</spoiler>
Лёгким движением руки, генерим уровни, файлами, по 10 уровней в каждом. Выглядит полученное <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/levels_01_10.zrf">следующим образом</a> (нет, <b>sokoban.inc</b>, в самом начале файла - это не название компании, а просто подгружаемый файл, с необходимыми определениями, созданными вручную). Некоторые не любят язык <a href="https://ru.wikipedia.org/wiki/Perl">Perl</a>, а многие другие могут найти мой стиль программирования не слишком изящным (чего стоят только разбросанные по коду "магические" константы), но я думаю, что для программы, которая (возможно) будет запущена всего один раз - это вполне приемлемое решение.

В любом случае, мы получили (почти даром) вожделенные уровни, но (пока) не можем их запустить. Для полного счастья, нам не хватает того самого "<b>sokoban.inc</b>" и графических ресурсов, конечно. Последние мы быстренько создаём в <b>paint</b>-е (не особенно заморачиваясь и рисуя разноцветные, однотонно закрашенные квадратики), а первый - содержит, пока, не так много полезного. Перемещение "погрузчика" будем программировать позже, сейчас мы хотим, всего лишь, полюбоваться на уровни!

<spoiler title="sokoban.inc - минималистическая версия">
<source lang="lisp">
(define common-grid
   (start-rectangle 0 0 25 25)
)

(define common-level
   (move-sound "Audio/Pickup.wav")
   (release-sound "Audio/Pickup.wav")
   (capture-sound "")

   (option "prevent flipping" true)
   (option "animate captures" false)

   (players    You)
   (turn-order You)

   (piece
      (name W)
      (image You "images/sokoban/w.bmp")
   )
   (piece
      (name B)
      (image You "images/sokoban/b.bmp")
   )
   (piece
      (name b)
      (image You "images/sokoban/b.bmp")
   )
   (piece
      (name T)
      (image You "images/sokoban/t.bmp")
   )
   (piece
      (name Y)
      (image You "images/sokoban/y.bmp")
   )
   (piece
      (name y)
      (image You "images/sokoban/g.bmp")
   )

   (win-condition (You) (pieces-remaining 0 B) )
)
</source>
</spoiler>
Стены, ящики, места для размещения ящиков и, разумеется, сам "погрузчик" - всё это фигуры. Некоторые из них, потом, даже будут двигаться. Всё это прекрасно, но нас уже поджидает очередная засада! Возможно, вы обратили внимание на имена файлов вида <b>black-NNxMM.bmp</b> в описаниях уровней? Это "задники" уровней. Всё, что от них требуется - предоставить фон, для отображения на нём фигур. Проблема лишь в том, что все эти задники разного размера (спасибо разработчикам Sokoban) и размер этот очень важен для корректного отображения уровней (за это стоит поблагодарить разработчиков ZoG).

Вновь вооружаемся <b>paint</b>-ом и, пытаясь посрамить <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BB%D0%B5%D0%B2%D0%B8%D1%87,_%D0%9A%D0%B0%D0%B7%D0%B8%D0%BC%D0%B8%D1%80_%D0%A1%D0%B5%D0%B2%D0%B5%D1%80%D0%B8%D0%BD%D0%BE%D0%B2%D0%B8%D1%87">Малевича</a>, рисуем чёрные прямоугольники всевозможных форм и размеров. Конечно их не шестдесят штук. Их всего пятьдесят четыре, но от этого не сильно легче! Парадоксально, но факт - более 90% нашего дистрибутива займут пустые, радикально чёрные прямоугольники (если бы они не были монохромными, то вполне могли бы занять и все 99%). Теперь можно полюбоваться на сами уровни:

<img align="center" src="https://habrastorage.org/files/74f/0c6/ae9/74f0c6ae905044fab11da1370f36be86.png"/>
Быстренько пробегаемся по всем уровням (просто чтобы убедиться, что нигде не напахали с кодогенератором), после чего нас охватывает дизайнерская лихорадка. Начинаем с жёлтых ящиков. Две диагональных линии делают их гораздо более привлекательными (а дорисованные по сторонам треугольники - вообще тянут на эксклюзив). Рисуя кирпичную кладку, начинаем понимать, что 25x25 - фиговый размер для тайла. 24 - гораздо более правильное значение (забавно, что простой перестановкой цифр из него можно легко получить универсальный ответ на никому не известный <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%B2%D0%B5%D1%82_%D0%BD%D0%B0_%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8,_%D0%B2%D1%81%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D0%B8_%D0%B2%D1%81%D0%B5%D0%B3%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE">вопрос</a>). Снова берём в руки <b>paint</b> и терпеливо ресайзим все чёрные прямоугольники (результат стоит затраченных усилий). Последним перерисовываем сам "погрузчик" (без градиентной заливки тоже дело не обходится).

Далее всё совсем просто. Необходимо <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/sokoban.inc">научить</a> фигуры двигаться. Единственная техническая сложность (очень небольшая) в том, что места размещения ящиков - тоже являются фигурами. Это означает, что когда мы по ним ходим и двигаем ящики - они должны удаляться (а затем автоматически восстанавливаться, при выходе с соответствующего поля). Конечно, можно было бы их просто нарисовать на задниках, но после этого последние уже перестали бы быть монохромными (солидно увеличившись в размере) и, в любом случае, 54 задника всё же лучше, чем все 60. На этом, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2427">всё</a>! Наслаждаемся результатом:

<video>http://www.youtube.com/watch?v=b0xLP9I6ZM0</video>

<spoiler title="P.S.">
Уже ближе к вечеру, Howard McCay прислал мне весьма неожиданное и очень элегантное <a href="https://github.com/GlukKazan/ZoG/commit/c2e5f126c607a85f4e2cc9f68d27e9b84f7746ca?diff=split">дополнение</a> к моей реализации <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2273">Yonin Shogi</a>, опубликованной в далёком уже 2014 году. Оглядываясь назад, я понимаю, что это был не самый худший день в моей жизни.
</spoiler>

Цвет волшебства

<img align="left" src="https://habrastorage.org/files/a9e/ebc/42c/a9eebc42c84e43b2bff7c3136d8d573f.PNG"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ближе к границе Краепада горели семь второстепенных цветов, искрясь и танцуя в пене умирающих морей. Но они были бледной тенью в сравнении с более широкой полосой, которая парила позади, наотрез отказываясь делить с ними один и тот же спектр.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Это Цвет-Король, по отношению к которому все менее важные цвета есть не более чем неполные и застиранные оттенки. Это октарин, цвет магии.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Праттчетт</i></b>&nbsp;

В этой игре никто никого не ест. Цель проста - перейти на другую сторону доски любой из фигур. Для этого могло бы хватить всего одного хода... Если бы не мешали другие фигуры.
<cut>
Хотя игра <a href="http://www.yucata.de/en/Rules/Kamisado">Kamisado</a> разработана нашим современником, она полностью соответствует духу китайской традиции. Дело не только в восточной символике. На досках китайских настольных игр (таких как "<a href="http://skyruk.livejournal.com/274836.html">Сян-ци</a>", "<a href="http://skyruk.livejournal.com/427724.html">Доу-шу-ци</a>" или "<a href="http://skyruk.livejournal.com/428408.html">Лу-чжань-ци</a>") можно найти дворцы и крепости, реки и озёра, холмы и ловчие ямы. И все эти "детали рельефа" имеют к игровому процессу самое непосредственное отношение! Нам мало что известно о "<a href="http://skyruk.livejournal.com/273963.html">Лю-бо</a>" - родоначальнице жанра настольных игр, но и там разметка доски, очевидно, имела первостепенное значение.

На мой взгляд, в этом суть традиционных китайских игр. Предельное ограничение "свободы" фигур, строгое следование "ритуалу", превращает игровой процесс в настоящую головоломку. Генерал в Сян-ци не может бегать по всей доске, спасаясь от мата, подобно королю в европейских шахматах. Он обязан оставаться внутри дворца! Также несвободен и "Конь". Хотя внешне его ходы напоминают перемещения аналогичных фигур из других шахматных игр, он не может "перепрыгивать" препятствия. Сян-ци - единственная традиционная игра (за исключением родственной ей корейской "<a href="http://skyruk.livejournal.com/275411.html#cutid1">Чанги</a>"), в которой ход коня может быть заблокирован!

Другой стороной китайских игр является "естественность" вводимых ограничений. Правила могут казаться надуманными, но лишь до того момента, пока мы не услышим их объяснение.  Например, генералы в Сян-ци не могут находится на одной открытой вертикали, не могут "видеть" друг друга. Считалось, что увидев вражеского генерала, фигура могла "перелететь" в его дворец и убить его! Сравните это поэтичное объяснение с необъяснимыми ограничениями матования в монгольском "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Шатар</a>" и вы поймёте, что я имею в виду. 

Kamisado, в равной степени, обладает этими двумя качествами. Это игра головоломка, фигуры которой не свободны в своих ходах. Даже двигаясь "только вперёд" (по вертикали и диагоналям), на любое количество полей, они могли бы достичь противоположной стороны доски всего за один ход, если бы <a href="https://en.wikipedia.org/wiki/Kamisado">Peter Burley</a> не придумал гениальное правило, ограничивающее их перемещение. Каждый раз (кроме самого первого хода) ходить может лишь фигура того цвета, на поле которого завершила своё движение фигура, выполнившая предыдущий ход:

<img align="center" src="https://habrastorage.org/files/9b3/e39/78a/9b3e3978a7984b6f860eb6b28b79e8b5.png"/>
Всё просто - "жёлтый дракон" чёрных заканчивает свой ход на пурпурном поле, после чего ходит "пурпурный дракон" белых. Это главное правило игры Kamisado и, в большинстве случаев, игроки им и ограничиваются. Игра продолжается до тех пор, пока одна из фигур не достигнет последней линии доски. Партия, по таким правилам, продолжается в течение 10-15 ходов, при условии того, что игроки не заблокируют друг друга. Естественным способом, продлить удовольствие, является игра до нескольких очков. Различают следующие варианты:

<ul>
	<li><b>Single Round</b>: до 1 очка</li>
	<li><b>Standard Match</b>: до 3 очков</li>
	<li><b>Long Match:</b> до 7 очков</li>
	<li><b>Marathon Match</b>: до 15 очков</li>
</ul>
Завершив очередной раунд, игроки расставляют фигуры на первой линии, после чего, продолжают игру, пока один из них не наберёт оговоренное количество очков. Расстановка фигур отличается от исходной (каждая фигура на поле своего цвета) и выполняется по определённому алгоритму. Игрок, победивший в очередном раунде, собирает фигуры (слева-направо и сверху-вниз) и расставляет на первой линии либо слева-направо, либо справа-налево. Проигравший должен использовать то же направление расстановки (порядок расстановки фигур, скорее всего, будет отличаться).

Играть несколько раундов подряд, по сути, в одну и ту же игру было бы не очень интересно. По этой причине, фигуры прошедшие через всю доску, получают знаки различия. Получив "пояс сумо" фигура становится менее подвижной (перемещается, максимум, на 5 полей), но приобретает новое качество. Сумоист может "толкнуть" вражескую фигуру, находящуюся непосредственно перед ним, на одно поле вперёд (при условии, что это поле свободно). Нельзя толкать свои фигуры, нельзя выталкивать фигуры за пределы доски, а также толкать более сильные (и равные по силе) фигуры. В дальнейшем, фигура может быть превращена в двукратного (ходит, максимум, на 3 поля) и троекратного (ходит на 1 поле) сумоиста, способного толкать две или три фигуры, соответственно.

Разумеется, сама по себе возможность "толкнуть" вражескую фигуру мало что даёт. Дело в том, что такое вынужденное перемещение фигуры противника рассматривается как его ход. Игрок, имеющий в своём распоряжении "сумоистов", может разнообразить свою тактику, заставляя противника пропускать ходы, при этом определяя цвет фигуры, выполняющей следующий ход. Кроме того, за превращение фигур "сумо" даётся большее количество очков (3, 7 и 15 очков, соответственно). Конечно, с учётом их тихоходности, добиться такого превращения гораздо сложнее.

Решив реализовать Kamisado на платформе "<a href="http://www.zillions-of-games.com/">Zillions of Games</a>", я немедленно столкнулся с техническими сложностями. Главной проблемой была разбивка игры на раунды. Сам процесс расстановки фигур, после завершения очередного раунда, довольно трудоёмок, в плане реализации на ZRF, но дело было не в этом. В конце концов, расстановка всех фигур одним ходом - задача муторная, но вполне решаемая. Сделать две кнопки, управляющие направлением расстановки, также не очень сложно. Главная трудность - в самом завершении раунда!

<img align="center" src="https://habrastorage.org/files/cc8/0e5/a5d/cc80e5a5d6894c1694f6a4a782735110.png"/>
Помимо "штатного" завершения, связанного с превращением фигуры, <a href="http://www.yucata.de/en/Rules/Kamisado">оригинальные правила</a> предусматривают действия, выполняемые при взаимной блокировке игроков. Такого рода ситуации редки (особенно если игроки к ним не стремятся), но вполне возможны. По правилам, игрок, ход которого привёл к взаимной блокировке, проигрывает раунд. Более того, заблокированная фигура противника "получает повышение", не доходя до последней линии!

<spoiler title="Лучшее - враг хорошего">
Когда я уже начинал писать эту статью, обнаружилось, что некоторые нюансы правил я понимал неправильно. На иллюстрации выше, можно заметить, что взаимная блокировка происходит при выполнения хода "оранжевым драконом" на синее поле (при этом, "синий дракон" белых вполне может двигаться! Причина этого проста. В Kamisado, нет понятия пропуска хода. Если фигура (такая как "синий дракон" чёрных) заблокирована, считается, что она выполняет вынужденный ход на 0 полей (такой ход возможен только при отсутствии других ходов). Поскольку он стоит (а следовательно и завершает свой ход) на оранжевом поле, мы должны перемещать не синего, а оранжевого дракона, заблокированного предыдущим ходом.

В практическом отношении, это означало, что мне пришлось <a href="https://github.com/GlukKazan/ZoG/commit/a0e1ef1c530a0176a71671573de20e0752bde392?diff=split">вернуть</a> полный перебор по позициям на доске, от которого я <a href="https://github.com/GlukKazan/ZoG/commit/dfcc83a8dd44720f2362d35dabaf99eb86fa60b0">пытался</a> избавиться ранее (но, в любом случае, один проход по доске на ход, лучше чем два). Разумеется, это сказалось на производительности. При использовании нового варианта правил, установка минимального времени выбора хода (на слабых машинах) приводит к совершенно неадекватному поведению AI. Он просто не успевает добраться до более менее вменяемых вариантов ходов, а какая либо возможность задания эвристик, для управления порядком перебора ходов, в ZoG отсутствует.
</spoiler>
В этом и заключалась проблема. Пропуск хода, на ZRF, реализуется легко. Более того, при отсутствии возможности хода, пропуск хода может быть выполнен автоматически, без выполнения игроком каких либо ручных действий. Но если "пас" сказали все участвующие в игре игроки, игра автоматически завершается ничьей и её никак нельзя продолжить! Я встал перед выбором: либо, выполнив большой объём работ, отказаться от автоматического пропуска хода (ухудшив, тем самым, usability приложения), либо... придумать что-то другое.

Так появился новый вариант игры "Kamisado non Stop". Я отказался от расстановки фигур между раундами, ограничившись немедленным возвратом превращённой фигуры на <b>любое</b> свободное поле первой линии (очевидно, такое поле найдётся всегда). Цвет выбранного поля определяет фигуру, которой будет ходить противник (что даёт дополнительное тактическое преимущество, после превращения фигуры). Игра по прежнему ведётся на очки (в моём варианте - до 7 очков), но, в моей реализации, превращение фигуры любого типа приносит лишь одно очко (просто, чтобы сделать игру более продолжительной).

Также, я решил изменить свойства фигур, начиная с "Двукратного сумоиста". По моему мнению, каждый новый уровень фигуры должен нести в себе новое <b>качество</b>. Моя версия "табеля о рангах среди драконов" выглядит следующим образом:

<ul>
	<li><b>Dragon</b> - обычная фигура Kamisado. Превращается в <b>Sumo</b></li>
	<li><b>Sumo</b> - в полном соответствии с правилами Kamisado, может двигаться не более чем на 5 полей, либо толкать одну вражескую фигуру типа <b>Dragon</b>, расположенную непосредственно впереди, на одно поле. Превращается в <b>Double</b></li>
	<li><b>Double</b> - перемещается не более чем на 3 поля и может толкать две фигуры (своих или противника), рангом ниже <b>Double</b>, расположенные спереди, друг за другом, на одно поле. Превращается в <b>Triple</b></li>
	<li><b>Triple</b> - может перемещаться лишь на 1 поле и толкать в любом из трёх направлений одну фигуру (свою или противника) рангом - <b>Double</b> и ниже</li>
</ul>
Вот как всё это выглядит:

<video>https://youtu.be/ab3Qk_cVCoU</video>

<spoiler title="И, таки да, в моей игре есть пасхалка">
Внимательный читатель может задаться вопросом: во что превращается фигура <b>Triple</b>? Поскольку фигуры этого типа <b>крайне</b> тихоходны, а желающих добраться до последней линии, на момент их появления, и без того достаточно, вероятность такого превращения стремится к нулю. Тем не менее, такое превращение возможно, а его результатом становится фигура <b>Ultimate</b>. По первоначальной задумке, эта фигура умела перемещаться на 0 полей и, в результате, не могла превратиться во что либо другое.

В порядке компенсации за полную потерю мобильности, она обретала возможность "телепортироваться" на любое свободное поле, а в качестве "ультимативной" способности - блокировку любых вражеских фигур, оказавшихся по соседству. При удачном расположении, все 8 вражеских фигур могли быть заблокированы всего одной фигурой класса <b>Ultimate</b>. Тестовые прогоны показали, что такое решение слишком брутально. Противник буквально не имел возможности подвинуть хотя бы одну из своих фигур со стартовых позиций, пока безумный <b>Ultimate</b> прыгал по доске.

В финальной версии, <b>Ultimate</b> перемещается как привычный нам шахматный конь. Он по прежнему имеет блокировать до 8 фигур противника, но обязан двигаться, при своей очереди хода, снимая, тем самым, блокировку, хотя бы с части фигур.
</spoiler>
На мой взгляд, результат получился неплохим. Иногда AI совершает довольно странные ходы, но это, в общем-то понятно. ZRF более всего пригоден для игр, напоминающих шахматы. В случае Kamisado, AI ZoG может опираться лишь на условия завершения игры. Любого рода шахматные эвристики и оценочные функции, для этой игры, не очень пригодны, а возможность их переопределения отсутствует. Если AI успевает выполнить полный перебор, до выполнения условия завершения - программа работает идеально, но как только завершение партии уходит за "горизонт перебора" - начинаются странности, связанные с применением неподходящей оценочной функции. Я думаю, эту проблему можно решить, полностью переписав игру на <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> и определив более адекватную оценочную функцию (и возможно какие-то эвристики), но это задачка не на один день.
</cut>

«Фермерские шахматы» — собираем по кусочкам

<img align="left" src="https://habrastorage.org/files/7d4/597/ab3/7d4597ab3ae646ca9384317df0c71b61.PNG"/><b><i>Пришел король шотландский,&nbsp;
Безжалостный к врагам,&nbsp;
Погнал он бедных пиктов&nbsp;
 К скалистым берегам.&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Роберт Льюис Стивенсон "<a href="http://www.stivenson.ru/med.html">Вересковый мёд</a>"</i></b>&nbsp;
&nbsp;
Лучший способ забыть что-то - положить на видное место. Это касается и настольных игр - современники не утруждают себя описанием  правил, полагая, что глупо тратить время, записывая то, что и так известно всем. Проходит каких нибудь сто лет и игра оказывается безнадёжно потеряна. <a href="http://skyruk.livejournal.com/273963.html">Любо</a>, <a href="http://skyruk.livejournal.com/244920.html">Петтейя</a>, <a href="http://skyruk.livejournal.com/246450.html">Латрункули</a> - все эти игры забыты не потому, что были нелюбимы. Напротив - в них играли так увлечённо, что не потрудились сохранить для потомков! 

Нам здорово повезло с тем, что <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%BD%D0%B5%D0%B9,_%D0%9A%D0%B0%D1%80%D0%BB">Карл Линней</a> интересовался, в том числе, и настольными играми. В противном случае, к скорбному списку ныне утраченных игр присоединился бы и <a href="http://skyruk.livejournal.com/246910.html">Хнефатафл</a>. Но, даже в таких счастливых случаях, слишком многие важные детали правил оказываются утерянными. Что-то забывают записать, часть утрачивается при переводах с одних языков на другие. Реконструкторы пытаются воссоздать правила, но результаты их трудов редко оказываются успешными. Об одной из "частично" забытых игр и пойдёт речь сегодня.
<cut>
Гала (или "Фермерские шахматы") известна нам, благодаря трудам знаменитого исследователя настольных игр <a href="https://en.wikipedia.org/wiki/Robert_Charles_Bell">Роберта Белла</a>. Подобно <a href="http://habrahabr.ru/post/234587/">Ритмомахии</a>, она была распространена в средневековой Германии, но, в отличии от последней, не в среде интеллектуальной элиты, а среди простого народа. Как и Ритмомахия, Гала не имеет непосредственного отношения к <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматам</a>, являясь вполне самостоятельной игрой с весьма оригинальными правилами.

Надо сказать, что, до начала поисков, про Галу я знал, но как-то поверхностно. Углубленное изучение предмета привело к новым вопросам. Поиск я начал, естественно, с <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BB%D0%B0_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Википедии</a>, но, после непродолжительного чтения, начал понимать, что описанная там игра не очень правдоподобна. За исключением излишней лаконичности статьи, настораживало заявление о том, что "брать" фигуры могут "в средней зоне". Фигуры, в такой трактовке, становятся практически бесполезными! В отношении "длинного" хода пешки, также указывалось очевидно ошибочное утверждение (<i>Пешки могут сделать первый ход на 2 поля, но чтобы при этом не выйти в среднюю зону</i>). <a href="http://www.chessvariants.org/historic.dir/gala.html">Первоисточник</a> приоткрыл покровы над этими загадками:

<ul>
	<li><i>Kings can only take when moving over a deflection line.</i> </li>
	<li><i>Rooks can only take in moves where they move over a deflection line.</i></li>
	<li><i>Bishops only take in moves where they pass the deflection line, but not when they move only one square in rookwise fashion.</i></li>
</ul>
Фразы по-прежнему оставались туманны, но, совершенно очевидно, не имели ничего общего со "взятием в средней зоне". Кроме того, было явно сказано, что пересекая "линию преломления", фигуры продолжают движение, изменяя лишь его направление (<i>A rook moves as a usual rook when in a corner of the board, and as a usual bishop in the middle of the board. <b>It is also possible to combine these moves in one turn</b></i>). Русскоязычный вариант полностью проигнорировал этот важный момент. Неясность с пешками полностью разъяснилась: (<i>It is allowed to move two squares if the deflection line isn't passed with the first move of the pawn</i>).

<img align="center" src="https://habrastorage.org/files/97b/67e/c2d/97b67ec2d8da4f6aa3782f90eee53f57.JPG"/>
В тексте всё ещё присутствовала некоторая "отсебятина": <i>(It is not clear whether it is possible for a rook to move over two deflection lines in one turn. <b>I would assume that this is possible</b>)</i> и я решил обратиться к ещё одному авторитетному <a href="https://boardgamegeek.com/boardgame/22625/gala">источнику</a>. Описание на этом ресурсе повторяется практически дословно, разумеется, за исключением нелепого предположения о том, что фигуры способны пересекать "линию преломления" дважды за ход. Фигуры, способные на это, получились бы слишком сильными, для того, чтобы игра оставалась интересна.

Непривычное ограничение на взятие (<i>Kornas can only take in moves where they move over a deflection line</i>), также, вызвано, скорее всего, желанием ослабить изначально сильные фигуры. Фигуры в Гала - оружие исключительно дальнего боя! Для того, чтобы взять фигуру противника, они должны "пересечь черту" своим ходом (и не могут сделать этого дважды за ход). В пределах "своего дома" они совершенно бессильны! Их задача - осуществление "кавалеристских наскоков" из средней зоны в дома (свои и противника), а также атака фигур, находящихся в средней зоне, с территории "домов". Всадник (Horsa), перемещающийся внутри домов по диагоналям, имеет дополнительное ограничение. Даже "пересекая линию" он не может взять фигуру противника, перемещаясь лишь на одно поле по ортогонали (такой ход возможен только при входе в "дом").

Королевских фигур (Gala) эти ограничения тоже касаются. Они могут бить противника, только пересекая границы домов, но, в отличии от тяжёлых фигур (Horsa и Korna), могут ходить лишь на одно поле в любом направлении (как король в шахматах). Такие правила делают их практически беззащитными. Есть, правда, в их арсенале оригинальный ход, позволяющий сбежать почти в любое место доски (<i>Gala is on one of the four squares in the middle of the board, it may be moved in one move <b>to any empty square</b> on the board with the <b>exception of those squares that contain a piece in the opening setup</b></i>), но, первоначально, с ним тоже не всё было понятно.

Каждый игрок обладал парой королевских фигур и проигрывал, теряя обе (<i>One wins the game by <b>taking both kings of the opponent</b></i>). В то же время (и этот момент был непонятен), потеря лишь по одному из королей каждым из игроков приводила к ничьей (<i>When only two kings of different players are left on the board, the game is a draw</i>). Находясь на одном из четырёх центральных полей доски, король мог резво прыгать по большей части доски, но без возможности боя фигур. Из <a href="http://www.chessvariants.org/historic.dir/gala.html">описания</a> на <a href="http://www.chessvariants.org/">chessvariants.org</a> оставалось совершенно неясно, зачем королю вообще могло понадобиться двигаться к центру доски, если, оставаясь в своём доме, он пребывал в не меньшей безопасности?

<img align="center" src="https://habrastorage.org/files/c02/cd6/bdb/c02cd6bdb77d496185d4d0e9710cc7c5.JPG"/>
Скупая фраза на <a href="https://boardgamegeek.com/boardgame/22625/gala">boardgamegeek.com</a> дала намёк на возможные мотивы: (<i>another goal in <b>placing the Galas in the 4 squares</b> in the very middle of the board</i>). Детали головоломки немедленно сложились! Основная цель игры заключалась в перемещении двух королевских фигур в центр доски. Теряя одного из королей, игрок уже не мог добиться своей цели, но мог помешать победе противника, взяв одного из его королей. Теряя двух королей, игрок терпел полное поражение.

В то же время, у королевских фигур появлялся мощный стимул для достижения центра доски. Войдя в центр, один король мог ожидать там другого,  но если ему самому что-то угрожало, имел возможность "отпрыгнуть" в безопасное место, чтобы начать свой путь с начала. Забавно, что самой сильной фигурой ближнего боя оказывалась пешка (Kampa). После пересечения границы своего дома, она начинала двигаться как король и имела возможность брать фигуры противника, в том числе, внутри его домов.

<img align="center" src="https://habrastorage.org/files/8cf/59d/09e/8cf59d09ee044e71a41658aaa0934047.png"/>
Был ещё один <a href="http://www.boardgamesoftheworld.com/gala.html">источник</a>, добавивший красок к описанию игры. Изначально, доверия к нему было мало, поскольку описание начиналось с ошибочной расстановки фигур: (<i>Each player has the following pieces: two Galas, <b>four Kornas</b>, <b>six Horsas</b> as well as eight Kampas</i>), но был ещё один, крайне интересный момент, отсутствовавший в других источниках: (<i>If the Korna crosses the deflection line with the first square he moves, he may also move any number of vacant squares. If the Korna has moved one or more squares before crossing the deflection line, he may then only move one square</i>). 

<img align="center" src="https://habrastorage.org/files/2c9/4c4/e7b/2c94c4e7b0f54cb580af3a0f4726e7af.png"/>
Для того, чтобы перемещаться (и брать фигуры) в чужом доме свободно, тяжелая фигура, предварительно, должна была подойти к нему вплотную, возможно становясь под удар фигур, находящихся в доме. Я счёл эту идею интересной, но остальные части описания выглядели странно: (<i>Kampas <b>can only capture when they are inside the cross</b>. A Kampa cannot capture as it crosses the deflection line into the cross</i>). Это было мало похоже на: (<i>Pawns only can take in the move <b>after they have crossed a deflection line</b></i>).

Уже завершив разработку <a href="https://raw.githubusercontent.com/GlukKazan/ZoG/738581c4e3f8147552dbbe694a8cdaf0e8aec498/Rules/FarmersChess.zrf">игры</a>, я продолжал искать подтверждения своим предположениям. Поиски завершились в неожиданном <a href="http://mlwi.magix.net/bg/gala.htm">месте</a>. <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=380">Mats Winter</a>, один из наиболее известных разработчиков приложений для ZoG, уже <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1281">опубликовал</a> игру в далёком 2005 году. Помимо всего описанного выше (отрадно, что я ни в чём не ошибся), он внёс в игру и несколько своих допущений:

<ul>
	<li>Ход тяжёлых фигур сделан составным (возможно для того, чтобы не ломать анимацию их перемещения в ZoG)</li>
	<li>Нет ограничений на взятие (кроме случая хода Horsa на одну клетку по ортогонали)</li>
	<li>Всадникам (Horsa), в первый ход, разрешается двигаться лишь на одну клетку (правда, не знаю зачем!)</li>
	<li>Центр доски объявлен "священным местом", на нём могут останавливаться только Gala и Kampa (последние лишь при условии нахождения в центре одной из фигур противника), королевские фигуры, находясь в центре, не могут есть другие фигуры, тяжёлые фигуры способны лишь проходить через центр, не останавливаясь на нём</li>
	<li>Воинам (Kampa) запрещено брать фигуры, пересекая "линию преломления", правила хода с пограничных полей "дома" выглядят странно и непоследовательно</li>
</ul>
<img align="center" src="https://habrastorage.org/files/853/588/44a/85358844af594a6e97127e3d2b00eb43.JPG"/>
Объясняя свой вариант правил, автор пишет следующее:
<blockquote><i>Personally, I would like to point out that there are significant similarities between Gala and the Viking game Tablut (Hnefatafl), and this is the reason why I chose to designate it as a Viking game. It has a kinship with the games of the Viking age, even if it probably appeared later. Gala has the "holy" central square, as in Tablut (Hnefatafl), where no other pieces than the king can enter. Like in Tablut, reaching absolute squares with the king is enough for a win. It has no leaping pieces, unlike chess and shatranj, which have both knight and alfil (elephant). Moreover, Hnefatafl and Tablut boards also often have that fourfold partition, i.e., a cross. In Tablut and Hnefatafl certain squares modify the capturing capability of the pieces. This is so also in Gala, but unknown in traditional chess. The Gala game also derives from an area close to former Viking country.</i> 
</blockquote>На мой взгляд, аналогия сомнительная. Нет никаких сведений о влиянии игр семейства "Тафл" на "Фермерские шахматы". Да, в этих играх, "рядовым фигурам" запрещено заходить на центральное поле ("королевский трон"), но им также запрещено и проходить сквозь него! В "Фермерских шахматах" Мэтса, это не возбраняется (в противном случае, перемещения тяжёлых фигур оказались бы крайне затруднены). Сомнительным выглядит и отказ от требования пересечения линии, при выполнении взятия. Фигуры становятся слишком сильными и игра превращается во взаимную бойню.

Поскольку правила моей реализации Gala существенно отличаются от версии Мэтса, я отправил её на публикацию в ZoG. В ближайшее время, я планирую внести коррективы в русскоязычную версию статьи на Википедии (то безобразие которое там есть сейчас оставлять никак нельзя). 

Кто из нас прав? Не знаю. Никто не знает.
</cut>

Dagaz: Пинки здравому смыслу (часть 10)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>... Десять настанет...
И ты задрожишь,
Как осиновый лист задрожишь!&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Юринэ "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D0%B0%D1%81_(%D0%B0%D0%BD%D0%B8%D0%BC%D0%B5)">Карас</a>"</i></b>&nbsp;
&nbsp;

Менее всего заметно то, что лежит на поверхности. За привычной обыденностью, мы не видим чудесного. Разработчики настольных игр придумывают всё новые и новые игровые механики, но часто путают "интересность" игры с её "сложностью". Чтобы было понятно, о чём идёт речь, приведу пример:

<spoiler title="Игра давления">
<b>TAMSK</b> или "Игра давления" была второй игрой, разработанной в рамках инициативы "<a href="http://www.gipf.com/">GIPF Project</a>". Это, пожалуй, самая странная из всех известных мне игр. В качестве игровых фишек, в ней используется набор песочных часов:

<img align="center" src="https://habrastorage.org/files/dda/596/406/dda59640657f45ab9da1f34972ecf738.jpg"/>

Каждый игрок имеет по три 3-минутных "склянки". Кроме того, в игре используются нейтральные 15-секундные часы, для ограничения времени хода. В начале игры, "фигуры" расставляются в углах шестиугольной доски, с чередованием цвета. Выполняя ход, каждый игрок перемещает одну из склянок на соседнее поле (в любом направлении), переворачивая её. Сразу же после этого, на поле с фигурой надевается кольцо. Правилами запрещается выполнять ход фигурой, песок в которой полностью высыпался (первыми тремя ходами каждый игрок обязан "взвести" все свои часы) и ходить на те поля, среза трубки которых достигли кольца (трубки полей имеют различную высоту). Игра заканчивается, когда ходы становятся невозможными. Побеждает игрок надевший больше всего колец.
</spoiler>
Безусловно, эта игра очень сложна (её совершенно точно не удастся описать на <a href="http://www.zillions-of-games.com/">ZRF</a>, а на <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>, с её поддержкой таймеров, вряд ли удастся разработать сколь нибудь дружественный интерфейс), но эта сложность выглядит какой-то искусственной, "притянутой за уши". Как разработчика настольных игр, меня интересуют игры, "бросающие вызов" существующим средствам разработки, но я не приветствую "сложность ради самой сложности". Я хочу рассказать про...
<cut>
<h4><b>1. Простые вещи</b></h4>
Весь этот цикл статей я затевал, в основном, для того, чтобы определить границы возможностей существующего "универсального" инструментария ("<a href="http://www.zillions-of-games.com/">Zillions of Games</a>" и "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a>"), предназначенного для разработки настольных игр. Новый проект стоит затевать лишь в том случае, если найдутся задачи, которые он сможет решать лучше, чем уже существующие (или просто <b>сможет</b> решать). В результате чего возникают ограничения функциональности? Разработчики сами придумывают их!

Разрабатывая любой продукт (ZoG не исключение), его создатели принимают ряд допущений, облегчающих им жизнь. За примерами далеко ходить не надо. В шахматах, фигуры выполняющие взятие, замещают собой взятые. Этот механизм настолько общий, для всех игр шахматного семейства, что называется "шахматным взятием". Разработчики ZoG посчитали хорошей идеей - не удалять взятые фигуры явно (если их место, по завершении хода, занимает другая фигура). В результате родилось ограничение - одно поле не может содержать более одной фигуры (для шашек шахматный механизм взятия был не актуален, но и новое ограничение их не аффектило). Игры, в которых это ограничение не выполняется (разнообразные <a href="http://geektimes.ru/post/253456/">манкалы</a>, <a href="http://cyclowiki.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Таврели</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовые шашки</a>) немедленно оказались "за бортом". Поймите меня правильно. Сделать такие игры <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1767">можно</a>, но их разработка превращается в настоящий кошмар! 

Другое "благое намеренье", отлитое из бронзы, звучит так: "игрок может ходить только своими фигурами". <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A1.D1.82.D0.B0.D0.B2.D1.80.D0.BE.D0.BF.D0.BE.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Ставропольские шашки</a> имеют своё мнение на этот счёт. Да, их тоже <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2247">можно</a> сделать, но как! Для того, чтобы оба игрока могли двигать все фигуры, их пришлось сделать нейтральными (то есть завести ещё одного игрока, не участвующего в игре, но владеющего всеми фигурами). Мало того, что совершенно искусственное ограничение приводит к серьёзному усложнению реализации, часть возможного функционала становится просто недоступной.

<img align="center" src="https://habrastorage.org/files/29d/6f2/c67/29d6f2c67e7e4f43ab470d151b22e132.gif"/>

В <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=656">этой</a> игре есть и фигуры, принадлежащие игрокам и нейтральная фигура "мяч". Сделав ход своей фигурой, игрок перемещает нейтральную фигуру. В таком виде всё работает, но средствами ZRF невозможно выполнить ход своей фигурой или нейтральной. То <b>и</b> другое по очереди, но не то <b>или</b> другое вместе! <a href="http://www.chessvariants.org/winning.dir/neutral-king.html">Иногда</a>, это мешает (и вновь приводит к чрезмерному усложнению кода). Ещё хуже всё становится при сочетании нескольких "антипаттернов".

Для определения обязательного взятия, в играх семейства шашек, ZRF использует механизм приоритетов. Это решение, само по себе, не очень удачно, поскольку приоритеты могли бы быть легко реализованы на основе <a href="http://habrahabr.ru/post/253397/">более универсального</a> механизма, но, что более важно, делает недоступным целый пласт функциональности, в таких играх как "Ставропольские шашки". В шашках, игрок обязан выполнить взятие, если у него есть такая возможность (это очень важно, в тактическом плане), но, в "Ставропольских шашках", игрок может ходить фигурами обеих сторон. Хотя оригинальные правила этот момент не оговаривают, было бы интересно сделать взятие своими фигурами более приоритетным (а взятие фигурами противника, например, вообще не обязательным), но добиться этого в ZRF нельзя! Никак!

<video>http://www.youtube.com/watch?v=k-dAsEYejUk&start=395</video>

Великолепная вторая миссия кампании Хаоса в <a href="http://www.battlevschess.com/en/">Battle vs Chess</a> (начиная с 6:40, настройка <b>start</b> на Хабре, к сожалению, <a href="http://geektimes.ru/post/42082/">не работает</a>). Чёрные могут добавлять свои фигуры из резерва в любое место доски, если тем самым не шахуют белых. Даже с учётом этого ограничения, у чёрных серьёзное преимущество, поскольку, как нам известно из <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>, "фигура в руке сильнее фигуры на доске". 

Играя в эту игру впервые, я не справился с управлением (сбрасываемая фигура переключается колёсиком мыши) и сбрасывал фигуры на доску строго по старшинству (первыми всех пешек, затем коней, слонов и лишь в последнюю очередь - ферзя). Даже с учётом этого, я легко победил и игра, в таком режиме, на мой взгляд, оказалась даже более интересной. Клон оригинальной миссии я <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2413">сделал</a>, но с добавлением фигур на доску "по старшинству" возникли проблемы, связанные со всё теми же приоритетами. Можно сделать приоритетными ходы сброса фигур, но приоритет перемещения фигур должен совпадать с каждым из этих приоритетов (иначе, до завершения сброса всех фигур, не удастся сдвинуть ни одну фигуру, включая короля, даже попавшего под шах). В ZRF это совершенно невозможно! Приоритетам ZRF явно не хватает гибкости.

Тема взаимодействия разнородных опций, вообще, неисчерпаема. Так, например, в играх семейства "<a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BB%D0%BC%D0%B0">Халма</a>" (в нашей стране, один из её вариантов известен под именем "<a href="https://ru.wikipedia.org/wiki/%D0%A3%D0%B3%D0%BE%D0%BB%D0%BA%D0%B8_(%D0%B8%D0%B3%D1%80%D0%B0)">Уголки</a>") возникает необходимость "пометки" ранее посещённых полей, во избежание возможного зацикливания ходов. На первый взгляд, для этой цели идеально подходят "позиционные флаги", позволяющие связать булевское значение с определённой позицией, на время выполнения хода. К сожалению, как и при использовании глобальных флагов, установленные значения автоматически обнуляются в начале <b>каждого</b> хода. Поскольку составной ход в ZoG состоит из вполне самостоятельных "частичных" ходов, позиционные флаги не оправдывают связанных с ними ожиданий. Решать проблему приходится "помечая" не поля, а фигуры при помощи их атрибутов (вроде используемых при выполнении проверки возможности рокировки), но это тема для отдельного разговора.

<video>http://www.youtube.com/watch?v=fAzYFoXMqfQ</video>

В играх семейства шашек, атрибуты фигур используются для предотвращения "Турецкого удара". По правилам, принятым в большинстве современных вариантов игры, взятые фигуры удаляются с доски лишь при завершении хода, все вместе. Для нас, это означает две вещи: во первых, из множества "частичных" необходимо выделить самый последний ход, чтобы при его выполнении удалить все взятые фигуры (при использовании "правила большинства" или превращения шашек во время выполнения хода, как в "Русских шашках" - это, само по себе, непростая задача). Кроме того, необходимо помечать взятые фигуры, используя атрибуты или превращение фигур. Здесь нас и подстерегает сюрприз. ZSG-нотация построена таким образом, что помеченную или превращённую фигуру, тем же ходом, удалить не удастся! Это означает, что последнюю взятую фигуру помечать не нужно и следует удалять индивидуально. Добавьте к этому не очень удобную семантику перемещения фигур (до завершения генерации хода, фигуры, выполняющие ход, как бы остаются на своих местах) и разработка, казалось бы, банальных <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2351">шашек</a> превратится в сложный и увлекательный <a href="http://habrahabr.ru/post/254947/">квест</a>, наполненный приключениями и борьбой с "боссами".

<spoiler title="Ещё немного о составном ходе">
Концепция составного хода в ZoG, вообще, очень далека от универсальности. Даже если не вспоминать о хардкодной реализации "правила большинства", остаётся главное его ограничение - составной ход должна продолжать фигура, перемещённая предыдущим частичным ходом! Это требование, а также специфика генерации случайных чисел в ZoG, сразу же ставит крест на всех попытках использования составного хода для реализации повторных бросков, в играх наподобие <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%80%D0%B4%D1%8B">Нард</a>, <a href="http://habrahabr.ru/post/225631/">Ура</a> и т.п. В результате, приходится пускаться "во все тяжкие", для реализации, в общем-то, простого и естественного требования.
</spoiler>
Когда, ко всему этому, добавляются проблемы с определением приоритетов, жизнь разработчика становится <b>ещё интереснее</b>. В варианте шашек, распространённом на территории Осетии (<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D0%BD%D1%8B">Кены</a>), в целом, очень похожем на турецкие и армянские шашки, было введено интересное правило. Не превращённая шашка (кен) может перескакивать через дружественные кены, подобно тому, как это делается в играх семейства "Халма". К сожалению, мне так и не удалось выяснить, разрешается ли чередовать такие прыжки со взятием вражеских фигур, но такой вариант был бы, несомненно, наиболее интересен. И именно его воплотить в ZRF, по всей видимости, никогда не удастся. Поскольку взятия должны оставаться приоритетными, а "прыжки" можно чередовать со взятиями в произвольном порядке - их необходимо сделать приоритетными тоже. Но если сделать так, обычные (низкоприоритетные) ходы удастся выполнять лишь в исключительно редких случаях.

<img align="center" src="https://habrastorage.org/files/88e/aff/c73/88eaffc73d9d435da78088265a747018.png"/>
Часто, сложные в реализации правила являются следствием усовершенствований игры её создателями. Так, в классическом "<a href="http://spielstein.com/games/ordo/">Ordo</a>"  Дитера Штейна, инвариантом игры является "связность" фигур, по завершении хода. Если группа фигур разделилась (учитываются соседи как по ортогоналям, так и по диагоналям), ход, восстанавливающий связность, является приоритетным. Если найти такой ход не удаётся - игроку засчитывается поражение. В таком виде, хотя и не без труда, игру <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2345">удалось</a> описать на Axiom. В улучшенном варианте <a href="http://www.iggamecenter.com/info/ru/ordo.html#ordox">OrdoX</a>, помимо введения новых (диагональных) ходов, было изменено правило сохранения связности. Теперь, на доске должна оставаться лишь наибольшая группа из разделённых, но если есть несколько (возможно больше двух) равных групп, игрок вправе выбрать, какую из них оставить на доске. Если решение и возможно в ZoG, оно окажется крайне трудоёмко.

Более древний пример улучшения игровых правил можно найти в одной из разновидностей "<a href="http://skyruk.livejournal.com/290069.html">Боевых гонок</a>", распространённой в Западной Сахаре, Марокко и Центральном Алжире. В <b>Sigh</b>, как и в большинстве таких игр, используются "кости", выполненные в виде четырёх плоских палочек. Выпавшие очки считаются по количеству палочек, упавших светлой стороной вверх. В целом, в этой игре, всё как обычно - есть броски, вводящие в игру новую фишку (1- <b>khadzh</b>), дополнительные броски (например, 4 - <b>barga</b>), но есть один, бросок, делающий игру действительно уникальной. Двухочковый (<b>khmar</b>) - аннулирует результат предыдущего броска и даёт право на повторный бросок. Если он выпадет снова, аннулируется ещё более ранний ход (соответствующая фишка возвращается в исходное положение) и так далее. Для корректной реализации этой игры, придётся вести журнал ходов, с возможностью их отката!

<video>http://www.youtube.com/watch?v=9lnQnnx68Gs</video>

Некоторые игры пересматривают саму концепцию хода. В "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1484">Ambiguous Chess</a>", показанной выше, игрок, выполняющий ход, указывает поле, на которое он собирается сходить, а уже его противник выполняет сам ход одной из фигур, способных его выполнить. Сделать такую игру в ZoG сложно, но можно. "<a href="http://www.chessvariants.org/other.dir/refusal.html">Refusal Chess</a>" идёт ещё дальше! В ней противник может запретить выполнение объявленного игроком хода (если этот ход не является единственно возможным) и тогда игрок должен будет сделать другой ход. Наверное, это тоже можно реализовать на ZRF, но я не очень-то хорошо себе представляю как.

Но и это не предел! В первой части цикла, я уже <a href="http://habrahabr.ru/post/248639/">упоминал</a> эфиопский <a href="https://en.wikipedia.org/wiki/Senterej">Senterej</a>, в котором игроки начинают игру, выполняя ходы <b>одновременно</b>, до первого боя фигуры. В манкале "<a href="http://geektimes.ru/post/253456/">Сулус-айди</a>", в таком же режиме выполняется "нулевой посев", определяющий право первого хода и, заодно, нарушающий детерминизм первоначального расклада камней. Подчеркну, игроки одновременно берут и раскладывают камни из <b>одних и тех же</b> лунок! Думаю, аудитория на Хабре хорошо понимает, что <a href="https://en.wikipedia.org/wiki/Race_condition">это означает</a>. Если вам мало и этого, подумайте о том, с какими сложностями придётся столкнуться в процессе реализации в ZoG всем знакомого "<a href="https://ru.wikipedia.org/wiki/%D0%94%D1%83%D1%80%D0%B0%D0%BA_(%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0)">Подкидного дурака</a>". Надеюсь, я довёл до вас свою мысль:

<b>На всякого мудреца довольно простоты.</b>
</cut>

Dagaz: Пинки здравому смыслу (часть 9)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>... И повторится все, как встарь:
Ночь, ледяная рябь канала,
Аптека, улица, фонарь.&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Александр Блок</i></b>&nbsp;
&nbsp;

Сегодня, я хочу рассказать о проблеме, традиционно игнорируемой большинством разработчиков настольных игр. Если компьютерная реализация игры, наподобие шашек или шахмат, корректно обрабатывает ситуации выигрыша (или проигрыша) игроков (а это тоже бывает <a href="http://habrahabr.ru/post/234587/">непросто</a>), результат считается вполне удовлетворительным. Но как быть, если игра зашла в тупик? Игроки двигают фигуры, без всякой надежды на победу (и могут продолжать делать это до бесконечности). 

При игре человека с компьютером, это не проблема (понятно кто устанет первым), но что делать если играют два бота? Для сравнения "силы" различных вариантов AI, например, требуется провести в автоматическом режиме большое количество игр. Корректная обработка "ничьих", в такой ситуации, жизненно необходима. И крайне желательно, чтобы она выполнялась в точном соответствии с правилами игры.
<cut>
<h4><b>2. Повторение пройденного</b></h4>
Наиболее прямолинейный подход, используется в играх семейства "Шашек". Партия прерывается, если ни одному из игроков не удаётся выиграть в течение заданного количества ходов. Так, в хорошо нам знакомых "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A0.D1.83.D1.81.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Русских шашках</a>", партия считается сыгранной вничью, если не удаётся выиграть за 30 ходов. Более сложные правила, связанные со спецификой "тихоходных дамок", используются в "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.90.D0.BD.D0.B3.D0.BB.D0.B8.D0.B9.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8_.28.D1.87.D0.B5.D0.BA.D0.B5.D1.80.D1.81.29">Английских шашках</a>". Если у каждого из противников остаётся по одной дамке, разрешается делать не более 20 ходов, до признания ничьей. Если у одного противника три дамки, а у другого две, последний имеет право требовать, чтобы игра была сыграна не более чем за 40 ходов. Правила "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.9C.D0.B5.D0.B6.D0.B4.D1.83.D0.BD.D0.B0.D1.80.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Международных шашек</a>" ещё более <a href="http://skyruk.livejournal.com/259756.html">подробно</a> описывают все возможные ситуации:

<ul>
	<li>Если игроки в течение 25 ходов делали ходы только дамками, не передвигая простых шашек и не производя взятия, объявляется ничья.</li>
	<li>Если у игрока в окончании партии остались 3 дамки, 3 дамки и 1 простая, 1 дамка и 2 простые, 3 простые шашки, 2 дамки, 1 дамка и 1 простая против одинокой дамки или 1 дамка против одинокой дамки или одинокой простой, игрок обязан 5-м ходом выиграть, иначе объявляется ничья.</li>
	<li>Если на доске остаются 5 дамок (или 4 дамки и 1 простая шашка) против 2 дамок, сильнейшая сторона обязана победить в 50 ходов, иначе объявляется ничья.</li>
	<li>Если три (или более) раза повторяется одна и та же позиция (т.е. одно и то же расположение шашек), причём, очередь хода каждый раз за одной и той же стороной – также объявляется ничья.</li>
</ul>
Вариации последнего из перечисленных правил часто используются и в других играх. В шахматах, троекратное повторение позиции (с учётом очерёдности хода) является одной из возможных причин признания "<a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B8%D1%87%D1%8C%D1%8F_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">ничьей</a>". В некоторых играх (например в <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>) повторять позицию запрещено. Я уже <a href="http://geektimes.ru/post/240680/">писал</a> о проблеме "Ко" в этой игре. Кратко напомню, о чём идёт речь:

<img src="https://habrastorage.org/files/5b4/b25/a31/5b4b25a31036479ead586a0b6a5ff2e2.PNG"/>

Если бы повторение позиции было разрешено, игроки могли бы продолжать эту последовательность ходов до бесконечности (забирая у противника всё новые и новые камни). С этим можно бороться, запретив белым играть С17, после хода чёрных на D17, но повторение позиции может быть и более сложным. В игре возможны ситуации "тройного Ко" и даже ещё более сложные позиции "Вечной жизни":

<img src="https://habrastorage.org/files/970/891/486/9708914864fe4192a418db92a8339459.PNG"/>

Правила <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%98%D0%BD%D0%B3%D0%B0#.D0.9F.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D0.BE_.D0.BA.D0.BE">Инга</a> пытаются регламентировать этот вопрос, но результат сложно считать удовлетворительным. Для того, чтобы отличить "боевое" Ко от "беспокоящего" требуется высокая квалификация. Начинающий игрок вряд ли справится с этим. В упрощённом <a href="https://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%98%D0%BD%D0%B3%D0%B0#.D0.9E.D1.82.D1.81.D1.83.D1.82.D1.81.D1.82.D0.B2.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B2.D1.82.D0.BE.D1.80.D0.B5.D0.BD.D0.B8.D0.B9">варианте</a> правил, позицию просто запрещено повторять. Этот подход называется "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE#.D0.92.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82.D1.8B_.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D0.B0_.D0.BA.D0.BE_.D0.B4.D0.BB.D1.8F_.D0.B4.D0.BB.D0.B8.D0.BD.D0.BD.D1.8B.D1.85_.D1.86.D0.B8.D0.BA.D0.BB.D0.BE.D0.B2">суперко</a>" и может определять повторение позиции двумя различными способами:

<ul>
	<li>Позиционное суперко — безусловный запрет на повторение позиции, без учета очерёдности хода</li>
	<li>Ситуационное суперко — запрет повторения позиции, при условии очереди хода того-же игрока</li>
</ul>
В общем, понятно, что умение сравнивать различные позиции может оказаться полезным, при реализации некоторых настольных игр (и жизненно необходимым для AI), но, с учётом того, что сравнивать придётся очень много, простое поэлементное сравнение позиций может оказаться слишком накладным. Чтобы решить эту проблему, известный разработчик компьютерных игр <a href="https://en.wikipedia.org/wiki/Albert_Lindsey_Zobrist">Albert Lindsey Zobrist</a> разработал простой и элегантный <a href="http://research.cs.wisc.edu/techreports/1970/TR88.pdf">метод</a>, названный в его честь.

<a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist hashing</a> применим для большинства настольных игр и суть его проста. Первым делом, составляется таблица случайных чисел (чем случайнее - тем лучше), для каждой возможной позиции каждой фигуры. В случае Шахмат, для каждого из 64 полей доски потребуется 12 случайных значений (по одному на каждый тип фигур, с учётом цвета). Далее, составляется хэш, путём "<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8E_2">сложения по модулю 2</a>" чисел, взятых из таблицы, для соответствующего расположения фигур на доске. Разумеется, если хэш-значения для двух позиций совпадут, это ещё не означает, что позиции одинаковы. Вероятность коллизий остаётся всегда, но использование этого метода позволяет минимизировать количество поэлементных сравнений позиций.

Важно, что такой хэш получается <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B4%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C">аддитивным</a>. Не обязательно каждый раз просматривать всю позицию, строя хэш "с нуля". Мы можем "передвинуть" фигуру по доске, оперируя лишь хэшем. Для этого, необходимо убрать из хэша значение соответствующее старой позиции фигуры и добавить новое (и то и другое выполняется операцией xor). Zobrist hashing - очень удобная методика и в большинстве компьютерных реализаций настольных игр она используется.

Разумеется, в <a href="http://www.zillions-of-games.com/">ZoG</a> она используется тоже (в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>-то уж точно), но лишь для внутренних нужд. Условие останова игры при троекратном повторении позиции "прибито гвоздями" в exe-нике! Axiom позволяет переопределить поведение (завершить игру поражением вместо ничьей) или детектировать первое повторение позиции вместо третьего, но работая в качестве <a href="http://www.zillions-of-games.com/progsample.html">engine</a> для ZoG, отменить эту проверку вовсе он тоже не может. Лично мне, такое неизменяемое "поведение по умолчанию" <a href="http://habrahabr.ru/post/224661/">попортило</a> немало нервов.

<spoiler title="Страдания по ''Уру''">
Конечно же, решение лежало на поверхности, но, к стыду своему, сам я до него не додумался (подсмотрел в реализации "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=218">Liberian Checkers</a>"). Если проверку повторения позиции нельзя отключить, можно постараться сделать каждую позицию "неповторимой". Для этого достаточно реализовать простейший двоичный счётчик в "лишних" или скрытых позициях на доске (фигуры будут невидимы, но будут нарушать уникальность позиции, что от них и требуется). Помню, в раннем детстве, отец учил меня мастерить такие счётчики из <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80#D-.D1.82.D1.80.D0.B8.D0.B3.D0.B3.D0.B5.D1.80_.D1.81.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.BD.D1.8B.D0.B9">DC-триггеров</a>:

<spoiler title="Обеспечение уникальности позиций">
<source>
{directions
	{link}		cntr q1 q2
	{link}		cntr q2 q3
	{link}		cntr q3 q4
	{link}		cntr q4 q5
directions}

: count-locks ( -- )
	q1 to
	BEGIN
		empty? IF
			LOCK create-piece-type
			TRUE
		ELSE
			capture
			cntr NOT
		ENDIF
	UNTIL
;
</source>
</spoiler>
Вот и всё! Просто идём по заданному направлению и добавляем фигуру на пустую позицию. Если же позиция не пуста, удаляем фигуру и идём дальше. Лишние фигуры "замусоривают" ZSG-нотацию, но и требуются они, как правило, в тех играх, где запись ходов и так уже совершенно не читаема. Кстати, никто <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2049">не сказал</a>, что счётчик обязан быть двоичным:

<img align="center" src="https://habrastorage.org/files/1ca/661/df1/1ca661df1b834fc7b51c43f9401d0380.gif"/>

Обратите внимание на левый верхний угол картинки. Лишь слегка изменив реализацию, можно визуализировать очень симпатичные счётчики ходов/взятий, даже несмотря на то, что в ZRF нет никакой арифметики! Подобные счетчики могут быть полезны и для подсчёта количества "не результативных" ходов, в рамках реализации правил, озвученных в начале статьи. К сожалению, такое решение нельзя назвать прямолинейным. Использование подобных приёмов ведёт к чрезмерному усложнению как ZSG-нотации, так и самой программы, а любое усложнение - лазейка для всевозможных ошибок.
</spoiler>
Отсутствие какой либо возможности настройки проверки повторения позиции в ZoG я считаю одной из наиболее серьёзных ошибок дизайна этой программы. Наряду с <a href="http://habrahabr.ru/post/251401/">"checkmated"</a> и <a href="http://habrahabr.ru/post/253397/">"maximal captures"</a>, эта опция достойна того, чтобы в честь неё отлили памятник из бронзы, на тему "как никогда не надо делать". При помощи ZRF можно лишь переопределить поведение, при обнаружении троекратного повторения позиции, но не более того. По умолчанию, действует следующее определение:

<source lang="lisp">
(draw-condition (White Black) repetition)
</source>
Одно то, что я никак не могу настроить эту проверку (например на обнаружение первого же повторения позиции, а не третьего по счёту) уже очень плохо, а то, что я не могу отключить эту проверку, когда она только мешает, просто ужасно! В своём проекте, я использовал бы (и надеюсь, что ещё использую) что нибудь вроде следующего определения:

<source lang="lisp">
(not-situation-repeated? 1 1)
</source>
Это знакомое нам <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE">Ко</a>. Первый аргумент определяет, какое по счёту повторение позиции необходимо детектировать, а второй - глубину поиска. И это должно быть универсальное выражение, которое можно использовать не только в условии завершения игры (как в ZRF), но и в любом инварианте, используемом генератором ходов (поскольку в Го повторение позиции должно запрещать ход, а не прерывать игру). Разумеется, также должна иметься возможность использования предиката <b>*-position-repeated?</b>, для определения позиционного Ко, наряду с ситуационным.

Возможно, ради всего сказанного выше, не стоило бы затевать эту статью, но у Zobrist hashing нашлось ещё одно неожиданное применение. Есть одна, поистине легендарная, <a href="http://skyruk.livejournal.com/241051.html">игра</a>, которая <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=428">связывает</a> собой "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашки</a>" и "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B5%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%BD%D0%BE%D0%BB%D0%B8%D0%BA%D0%B8">Крестики-нолики</a>". Также как в африканской "<a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2384">Bolotoudou</a>", в ней требуется строить линии "3 в ряд" из своих камней, чтобы снимать камни противника, но, в отличии от последней, для этой игры существуют <a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html">варианты</a>, запрещающие выполнять взятие построением одного и того же ряда два раза подряд. 

<video>http://www.youtube.com/watch?v=csy39T5G220</video>

Легко заметить, что в <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=428">реализации</a> на видео, такая проверка не выполняется и это не случайно! Мне трудно придумать требование, реализовать которое на ZRF было бы сложнее. Эта проверка должна контролировать повторение позиции, но не всей, а лишь её части. Если три камня составили линию ("мельницу"), повторное их расположение на тех же местах, через один ход, должно быть либо запрещено, либо не должно приводить к взятию. Но ведь и хэш можно строить лишь частичный!

<spoiler title="Построение частичного хэша">
<source lang="lisp">
(define (check-in-line direction)
   (let hash 0)
   (add-to-zobrist-hash hash)
   (check direction)
   (check is-friend?)
   (add-to-zobrist-hash hash)
   (check direction)
   (check is-friend?)
   (add-to-zobrist-hash hash)
   (check (not-situation-repeated? hash 1 2))
)
</source>
</spoiler>
Здесь, мы двигаемся вдоль выбранного направления <b>direction</b> и последовательно добавляем в хэш три позиции, если на них стоят дружественные камни. После чего, проверяем, не был ли такой хэш сформирован два хода назад. Подразумевается, что хэш-ключи у всех камней уникальные, например формируемые на основе значения атрибута, устанавливаемого при добавлении камней на доску:

<spoiler title="Обеспечение уникальности">
<source lang="lisp">
(define man-drop
   (check (decrement! mans-left))
   (check is-empty?)
   drop-pieces
   (set! unique mans-left)
   add-move
)
</source>
</spoiler>
Со снятием камней противника всё тоже не так просто. Во первых, в большинстве вариантов игры, нельзя снимать камни, составляющие одну из "мельниц" противника (в некоторых разновидностях такие камни снимать разрешается, если нет других вариантов взятия). Кроме того, если нам, своим ходом, удалось построить одновременно несколько "мельниц", мы имеем право взять соответствующее количество камней противника (этим правилом тоже часто пренебрегают).

<spoiler title="Взятие камней">
<source lang="lisp">
(define capturing
   (let capturing-count
      (count 
          (any
              (check-in-line n) (check-in-line ne)
              (check-in-line s) (check-in-line sw)
              (check-in-line e) (check-in-line se)
              (check-in-line w) (check-in-line nw)
          )
      )
   )
   (while (decrement! capturing-count)
       (all
           any-position
           (check is-enemy?) 
           (check (not (or
              (check-in-enemy-line n) (check-in-enemy-line ne)
              (check-in-enemy-line s) (check-in-enemy-line sw)
              (check-in-enemy-line e) (check-in-enemy-line se)
              (check-in-enemy-line w) (check-in-enemy-line nw)
           )))
           capture
           add-move-part
       )
   )
)
</source>
</spoiler>
Как можно видеть, древние разработчики настольных игр хорошо потрудились над тем, чтобы мы не заскучали над их реализацией. Вот пожалуй и всё, что я хотел рассказать о применении Zobrist hashing в проекте "Dagaz". Надеюсь, что мой рассказ был вам интересен.
</cut>

AI для «Дурака»

<img align="left" src="https://habrastorage.org/files/085/335/776/085335776ec64765afb114bb8266ab1e.PNG"/><i><b>Знал бы прикуп - жил бы в Сочи.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Народная мудрость.&nbsp;

Под игрока - с семака, под вистующего - с тузующего.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ещё одна народная мудрость.&nbsp;</b></i>

Похоже, в этом посте всё смешалось. "<a href="https://ru.wikipedia.org/wiki/%D0%94%D1%83%D1%80%D0%B0%D0%BA_(%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0)">Дурак</a>" в заголовке, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B5%D1%80%D0%B0%D0%BD%D1%81">преферансные</a> поговорки в эпиграфе и <abbr title="Картинка Для Привлечения Внимания">КДПВ</abbr>, не имеющая отношения ни к тому ни к другому. Впрочем, само понятие "<a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D0%BE%D0%BA%D0%B5%D1%80">джокера</a>", к предмету сегодняшнего разговора, отношение имеет самое непосредственное.
<cut>
Около месяца назад @ComradMax опубликовал <a href="http://habrahabr.ru/post/261189/">статью</a> о своей дебютной игре под Android (статья, кстати, тоже дебютная). Затронутая тема приятно поразила меня обилием вариантов <a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415">известной всем игры</a>. Про некоторые я знал, другие стали для меня откровением. Сама идея - превратить карточную игру в некое подобие <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%80%D0%BE%D0%BB%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0">RPG</a> взяла меня за живое. К сожалению, AI реализации проявил себя не лучшим образом. Хоть я и не играл в "Дурака" с пятилетнего возраста, я легко обыгрываю программу. Некоторые её ходы просто глупые (надеюсь, что автор на меня не обидится).

Это несоответствие мощи задумки и весьма слабого "интеллекта" реализации и заставило меня задуматься над тем, каким образом должен работать AI подобной игры. Надо сказать, что эта проблема гораздо сложнее, чем кажется на первый взгляд. Карточные игры (и "Дурак" в том числе) относятся к категории игр с неполной информацией. Алгоритмы, применяемые в шахматных программах или программах для игры в Го к ним не подходят. Во всяком случае, в исходном виде.

<h4><b>Сбор данных</b></h4>
Залогом победы является разведка! А основа разведки - тщательный анализ полностью открытых данных. Что нам известно о картах противника, когда мы играем в "Дурака"? Казалось бы немного, карты ведь от нас закрыты? На деле, всё не так плохо. Например, мы знаем какие карты у нас на руках и номинал карты показывающей козырь (если игра идёт с козырем). Это само по себе уже неплохо, но еще лучше наше знание о том, что этих карт нет у противника (это в случае, если игра идёт одной колодой). Попробуем составить полный список источников данных о картах противников, применительно к "Дураку":

<ol>
	<li>Открытые карты (об этом я уже говорил)</li>
	<li>Карты взятые игроками по ходу игры (в том числе те, которыми они пытались неуспешно отбиться)</li>
	<li>Карты вышедшие из игры, в результате отбоя (этот источник менее очевиден, чем предыдущие)</li>
	<li>Карты, побить которые не удалось (это еще менее очевидно и я расскажу об этом ниже)</li>
</ol>
<spoiler title="Ещё один источник">
Программа @ComradMax может получить информацию о картах противника ещё одним забавным образом. Дело в том, что все действия в ней (такие как отбой или взятие карт с колоды) автор постарался реализовать жестами. Это управление достаточно интуитивно, для того, чтобы обходиться без кнопок (хотя кнопки, на всякий случай, тоже есть). Так вот, если взять карту с колоды и "не дотащить" до своих карт, она открывается и противники её "видят". Компьютерные игроки отпускают ехидные замечания, но, со слов автора, AI программы эту информацию пока никак не использует.

В принципе, никто не может помешать компьютеру подсмотреть <b>все</b> карты игрока. Более того, именно по этому пути идут разработчики большинства карточных игр, но этот путь порочен, по своей сути. Игра компьютера, сама по себе, мало напоминает человеческую, а если он "знает" все карты - это ещё больше бросается в глаза. Пользователь может даже не осознать этого, но сыграв десяток партий он охладеет к программе. Я считаю, что стиль игры подобных "развлекательных" программ следует максимально приближать к человекоподобному. Цель не в том, чтобы программа играла максимально сильно. Главное, чтобы она не вызывала отторжения! А вариант AI с "подглядыванием" карт можно использовать для специальных опций, таких как "игра с шуллером".
</spoiler>
Хотя со вторым пунктом всё и так понятно, хочу подчеркнуть, что мы должны учитывать <b>любые</b> известные нам карты, которые берёт противник. Например, в модификации игры "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.92.D0.BE.D0.BB.D1.88.D0.B5.D0.B1.D0.BD.D1.8B.D0.B9">Волшебный</a>", если мы ходим чёрным джокером (к месту всё-таки картинка), то отдаём противнику свои две карты. После этого, мы точно знаем, что эти карты у него есть, до тех пор, пока он от них, каким либо образом, не избавится (мы узнаем об этом). Возможно это не очевидно, но подобное может произойти в тот момент, когда он, в свою очередь, сходит чёрным джокером. Как поступить, в таком случае, будет ясно из дальнейшего повествования.

Начиная с третьей цифры, всё становится чуть сложнее. В общем-то понятно, что AI должен учитывать карты, вышедшие из игры, вопрос в том, как это реализовать технически. Для представления карт на руках противников, можно использовать два типа объектов. Первый - карта с точно известным номиналом (масть + значение), второй - джокер, который, в самом плохом случае (то есть, в начале игры), может быть почти чем угодно. По мере того, как игроки делают ходы, мы получаем всё больше информации о вышедших из игры картах. Вычеркивая эти значения из "джокера" (при таком представлении данных, он один на все неизвестные карты), мы уточняем свои знания о закрытых картах. Когда колода полностью разобрана, мы знаем все карты (не знаем только какие у кого), а когда игроков остаётся двое, мы просто знаем все карты противника!

Четвёртый источник ещё более эфемерный. Допустим, мы ходим под противника, а он берёт карту, даже не попытавшись её побить. Что нам это даёт? Скорее всего ничего (возможно он просто копит карты для своего хода), но можно взять на заметку, что эту масть он берёт и, скорее всего, если сходить тоё-же мастью, но номиналом повыше (ниже ходить резона нет, по понятным причинам), то он и её возьмёт тоже (или наконец возьмётся за козыри). Это означает, что для "джокеров", у него на руках, можно сделать пометку, что они не выше того номинала, картой которого мы сходили (с учётом старшинства козырей). Если мы ошиблись, пометку никогда не поздно снять.

Разумеется, чтобы жизнь совсем уж не казалась нам мёдом, были придуманы разнообразные правила, усложняющие сбор информации. В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D0.BE.D0.BA.D0.B5.D1.80.D0.BD.D1.8B.D0.B9">Покерном</a>" дураке, игрок, перед отбоем, имеет право поменять любые свои две карты на карты из колоды. Фактически, это означает, что нам придётся полностью сбрасывать информацию о точно известных картах игрока. После такого обмена, все его карты превращаются в "джокеров". Исключение можно сделать, разве что, для старших карт в мастях и козырей (вряд ли кто-то в трезвом уме станет их менять).

В дураке "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.A1_.D0.BF.D1.80.D0.B8.D0.BA.D1.83.D0.BF.D0.BE.D0.BC">С прикупом</a>" (есть прикуп в "Дураке", не врал эпиграф), каждому игроку, в начале игры, раздаётся несколько закрытых карт. Игрок берёт эти карты, когда карты в колоде и на руках полностью заканчиваются, после чего, доигрывают игру с ними. Это гораздо более щадящий вариант. Фактически, в финальной стадии игры, он почти ничего не меняет в наших знаниях о раскладе, но лишь обязывает заканчивать игру совершенно случайными картами. Если карты окажутся неудачными, AI вряд ли чем сможет помочь.

Также, на неожиданный финал ориентирован "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D0.BE.D1.82.D0.B0.D0.B9.D0.BD.D0.BE.D0.B9">Потайной</a>" дурак. Под козырь кладётся закрытая карта. Когда козырь (после разбора колоды) забирается одним из игроков, эта карта открывается и показывает новый козырь. В этот момент, всё что было нажито непосильным трудом, в ходе игры (включая вожделенную козырную карту, внизу колоды), вполне может превратиться в пыль. В этой игре, случайность также может перевесить интеллект AI (если только не использовать стратегию игры в "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.91.D0.B5.D1.81.D0.BA.D0.BE.D0.B7.D1.8B.D1.80.D0.BD.D1.8B.D0.B9">Бескозырного</a>" дурака, с набором старших карт во всех мастях).

Пожалуй, самый жёсткий для AI вариант - "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.A7.D1.83.D0.BA.D0.BE.D1.82.D1.81.D0.BA.D0.B8.D0.B9">Чукотский</a>". Сразу после раздачи и открытия козыря, колода (вместе с открытым козырем) удаляется из игры. Игра очень скоротечна и происходит, практически, "в тёмную". AI здесь негде развернуться.

<h4><b>Во всём важна мера</b></h4>
Хорошо, мы собрали данные и, в какой-то мере, знаем, что за карты на руках у противника. Мы можем вычислить вероятность того, что противник <b>может</b> успешно отбиться от нашего захода (это не значит, что он будет это делать), но этого мало! Мы всё ещё не можем "взять и просто использовать" <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BA%D1%81">минимаксный</a> алгоритм с <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0-%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">альфа-бета отсечением</a>. Необходима количественная оценка позиции. Как вы уже догадываетесь, в разных "дураках" она будет разная.

Для того, чтобы понять, насколько хороши карты на руках, мы можем, для каждой из них, определить количество карт (находящихся в игре), способных её побить (это не единственно возможный подход, но мне он представляется наиболее перспективным). Проще всего дело обстоит с "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.91.D0.B5.D0.B7.D0.BC.D0.B0.D1.81.D1.82.D0.BD.D1.8B.D0.B9">Безмастным</a>" вариантом. Выстраиваем карты по ранжиру (без учёта масти) и подсчитываем количество тех, что старше (из тех, что ещё в игре, разумеется). В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.91.D0.B5.D1.81.D0.BA.D0.BE.D0.B7.D1.8B.D1.80.D0.BD.D1.8B.D0.B9">Безкозырном</a>" этих "ранжиров" будет уже четыре (по количеству мастей), а в наиболее распространённом "Козырном" варианте, цепочка козырей будет покрывать каждую из мастей.

Существуют и более заковыристые варианты. В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.94.D0.B2.D1.83.D1.85.D0.BA.D0.BE.D0.B7.D1.8B.D1.80.D0.BD.D0.BE.D0.B9">Двухкозырном</a>" дураке каждый из игроков объявляет свой козырь. По договорённости, козыри одного игрока необходимо бить либо той-же мастью либо, дополнительно, ещё и своими козырями. В результате, оценочные функции, применяемые для игроков, будут различными, но, разумеется, неизменными от одного хода к другому (иначе весь минимакс полетит к чёрту).

<spoiler title="Небольшое разъяснение">
Вообще говоря, даже при наличии хорошей оценочной функции, применить альфа-бета отсечение мешают ещё два обстоятельства. Во первых, все эти минимаксные штуки рассчитаны на игру двух игроков. Оценочная функция строится таким образом, что из оценки состояния игрока, вычитается оценка состояния его противника. Если мы вычисляем оценку той-же позиции, но с точки зрения противника - знак изменяется, но абсолютное значение остаётся тем же (и это важно для работы алгоритма). В случае "Дурака", игра двух человек - скорее исключение чем правило. Впрочем, можно вывернуться и считать всех противостоящих игроков одним единым противником (нас ведь интересует худший вариант их совместного поведения). В случае же игры "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#2x2">2x2</a>", противостоящими игроками следует считать пары.

Другим открытым вопросом остаются "джокеры" на руках противников, номинал которых нам известен лишь приблизительно. Здесь сложно предложить удовлетворительное решение. Можно усреднять номиналы тех карт, которые может представлять "джокер", но требуются эксперименты, чтобы определить, насколько этот подход хорош.
</spoiler>
"<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.94.D0.B2.D0.BE.D0.B9.D0.BD.D0.BE.D0.B9">Двойной</a>", "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9A.D0.BE.D1.80.D0.BE.D0.BB.D0.B5.D0.B2.D1.81.D0.BA.D0.B8.D0.B9">Королевский</a>" и "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.94.D0.B8.D0.BA.D0.B8.D0.B9">Дикий</a>" варианты игры также требуют специального построения оценочных функций, но предложенный выше подход вполне работает и в их случае.

<h4><b>Битва за кормушку</b></h4>
Какой стратегии следует придерживаться при игре в "Дурака"? В первую очередь, это зависит от фазы игры. В наиболее распространённом варианте, можно выделить три основных фазы:

<ol>
	<li>Начальная</li>
	<li>Промежуточная</li>
	<li>Финальная</li>
</ol>
Первая фаза самая длительная. Пока колода не разобрана, основная задача игрока (кроме сбора данных) - накопление на руках старших карт (особенно козырей). Это означает, что следует ходить так, чтобы избавиться от как можно большего количества младших карт (для того, чтобы взять соответствующее количество карт с колоды). Противников следует от колоды оттеснять, следя за тем, чтобы они не испытывали недостатка в картах на руках.

Если на руках большое количество старших карт, их следует экономить. Часто выгоднее взять карты (тем самым сэкономив свои старшие карты), даже если есть возможность отбиться. Взятые карты можно будет впоследствии отдать или подкинуть (особенно если взятая карта приходит в пару или тройку к картам другой масти), а с учётом того, что старшие карты уже у нас на руках, вероятность того, что противники найдут в колоде что-то ценное, мала. 

В какой-то момент карт в колоде остаётся так мало, что они будут полностью выбраны перед следующим ходом. Эту мимолётную фазу игры сложно заметить человеку, но она может быть очень важна. В первую очередь, на этом ходу, следует заботиться о том, чтобы забрать себе не полный комплект карт. Вторая цель - открытая карта козыря внизу колоды (если там лежит туз или король, за него стоит побороться). Помимо открытого козыря, целью борьбы могут быть и последние карты колоды. Про них известно меньше, но в некоторых случаях, можно с высокой вероятностью предсказать там наличие крупных карт.

Из всего сказанного следует, что AI следует постараться, чтобы ход, после которого вся колода разбирается, приходился на его отбой (отбивающийся берёт карты последним), но при этом в колоде оставалось бы достаточное количество карт, чтобы успеть взять козыря. Если карт в колоде мало, AI может быть выгодно быть одним из подкидывающих (тем, кто заберёт последние карты). Это головоломная задача, но для компьютера вполне посильная, поскольку точное число карт, оставшихся в колоде, ему известно в любой момент игры.

Когда колода разобрана и карта, показывающая козырь, взята, наступает финальная стадия игры. Единственная цель игрока, в этой фазе игры - как можно скорее избавиться от всех своих карт. Частным (но очень важным) случаем оказывается ситуация, когда игроков остаётся двое. В этом случае, карты на руках противника точно известны (если речь не идёт о "Чукотском" варианте) и можно распланировать последовательность своих ходов так, чтобы противник не мог отбиться ни на каком ходу кроме последнего. Если это невозможно, следует отбиваться таким образом, чтобы противник не имел возможности подкидывать свои карты.

Разумеется, народная мудрость и здесь изыскала способы, сделать нашу жизнь интереснее. В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9E.D1.82.D0.B1.D0.BE.D0.B9.D0.BD.D1.8B.D0.B9">Отбойном</a>" дураке каждый второй отбой идёт в колоду, что усложняет игру, но даёт "второй" шанс заполучить хорошие карты. В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D1.83.D1.81.D1.82.D0.BE.D0.B9">Пустом</a>" карты берутся лишь тогда, когда рука полностью опустеет (при таком подходе, сохранить до конца игры козыри, полученные при первоначальном раскладе вряд ли удастся). В варианте "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.92.D1.82.D0.BE.D1.80.D0.B0.D1.8F_.D0.BF.D0.BE.D0.BF.D1.8B.D1.82.D0.BA.D0.B0">Вторая попытка</a>", игрок, которому не удаётся побить карту, может попытаться отбиться картой взятой с колоды, а в "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.90.D1.80.D0.BC.D1.8F.D0.BD.D1.81.D0.BA.D0.B8.D0.B9">Армянском</a>" дураке может брать карту с колоды для своего захода (эти варианты можно <a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.90.D1.80.D0.BC.D1.8F.D0.BD.D1.81.D0.BA.D0.B8.D0.B9-.D0.92.D1.82.D0.BE.D1.80.D0.B0.D1.8F_.D0.BF.D0.BE.D0.BF.D1.8B.D1.82.D0.BA.D0.B0">комбинировать</a>). Наконец в "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9D.D0.B0.D0.B2.D0.B0.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9">Наваленном</a>" колода просто делится между всеми игроками, после чего всякая борьба за колоду оказывается исключена, ввиду отсутствия таковой. С Дураком не соскучишься!

<h4><b>Враг моего врага</b></h4>
Итак, со стратегическими целями всё ясно (требуется накапливать крупные карты), но как этого добиться? В наиболее распространённом "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D0.BE.D0.B4.D0.BA.D0.B8.D0.B4.D0.BD.D0.BE.D0.B9">Подкидном</a>" дураке (и в "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D0.B5.D1.80.D0.B5.D0.B2.D0.BE.D0.B4.D0.BD.D0.BE.D0.B9">Переводном</a>" тоже, если речь идёт не про "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.91.D0.B5.D1.81.D0.BF.D0.BE.D0.B4.D0.BA.D0.B8.D0.B4.D0.BD.D1.8B.D0.B9">Бесподкидный</a>") имеется великолепная тактическая возможность. Подкидывая отбивающемуся игроку карты, можно добиться того, чтобы он их взял (или растратил всех своих козырей). Есть ряд ограничений, касающихся этой возможности, например нельзя подкидывать больше карт чем есть на руках отбивающегося и, как правило, первым подкидывает тот, кто ходил, но, всё равно, "подкидывание" карт - это великолепная возможность изменить ход игры.

Осталось определиться с тем, кому подкидывать карты. В игре двух игроков всё понятно - мелкие карты следует подкидывать при любой возможности, крупные (особенно козыри) - лишь в редких случаях (например, когда идёт борьба за последние карты колоды). Если играют трое (наиболее распространённый случай), всё становится интереснее. Противник, ходящий под игрока, очевидно является его естественным врагом, но тот, под кого ходит сам игрок, до некоторой степени, его союзник! Невыгодно "топить" его, подкидывая ему карты или выполняя ход крупной картой (это, в любом случае, не самая удачная мысль), поскольку, если он не отобьётся - следующий ход будет уже под нас. 

Игроку слева (ход передаётся по часовой стрелке) следует дать легко отбиться, после чего поддержать его ход, по возможности вынудив отбивающегося забрать карты. По аналогии с преферансной поговоркой из эпиграфа, тот, под кого ходим мы - "игрок", а тот, кто ходит под нас - "вистующий". При игре четырёх игроков (или шести, что совсем уж редко), естественным образом формируются две "коалиции" (даже если формально игра не идёт "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#2x2">2x2</a>"). Игроки, сидящие друг на против друга - союзники (по крайней мере, пока количество игроков, оставшихся в игре, не уменьшится).

Все наши прекрасные планы, как обычно, вдребезги разбиваются "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.94.D0.BE.D0.B1.D1.80.D1.8B.D0.B9">Добрым</a>" дураком. В этом варианте игры, не имеет значения, кому подкидывать карты, поскольку, даже если игрок не сможет отбиться, следующим ходить будет всё равно он! В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9F.D1.80.D0.B8.D0.B1.D0.B0.D0.BB.D1.82.D0.B8.D0.B9.D1.81.D0.BA.D0.B8.D0.B9">Прибалтийском</a>" же дураке сам процесс отбоя может легко перерасти в контратаку (но, пожалуй, это слишком уж экзотический вариант игры, во всяком случае, не очень понятно, как играть по этим правилам трём и более игрокам).

<h4><b>Конец - делу венец</b></h4>
Как я уже говорил, когда колода полностью разобрана и все карты на руках, единственная задача игрока - поскорее от них избавиться. И здесь становится важна не столько сила карт, сколько их количество. В самом деле, если игрок остался на своём ходу с одной, пусть даже самой младшей картой (или с парой карт одного ранга) - он уже выиграл. Сильные карты нужны лишь для успешного отбоя (и очень желательно, чтобы после этого отбоя у противника ещё оставались карты). Если играют два игрока (и если не используются специальные правила, скрывающие информацию до последнего) выигрышную последовательность ходов можно просто просчитать полным перебором (все карты на руках известны и возможных вариантов не очень много). При этом, можно даже приберечь пару шестёрок для последнего хода, чтобы одеть "погоны" на проигравшего.

Если игроков больше двух, карты оставшиеся в игре также известны, но нет информации о том у кого из игроков какие. Если нет возможности сразу отдать карты своим ходом (или сбросить все мелкие карты, оставив козырей для последнего отбоя), следует придерживаться той же тактики, что и в основной фазе игры - ходить мелкими картами, подкидывать игроку справа покрупнее, беречь козыри. Рано или поздно игроков останется двое (и если вам не повезёт - вы будете одним из них). В этот момент станет ясно, кто победил, поскольку скрытой информации в игре не останется.

Есть несколько разновидностей "Дурака", позволяющих поскорее избавляться от своих карт. Например, в "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.90.D0.BC.D0.B5.D1.80.D0.B8.D0.BA.D0.B0.D0.BD.D1.81.D0.BA.D0.B8.D0.B9">Американском</a>" можно подкидывать карты самому себе, на своём отбое, и покрывать их (после того как подкинули все остальные игроки). В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.A5.D0.B8.D1.82.D1.80.D1.8B.D0.B9">Хитром</a>" дураке, если игрок не смог побить одну или несколько карт, то тот участник игры, из за которого не удалось отбиться, может побить эти карты из "своих запасов". В результате, он избавляется от лишних карт, а тот игрок, что не смог отбиться - забирает дополнительные карты. В "<a href="https://ru.wikipedia.org/w/index.php?title=%D0%94%D1%83%D1%80%D0%B0%D0%BA_%28%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%B8%D0%B3%D1%80%D0%B0%29&diff=67639377&oldid=67377415#.D0.9D.D0.B0.D0.B3.D0.BB.D1.8B.D0.B9">Наглом</a>" дураке, побить свою карту таким образом можно ещё до того как подкинуть её сопернику. Разумеется, если правила предоставляют такие возможности избавления от своих карт, их надо всячески использовать.

Конечно, моя статья не претендует ни на сколь нибудь подробное описание всех существующих правил игры ни на формальное описание алгоритмов AI для неё. Это всего лишь разрозненные мысли, которыми я обещал поделиться с уважаемым @ComradMax до отпуска. Надеюсь, что они будут ему полезны.
</cut>

Манкала — время разбрасывать камни

<img align="left" src="https://habrastorage.org/files/f95/5e7/3e9/f955e73e922d400e9137b2654f5ae000.PNG"/><i><b>Всему свой час, и время всякому делу под небесами ...
Время разбрасывать камни и время складывать камни, 
Время обнимать и время избегать объятий,
Время отыскивать и время дать потеряться,
Время хранить и время тратить...

"<a href="http://lib.ru/HRISTIAN/ekkleziast.txt">Книга Экклезиаста</a>"</b></i>&nbsp;

Если проводить аналогию с эволюцией животного мира, игры семейства <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D0%BA%D0%B0%D0%BB%D0%B0">Манкалы</a> представляют из себя динозавров. Они царили на планете, когда Шахмат не было даже в проекте! Очень сложно установить их возраст, поскольку, зачастую, для игры не требуется каких либо особенных материальных артефактов. Достаточно выкопать ямки в земле да взять горсть камушков. В отличии от динозавров, Манкала, в добром здравии, дожила до наших дней, сохранив всё своё удивительное многообразие. Добро пожаловать в "Парк юрского периода" настольных игр.
<cut>
Существует невероятное количество вариантов этой игры. В одной только Западной Африке насчитывается <a href="http://skyruk.livejournal.com/410114.html">более 20</a> разновидностей двухрядной манкалы (а есть ещё трёх- и четырёхрядные). Все эти игры объединяет общий принцип выполнения хода - "правило посева". "Посев" выполняется следующим образом: игрок берёт <b>все</b> камни из какой либо лунки и начинает раскладывать <b>по одному</b> в выбранном направлении, не пропуская ни одной лунки. Вот как выглядит типичная доска двухрядной манкалы:

<img align="center" src="https://habrastorage.org/files/58d/031/0e7/58d0310e7f11404b831436dc4694655d.jpg"/>
На доске расположены два ряда лунок. Количество лунок в ряду и начальное количество камней в лунках зависят от игры. Две лунки большого размера называются "амбарами" (они используются не во всех играх). Цель игры - накопить в своём амбаре (расположенном с правой стороны) больше камней, чем у противника. А вот попадать в амбар камни могут по разному.

Прежде всего, в играх может различаться направление "посева". В большинстве игр, посев осуществляется против часовой стрелки, но имеются и <a href="http://skyruk.livejournal.com/413629.html">исключения</a>. Также, существуют игры (<a href="http://skyruk.livejournal.com/396115.html">Бечи</a>, <a href="http://skyruk.livejournal.com/390575.html">Алемунгула</a>), в которых направление посева определяется стартовой лункой. Если лунка расположена ближе к левому краю - посев идёт по часовой стрелке, из лунок, расположенных справа - против часовой (в общем, посев всегда идёт сначала в сторону противника, а потом уже возвращается к своим лункам). На "нечётных" досках, при ходе из средней лунки, игрок может выбирать направление посева.

<spoiler title="Кстати о вечном">
В игре "Алемунгула" имеется любопытный аналог правила <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BA%D0%BE">Ко</a>, запрещающего повторение позиции в игре <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>. Дело в том, что ход одиночным камнем, в следующую по направлению движения лунку, является, по правилам этой игры, совершенно законным. Если одиночный камень расположен в крайней левой (или правой) лунке, а лунка напротив него пуста, игроки могут перекидывать этот камень друг другу до бесконечности. Правило "пинг-понга" запрещает это. Впрочем, до "суперко" в манкалах дело не доходит (если не рассматривать правила, касающиеся "бесконечного посева").
</spoiler>
При достаточном количестве камней, посев может вернуться к стартовой лунке (и пойти на второй круг). В большинстве игр, в стартовую лунку, при её прохождении, также кладётся камень, но есть и такие, в которых стартовая лунка пропускается (<a href="http://skyruk.livejournal.com/413629.html">Сонго</a>), что несколько усложняет расчёт  ходов. Также, встречаются игры, в которых посев начинается не со следующей, а со стартовой лунки (то есть, один камень остаётся в ней). В таких играх как <a href="http://skyruk.livejournal.com/401206.html">Моди</a>, подобная схема посева приводит к естественному запрету хода одиночным камнем, но в <a href="http://skyruk.livejournal.com/406732.html">Тогыз кумалак</a>, например, ход одиночным камнем вполне допускается (камень перекладывается в следующую лунку). Это правило может сильно запутать неопытного игрока.

<spoiler title="Размер - не главное">
Игра "Моди" с её доской 2x3 не является самой маленькой манкалой. Такой же размер доски (но совершенно другие правила) используется в малом <a href="http://skyruk.livejournal.com/396115.html">Бечи</a>, а в берберской игре "<a href="http://skyruk.livejournal.com/2015/07/18/">Urar n kkuz imrujen</a>" используется ещё меньшая по размерам доска 2x2 (при этом, в игре участвует 28 камней).
</spoiler>
Чтобы сделать жизнь ещё интересней, в некоторых играх (<a href="http://skyruk.livejournal.com/468202.html">Абаво</a>, <a href="http://skyruk.livejournal.com/410114.html">Сокусово</a>) используется "циклический" посев. Если последний камень падает в непустую лунку, все камни из неё забираются и используются для посева, начиная со следующей лунки. В Гиути используется ещё более сложная, реверсивная, схема. Направление, в каждом раунде посева, меняется на противоположное. Подобная механика усложняет расчёт хода и, до некоторой степени, выравнивает шансы слабых игроков, при игре с более сильным противником. 

<spoiler title="На радость гикам">
Возможно, именно эта схема посева натолкнула многочисленных энтузиастов на идею кросс-манкал. Идея проста. Берётся практически любая манкала, например <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=226">Kalah</a> или <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=228">Wari</a>, после чего в правила вносится "небольшое" дополнение. Направление посева в таких играх зависит от начального количества камней в стартовой лунке. Если оно чётно - посев идёт по часовой стрелке, в противном случае - против часовой. Это адски усложняет расчёт ходов, но гикам <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=232">того</a> и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=231">надо</a>.
</spoiler>
Не менее разнообразны способы взятия, при помощи которых игроки пополняют свои амбары. В игре <a href="http://skyruk.livejournal.com/228552.html">Калах</a>, известной многим ещё со времён СССР, взятие позиционное - если последний камень посева попал в пустую лунку в своём ряду, а лунка напротив неё не пуста, все камни из неё забираются. Но это не единственный источник "дохода" в Калахе! Выполняя посев, игрок пропускает "амбар" противника, но кладёт по одному камню, каждый раз, проходя свой амбар (именно по этой причине, амбары должны присутствовать на доске). Если последний камень посева попадает в амбар, игрок делает ещё один ход.

Совершенно иным способом осуществляется взятие в <a href="http://skyruk.livejournal.com/228552.html">Оваре</a>. Во время посева, оба амбара пропускаются (обычно их нет на доске). Если последний камень попадает в лунку противника, количество камней в которой становится равно 2 или 3 - камни забираются. Кроме того, выполняется "серийное взятие". Если в предыдущей лунке противника также оказывается 2 или 3 камня, они тоже забираются и так далее, пока по направлению движения, противоположном направлению посева, не встретится лунка, не удовлетворяющая условию.

Дальнейшим развитием этой идеи можно считать промежуточное взятие, применяемое в <a href="http://skyruk.livejournal.com/468202.html">Абаво и Айо-айо</a>. В этих играх, камни захватываются, не прерывая циклического посева. Как только в лунке образовалось 4 камня, они сразу перемещаются в амбар, причём, если в Айо-айо захват всегда осуществляется игроком, выполняющим посев, то в Абаво камни получает тот игрок, на стороне которого расположена лунка (независимо от того, кто выполняет посев).Это делает игру ещё более интересной, поскольку, выполняя ход, приходится заботится не только о том, как взять больше камней себе, но и о том, как дать меньше камней противнику. Более "взрослый" вариант <a href="http://skyruk.livejournal.com/468202.html">Аньиволи</a> играется на доске 2x12 и представляет собой, своего рода, гибрид этих двух игр. Промежуточное взятие выполняется также как в Абаво, но если 4 камня образует последний камень посева, их забирает игрок, выполнявший посев (как в Айо-айо), независимо от того, на чьей стороне расположена лунка. Похожая система промежуточного взятия используется и в индийской игре <a href="http://skyruk.livejournal.com/467755.html">Палланкужи</a>.

<img align="center" src="https://habrastorage.org/files/249/780/a1e/249780a1e404429eb54e771d697d0122.jpg"/>
Ещё дальше развивает идею промежуточного взятия казахский <a href="http://skyruk.livejournal.com/406732.html">Тогыз кумалак</a>, который я упоминал выше, в связи с сложным комбинированным посевом. Эта вообще довольно интересная и прогрессивная манкала. Посев в ней однократный и если последний камень дополняет лунку противника до чётного числа камней, они забираются в амбар, но, помимо этого, в игре имеется возможность выполнения промежуточного взятия. Если, по завершении посева, в последней лунке, на стороне противника, образуется 3 камня - можно объявить "туздык" (святое место). Камни из этой лунки переносятся в амбар, как и все камни, попадающие в неё в дальнейшем. На объявление "туздыка" наложен целый ряд ограничений (его нельзя заводить напротив "туздыка" противника, в 9-ой лунке, игрок не может завести 2 "туздыка" одновременно), но сама эта возможность вносит в игру важную стратегическую составляющую.

В играх <a href="http://skyruk.livejournal.com/470951.html">Сулус и Ламе</a> ограничений на количество создаваемых ловушек нет. Ловушкой становится лунка, в которой оказывается 4 камня, после попадания в неё последнего камня посева (циклический посев при этом прерывается). Ловушка создаётся на стороне противника, но если в Сулус-айди она принадлежит игроку, выполнившему посев, то в Ламе и Сулус-ништав её владельцем становится  противник (создаёт ловушки один игрок, а другой пользуется ими). В этих трёх играх, ловушки "вегу" используются исключительно для накопления камней, ходить из них запрещено. В более архаичном "<a href="http://skyruk.livejournal.com/470951.html">Селус</a>", при определённых условиях, камни из ловушек могут изыматься. Опустевшая "вегу" теряет свой статус.

<spoiler title="Два или три?">
Селус, Сулус, Ламе - все эти игры играют на очень редко используемой трёхрядной доске, но камни раскладываются таким образом, что с тем же успехом можно было бы использовать и двурядную 2x9 доску:

<img align="center" src="https://habrastorage.org/files/6de/e6e/780/6dee6e78038e4c55a006035810106c29.jpg"/>
Неужели дело просто в большей компактности доски 3x6? Конечно же нет! На той же доске играют и в другую игру, в которой трёхрядность имеет значение. В игре "<a href="http://skyruk.livejournal.com/228552.html">Габата</a>" используется та же схема циклического посева, но механизм взятия другой. Когда последний камень попадает в пустую лунку, игрок забирает все камни из двух других лунок того же столбца. Возможно, Габата является переходной формой от двух- к четырёхрядным манкалам.
</spoiler>
К сожалению, построить ловушки из начальной расстановки в Сулус слишком легко. Для того, чтобы справиться с этим недостатком, используется "нулевой посев", во время которого взятия и создание ловушек запрещены (это правило используется и в других разновидностях манкалы). В Сулус-ништав, на первом ходу, каждому из игроков запрещено создавать "вегу", но, в Сулус-айди, первый циклический посев игроки выполняют одновременно! Учитывая то, что траектории посева пересекаются, происходит своеобразный "<a href="https://en.wikipedia.org/wiki/Race_condition">Race condition</a>", нарушающий детерминизм исходного расклада. Тот игрок, у которого посев завершается раньше, начинает игру, делая следующий ход.

Коль скоро речь зашла о детерминизме, нельзя не вспомнить о ещё одной любопытной  игре. <a href="http://skyruk.livejournal.com/401512.html">La'b madjnuni</a> называют "игрой безумцев" (или "игрой мудрецов", как кому больше нравится), по той причине, что игроки <b>не имеют</b> в ней возможности выбора. Это игра на доске 2x7 с цикличным посевом против часовой стрелки. Каждый игрок <b>всегда</b> начинает посев с крайней правой лунки (голова "el ras"). Если "голова" пуста, камни берутся из следующей (по ходу движения) лунки, но свободы выбора нет! Взятие серийное - если последний камень дополняет лунку до 2 или 4 камней, камни из этой лунки (и из последующих, содержащих по 2 или 4 камня) забираются игроком. Первоначальный расклад готовится одним из игроков, но шансы второго игрока уравнивает "правило пирога" - если ему не понравится расклад, он может развернуть доску. После этого, результат игры предопределён (это если не жульничать), но что такое результат, по сравнению с самим процессом?

<spoiler title="Игра для одного">
Для многих настольных игр (особенно для карт) существуют варианты игры, рассчитанные на одного человека - <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D1%8C%D1%8F%D0%BD%D1%81">пасьянсы</a>. Манкала не является исключением. <a href="http://skyruk.livejournal.com/311958.html">Чука Рума</a> - разновидность однорядной манкалы, впервые описанная в 1895 году в переписке французского математика Анри-Огюста Деланнуа с его коллегой Эдуардом Лукасом.

<img align="center" src="https://habrastorage.org/files/0d9/feb/904/0d9feb9049e54506ab87675f7d8aaf10.PNG"/>
Правила просты - игрок берёт все камни из любой лунки и раскладывает их по одному, слева-направо, не пропуская ни одной лунки (включая амбар). Посев циклический - если последний камень упал в непустую лунку, все камни из неё забираются и посев продолжается со следующей лунки. Если последний камень посева упал в амбар, игрок может использовать, для продолжения посева, любую лунку. Если последний камень упал в пустую лунку - пасьянс не сошелся. Помимо простого (с раскладкой по два камня на лунку), существует более сложный вариант этой игры (с шестью камнями в каждой лунке). Также может использоваться семилуночная доска, с раскладкой по 4 камня в каждую лунку.
</spoiler>
Существуют и более сложные двухрядные манкалы. В <a href="http://skyruk.livejournal.com/413629.html">Сонго</a>, например, используется очень запутанная схема посева, а в <a href="http://www.iggamecenter.com/info/ru/kauri.html">Каури</a> - два типа камней. Что касается <a href="http://skyruk.livejournal.com/408356.html">Реду</a>, то есть мнение, что её придумали инопланетяне. Это, вообще, похоже самая сложная двухрядная манкала, но, на мой взгляд, более всего в ней интересно наличие элементов "дипломатии". В некоторых случаях, взятие камней игроком не обязательно, но противник может заставить взять камни (и завершить тем самым ход). Право требования взятия переходит другому игроку (его нельзя использовать два раза подряд). <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрий Скирюк</a> приводит видео, на котором, скорее всего, играют в Реду, но, даже ознакомившись с правилами, разобраться в том, что происходит на доске, совсем не просто:

<spoiler title="Видео">
<video>http://www.youtube.com/watch?v=QJ2FO6xTsH4</video>
</spoiler>
Среди двурядных манкал есть совершенно уникальная игра, не похожая ни на одну другую. В <a href="http://skyruk.livejournal.com/396880.html">Охочичи</a> всё "не так". Доска (2x6) в ней развёрнута на 90 градусов (концами к игрокам), а посев никогда не заходит на территорию противника. Посев однократный и если последний камень дополняет лунку до 4 камней, камни забираются. Если в предыдущей лунке также 4 камня, забираются и они и так далее (взятие серийное). Взятые камни перекладываются в любую из лунок противника (разумно выбирая лунку, можно разрушить все его планы). Цель игры также необычна - требуется избавиться от всех камней на своей территории. Вот видео, которое поможет разобраться в правилах (эта игра проще предыдущей):

<spoiler title="Видео">
<video>http://www.youtube.com/watch?v=yrcp6lAcFMo</video>
</spoiler>
Охочичи "перебрасывает мостик" к семейству четырёхрядной манкалы, типичным представителем которого является <a href="http://skyruk.livejournal.com/404275.html">Тшуба</a>. Для этой игры, распростраённой на юге Африки, могут использоваться доски 4x4, 4х8, 4x10, 4x16, 4x22. Никогда не используется доска 4x6. Посев циклический, против часовой стрелки, выполняется лишь на своей территории (в двух ближних к игроку рядах). Можно начинать ход одиночным камнем. Если последний камень падает в пустую лунку во внутреннем ряду и напротив него (у соперника) есть камни - они забираются. Также забираются камни противника из внешнего ряда, в том же столбце (если они есть). Одиночный камень во внешнем ряду не забирается. Далее следует бонусное взятие - игрок может забрать камни противника из любой лунки (этим правилом игра напоминает <a href="http://skyruk.livejournal.com/250752.html">Йотай</a>).

<img align="center" src="https://habrastorage.org/files/f62/7af/f3f/f627aff3f100401c958b73b89fb5c9b2.png"/>
Разновидностей четырёхрядной манкалы, также как и двурядной, довольно <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1004">много</a>. Все эти игры (такие как <a href="http://skyruk.livejournal.com/308650.html">Бао, Омвесо и Игисоро</a>) объединены тем, что "посев" всегда ведётся на своей территории (в двух обращённых к игроку рядах), не заходя на территорию противника. Правила игр могут существенно различаться. Самой сложной игрой этого семейства считается "<a href="http://skyruk.livejournal.com/390109.html">Бао-суахили</a>", хорошо описанная Дмитрием Скирюком. Я не буду пересказывать правила этой игры (лучше чем у него, у меня всё равно не получится), вот <a href="http://www.baogame.com">здесь</a> в неё можно поиграть.

Разумеется, я не мог завершить свой рассказ, не попытавшись разработать собственную макнкалу. Для игры я взял распространённые варианты доски четырёхрядной манкалы, но сам игровой процесс мне хотелось сделать особенным. В обычной манкале используется одно или два направления посева. Я решил, что у меня их будет восемь. Поскольку для манкалы очень важно, чтобы посев выполнялся по замкнутой траектории, доску было решено "склеить" в <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%80_%28%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%BE%D1%81%D1%82%D1%8C%29">тор</a>. В начале игры, лунки заполняются случайным образом. Посев циклический, если последняя лунка не пуста, следует продолжить посев, возможно изменив направление.

С посевом разобрались, но как брать камни? Первое, что пришло в голову - по завершении посева в пустой лунке, брать все камни из следующей (если они там есть). Независимо от результата посева, по его завершении, ход переходит следующему игроку (в эту игру могут играть и более двух человек). Поскольку я находился под впечатлением "стратегических" манкал семейства <a href="http://skyruk.livejournal.com/470951.html">Селус</a>, "ловушки" я решил сделать тоже. Если последний камень посева падает в лунку с тремя камнями - посев прерывается и образуется ловушка.

Ловушек на доске может быть сколько угодно, но каждая из них закреплена за определённым игроком. Другой игрок не может каким либо образом разрушить ловушку или взять из неё камни. Эти камни всё равно что находятся в амбаре игрока, но владелец (и только он) может вернуть их в игру (разрушив ловушку) или забрать камни в амбар обычным образом. Такая трактовка ловушек делает их похожими на "гиены" из "<a href="http://skyruk.livejournal.com/2015/07/18/">Tihulelin Ti-n Äzgag</a>". В моём варианте манкалы, ловушки останавливают любой посев. Все "недосеянные" камни попадают в ловушку и посев завершается. Впрочем, у меня есть некоторые сомнения в играбельности этого варианта, поэтому я сделал варианты и со слабыми (не прерывающими посев) ловушками тоже. Вот видео, в котором я постарался показать особенности правил:

<spoiler title="Видео">
<video>http://www.youtube.com/watch?v=22UnPEKJ1mQ</video>
</spoiler>
В общем, на мой взгляд, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2398">получилось</a> неплохо. К сожалению, AI пока работает не слишком хорошо (можно сказать совсем не работает), так что это скорее концепт, чем законченная игра. Впрочем, я буду думать как это исправить. Код проекта доступен на <a href="https://github.com/GlukKazan/ZoG/tree/master/Axiom/AbstractMancala">GitHub</a>.
</cut>

ФВП спешат на помощь

<img align="left" src="https://habrastorage.org/files/2a4/61e/ed7/2a461eed7238486cb288a6666020cb5e.PNG"/>Эта статья о том, как элементы функционального программирования помогают в реальной жизни. Таких статей на Хабре <a href="http://habrahabr.ru/search/?q=%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">много</a>, но, насколько я помню, про <a href="http://habrahabr.ru/hub/forth/">Forth</a>, на эту тему, ещё никто не писал. Кроме того, я не собираюсь разводить по этому поводу теорию (теоретик из меня ещё тот). Я расскажу о сугубо практической задаче, с которой столкнулся буквально вчера. Надеюсь, мой рассказ будет интересен.
&nbsp;
<habracut>
Строго говоря, речь пойдёт не о <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Forth</a>-е, а о его специализированном диалекте ForthScript, разработанном Грегом Шмидтом, в рамках его проекта <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a>, для описания настольных игр. Я уже довольно давно пользуюсь этим продуктом и успел разработать <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?searchauthor=498">несколько игр</a> с его помощью. В настоящее время, я работаю над очень интересной, на мой взгляд, <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">игрой</a>, чем-то напоминающей <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>. Я уже упоминал о ней в <a href="http://habrahabr.ru/post/259611/">предыдущей статье</a>. Выглядеть она будет приблизительно так:

<img align="center" src="https://habrastorage.org/files/8c7/e7d/42d/8c7e7d42d5ea49bbbabe9523101cd608.png"/>

Отображение имён полей включено специально. Дело в том, что платформа <a href="http://www.zillions-of-games.com/">Zillions of Games</a>, на которой ведётся разработка, не позволяет размещать фигуры "с наложением" друг на друга. Каждая "фигура" здесь составлена из 4 частей - тайлов. Понимание этого факта крайне важно для последующего изложения. Доска становится в 4 раза больше, а код сложнее (ZSG-нотация становится совершенно нечитаемой), но результат определённо того стоит.

Как легко догадаться, доска в этой игре трёхмерная. Для варианта игры 7x7 проще всего хранить состояние 14x14x7 = 1372 позиций. В ZRF с этим не возникает проблем (этот язык позволяет определять многомерные доски), но, к сожалению, у меня возникла проблема с самим ZRF. Алгоритмы удаления фигур, при выполнении хода в Margo, слишком сложны для этого языка. Кроме того, AI ZoG наверняка не справится с этой игрой. Используя Axiom я стараюсь убить сразу двух этих зайцев. Увы, Axiom приносит с собой новые проблемы. В частности, этот продукт не позволяет определять трёхмерные доски:

<spoiler title="Наивное определение доски в Axiom">
<source>
7		 CONSTANT	DIM
DIM 2 *		 CONSTANT	COLS
COLS DIM * 	 CONSTANT	ROWS

{board
	ROWS COLS	{grid}
board}
</source>
</spoiler>
Легко заметить, что здесь определяется двумерная доска. Слои третьего измерения просто "выкладываются" друг за другом по координате Y. На самом деле, Axiom определяет одномерный массив, руководствуясь следующей схемой:

<img align="center" src="https://habrastorage.org/files/df9/a0e/c9c/df9a0ec9cc8e4b0aade3a5ca3f2c5b6c.png"/>
Поля доски нумеруются сверху-вниз слева-направо. Кроме того, автоматически создаются константы, используемые для именования полей, по аналогии с шахматной доской. Для доски 8x7, показанной выше, нет никакой разницы будет ли использоваться в коде имя позиции <b>a2</b> или соответствующее её числовое значение (часто это бывает удобно). Допускается определение каждой позиции вручную, без использования <b>grid</b>, но я боюсь себе даже представить объём такого описания для доски 14x14x7 и, что самое главное, время его загрузки.

Конструкция <b>grid</b> обеспечивает ещё одну крайне полезную возможность. В игре для нас важны не только сами позиции, но и связи между ними. При использовании конструкции <b>grid</b>, направления, определяющие эти связи, могут быть заданы простым приращением координат:

<spoiler title="Определение направлений">
<source>
COLS         CONSTANT	DDIR
DDIR NEGATE  CONSTANT	UDIR

{directions
	-1	  0	{direction} n
	 1	  0	{direction} s
	 0	  1	{direction} e
	 0	 -1	{direction} w
	-1	 -1	{direction} nw
	 1	 -1	{direction} sw
	-1	  1	{direction} ne
	 1	  1	{direction} se
	 DDIR 0	{direction} down
	 UDIR 0	{direction} up
directions}
</source>
</spoiler>
Традиционно, для имён направлений используются одно- и двухбуквенные обозначения по наименованиям сторон света. Имея определения направлений, можно легко написать следующий код (управляющий перемещением фигуры на север):

<source>
: move-to-north ( -- )
	n verify		( Переместиться на север, если такая связь существует )
	empty? verify	( Целевое поле пусто )
	from here move	( Переместить фигуру )
	add-move		( Завершить формирование хода )
;
</source>
Конечно, писать по одной такой (пусть даже совсем маленькой) функции на каждое направление было бы совсем тоскливо. Здесь нам на помощь в первый (но не в последний) раз приходят <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0">функции высшего порядка</a>. Направление <b>n</b> - это функция, которая изменяет текущую позицию (в качестве побочного эффекта) и возвращает признак успешности своего выполнения. Мы можем взять адрес этой функции (слова, в терминологии Forth) и передать его другой функции. Потребуется лишь возможность выполнения функции, размещённой по полученному адресу. Вот как это делается:

<spoiler title="Передача функции через стек">
<source>
: move-to ( 'dir -- )
    EXECUTE verify	( Выполнить полученную функцию и прерваться, если выполнение не успешно )
    empty? verify	( Целевое поле пусто )
    from here move	( Переместить фигуру )
    add-move		( Завершить формирование хода )
;

: move-to-n ( -- ) ['] n move-to ;
: move-to-s ( -- ) ['] s move-to ;
: move-to-w ( -- ) ['] w move-to ;
: move-to-e ( -- ) ['] e move-to ;
</source>
</spoiler>
Это очень распространённая идиома Axiom и редкая программа без неё обходится (разумеется толку от всей этой эквилибристики тем больше чем сложнее обобщённая функция). Но вернёмся к Margo. Описанная мной выше реализация доски работает вплоть до размера 8x8 (16x16x8 = 2048 позиций), но уже для доски 9x9 (18x18x9 = 2916 позиций) работать перестаёт. Видимо это значение больше максимально допустимого размера доски (упоминания об этом ограничении в документации по Axiom я не нашёл). Разумеется, я не мог с этим смириться. Только не после того, как я <a href="https://raw.githubusercontent.com/GlukKazan/ZoG/a59239e236c59f40abc9a2f192746a66c12bdc97/Images/margo/9x9.bmp">долго и упорно</a> рисовал <a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points3.html"><b>хоси</b></a> для этой доски (на самом деле, четыре <a href="http://go-igo.ru/theory/18kudoc/angular-points/angular-points2.html"><b>сан-сана</b></a> и один <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_%D0%B3%D0%BE"><b>тэнген</b></a>, но именно они и требуются для доски такого размера).

Если внимательно приглядеться к рисунку в начале статьи и тому определению доски, что я дал выше, можно понять, что хранить она будет, в основном, воздух. Каждый слой, начиная со второго, содержит всё меньше и меньше фигур. Сохраняя строки, в которых фигуры не появятся никогда, мы расходуем оперативную память крайне не рационально. В оптимизации не было бы смысла, если бы всё и так работало, но коль скоро мы упёрлись в ограничения Axiom, почему бы не попробовать хранить меньше строк для каждого последующего слоя? Это тоже не самый оптимальный способ, но он гораздо экономичнее предыдущего:

<spoiler title="Оптимизированное определение доски">
<source>
9		 CONSTANT	DIM
DIM 2 *		 CONSTANT	COLS
90 	 	 CONSTANT	ROWS
COLS 1- 	 CONSTANT	DDIR
DDIR NEGATE	 CONSTANT	UDIR

{board
	ROWS COLS	{grid}
board}
</source>
</spoiler>
Для доски 9x9 потребуется хранить всего 18x90 = 1710 позиций. Такой объём Axiom вполне по силам. Обратите внимание на изменение константы <b>DDIR</b>, используемой для определения направления "вглубь" доски (забыл сказать, что доску мы будем хранить в перевёрнутом виде). К сожалению, это не единственное необходимое изменение. Что произойдёт если попытаться перейти вниз из любой позиции нулевой строки? Поскольку <b>DDIR</b> стала меньше на единичку, мы попадём на последнюю строку того же слоя! Это может сломать всю логику игры. 

Также, может получиться нехорошо если пойти с последней строки слоя на юг или с первой на север (за исключением нулевой строки первого слоя). Можно было бы запретить все лишние связи вручную, но мне не очень-то нравится много работать руками. Попробуем решить задачку по-умному. Для начала, научимся определять текущие координаты. Это совсем просто:

<source>
: get-x ( pos -- x )
	COLS MOD
;

: get-y ( pos -- y )
	COLS /
;
</source>
Определить граничную строку слоя немного сложнее:

<source>
: is-edge? ( -- ? )
	COLS here get-y
	BEGIN
		2DUP <= IF
			OVER -
			SWAP 2 - SWAP
			FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL
	SWAP 1- OVER = SWAP 0= OR
;
</source>
Суть этой стековой акробатики проста. Из номера текущей строки мы вычитаем (до тех пока есть из чего вычитать) ширину слоя, начиная с <b>COLS</b> и уменьшая это значение на <b>2</b> в каждой итерации цикла. Если в результате значение обнулилось или стало на единичку меньше текущей ширины слоя - строка граничная. Теперь, можно легко запретить все перемещения из этих строк (для интересующих нас направлений):

<source>
{directions
	-1	  0	{direction} n-internal
	 1	  0	{direction} s-internal
	 0	  1	{direction} e
	 0	 -1	{direction} w
	-1	 -1	{direction} nw
	 1	 -1	{direction} sw
	-1	  1	{direction} ne
	 1	  1	{direction} se
	 DDIR 0	{direction} d-internal
	 UDIR 0	{direction} u
directions}

: common-dir ( 'dir -- ? )
	is-edge? IF		( Это край? )
		DROP FALSE	( Функция отбрасывается и возвращается результат не успешного выполнения )
	ELSE
		EXECUTE		( Выполняем функцию перехода и возвращаем результат её выполнения )
	ENDIF
;

: n ( -- ) ['] n-internal common-dir ;
: s ( -- ) ['] s-internal common-dir ;
: d ( -- ) ['] d-internal common-dir ;
</source>
Функции высшего порядка снова с нами! К сожалению, этот код содержит серьёзную ошибку. Дело в том, что только для направления вниз необходимо запрещать движение из любой граничной строки. Северное направление следует запрещать лишь в верхних граничных строках, а южное - в нижних. Предикат <b>is-edge?</b> должен вычисляться по-разному, в зависимости от выбранного направления! Перед нами вновь предстаёт зловещая тень "копипаста". К счастью, никто не запрещает передавать указатели и на функции от нескольких аргументов. Вот корректная <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/Margo/Pieces.4th">реализация</a>:

<spoiler title="Окончательное решение вопроса">
<source>
: is-edge? ( 'op -- ? )
	COLS here get-y
	BEGIN
		2DUP <= IF
			OVER -
			SWAP 2 - SWAP
			FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL
	SWAP 1- OVER = SWAP 0= ROT EXECUTE
;

: my-first ( a b -- b )
	SWAP DROP
;

: n ( -- ) ['] n-internal ['] my-first common-dir ;
: s ( -- ) ['] s-internal ['] DROP     common-dir ;
: d ( -- ) ['] d-internal ['] OR       common-dir ;
</source>
</spoiler>
Держите свои глаза и ум открытыми. Для того чтобы столкнуться с функциональным программированием не обязательно заниматься академической деятельностью. Функции высшего порядка могут оказаться ближе чем вы думаете.
</habracut>

Dagaz: Пинки здравому смыслу (часть 8)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>- Для начала, ты должен понять главное...
- Что главное?
- Нет никакой ложки!

"<a href="http://www.kinopoisk.ru/film/301/">Матрица</a>"
&nbsp;</b></i>

Как я уже неоднократно говорил <a href="http://habrahabr.ru/post/258437/">ранее</a>, некоторые вещи реализовать в <a href="http://www.zillions-of-games.com/">Zillions of Games</a> попросту невозможно. Впрочем, если нельзя, но очень хочется, то иногда бывает всё таки можно. Как далеко можно зайти по этому пути?
<habracut>
<h4><b>3. Всё обман</b></h4>
Мы уже сталкивались с этим. ZoG не позволяет определять ходы, ограничивающиеся удалением фигур с доски? Нет проблем - создадим ход, <b>сбрасывающий</b> фигуру на доску и немедленно удаляющий её (в результате чего, фигура располагавшаяся на целевом поле, будет удалена автоматически). Таким образом можно создавать "кнопки", расширяя интерфейсные возможности ZoG (хотя, на самом деле, никакие это не кнопки, а просто специальные фигуры на доске). ZoG ограничивает размерность доски пятью измерениями? Тоже не беда!

<spoiler title="Создадим недостающие позиции и свяжем их вручную">
<source lang="lisp">
(define 6D
    (image "images\6DChess\6DChess.bmp")
    (grid
       	(start-rectangle 34 7 76 53)
       	(dimensions 			; 2x2x2x2x2
                ("Zii/Zi" (0 148))	; 5D
                ("A/B" (162 0)) 	; 4D
                ("II/I" (0 68)) 	; 3D
                ("a/b" (66 0)) ; columns
                ("2/1" (31 19))) ; rows offset 31
        (directions (n   0  0  0  0 -1) (s  0  0  0  0  1) 
		    	(e   0  0  0  1  0) (w  0  0  0 -1  0) 
		        (u   0  0 -1  0  0) (d  0  0  1  0  0) 
		        (4e  0  1  0  0  0) (4w 0 -1  0  0  0)
		        (5u -1  0  0  0  0) (5d 1  0  0  0  0)))
	(positions	; 6D
                (YiAIa1   413 241 445 287) (YiAIa2   383 223 415 269)
                (YiAIb1   477 241 509 287) (YiAIb2   448 223 480 269)
                (YiAIIa1  413 175 445 221) (YiAIIa2  383 155 415 201)
                (YiAIIb1  477 175 509 221) (YiAIIb2  448 155 480 201)
                (YiBIa1   577 241 609 287) (YiBIa2   547 223 579 269)
                (YiBIb1   641 241 673 287) (YiBIb2   609 223 642 269)
                (YiBIIa1  577 175 609 221) (YiBIIa2  547 155 579 201)
                (YiBIIb1  641 175 673 221) (YiBIIb2  609 155 642 201)
                (YiiAIa1  413 95  445 141) (YiiAIa2  383  76 415 122)
                (YiiAIb1  477 95  509 141) (YiiAIb2  448  76 480 122)
                (YiiAIIa1 413 26  445  72) (YiiAIIa2 383   7 415  53)
                (YiiAIIb1 477 26  509  72) (YiiAIIb2 448   7 480  53)
                (YiiBIa1  577 95  609 141) (YiiBIa2  547  76 579 122)
                (YiiBIb1  641 95  673 141) (YiiBIb2  609  76 642 122)
                (YiiBIIa1 577 26  609  72) (YiiBIIa2 547   8 579  54)
                (YiiBIIb1 641 26  673  72) (YiiBIIb2 609   8 642  54)
	)
	(links n 
		(YiAIa1 YiAIa2)     (YiAIb1 YiAIb2)
		(YiAIIa1 YiAIIa2)   (YiAIIb1 YiAIIb2)
		(YiBIa1 YiBIa2)     (YiBIb1 YiBIb2)
		(YiBIIa1 YiBIIa2)   (YiBIIb1 YiBIIb2)
		(YiiAIa1 YiiAIa2)   (YiiAIb1 YiiAIb2)
		(YiiAIIa1 YiiAIIa2) (YiiAIIb1 YiiAIIb2)
		(YiiBIa1 YiiBIa2)   (YiiBIb1 YiiBIb2)
		(YiiBIIa1 YiiBIIa2) (YiiBIIb1 YiiBIIb2))
	(links s 
		(YiAIa2 YiAIa1)     (YiAIb2 YiAIb1)
		(YiAIIa2 YiAIIa1)   (YiAIIb2 YiAIIb1)
		(YiBIa2 YiBIa1)     (YiBIb2 YiBIb1)
		(YiBIIa2 YiBIIa1)   (YiBIIb2 YiBIIb1)
		(YiiAIa2 YiiAIa1)   (YiiAIb2 YiiAIb1)
		(YiiAIIa2 YiiAIIa1) (YiiAIIb2 YiiAIIb1)
		(YiiBIa2 YiiBIa1)   (YiiBIb2 YiiBIb1)
		(YiiBIIa2 YiiBIIa1) (YiiBIIb2 YiiBIIb1))
	(links e 
		(YiAIa1 YiAIb1)     (YiAIa2 YiAIb2)
		(YiAIIa1 YiAIIb1)   (YiAIIa2 YiAIIb2)
		(YiBIa1 YiBIb1)     (YiBIa2 YiBIb2)
		(YiBIIa1 YiBIIb1)   (YiBIIa2 YiBIIb2)
		(YiiAIa1 YiiAIb1)   (YiiAIa2 YiiAIb2)
		(YiiAIIa1 YiiAIIb1) (YiiAIIa2 YiiAIIb2)
		(YiiBIa1 YiiBIb1)   (YiiBIa2 YiiBIb2)
		(YiiBIIa1 YiiBIIb1) (YiiBIIa2 YiiBIIb2))
	(links w 
		(YiAIb1 YiAIa1)     (YiAIb2 YiAIa2)
		(YiAIIb1 YiAIIa1)   (YiAIIb2 YiAIIa2)
		(YiBIb1 YiBIa1)     (YiBIb2 YiBIa2)
		(YiBIIb1 YiBIIa1)   (YiBIIb2 YiBIIa2)
		(YiiAIb1 YiiAIa1)   (YiiAIb2 YiiAIa2)
		(YiiAIIb1 YiiAIIa1) (YiiAIIb2 YiiAIIa2)
		(YiiBIb1 YiiBIa1)   (YiiBIb2 YiiBIa2)
		(YiiBIIb1 YiiBIIa1) (YiiBIIb2 YiiBIIa2))
	(links u 
		(YiAIa1 YiAIIa1)   (YiAIa2 YiAIIa2)
		(YiAIb1 YiAIIb1)   (YiAIb2 YiAIIb2)
		(YiBIa1 YiBIIa1)   (YiBIa2 YiBIIa2)
		(YiBIb1 YiBIIb1)   (YiBIb2 YiBIIb2)
		(YiiAIa1 YiiAIIa1) (YiiAIa2 YiiAIIa2)
		(YiiAIb1 YiiAIIb1) (YiiAIb2 YiiAIIb2)
		(YiiBIa1 YiiBIIa1) (YiiBIa2 YiiBIIa2)
		(YiiBIb1 YiiBIIb1) (YiiBIb2 YiiBIIb2))
	(links d 
		(YiAIIa1 YiAIa1)   (YiAIIa2 YiAIa2)
		(YiAIIb1 YiAIb1)   (YiAIIb2 YiAIb2)
		(YiBIIa1 YiBIa1)   (YiBIIa2 YiBIa2)
		(YiBIIb1 YiBIb1)   (YiBIIb2 YiBIb2)
		(YiiAIIa1 YiiAIa1) (YiiAIIa2 YiiAIa2)
		(YiiAIIb1 YiiAIb1) (YiiAIIb2 YiiAIb2)
		(YiiBIIa1 YiiBIa1) (YiiBIIa2 YiiBIa2)
		(YiiBIIb1 YiiBIb1) (YiiBIIb2 YiiBIb2))
	(links 4e 
		(YiAIa1 YiBIa1)     (YiAIa2 YiBIa2)
		(YiAIb1 YiBIb1)     (YiAIb2 YiBIb2)
		(YiAIIa1 YiBIIa1)   (YiAIIa2 YiBIIa2)
		(YiAIIb1 YiBIIb1)   (YiAIIb2 YiBIIb2)
		(YiiAIa1 YiiBIa1)   (YiiAIa2 YiiBIa2)
		(YiiAIb1 YiiBIb1)   (YiiAIb2 YiiBIb2)
		(YiiAIIa1 YiiBIIa1) (YiiAIIa2 YiiBIIa2)
		(YiiAIIb1 YiiBIIb1) (YiiAIIb2 YiiBIIb2))
	(links 4w 
		(YiBIa1 YiAIa1)     (YiBIa2 YiAIa2)
		(YiBIb1 YiAIb1)     (YiBIb2 YiAIb2)
		(YiBIIa1 YiAIIa1)   (YiBIIa2 YiAIIa2)
		(YiBIIb1 YiAIIb1)   (YiBIIb2 YiAIIb2)
		(YiiBIa1 YiiAIa1)   (YiiBIa2 YiiAIa2)
		(YiiBIb1 YiiAIb1)   (YiiBIb2 YiiAIb2)
		(YiiBIIa1 YiiAIIa1) (YiiBIIa2 YiiAIIa2)
		(YiiBIIb1 YiiAIIb1) (YiiBIIb2 YiiAIIb2))
	(links 5u 
		(YiAIa1 YiiAIa1)   (YiAIa2 YiiAIa2)
		(YiAIb1 YiiAIb1)   (YiAIb2 YiiAIb2)
		(YiAIIa1 YiiAIIa1) (YiAIIa2 YiiAIIa2)
		(YiAIIb1 YiiAIIb1) (YiAIIb2 YiiAIIb2)
		(YiBIa1 YiiBIa1)   (YiBIa2 YiiBIa2)
		(YiBIb1 YiiBIb1)   (YiBIb2 YiiBIb2)
		(YiBIIa1 YiiBIIa1) (YiBIIa2 YiiBIIa2)
		(YiBIIb1 YiiBIIb1) (YiBIIb2 YiiBIIb2))
	(links 5d 
		(YiiAIa1 YiAIa1)   (YiiAIa2 YiAIa2)
		(YiiAIb1 YiAIb1)   (YiiAIb2 YiAIb2)
		(YiiAIIa1 YiAIIa1) (YiiAIIa2 YiAIIa2)
		(YiiAIIb1 YiAIIb1) (YiiAIIb2 YiAIIb2)
		(YiiBIa1 YiBIa1)   (YiiBIa2 YiBIa2)
		(YiiBIb1 YiBIb1)   (YiiBIb2 YiBIb2)
		(YiiBIIa1 YiBIIa1) (YiiBIIa2 YiBIIa2)
		(YiiBIIb1 YiBIIb1) (YiiBIIb2 YiBIIb2))
	(links 6e 
		(ZiAIa1 YiAIa1)     (ZiAIa2 YiAIa2)   
		(ZiAIb1 YiAIb1)     (ZiAIb2 YiAIb2)
		(ZiAIIa1 YiAIIa1)   (ZiAIIa2 YiAIIa2)  
		(ZiAIIb1 YiAIIb1)   (ZiAIIb2 YiAIIb2)
		(ZiBIa1 YiBIa1)     (ZiBIa2 YiBIa2)   
		(ZiBIb1 YiBIb1)     (ZiBIb2 YiBIb2)
		(ZiBIIa1 YiBIIa1)   (ZiBIIa2 YiBIIa2)  
		(ZiBIIb1 YiBIIb1)   (ZiBIIb2 YiBIIb2)
		(ZiiAIa1 YiiAIa1)   (ZiiAIa2 YiiAIa2)  
		(ZiiAIb1 YiiAIb1)   (ZiiAIb2 YiiAIb2)
		(ZiiAIIa1 YiiAIIa1) (ZiiAIIa2 YiiAIIa2) 
		(ZiiAIIb1 YiiAIIb1) (ZiiAIIb2 YiiAIIb2)
		(ZiiBIa1 YiiBIa1)   (ZiiBIa2 YiiBIa2)  
		(ZiiBIb1 YiiBIb1)   (ZiiBIb2 YiiBIb2)
		(ZiiBIIa1 YiiBIIa1) (ZiiBIIa2 YiiBIIa2) 
		(ZiiBIIb1 YiiBIIb1) (ZiiBIIb2 YiiBIIb2))
	(links 6w 
		(YiAIa1 ZiAIa1)     (YiAIa2 ZiAIa2)   
		(YiAIb1 ZiAIb1)     (YiAIb2 ZiAIb2)
		(YiAIIa1 ZiAIIa1)   (YiAIIa2 ZiAIIa2)  
		(YiAIIb1 ZiAIIb1)   (YiAIIb2 ZiAIIb2)
		(YiBIa1 ZiBIa1)     (YiBIa2 ZiBIa2)   
		(YiBIb1 ZiBIb1)     (YiBIb2 ZiBIb2)
		(YiBIIa1 ZiBIIa1)   (YiBIIa2 ZiBIIa2)  
		(YiBIIb1 ZiBIIb1)   (YiBIIb2 ZiBIIb2)
		(YiiAIa1 ZiiAIa1)   (YiiAIa2 ZiiAIa2)  
		(YiiAIb1 ZiiAIb1)   (YiiAIb2 ZiiAIb2)
		(YiiAIIa1 ZiiAIIa1) (YiiAIIa2 ZiiAIIa2) 
		(YiiAIIb1 ZiiAIIb1) (YiiAIIb2 ZiiAIIb2)
		(YiiBIa1 ZiiBIa1)   (YiiBIa2 ZiiBIa2)  
		(YiiBIb1 ZiiBIb1)   (YiiBIb2 ZiiBIb2)
		(YiiBIIa1 ZiiBIIa1) (YiiBIIa2 ZiiBIIa2) 
		(YiiBIIb1 ZiiBIIb1) (YiiBIIb2 ZiiBIIb2))
  	(symmetry Black (n s) (s n) (u d) (d u) 
		(4e 4w)   (4w 4e)   (5u 5d)   (5d 5u)
		(6e 6w)   (6w 6e))
  	(zone
     		(name promotion-zone)
     		(players White)
     		(positions YiiAIIa2 YiiAIIb2 YiiBIIa2 YiiBIIb2))
  	(zone
     		(name promotion-zone)
     		(players Black)
     		(positions ZiAIa1 ZiAIb1 ZiBIa1 ZiBIb1))
) 
</source>
</spoiler>
Выглядит страшно? Зато <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=858">работает</a>!

<img align="center" src="https://habrastorage.org/files/005/0a2/194/0050a21947814283b4ac0dbc558db5d2.png"/>

Немного схитрив, <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=376">можно</a> определять гексагональные доски:

<img align="center" src="https://habrastorage.org/files/acb/b6d/294/acbb6d294887466a95c061ca62f7a5e8.png"/>

<spoiler title="Это всё тот же двумерный grid, строки которого сдвинуты друг относительно друга">
<source lang="lisp">
(define Board-Definitions
  (image "Images\6Chess.bmp")
  (grid
     (start-rectangle 21 -79 69 -31)
     (dimensions
	 ("a/b/c/d/e/f/g/h/i" (38 22)) ; files
	 ("10/9/8/7/6/5/4/3/2/1" (0 44)) ; ranks
     )
     (directions
       (z0 0 -1) (z1 1 -2) (z2 1 -1) (z3 2 -1) (z4 1 0) (z5 1 1)
       (z6 0 1) (z7 -1 2) (z8 -1 1) (z9 -2 1) (zx -1 0) (zy -1 -1)
     )
  )
  (kill-positions
     a7 a8 a9 a10 b8 b9 b10 c9 c10 d10
     f1 g1 g2 h1 h2 h3 i1 i2 i3 i4)
  (symmetry Black
    (z0 z6)(z6 z0) (z1 z7)(z7 z1) (z2 z8)(z8 z2)
    (z3 z9)(z9 z3) (zx z4)(z4 zx) (zy z5)(z5 zy)
  )
  (zone
     (name promotion-zone) (players White)
     (positions a6 b7 c8 d9 e10 f10 g10 h10 i10)
  )
  (zone
     (name promotion-zone) (players Black)
     (positions a1 b1 c1 d1 e1 f2 g3 h4 i5)
  )
  (zone
     (name fast-through) (players White)
     (positions b3 c3 d3 e3 f4 g5 h6)
  )
  (zone
     (name fast-through) (players Black)
     (positions b5 c6 d7 e8 f8 g8 h8)
  )
  (zone
     (name faster-through) (players White)
     (positions d4 e4 f5)
  )
  (zone
     (name faster-through) (players Black)
     (positions d6 e7 f7)
  )
)
</source>
</spoiler>
<a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=712">Можно</a> перемещать части доски, вместе с находящимися на них фигурами!

<video>https://youtu.be/au93TWncKBw</video>

Это действительно просто.

<spoiler title="На самом деле, здесь две доски">
<source lang="lisp">
 (board
  (image "Images\PlatformChess\Void8x8.bmp")
  (grid
    (start-rectangle 10 10 48 48)
     (dimensions
         ("a/b/c/d/e/f/g/h" (49 0)) ; files
         ("8/7/6/5/4/3/2/1" (0 49)) ; ranks
     )
     (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0)
			     (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1)
     )
  )
  (grid
    (start-rectangle 5 5 103 103)
    (dimensions
     ("A/B/C/D" (98 0)) ; grid files
     ("4/3/2/1" (0 98)) ;grid ranks
    )
    (directions (n 0 -1) (e 1 0) (w -1 0) (s 0 1)))
  (links up (A1 a2) (A2 a4) (A3 a6) (A4 a8)
            (B1 c2) (B2 c4) (B3 c6) (B4 c8)
            (C1 e2) (C2 e4) (C3 e6) (C4 e8)
            (D1 g2) (D2 g4) (D3 g6) (D4 g8))
  (links down (a1 A1) (a2 A1) (b1 A1) (b2 A1)
              (a3 A2) (a4 A2) (b3 A2) (b4 A2)
              (a5 A3) (a6 A3) (b5 A3) (b6 A3)
              (a7 A4) (a8 A4) (b7 A4) (b8 A4)

              (c1 B1) (c2 B1) (d1 B1) (d2 B1)
              (c3 B2) (c4 B2) (d3 B2) (d4 B2)
              (c5 B3) (c6 B3) (d5 B3) (d6 B3)
              (c7 B4) (c8 B4) (d7 B4) (d8 B4)

              (e1 C1) (e2 C1) (f1 C1) (f2 C1)
              (e3 C2) (e4 C2) (f3 C2) (f4 C2)
              (e5 C3) (e6 C3) (f5 C3) (f6 C3)
              (e7 C4) (e8 C4) (f7 C4) (f8 C4)

              (g1 D1) (g2 D1) (h1 D1) (h2 D1)
              (g3 D2) (g4 D2) (h3 D2) (h4 D2)
              (g5 D3) (g6 D3) (h5 D3) (h6 D3)
              (g7 D4) (g8 D4) (h7 D4) (h8 D4)
  )

  (symmetry Black (n s) (s n) (ne se) (se ne) (nw sw) (sw nw))

  (zone
     (name promotion-zone)
     (players White)
     (positions a8 b8 c8 d8 e8 f8 g8 h8)
  )
  (zone
     (name promotion-zone)
     (players Black)
     (positions a1 b1 c1 d1 e1 f1 g1 h1)
  )
  (zone
     (name enemy-promotion-zone)
     (players Black)
     (positions a8 b8 c8 d8 e8 f8 g8 h8)
  )
  (zone
     (name enemy-promotion-zone)
     (players White)
     (positions a1 b1 c1 d1 e1 f1 g1 h1)
  )
  (zone
     (name third-rank)
     (players White)
     (positions a3 b3 c3 d3 e3 f3 g3 h3
                a2 b2 c2 d2 e2 f2 g2 h2)
  )
  (zone
     (name third-rank)
     (players Black)
     (positions a6 b6 c6 d6 e6 f6 g6 h6
                a7 b7 c7 d7 e7 f7 g7 h7)
  )
 )
</source>
</spoiler>
Традиционная доска 8x8 совмещена с доской 4x4, по которой перемещаются "части доски" - платформы. Дополнительные направления <b>up</b> и <b>down</b> помогают фигурам контролировать наличие "почвы под ногами". Сложнее всего обеспечить синхронное перемещение фигур вместе с платформами.

<spoiler title="На помощь приходят операторы cascade и to">
<source lang="lisp">
(define wplatform-move
 (mark $1 (verify empty?) to
    back up
    (if (and empty? (empty? e) (empty? s) (empty? se)) add
     else
       back up (if not-empty? cascade from $1 
                   (if (and (in-zone? promotion-zone $1)
                            (piece? Pawn (opposite $1))
                            (friend? (opposite $1))) $1 (change-type Queen) to
                    else $1 to))
       back up e (if not-empty? cascade from $1
                   (if (and (in-zone? promotion-zone $1)
                            (piece? Pawn (opposite $1))
                            (friend? (opposite $1))) $1 (change-type Queen) to
                    else $1 to))
       back up s (if not-empty? cascade from $1
                    (if (and (in-zone? enemy-promotion-zone $1)
                             (piece? Pawn (opposite $1))
                             (enemy? (opposite $1))) $1 (change-type Queen) to
                    else $1 to))
       back up se (if not-empty? cascade from $1
                    (if (and (in-zone? enemy-promotion-zone $1)
                             (piece? Pawn (opposite $1))
                             (enemy? (opposite $1))) $1 (change-type Queen) to
                    else $1 to))
       add
    )
 )
)
</source>
</spoiler>
Можно подумать, что это предел возможностей ZoG, но посмотрите-ка вот на <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2051">это</a>:

<img align="center" src="https://habrastorage.org/files/dcf/bb6/79e/dcfbb679e7d541b0bc167a4a89d10bee.png"/>
Здесь явно что-то не так. Фигуры накладываются друг на друга! Разве ZoG так умеет? Конечно нет! Но кто сказал, что фигуры обязаны быть цельными? В этой игре, каждая "фигура" составлена из четырёх кусков, а доска, разумеется, трёхмерная (но видим мы лишь её "верхний план"). Реализация замечательная. Единственное, что может смутить - это то, что для выбора любой из фигур необходимо указывать её левый верхний угол (это можно исправить, при желании).

Можно пойти ещё дальше! С того самого момента, как я впервые увидел <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">эту</a> книгу, я загорелся желанием сделать доску для "Margo". Поскольку я реалист, я отдаю себе отчёт в том, что мне вряд ли удастся заставить AI ZoG правильно с ней работать. Даже для классической реализации <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a> на двумерной доске, ZoG понадобился <a href="http://www.zillions-of-games.com/progsample.html">engine</a>, чтобы играть на уровне среднего новичка. В Margo, с её "зомби", "мостами" и "виртуальными группами", всё ещё сложнее. Полноценную игру можно реализовать в <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>, но там разработка AI - отдельная история. Для начала, меня вполне устроит доска, контролирующая правила игры, поддерживающая игру двух человек и разбор этюдов. Начать следует с определения доски:

<spoiler title="Доска ''Margo''">
<source lang="lisp">
   (board
      (image "../images/margo/board.bmp")
      (grid
         (start-rectangle 30 30 59 59)
         (dimensions
             ("a/b/c/d/e/f/g/h/i/j/k/l/m/n" (30 0)) ; files
             ("14/13/12/11/10/9/8/7/6/5/4/3/2/1" (0 30)) ; ranks
             ("I/II/III/IV/V/VI/VII" (1600 0))  ;layers
         )
         (directions (n   0 -1 0) (e  1  0 0) (s  0  1 0) (w -1 0 0)
                     (nw -1 -1 0) (ne 1 -1 0) (sw -1 1 0) (se 1 1 0)
                     (u 0 0 -1) (d 0 0 1) 
         )
      )
      (zone (name im) (players R)
            (positions a1I)
      )
      (zone (name im) (players B)
            (positions a2I)
      )
      (zone (name empty-plane) (players R B)
            (positions a2I a4I a6I a8I a10I a12I a14I
                       c2I c4I c6I c8I c10I c12I c14I
                       e2I e4I e6I e8I e10I e12I e14I
                       g2I g4I g6I g8I g10I g12I g14I
                       i2I i4I i6I i8I i10I i12I i14I
                       k2I k4I k6I k8I k10I k12I k14I
                       m2I m4I m6I m8I m10I m12I m14I
            )
      )
      (zone (name plane) (players R B)
            (positions a1I a2I a3I a4I a5I a6I a7I a8I a9I a10I a11I a12I a13I a14I
                       b1I b2I b3I b4I b5I b6I b7I b8I b9I b10I b11I b12I b13I b14I
                       c1I c2I c3I c4I c5I c6I c7I c8I c9I c10I c11I c12I c13I c14I
                       d1I d2I d3I d4I d5I d6I d7I d8I d9I d10I d11I d12I d13I d14I
                       e1I e2I e3I e4I e5I e6I e7I e8I e9I e10I e11I e12I e13I e14I
                       f1I f2I f3I f4I f5I f6I f7I f8I f9I f10I f11I f12I f13I f14I
                       g1I g2I g3I g4I g5I g6I g7I g8I g9I g10I g11I g12I g13I g14I
                       h1I h2I h3I h4I h5I h6I h7I h8I h9I h10I h11I h12I h13I h14I
                       i1I i2I i3I i4I i5I i6I i7I i8I i9I i10I i11I i12I i13I i14I
                       j1I j2I j3I j4I j5I j6I j7I j8I j9I j10I j11I j12I j13I j14I
                       k1I k2I k3I k4I k5I k6I k7I k8I k9I k10I k11I k12I k13I k14I
                       l1I l2I l3I l4I l5I l6I l7I l8I l9I l10I l11I l12I l13I l14I
                       m1I m2I m3I m4I m5I m6I m7I m8I m9I m10I m11I m12I m13I m14I
                       n1I n2I n3I n4I n5I n6I n7I n8I n9I n10I n11I n12I n13I n14I
            )
      )
   )
</source>
</spoiler>
Взяв за основу определение доски "Маджонга", я изменил графические ресурсы и размеры доски (для получения доски 7x7 необходимо определить <b>grid</b> 14x14 тайлов, с поддержкой 7 слоёв). Здесь стоит обратить внимание на определение игровых зон. Во первых, необходимо определить "верхний план" - зону <b>plane</b>, в которой будут расположены все видимые тайлы. Только в этой зоне возможно добавление новых фигур и с неё же должно начинаться их удаление. Далее, создание фигур на пустой доске возможно не в любом месте. Зона <b>empty-plan</b> определяет возможное расположение их левых верхних тайлов.

Что касается определения зоны "<b>im</b>" - это забавный трюк, который позволит в дальнейшем определять принадлежность фигур тому или иному игроку (а не просто их дружественность или враждебность). Этот макрос будет использоваться для получения полной информации о тайле, расположенном на текущей позиции (к сожалению, никаким более внятным способом реализовать аналогичный функционал в ZRF невозможно):

<spoiler title="Получение информации о тайле">
<source lang="lisp">
(define get-piece
   (set-flag is-piece? false)
   (set-flag is-black? false)
   (set-flag is-left?  false)
   (set-flag is-top?   false)
   (if not-empty?
       (set-flag is-piece? true)
       (if (and enemy? (in-zone? im a1I))
           (set-flag is-black? true)
       )
       (if (and friend? (in-zone? im a2I))
           (set-flag is-black? true)
       )
       (if (or (piece? tnw) (piece? tne))
           (set-flag is-top?   true)
       )
       (if (or (piece? tnw) (piece? tsw))
           (set-flag is-left?  true)
       )
   )
)
</source>
</spoiler>
Задача размещения фигуры (четырёх тайлов) на пустую доску решается тривиально. Единственная техническая сложность заключается в том, что ход начинается сбросом <b>другой</b> специальной фигуры (не тайла), поскольку это единственная фигура, которую можно сбрасывать <b>на любое</b> поле. В точке сброса, её необходимо подменить на соответствующий тайл (это почти тоже самое, что делалось в "Huffing Checkers" в предыдущей статье). Остальные тайлы просто создаются на соседних полях (поскольку ход может начаться с любого тайла, необходимо определить 4 возможных хода):

<spoiler title="Ход на пустую доску">
<source lang="lisp">
(define pre-check-3
   (verify (on-board? $1))
   (verify (on-board? $2))
   (verify (in-zone? $3))
)

(define pre-check-4
   (verify (on-board? $1))
   (verify (on-board? $2))
   (verify (in-zone? $3 $4))
)

(define check-e
   (verify empty?)
   (verify (empty? $1))
   (verify (empty? $2))
   (verify (empty? $3))
)

(define post-action
   (create t-$1)
   (create t-$2 $2)
   (create t-$3 $4)
   (create t-$5 $6)
   add
)

(define de-nw (
   (pre-check-3 e s empty-plane)
   (check-e e s se)
   (post-action nw se ne e sw s)
))                          

(define de-ne (
   (pre-check-4 w s empty-plane w)
   (check-e w s sw)
   (post-action ne sw nw w se s)
))

(define de-se (
   (pre-check-4 w n empty-plane nw)
   (check-e n w nw)
   (post-action se nw ne n sw w)
))

(define de-sw (
   (pre-check-4 e n empty-plane n)
   (check-e e n ne)
   (post-action sw ne nw n se e)
))

(define tile
   (name  $1$2)
   (image G "../images/margo/w$1$2.bmp"
          R "../images/margo/b$1$2.bmp")
   (attribute is-ko? false)
)

(piece (tile t nw) )
(piece (tile t ne) )
(piece (tile t sw) )
(piece (tile t se) )

(piece
   (name  M)
   (image R "../images/margo/m.bmp"
          B "../images/margo/m.bmp")
   (drops (de-nw)
          (de-ne)
          (de-se)
          (de-sw)
   )
)
</source>
</spoiler>
Ход, выстраивающий "пирамиду", более сложен. Необходимо убедиться, что все четыре тайла,  на которых размещается новая фигура, имеют требуемый тип и глубина под ними одинакова. Далее, перед тем как размещать фигуру на доске в верхнем (видимом) слое, необходимо перенести ранее размещённые там тайлы в более глубокие слои. Первоначально, я выбрал не вполне удачное решение, используя слои со <b>II</b> по <b>VII</b> в качестве "стека", сверху-вниз:

<spoiler title="Выстраивание пирамид">
<source lang="lisp">
(define check-p
   (verify (piece? t-$1))
   (verify (piece? t-$2 $3))
   (verify (piece? t-$4 $5))
   (verify (piece? t-$6 $7))
)

(define check-d
   mark
   u
   (while not-empty?
       (verify (not-empty? $1))
       (verify (not-empty? $2))
       (verify (not-empty? $1$2))
       u
   )
   (verify (empty? $1))
   (verify (empty? $2))
   (verify (empty? $1$2))
   back
)

(define dp-nw (
   (pre-check-3 e s plane)
   (check-p se sw e nw se ne s)
   (check-d s e)
   (pre-action s e)
   (post-action nw se ne e sw s)
))

(define dp-ne (
   (pre-check-4 w s plane w)
   (check-p sw se w nw s ne sw)
   (check-d s w)
   (pre-action s w)
   (post-action ne sw nw w se s)
))

(define dp-se (
   (pre-check-4 w n plane nw)
   (check-p nw sw n ne w se nw)
   (check-d n w)
   (pre-action n w)
   (post-action se nw ne n sw w)
))

(define dp-sw (
   (pre-check-4 e n plane n)
   (check-p ne nw e se n sw ne)
   (check-d n e)
   (pre-action n e)
   (post-action sw ne nw n se e)
))

(piece
   (name  M)
   (image R "../images/margo/m.bmp"
          B "../images/margo/m.bmp")
   (drops (de-nw) (dp-nw)
          (de-ne) (dp-ne)
          (de-se) (dp-se)
          (de-sw) (dp-sw)
   )
)
</source>
</spoiler>
Впоследствии, стало ясно, что гораздо удобнее держать все тайлы одной фигуры (кроме видимых) в одном слое. Стек пришлось "<a href="https://github.com/GlukKazan/ZoG/commit/f7fa7a5cdd79ba48b11e6dd4857d1bed60ad4637">перевернуть</a>" (для этого потребовалось создать дополнительное направление, соединяющее первый слой с седьмым). Следующим шагом стало удаление. Алгоритмы удаления фигур, в связи с их "смертью" в Го (и тем более в Margo) очень сложны. Я решил начать с простого - удаления любой фигуры простым щелчком мыши. Разумеется, чтобы вся конструкция не развалилась, тем же ходом необходимо удалить и все фигуры "опирающиеся" на удалённую (прямо или опосредованно). Само по себе удаление помеченных тайлов достаточно очевидно.

<spoiler title="Групповое удаление тайлов">
<source lang="lisp">
(define clean-piece
   (set-flag is-piece? false)
   d (while empty? d)
   (while (and not-empty? (position-flag? is-dead?))
        capture
        d
   )
   (if not-empty?
        (get-piece)
        capture
   )
   (while (not-in-zone? plane) u)
   (if (flag? is-piece?)
        (add-piece)
    else
        capture
   )
)

(define clean-pieces
   mark a0
   (while (on-board? next)
        next
        (if (and not-empty? (position-flag? is-dead?))
            (if (empty? b)
                 capture
             else
                 (clean-piece)
            )
        )
   )
   back
)
</source>
</spoiler>
В главном цикле <b>clean-pieces</b> просматриваются все тайлы "верхнего плана". Если какой-то из них помечен для удаления, проверяются тайлы непосредственно под ним, в нижних слоях. Всё помеченное для удаления - удаляется, а первый не помеченный тайл перемещается наверх, в первый слой. Для пометки используются позиционные флаги, позволяющие связать с произвольной позицией булевское значение. Осталось придумать, как помечать тайлы для удаления.

<spoiler title="Пометка тайлов для удаления">
<source lang="lisp">
(define check-top
   (verify (on-board? $1))
   (if (and (not-empty? $1) (not-position-flag? is-dead? $1) (not-position-flag? is-current? $1))
        $1 
        (set-position-flag is-current? true)
        (if (not-piece? t$3)
            d (while (and empty? (on-board? d)) d)
            (verify not-empty?)
            (if (and not-empty? (not-position-flag? is-dead?) (not-position-flag? is-current?))
                (set-position-flag is-current? true)
            )
            (while (not-in-zone? plane) u)
        )
        $2
   )
)

(define check-deep
   (verify (on-board? $1))
   (if (and (not-empty? $1) (not-position-flag? is-dead? $1) (not-position-flag? is-current? $1))
       $1
       (set-position-flag is-current? true)
       (verify (on-board? u))
       (if (and (not-empty? u) (not-position-flag? is-dead? u) (not-position-flag? is-current? u))
           u (set-position-flag is-current? true) d
       )
       $2
   )
)

(define proceed-current
   (set-position-flag is-dead? true)
   (set-position-flag is-current? false)
   (get-piece)
   (if (in-zone? plane)
       (if (flag? is-left?)
           (if (flag? is-top?)
               (check-top e  w  ne)
               (check-top s  n  sw)
               (check-top se nw se)
            else
               (check-top e  w  se)
               (check-top n  s  nw)
               (check-top ne sw ne)
           )
        else
           (if (flag? is-top?)
               (check-top w  e  nw)
               (check-top s  n  se)
               (check-top sw ne sw)
            else
               (check-top w  e  sw)
               (check-top n  s  ne)
               (check-top nw se nw)
           )
       )
    else
       (if (flag? is-left?)
           (if (flag? is-top?)
               (check-deep e  w)
               (check-deep s  n)
               (check-deep se nw)
            else
               (check-deep e  w)
               (check-deep n  s)
               (check-deep ne sw)
           )
        else
           (if (flag? is-top?)
               (check-deep w  e)
               (check-deep s  n)
               (check-deep sw ne)
            else
               (check-deep w  e)
               (check-deep n  s)
               (check-deep nw se)
           )
       )
   )
)

(define proceed-all
   (set-flag is-done? false)
   (while (not-flag? is-done?)
        (set-flag is-done? true)
        mark a0
        (while (on-board? next-all)
             next-all
             (if (position-flag? is-current?)
                 (set-flag is-done? false)
                 (proceed-current)
             )
        )
        back
   )
)

(define dp-clear (
   (verify not-empty?)
   (set-position-flag is-current? true)
   (proceed-all)
   (clean-pieces)
   add
))
...
(piece
   (name  M)
   (image G "../images/margo/m.bmp"
          R "../images/margo/m.bmp")
   (drops (de-nw) (dp-nw)
          (de-ne) (dp-ne)
          (de-se) (dp-se)
          (de-sw) (dp-sw)

          (dp-clear)
   )
)
</source>
</spoiler>
Здесь, важно понимать, что удаление <b>всегда</b> начинается с видимых тайлов, расположенных в первом слое. Установив начальную пометку в <b>dp-clear</b>, мы выполняем <b>proceed-current</b> до тех пор, пока встречаются новые, ещё не удалённые тайлы. Сама эта процедура выполняет "распространение" флагов на соседние тайлы и делает это по разному, в зависимости от того, происходит ли действие в верхнем слое или на глубине. 

В первом слое, контролируется тип соседнего тайла и если он не совпадает с ожидаемым (это означает, что фигура перекрыта лежащей выше), помимо пометки тайла перекрывающей фигуры, флаг распространяется в глубину. На более глубоких слоях, тайлы фигуры всегда расположены в одном слое. Мы просто распространяем флаг на соседние тайлы и если поверх них есть ещё что-то, передаём его и вверх тоже. В результате, всё работает как и ожидалось, но сама картинка выглядит как-то так:

<img align="center" src="https://habrastorage.org/files/e33/68d/5af/e3368d5af6d6444390b59b6bb23a99e8.png"/>

Ну... это тайлы. Для того, чтобы учесть цвет лежащей ниже фигуры, потребуется, поработав в графическом редакторе, добавить ещё по два типа для каждого тайла и немного усложнить код. В конечном счёте, всё вместе будет выглядеть следующим <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/margo.zrf">образом</a>.

<video>https://youtu.be/tfKkstb9FtA</video>

Разумеется, для того чтобы превратить эту заготовку в полноценную игру "Margo", мне придётся ещё очень много поработать. Скорее всего, мне всё-таки придётся переделать всё на Axiom, а это само по себе целая история. В Axiom нет атрибутов фигур, игровых зон и позиционных флагов, но, в плане разработки (в том числе AI) её возможности неизмеримо превосходят ZRF. Кроме того, код на ForthScript можно худо-бедно отлаживать. Когда (и если) я справлюсь со всеми трудностями, это будет заслуживать отдельной статьи, сегодня же я хотел показать лишь то, что при помощи ZRF <b>можно</b> делать действительно удивительные вещи. Достаточно проявить немного изобретательности и не бояться (очень много) поработать руками.
</habracut>

Dagaz: Пинки здравому смыслу (часть 7)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>- Знаешь свой главный грех?
- Какого черта? я обожаю все семь...
&nbsp;&nbsp;&nbsp;но сейчас... я готов дать волю гневу!
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Малькольм Рейнольдс "<a href="http://www.kinopoisk.ru/film/61455/">Миссия Серенити</a>"&nbsp;
</b></i>

По мере того, как мой личный "<a href="http://habrahabr.ru/post/248639/">рейтинг неприятностей</a>" стремительно движется к завершению, становится всё сложнее добиваться от <a href="http://www.zillions-of-games.com/">Zillions of Games</a> требуемого поведения. Некоторые правила очень легко сформулировать, но они способны попортить разработчику немало крови. "Правило гнева" - одно из них.
<habracut>
<h4><b>4. За фук!</b></h4>
Возможность снятия с доски фигур (своих или противника) бывает очень полезна. За примерами далеко ходить не надо. Я уже <a href="http://habrahabr.ru/post/255621/">писал</a> об игре "<a href="http://www.di.fc.ul.pt/~jpn/gv/focus.htm">Фокус</a>", описанной Мартином Гарднером в его "<a href="http://www.twirpx.com/file/67840/">Математических досугах</a>". Играть в неё не просто, но удовольствие от игры может несколько омрачить факт наличия очень простой беспроигрышной стратегии для второго игрока. Повторяя каждый ход противника симметрично относительно центра доски, он может затянуть игру до бесконечности:

<video>http://www.youtube.com/watch?v=IS1cVXGUTSQ</video>

Каждым своим ходом, второй игрок восстанавливает центральную симметрию, нарушенную предыдущим ходом. Поскольку фигуры не могут перемещаться по диагоналям, первый игрок не может нарушить симметрию невосстановимым (за один ход) образом, следовательно - его противник не может проиграть, в точности повторяя все ходы. Очевидно, что справиться с этим недостатком можно лишь нарушив первоначальную симметричную расстановку фигур.

В качестве первого хода, каждый из игроков может удалить по одной фигуре с доски (разумеется, следует запретить второму игроку удаление фигуры расположенной симметрично по отношению к ходу сделанному первым игроком). В ZRF отсутствует возможность формирования ходов, ограничивающихся лишь удалением с доски некоторых фигур, но можно схитрить. Этот код приведёт к желаемому результату:

<spoiler title="Удаление фигуры">
<source lang="lisp">
(define capture-enemy (
   (verify enemy?)
   (verify (not is-protected?))
   mark sym
   (set-attribute is-protected? true)
   back
   capture
   add
))
...
  (piece
     ...
     (drops (move-type capturing)
            (capture-enemy)
     )
  )
</source>
</spoiler>
Здесь <b>sym</b> - направление, попарно связывающее поля доски, расположенные симметрично. Фактически мы не удаляем, а помещаем на доску некую вспомогательную фигуру. Фигура, размещавшаяся ранее на целевом поле, удаляется автоматически, а саму добавленную фигуру мы удаляем командой <b>capture</b>, перед завершением хода командой <b>add</b>. В ZSG-нотации такой ход выглядит следующим образом:

<source lang="lisp">
1. White t e6 x e6
</source>
Ещё проще выполнить "переключение" фигуры, изменив цвет противника на свой (достаточно закомментировать команду <b>capture</b> в приведённом выше фрагменте кода), но уже здесь нас подстерегает первая засада. Можно поместить свою фигуру поверх фигуры противника, но не наоборот! ZoG разрешает играть лишь своими фигурами. К счастью, в данном случае, это не очень значимое ограничение. Добровольное удаление с доски своих фигур (а тем более замена их фигурами противника) - не самая удачная мысль. Поскольку нам вряд ли удастся убедить противника поступить столь же благородно, дело закончится гигантским дисбалансом в самом начале игры. 

<img align="center" src="https://habrastorage.org/files/b69/1f8/75b/b691f875b7e540179223fb64c5d91092.jpg"/>
Разумеется, "Фокус" - не единственная игра, в которой ходы, выполняющие удаление произвольных фигур оказываются востребованными. В 30-е годы прошлого века, в СССР активно пропагандировалась игра "<a href="http://gest.livejournal.com/889387.html?thread=3121963">Шахбой</a>", в которой фигуры на игровом поле символизировали силы пехоты, авиации и артиллерии. Артиллерия, в этой игре, представляла собой грозную силу, поскольку могла уничтожать фигуры противника, буквально "не сходя с места". Это могло полностью разрушить игровой баланс, но проблема была решена весьма оригинальным образом.

Самая слабая фигура "пехотинца", в этой игре, доходя до противоположного края доски, не превращалась в какую либо другую фигуру. В самом деле, игра выглядела бы очень странно, если бы пехотинец, дойдя до лагеря противника, превращался в танк или самолёт (не говоря уже о "штабе"). Пройдя через всё поле боя, "пехотинец" убирался с доски, но имел право "выполнить диверсию" - убрать с доски любую фигуру противника на выбор (кроме "штаба", конечно). Другое правило позволяло "пехотинцу" перепрыгивать через чёрные поля доски (не занятые другими фигурами), что позволяло эффективно "просачиваться" сквозь артиллеристские заслоны.

<img align="center" src="https://habrastorage.org/files/e11/966/89e/e1196689e66b4990a264133d0ba7efb2.gif"/>

В различных вариантах "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельницы</a>", являющихся переходной формой между "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B5%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%BD%D0%BE%D0%BB%D0%B8%D0%BA%D0%B8">Крестиками-ноликами</a>" и играми семейства <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>, удаление произвольных фигур противника выполняется при выстраивании в ряд трёх своих фишек. В начале игры, фишки, принадлежащие игрокам, поочерёдно выкладываются на пустую доску, после чего их разрешается двигать по линиям доски. В существующих ZoG-реализациях, удаление фигуры противника совмещено с ходом, выстраивающим "мельницу" (линию из 3 фишек в ряд).

<spoiler title="Взятие произвольной фигуры в ''Мельнице''">
<source lang="lisp">
(define take-piece 
   a1 
   (while (on-board? next) 
         (if enemy?  mark 
         (not-in-a-mill n s) back 
         (if (flag? eatit) 
            (not-in-a-mill e w) back 
            (if (flag? eatit)
               (not-in-a-mill in out) back 
               (if (flag? eatit)
                  capture add (set-flag writeit false) 
               ) 
            ) 
         )
      ) 
      next
  ) 
)

(define check-mill (set-flag mill false) 
    (check-dir1 n s)(check-dir2 n s)(check-dir3 n s)
    (check-dir1 e w)(check-dir2 e w)(check-dir3 e w)
    (check-dir1 in out)(check-dir2 in out)(check-dir3 in out)
    to
    (if (flag? mill) 
        (take-piece)
    )
)

(define shift 
   (
      mark $1 
      (verify empty?) 
      (set-flag writeit true) 
      (check-mill) 
      (if (flag? writeit) 
         add
      )
   )
) 
</source>
</spoiler>
Здесь стоит обратить внимание на использование флага <b>writeit</b>. Формирование "тихого" хода (командой <b>add</b>) в макросе перемещения фишки (<b>shift</b>) происходит лишь в том случае, если не найдено ни одного варианта удаления вражеской фишки. В свою очередь, каждая команда <b>add</b>, выполняемая после взятия (<b>capture</b>) в макросе <b>take-piece</b> приводит к формированию независимого варианта хода (одновременно запрещая формирование "тихого" хода).

Это весьма интересная реализация алгоритма взятия "Мельницы", не покрывающая, к сожалению, всех возможных ситуаций этой игры. По некоторым вариантам правил, одновременное выстраивание нескольких рядов фишек должно обеспечивать возможность снятия соответствующего количества фишек противника. Попытка решения этой задачи представленным выше алгоритмом приводит к "комбинаторному взрыву". В своей <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/bolotoudou.zrf">реализации</a> похожей африканской игры "<a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D0%BB%D0%BE%D1%82%D1%83%D0%B4%D1%83">Болотуду</a>" я решил применить другой подход:

<spoiler title="Взятие фигур в ''Болотуду''">
<source lang="lisp">
(define my-friend?
   (and (in-zone? inner $1)
        (not (position-flag? from? $1)) 
        (friend? $1)
   )
)

(define check-side
   (set-flag is-checked? false)
   (if (my-friend? $1)
       mark $1
       (if (my-friend? $1)
           (set-flag is-checked?  true)
           (set-flag is-accepted? false)
           (set-position-flag is-marked? true $2)
           (set-position-flag is-marked? true $3)
           $1
           (set-position-flag is-marked? true $2)
           (set-position-flag is-marked? true $3)
       )
       back
       (if (flag? is-checked?)
           (set-position-flag is-marked? true $2)
           (set-position-flag is-marked? true $3)
       )
   )
)

(define check-middle
   (if (and (my-friend? $1) (my-friend? $2))
       (set-flag is-accepted? false)
       mark
       $1
       (set-position-flag is-marked? true $3)
       (set-position-flag is-marked? true $4)
       $2 $2
       (set-position-flag is-marked? true $3)
       (set-position-flag is-marked? true $4)
       back
       (set-position-flag is-marked? true $3)
       (set-position-flag is-marked? true $4)
   )
)

(define shift-man (
   (set-position-flag from? true)
   (verify (in-zone? inner))
   $1
   (verify (in-zone? inner))
   (verify empty?)
   (set-flag is-accepted? true)
   (check-side $1 $2 $4)
   (check-side $2 $3 $1)
   (check-side $4 $1 $3)
   (check-middle $2 $4 $1 $3)
   (if (not-flag? is-accepted?)
        mark a0 
        (while (on-board? next) 
            next
            (if (and enemy? (position-flag? is-marked?))
                (set-attribute is-capturing? true)
            )
        )
        back
   )
   add
))
...
  (piece
     (name  Man)
     ...
     (attribute is-capturing? false)
     (drops
        (move-type droptype)
           (drop-man)
     )
     (moves
        (move-type normaltype)
           (shift-man n e s w)
           (shift-man e s w n)
           (shift-man s w n e)
           (shift-man w n e s)
     )
  )
</source>
</spoiler>
В этой игре, выстраивание ряда из трёх фигур, также как и в "Мельнице", даёт возможность боя фигуры противника, но не любой, а лишь "примыкающей к тройке сбоку". Для того, чтобы понять, что под этим имеется в виду, пришлось воспроизвести партию этой игры по следующей <a href="http://worldofchildren.ru/vospitatelyam-uchitelyam-pedagogam.html?id=1362">записи</a>. Сразу скажу, что качество этой нотации ужасно. Скан с какой-то неизвестной мне книги не потрудились вычистить от ошибок распознавания. Впрочем, имея перед глазами доску, ход партии восстановить <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/bolotoudou.zsg">удалось</a> (некоторые ходы игроков не показались мне особо умными).

Фрагмент кода, приведённый выше, основан на анализе этой партии. Макросы <b>check-side</b> и <b>check-middle</b> не только проверяют формирование троек, но и помечают поля, находящиеся "под боем" позиционным флагом <b>is-marked?</b>. Поскольку все флаги (включая позиционные) автоматически очищаются в начале каждого хода, не требуется выполнять какую либо "чистку мусора", по завершении расчёта хода. По той же причине, полученную информацию о возможном бое фигур приходится передавать в следующий ход, установкой атрибута <b>is-capturing?</b>. Следующим ходом, разрешается удалить любую фигуру, у которой установлен этот атрибут. Такой подход представляется мне более гибким, кроме того, удаление фигуры, выполненное отдельным ходом, более наглядно, чем выбор из длинного списка возможных ходов, формируемых "Мельницей".

<video>https://youtu.be/HI-Qsg8kz34</video>

Графические ресурсы я взял из <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=960">реализации</a> другой африканской <a href="http://en.wikipedia.org/wiki/Yot%C3%A9">игры</a>. Ситуация была совершенно анекдотична. Когда я уже практически полностью реализовал игровой алгоритм, ZoG преподнесла сюрприз: 

<source lang="lisp">
(loss-condition (White Black) (pieces-remaining 2))
</source>
Партия в "Болотуду" начинается с установки фигур парами на пустую доску. Указанная выше строка завершала игру в момент добавления второй фигуры любым из игроков. Потребовалось реализовать одноразовый "резерв" для того, чтобы фигуры учитывались ZoG уже на этапе добавления фигур на доску. Поскольку рисовать и настраивать доску с "резервом" сил уже не было, я взял подходящее определение доски из "Йотай".

Кстати, "Йотай" тоже подходит под тему сегодняшнего разговора. Эта игра ещё более похожа на шашки. Взятия в ней осуществляются привычным нам "перепрыгиванием" через фигуру противника. Как и в шашках, допускается несколько взятий "по цепочке" за ход. Отличие в том, что на каждую взятую фигуру, игрок имеет права взять <b>ещё одну</b> (любую) фигуру противника. Такая "положительная обратная связь" приводит к тому, что любой полученный перевес быстро приводит к победе (ничьи в этой игре бывают редко), а сам характер игры весьма подходит для темпераментных жителей африканского континента.

Но не следует думать, что подобные правила встречаются лишь в экзотических играх. Многие из тех, кто играл в шашки в детстве, наверняка помнят правило, по которому фигура, "прозевавшая" возможность боя, могла быть удалена с доски "за фук". Это правило ни в коем случае не изобретение "Русских шашек"! Точно также "профукать" (<b>huffing</b>) фигуру можно и в английских <a href="http://en.wikipedia.org/wiki/Huff_(board_games)">Checkers</a>. Многие исследователи сходятся к тому, что подобное "правило гнева" существовало уже в прародителе всех шашечных игр - <a href="http://skyruk.livejournal.com/249847.html">Алькуэрке</a>.

<img align="center" src="https://habrastorage.org/files/a89/64d/049/a8964d0490c545d5a4ba5a6bcb5025a8.jpg"/>

В отношении самого "правила гнева" история вынесла практически однозначный приговор. Применение этого правила в шашках делает практически невозможной хоть сколь-нибудь сложную комбинационную игру. Действительно, в большинстве случаев, игроку гораздо выгоднее отдать "за фук" одну фигуру чем позволить заманить себя в ловушку, в результате которой он может потерять гораздо больше! Не удивительно, что в большинстве современных вариантов шашек "правило гнева" было упразднено. 

В настоящее время, оно применяется лишь в некоторых африканских вариантах, таких как <a href="http://docslide.us/documents/damii-ghana-draughts-history-rules.html">Damii</a>, в которую играют на территории республики <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BD%D0%B0">Гана</a>. Как и многие другие африканские игры, этот вариант шашек играется "на скорость" и "зевки" в нём - важный элемент тактики. В остальном, правила Damii аналогичны "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Международным шашкам</a>".

В качестве своего рода "интеллектуальной гимнастики", я решил <a href="https://github.com/GlukKazan/ZoG/commits/master/Rules/HuffCheckers.zrf">реализовать</a> шашки "с зевками" на ZRF. Первый шаг был очевиден - поскольку для игрока требовалось обеспечить максимальную свободу выбора, я отключил приоритеты взятий, правило большинства и разрешил прерывание цепочки взятий. В этой игре, игрок <b>не обязан</b> "есть" фигуры противника, но если его шашки что-то "недоели",  противник имеет право удалить любую из них с доски. Фигуры, подпадающие под действие "правила гнева" я решил помечать атрибутами. Немедленно сформировался следующий нехитрый алгоритм:

<ol>
	<li>По завершении своего хода, для всех фигур противника, выполнять проверку возможности боя своих фигур (фигуры, способные выполнить бой, помечать атрибутом)</li>
	<li>При выполнении противником взятия, очищать атрибуты на всех его фигурах (при выполнении тихого хода - атрибуты не трогать)</li>
	<li>Если какая либо из фигур противника помечена атрибутом, взять её (очистив атрибуты на всех остальных фигурах)</li>
	<li>Выполнить очередной свой ход</li>
</ol>
На бумаге всё было гладко. Разумеется, ZoG немедленно принялась вносить свои коррективы. Первое с чем приходится сталкиваться при реализации чего-то более менее сложного в ZRF - не очень внятная модель перемещения фигур. Вплоть до завершения хода, фигура в ZoG остаётся "как бы" на своей начальной позиции и, в большинстве случаев, это дьявольски неудобно. Приходится "помнить" о том, что стартовое поле "на самом деле" пустое, а конечное - заполнено перемещаемой фигурой. В результате получаются следующие макросы:

<spoiler title="Борьба с ZoG">
<source lang="lisp">
(define my-friend?
  (and 
       (not (position-flag? from? $1))
       (or (position-flag? to? $1)
           (friend? $1)
       )
  )
)

(define my-empty?
  (and (not (position-flag? to? $1))
       (or (position-flag? from? $1)
           (empty? $1)
       )
  )
)
</source>
</spoiler>
Разумеется, позиционные флаги <b>from?</b> и <b>to?</b> требуется ещё и правильно заполнить, да и сами макросы пришли к своему конечному варианту <a href="https://github.com/GlukKazan/ZoG/commit/ff1099c8c062e155248e41ea0c08dc51331b5d76">не сразу</a>. Следующей стала проблема удаления помеченных фигур. Взяв фигуру "за фук" игрок должен выполнить ещё один ход, без передачи хода противнику. Мне не хотелось изменять порядок ходов в <b>turn-order</b> (на то были причины) и я решил <a href="https://github.com/GlukKazan/ZoG/commit/94ed96a13cb00df6a9d936bea0acbed450542bf8">блокировать</a> возможность последующего хода, размещением на поле специальной невидимой фигуры (удаляемой по завершении обычного хода). Для того, чтобы игрок мог пропустить ход, пришлось активировать соответствующую опцию:

<source lang="lisp">
(option "pass turn" forced)
</source>
Далее, одно потянуло за собой другое. Опция "<b>pass turn</b>" управляет возможностью пропуска хода игроком (то есть добавляет к списку сгенерированных ходов пустой ход - <b>pass</b>). При установке значения "<b>forced</b>", её действие ещё хитрее - пас возможен лишь при отсутствии любых других возможных ходов (и пропуск хода, в этом случае, выполняется автоматически). К сожалению, по самой своей сути, эта опция совершенно несовместима со следующим условием завершения игры:

<source lang="lisp">
(loss-condition (First Second) stalemated)
</source>
И это очень плохо, поскольку завершение игры поражением игрока, при отсутствии возможности хода, едва ли не главное из того, что есть в шашках. Где-то в другом, более идеальном мире, хотелось бы, чтобы работала следующая конструкция (но это пустые мечты):

<source lang="lisp">
(loss-condition (First Second) (and stalemated (total-piece-count 0 Lock) ) )
</source>
Пропуск хода пришлось делать "вручную". На самом деле, это <a href="https://github.com/GlukKazan/ZoG/commit/133c7738a0ca0720d9c46b479d10495e88944962">не так страшно</a> как звучит. Требуется всего лишь реализовать "кнопку", на которую будет нажимать игрок, выполняя "пропуск хода". Поле <b>a8</b> (на 64-клеточной доске) - подходящее место для её размещения (поскольку нормальные фигуры на него не заходят). Есть правда один минус - в отличии от честного "<b>pass turn forced</b>", эта кнопка сама "нажиматься" не будет. С другой стороны, в код обработки этого хода, можно поместить любую дополнительную логику, например очистку атрибутов (в текущей реализации это не понадобилось, но так везёт не всегда). В конечном итоге, с "<a href="http://en.wikipedia.org/wiki/English_draughts">Английскими шашками</a>" всё получилось, но дальнобойные дамки - дело другое:

<spoiler title="Русские шашки (с ''зевками'')">
<source lang="lisp">
(define check-huff
  (if (and (on-board? $1) (my-friend? $1))
      $1
      (if (and (on-board? $1) (my-empty? $1))
          (set-flag is-huffing? true)
      )
      $2
  )
)

(define check-huff-2
  (set-flag is-huffing? false)
  (if (and (on-board? $1) (empty? $1))
      $1 (check-huff $1 $2) $2
  )
  (if (and (flag? is-huffing?) (not is-huff?))
      (set-attribute is-huff? true)
  )
)
...
(define check-huff-6
  (set-flag is-huffing? false)
  (if (and (on-board? $1) (empty? $1))
      $1 (check-huff-5 $1 $2) $2
  )
  (if (and (flag? is-huffing?) (not is-huff?))
      (set-attribute is-huff? true)
  )
)

(define check-long-enemies
  (set-position-flag to? true)
  mark
  a0
  (while (on-board? next) 
     next
     (if enemy?
         (if is-huff?
             (set-attribute is-huff? false)
         )
         (check-huff-1 sw ne) (check-huff-1 se nw) 
         (check-huff-1 ne sw) (check-huff-1 nw se)
         (if (piece? King)
             (check-huff-2 sw ne) (check-huff-2 se nw) 
             (check-huff-2 ne sw) (check-huff-2 nw se)
             (check-huff-3 sw ne) (check-huff-3 se nw) 
             (check-huff-3 ne sw) (check-huff-3 nw se)
             (check-huff-4 sw ne) (check-huff-4 se nw) 
             (check-huff-4 ne sw) (check-huff-4 nw se)
             (check-huff-5 sw ne) (check-huff-5 se nw) 
             (check-huff-5 ne sw) (check-huff-5 nw se)
             (check-huff-6 sw ne) (check-huff-6 se nw) 
             (check-huff-6 ne sw) (check-huff-6 nw se)
         )
     )
  )
  back
)

(define king-jump (
  (check-lock)
  (set-position-flag from? true)
  (while (empty? $1)
      $1
  )
  (verify (enemy? $1))
  $1
  (set-position-flag from? true)
  (verify (empty? $1))
  $1
  (while empty?
      (clear-enemy-huffs)
      mark
      (while empty? 
          (opposite $1)
      ) 
      (verify enemy?)
      capture
      back
      (clear-huffs)
      (clear-lock)
      (set-flag more-captures false)
      (king-captured-find $1)
      (king-captured-find $2)
      (king-captured-find $3)
      (if (flag? more-captures)
          (set-attribute is-huff? true)
          (add-partial jumptype)
       else
          (check-long-enemies)
          (set-attribute is-huff? false)
          (add-partial notype)
      )
      $1
  )
))

(define king-shift (
  (check-lock)
  (set-position-flag from? true)
  (while (empty? $1)
      (clear-enemy-huffs)
      $1
      (check-long-enemies)
      (clear-lock)
      add
  )
))
</source>
</spoiler>
Этот вариант даже работал, пока дело не доходило до дамок. Дамки вели себя загадочно:

<video>https://youtu.be/b-AFRVPb16Q</video>

Загадка разрешилась просто. Дальнобойная дамка может остановиться на любом поле, по пути следования, следовательно для каждого из них должна быть проведена проверка возможности боя вражескими фигурами. Флаг, для дамки на <b>h8</b>, устанавливался при прохождении чёрной дамкой поля <b>b2</b>, но уже не сбрасывался в начале следующей итерации цикла. Подобным играм со значениями атрибутов не место в цикле генерации хода. Старый добрый "копипаст" в очередной раз пришёл на помощь:

<spoiler title="Исправленная реализация">
<source lang="lisp">
(define king-jump-1 (
  (check-lock)
  (set-position-flag from? true)
  (while (empty? $1)
      $1
  )
  (verify (enemy? $1))
  $1
  capture
  (set-position-flag from? true)
  $1
  (verify empty?)
  (clear-huffs)
  (clear-lock)
  (set-flag more-captures false)
  (king-captured-find $1)
  (king-captured-find $2)
  (king-captured-find $3)
  (if (flag? more-captures)
      (set-attribute is-huff? true)
      (add-partial jumptype)
   else
      (check-long-enemies)
      (set-attribute is-huff? false)
      (add-partial notype)
  )
))
...
(define king-jump-6 (
  (check-lock)
  (set-position-flag from? true)
  (while (empty? $1)
      $1
  )
  (verify (enemy? $1))
  $1
  capture
  (set-position-flag from? true)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  (clear-huffs)
  (clear-lock)
  (set-flag more-captures false)
  (king-captured-find $1)
  (king-captured-find $2)
  (king-captured-find $3)
  (if (flag? more-captures)
      (set-attribute is-huff? true)
      (add-partial jumptype)
   else
      (check-long-enemies)
      (set-attribute is-huff? false)
      (add-partial notype)
  )
))

(define king-shift-1 (
  (check-lock)
  (set-position-flag from? true)
  $1
  (verify empty?)
  (check-long-enemies)
  (clear-lock)
  add
))
...
(define king-shift-7 (
  (check-lock)
  (set-position-flag from? true)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  (check-long-enemies)
  (clear-lock)
  add
))

(variant
  (title "Russian Checkers (with huffs)")

; (option "maximal captures" true)   ; AI Bug
; (option "pass partial"     false)

  (piece
     (name Checker)
     (image First "images/wiedem/CheckerWhite.bmp"
            Second "images/wiedem/CheckerBlack.bmp")
     (attribute is-huff? false)
     (drops (move-type normaltype)
            (capture-huff)
     )
     (moves (move-type jumptype)
            (long-checker-jump nw sw ne)
            (long-checker-jump ne se nw)
            (long-checker-jump sw se nw)
            (long-checker-jump se ne sw)
        
            (move-type normaltype)
            (long-checker-jump nw sw ne)
            (long-checker-jump ne se nw)
            (long-checker-jump sw se nw)
            (long-checker-jump se ne sw)
            (long-checker-shift nw)
            (long-checker-shift ne)
       
            (move-type notype)
     )
  )

  (piece
     (name King)
     (image First "images/wiedem/CheckerKingWhite.bmp"
            Second "images/wiedem/CheckerKingBlack.bmp")
     (attribute is-huff? false)
     (moves (move-type jumptype)
            (king-jump-1 nw sw ne) (king-jump-1 ne se nw) (king-jump-1 sw se nw) (king-jump-1 se ne sw)
            (king-jump-2 nw sw ne) (king-jump-2 ne se nw) (king-jump-2 sw se nw) (king-jump-2 se ne sw)
            (king-jump-3 nw sw ne) (king-jump-3 ne se nw) (king-jump-3 sw se nw) (king-jump-3 se ne sw)
            (king-jump-4 nw sw ne) (king-jump-4 ne se nw) (king-jump-4 sw se nw) (king-jump-4 se ne sw)
            (king-jump-5 nw sw ne) (king-jump-5 ne se nw) (king-jump-5 sw se nw) (king-jump-5 se ne sw)
            (king-jump-6 nw sw ne) (king-jump-6 ne se nw) (king-jump-6 sw se nw) (king-jump-6 se ne sw)
        
            (move-type  normaltype)
            (king-jump-1 nw sw ne) (king-jump-1 ne se nw) (king-jump-1 sw se nw) (king-jump-1 se ne sw)
            (king-jump-2 nw sw ne) (king-jump-2 ne se nw) (king-jump-2 sw se nw) (king-jump-2 se ne sw)
            (king-jump-3 nw sw ne) (king-jump-3 ne se nw) (king-jump-3 sw se nw) (king-jump-3 se ne sw)
            (king-jump-4 nw sw ne) (king-jump-4 ne se nw) (king-jump-4 sw se nw) (king-jump-4 se ne sw)
            (king-jump-5 nw sw ne) (king-jump-5 ne se nw) (king-jump-5 sw se nw) (king-jump-5 se ne sw)
            (king-jump-6 nw sw ne) (king-jump-6 ne se nw) (king-jump-6 sw se nw) (king-jump-6 se ne sw)
            (king-shift-1 ne) (king-shift-1 nw) (king-shift-1 se) (king-shift-1 sw)
            (king-shift-2 ne) (king-shift-2 nw) (king-shift-2 se) (king-shift-2 sw)
            (king-shift-3 ne) (king-shift-3 nw) (king-shift-3 se) (king-shift-3 sw)
            (king-shift-4 ne) (king-shift-4 nw) (king-shift-4 se) (king-shift-4 sw)
            (king-shift-5 ne) (king-shift-5 nw) (king-shift-5 se) (king-shift-5 sw)
            (king-shift-6 ne) (king-shift-6 nw) (king-shift-6 se) (king-shift-6 sw)
            (king-shift-7 ne) (king-shift-7 nw) (king-shift-7 se) (king-shift-7 sw)

            (move-type notype)
     )
  )
)
</source>
</spoiler>
Может показаться, что на этом мои мытарства закончились и я получил корректную работающую реализацию "Русских шашек с зевками", но всё не так просто. Во первых, включение опции "<b>maximal captures</b>" возвращало к жизни баг, описанный мной в одной из предыдущих <a href="http://habrahabr.ru/post/254947/">статей</a>. В какой-то момент игры, под управлением AI, программа переставала видеть возможность взятия своими фигурами (а поскольку код, выполняющий проверку за противника такую возможность видел, он брал шашки "за фук" буквально на ровном месте).

Я уже научился бороться с подобным багом в "Checkers Collection" и даже выложил соответствующее <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2351">исправление</a>, но в варианте "с зевками" этот метод почему-то не сработал.

<img align="center" src="https://habrastorage.org/files/009/318/6ed/0093186eda064c49aab2aaf9afe62457.PNG"/>

Но и это лишь часть проблемы. На иллюстрации выше, белая дамка должна взять фигуры на <b>d6</b> и <b>f6</b>, попав под бой <b>h8</b>. Конечно, она может "зевнуть", выполнив тихий ход или оставшись на месте, но в этом случае, её можно будет взять "за фук". Сложность заключается в том, что никакими техническими средствами я не могу "заставить" белую дамку продолжить бой. Она может уйти на <b>f4</b> или <b>g3</b> и пометка "зевка" всё равно будет снята. Некоторые вещи реализовать на ZRF корректно попросту невозможно.
</habracut>

Dagaz: Пинки здравому смыслу (часть 6)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>... мой двойник ожидает в доме Ихи, я встречаю его, я поднимаю мою фишку к [нему]
Я встречаю его в Прекрасном доме.
Я поднимаю три фишки и нахожу две фишки, мой двойник позади меня.
...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;папирус времён Рамсеса III</b></i>&nbsp;

До сих пор, я рассматривал игры, в которых каждая фигура действует как бы "сама по себе". Взаимодействие фигур, в таких играх, сводится к "поеданию" фигур противника. Но не все игры таковы. Существует множество игр, в которых одна фигура может "усиливать" или "ослаблять" другую, изменяя, тем самым, её свойства. Об этом я и хочу поговорить сегодня.
<habracut>
<h4><b>5. В единстве сила</b></h4>
Идея о том, что свойства фигур могут зависеть от их взаимного расположения, не нова. По всей видимости, этот принцип использовался в древнеегипетской игре <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BD%D0%B5%D1%82">Сенет</a>, известной начиная с 3500 года до н.э. В наше время, точных правил этой игры никто не знает, но существует несколько реконструкций, основанных на анализе материалов, обнаруженных египтологами.

По <a href="http://www.cs.brandeis.edu/~storer/JimPuzzles/GAMES/Senet/INFO/WalkersRulesKendal.pdf">версии</a> Тимоти Кендалла, опубликованной в 1978 году, бой фигур в Сенете производился особым образом. Побитая фигура не убиралась с доски, а менялась местами с выполнившей ход. Эта идея хорошо согласуется с названием фигур <b>Ibau</b> - "танцоры" (в отличии от большинства других игр, Сенет использовал метафору танца, а не боевых действий). Игра в Сенет рассматривалась как "тренировка" в прохождении душой её посмертных испытаний (древние египтяне очень серьёзно относились к этому вопросу).

Важным моментом правил Кендалла является возможность "защиты" фигур друг другом. Запрещается "бить" фишку, входящую в состав "пары" - двух фишек, принадлежащих одному игроку, расположенных на соседних полях доски. К сожалению, реконструкция Кендалла не оговаривает ряд важных моментов. Можно ли перепрыгивать через "пару"? Можно ли разбивать "тройки" и "четвёрки" фишек? Эти вопросы оставлены без ответа. Правила хода фишек в "домах" (специальных полях доски) также не слишком удачны. В результате, игра получается довольно нудной:

<video>http://www.youtube.com/watch?v=J__os22LliA</video>

Существует несколько "улучшений" правил Кендалла, среди которых я хотел бы выделить <a href="http://skyruk.livejournal.com/183773.html">версию</a> <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрия Скирюка</a>. В этом варианте правил, "пары" препятствуют продвижению других фишек. Перепрыгивать их нельзя! Разбивать "пары" также нельзя, но если подряд стоят три и более фишек - это уже не "пара". Фишку, имеющую двух соседей, "бить" можно ("тройка", таким образом, легко "разбивается" посередине). Простые изменения правил превращают "Сенет Кендалла" в очень динамичную и увлекательную игру. Как и в случае с "<a href="http://habrahabr.ru/post/225631/">Игрой из города Ур</a>", Дмитрий провёл большую работу по проверке предложенного им варианта правил на практике.

<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B4%D0%B6%D0%B0">Сиджа</a> - ещё одна египетская игра, в которой фигуры действуют "сообща". В этой древней игре, сохранившейся до наших дней, захват фигуры противника осуществляется путём "зажимания" её в "клещи" с двух сторон. Вполне возможно, что именно от этой игры произошли и другие "зажимные" игры, такие как <a href="http://skyruk.livejournal.com/246910.html">Хнефатафл</a>.

<video>http://www.youtube.com/watch?v=Weaop9VKhuo</video>

Способ взятия "зажимом в клещи" позволяет брать несколько фигур противника сразу (до трёх фигур, в разные стороны), но это не единственная возможность "увеличения производительности". В тибетской игре "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1819">Мин Манг</a>" разрешается брать сразу несколько фигур противника, выстроенных в ряд, "закрыв" линейку своими фигурами с обеих сторон. Взятые фигуры "меняют цвет", аналогично тому, как это происходит в "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B2%D0%B5%D1%80%D1%81%D0%B8">Реверси</a>".

<video>http://www.youtube.com/watch?v=oc9dDCPgEc4</video>

Ещё дальше идут некоторые региональные варианты "<a href="http://en.wikipedia.org/wiki/Hasami_shogi">Hasami Shogi</a>". В следующем ниже видео показано, каким образом может быть взята "компактная" группа фигур, расположившихся в углу доски. Признаться честно, я пока затрудняюсь с формализацией этих правил. Например, из объяснения непонятно, как брать фигуры у края доски:

<video>http://www.youtube.com/watch?v=5EcpCGDu1Bw</video>

Своего наивысшего развития идея "связности" фигур достигает в другой древнейшей игре - <a href="http://geektimes.ru/post/240456/">Го</a>. Эта игра строится на понятии "группы" камней. Камни, расположенные на соседних пунктах доски (по вертикали или горизонтали) составляют единую группу. Группа должна соседствовать с не захваченными пунктами доски (<b>дамэ</b>), в противном случае, она "умирает" и снимается с доски полностью. Удивительно, но столь простые правила приводят к невероятному разнообразию тактических комбинаций.

<img src="https://habrastorage.org/files/50c/412/d2e/50c412d2e9a44d24ad41b5a2e3ba849e.PNG"/>

Го - не единственная игра, использующая идею "связности". В игре "<a href="http://www.iggamecenter.com/info/ru/ordo.html">Ордо</a>", например, игроки преследуют две цели: прорыв к противоположной стороне доски и сохранение "строя" своих фигур. В отличии от Го, фигуры считаются связанными не только по ортогональным, но и по диагональным направлениям. Ходы "разрывающие" единую группу фигур не допускаются. Если группа оказалась разорвана, в результате атаки противника, её целостность должна быть восстановлена следующим ходом (в противном случае, игроку засчитывается поражение). На видео вариант этой игры, допускающий перемещение групп фигур, связанных по диагонали:

<video>http://www.youtube.com/watch?v=PeMJylAeNZg</video>

Конечно, это не предел того, куда может завести воспалённая фантазия изобретателя настольных игр. Связывая фигуры, совсем не обязательно ограничиваться соседними клетками. В "военной" игре Ги Дебора "<a href="http://gest.livejournal.com/1242924.html">Кригшпиль</a>", прямые линии от "Арсеналов" и "Передатчиков" символизируют линии снабжения. Потеряв контакт с такой линией (непосредственный или через расположенную рядом фигуру), фигура "замирает", теряя возможность хода, до тех пор, пока контакт не будет восстановлен. Не знаю кому как, а мне это сильно напоминает "энергетическую сеть" протосов из Старкрафта.

<img align="center" src="https://habrastorage.org/files/d44/888/511/d448885110fc46c28fdc98c9efac5875.png"/>

Простота формулировки правил Го обманчива. Корректная их реализация, на языке <a href="http://www.zillions-of-games.com/">ZRF</a>, столь же многословна сколь малопонятна. Приведу, в качестве примера, фрагмент реализации "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2070">Stoical Go</a>":

<spoiler title="Много непонятного кода">
<source lang="lisp">
(define adjacent-to
	(or
		(position-flag? $1 n)
		(position-flag? $1 s)
		(position-flag? $1 e)
		(position-flag? $1 w)
	)
)

(define set-danger-flag 
	(if (and (enemy? $1) (not-neutral? $1) (not-position-flag? safe $1))
		(set-position-flag danger true $1)
		(set-flag Changed true)
	)
)

(define stone
	(name Stone)
	(image
		Black "images\Stoical Go\pieces\b$1.bmp"
		White "images\Stoical Go\pieces\w$1.bmp"
	)
	(attribute makes-capture false)
	(drops
		(
			(verify empty?)
			(verify (not-position? end))

			(set-flag Capturing false)

			; if next to enemy
			(if
				(or
					(and (enemy? n) (not-neutral? n) )
					(and (enemy? s) (not-neutral? s) )
					(and (enemy? e) (not-neutral? e) )
					(and (enemy? w) (not-neutral? w) )
				)
				mark

				; *** Initialize safe
				; for each point
				; if enemy
				; if next to empty
				; P[safe] = true

				a1
				(while
					(not-position? end)
					(set-position-flag safe empty?)
					next
				)
				back
				(set-position-flag safe false)

				a1
				(while
					(not-position? end)
					(if
						(and
							enemy?
							not-neutral?
							(adjacent-to safe)
						)
						(set-position-flag safe true)
					)
					next
				)

				; *** Initialize danger
				; for each adjacent
				; if enemy
				; P[danger] = true

				back
				(set-flag Changed false)
				(set-danger-flag n)
				(set-danger-flag s)
				(set-danger-flag e)
				(set-danger-flag w)
				(if
					(flag? Changed)

					; *** Spread danger, safe
					; Changed = true
					; while Changed
					; Changed = false
					; for each point
					; if enemy
					; if !P[safe]
					; if any adjacent is enemy with P[safe]
					; P[safe] = true
					; if !P[safe] and !P[danger]
					; if any adjacent is enemy with P[danger]
					; P[danger] = true
					; Changed = true

					(while (flag? Changed)
						(set-flag Changed false)
						a1
						(while (not-position? end)
							(if (and enemy? not-neutral?)
								(if
									(and (not-position-flag? safe) (adjacent-to safe))
									(set-position-flag safe true)
									(set-flag Changed true)
								)
								(if
									(and
										(not-position-flag? safe)
										(not-position-flag? danger)
										(adjacent-to danger)
									)
									(set-position-flag danger true)
									(set-flag Changed true)
								)
							)
							next
						)
					)

					; *** Add captures for stones
					; for each point
					; if P[danger] and !P[safe]
					; capture

					a1
					(while (not-position? end)
						(if
							(and (position-flag? danger) (not-position-flag? safe))
							capture
							(set-flag Capturing true)
						)
						next
					)

					back
				) ; if Changed
			) ; if next to enemy


			;!!!!!!! Find out if suicide

			; if no captures

			(if 
				(and
					(not-flag? Capturing)
					(not
						(or
							(empty? n) (empty? s) (empty? e) (empty? w)
						)
					)
				)

				; *** Initialize safe
				; for each point
				; P[safe] = empty and not-marked

				a1
				(while (not-position? end)
					(set-position-flag safe empty?)
					next
				)
				back
				(set-position-flag safe false)

				; Changed = true
				; while Changed and not adjacent to safe
				; Changed = false
				; for each point
				; if friend
				; if !P[safe]
				; if any adjacent is friend with P[safe]
				; P[safe] = true
				; Changed = true

				(set-flag Valid (adjacent-to safe))
				(set-flag Changed true)
				(while
					(and
						(not-flag? Valid)
						(flag? Changed)
					)
					(set-flag Changed false)
					a1
					(while (not-position? end)
						(if
							(and
								friend?
								(not-position-flag? safe)
							)
							(if (adjacent-to safe)
								(set-position-flag safe true)
								(set-flag Changed true)
							)
						)
						next
					)
					back
					(set-flag Valid (adjacent-to safe))
				)

				; *** Add if not suicide
				; verify next to safe square

				back
				(verify (flag? Valid))

			) ; if no captures

			; *** Add stone
			(if
				(flag? Capturing)
				(go last-to)
				(if
					(piece? CapturingStone)
					(verify friend?)
					(change-type Stone)
				)
				was-a-capture
				(change-type yes)
				back
				(add CapturingStone)
				else
				was-a-capture
				(if
					(piece? yes)
					(change-type no)
					(go last-to)
					(change-type Stone)
				)
				back
				add
			)
		)
	) ; drops
)
</source>
</spoiler>
Даже с комментариями, разобраться в этом крайне тяжело (ещё сложнее найти в коде ошибки). С появлением в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> массивов, ситуация несколько улучшилась (настолько, насколько это вообще возможно, при использовании языка ForthScript). Вот фрагмент кода, проверяющего связность групп из моей реализации <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2345">Ordo</a>:

<spoiler title="Чуть лаконичнее, но не менее загадочно">
<source lang="lisp">
20		CONSTANT	LS
10		CONSTANT	SS

LS []		list[]
VARIABLE	list-size
SS []		set[]
VARIABLE	set-size
VARIABLE	curr-pos

: not-in-list? ( pos - ? )
	curr-pos !
	TRUE list-size @
	BEGIN
		1- DUP 0 >= IF
			DUP list[] @ curr-pos @ = IF
				2DROP FALSE 0
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL DROP
;

: not-in-set? ( pos - ? )
	curr-pos !
	TRUE set-size @
	BEGIN
		1- DUP 0 >= IF
			DUP set[] @ curr-pos @ = IF
				2DROP FALSE 0
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL DROP
;

: add-position ( -- )
	list-size @ LS < IF
		here not-in-list? IF
			here list-size @ list[] !
			list-size ++
		ENDIF
	ENDIF
;

: not-from? ( pos -- ? )
	DUP from <>
	SWAP not-in-set? AND
;

: check-dir ( 'dir -- )
	EXECUTE here not-from? AND friend? AND IF
		add-position 
	ENDIF
;

: check-coherence ( -- ? )
	here 0 list[] @
	0 BEGIN
		DUP list[] @
		DUP to ['] n  check-dir
		DUP to ['] s  check-dir
		DUP to ['] w  check-dir
		DUP to ['] e  check-dir
		DUP to ['] nw check-dir
		DUP to ['] sw check-dir
		DUP to ['] ne check-dir
		to ['] se check-dir
		1+ DUP list-size @ >=
	UNTIL 2DROP to
	TRUE SIZE BEGIN
		1- DUP 0 >= IF
			DUP not-from? IF
				DUP from <> OVER friend-at? AND IF
					DUP not-in-list? IF
						2DROP FALSE 0
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL DROP
	0 list-size !
;
</source>
</spoiler>
Во всяком случае, теперь просматривается не вся доска, а лишь группа связанных фигур, что весьма благотворно сказывается на производительности. Для алгоритма построения связной группы требуется очередь, позволяющая добавлять элементы "в хвост", не останавливая перебора, начатого "с головы". Дойдя до элементов, добавленных в процессе обработки, цикл перебора должен обработать их также как и все предыдущие элементы. Вот так должен выглядеть этот алгоритм "в новом дизайне":

<spoiler title="Проверка связности в Dagaz">
<source lang="lisp">

(define add-piece-neighbors
   (foreach current-group
       (all
           (if (any n s e w nw sw ne se)
               (check is-friend?)
               (if (not (piece-contains current-group))
                   (take-piece current-group)
               )
           )
       )
   )
)

(define check-coherence
   (if (exists?
           any-position
           (check is-friend?)
           (take-piece current-group)
           add-piece-neighbors
       )
       (check (not (exists?
           any-position
           (check is-friend?)
           (check (not (piece-contains current-group)))
        ) ) )
   )
)
</source>
</spoiler>
После двух предыдущих листингов, в это может быть трудно поверить, но здесь есть всё необходимое, чтобы решить задачу. Выбираем любую дружественную фигуру, добавляем в набор её соседей, затем соседей её соседей и так далее, пока соседи не кончатся. Если по завершении этой процедуры осталась хотя бы одна дружественная фигура, не принадлежащая построенному набору - инвариант нарушен. Очень жаль, что в <a href="http://www.zillions-of-games.com/">ZoG</a> и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> нельзя решить эту задачу также просто.
</habracut>

Dagaz: Пинки здравому смыслу (часть 5)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>По обеим сторонам нашего плоского бытия 
бесконечно глубоко и далеко 
простирается сама жизнь.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чарлз Ховард Хинтон "Эпизод из жизни Флатландии"</i></b> &nbsp;
&nbsp;

<blockquote>    - Надо было ходить пешкой на е-один-дельта-аш...
    - Тогда летит четвертый конь.
    - Пусть. Пешки выходят в пространство слонов...
    - Какое пространство слонов? Где  ты взял пространство слонов?! Ты  же девятый ход неверно записал!
</blockquote>
Многие наверняка помнят этот отрывок из незабвенного "<a href="http://lib.ru/STRUGACKIE/pocthi.txt">Полдня</a>" Аркадия и Бориса Стругацких. Люди "Полдня" почти такие же как мы, но умнее и лучше нас. Они покоряют космос и играют в четырёхмерные шахматы. Авторы "<a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D1%91%D0%B7%D0%B4%D0%BD%D1%8B%D0%B9_%D0%BF%D1%83%D1%82%D1%8C">Звёздного пути</a>" также не обошли тему настольных игр стороной, но, в их случае, Спок играет в шахматы в трёх измерениях:

<img align="center" src="https://habrastorage.org/files/601/f10/4c5/601f104c559f43b7b4a5e866a8305597.jpg"/>

Выход за привычные нам пределы двумерной шахматной доски символизирует интеллектуальную мощь людей будущего и, по замыслу авторов, делает игру более интересной. Так ли это? Что, на самом деле, могут дать настольным играм третье и последующие за ним измерения?
<habracut>
<h4><b>6. Третье измерение</b></h4>
<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=381">Трёх</a>-, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=380">четырёх</a>-, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=379">пяти-</a> и даже <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=858">шести</a>-мерные доски не являются в <a href="http://www.zillions-of-games.com">Zillions of Games</a> какой-то экзотикой. Имеются варианты с <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=918">гексагональными</a> досками. Поклонники StarTrek-а также не оставлены <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=103">без</a> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=550">внимания</a> (трёхмерная <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=549">Klin Zha</a> мне особенно нравится). Дело не ограничивается лишь шахматами. Здесь есть <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=418">четырёхмерные крестики-нолики</a>, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=727">Reversi</a> и даже что-то <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=431">отдалённо напоминающее Go</a>. 

ZoG поддерживает доски вплоть до пяти измерений (<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> поддерживает лишь двумерные <b>grid</b>-ы), но никто не мешает задать доску с произвольной топологией, определив все её позиции и связи между ними вручную. Проблема не в реализации таких игр, а в том, чтобы понять, что происходит на доске:

<video>https://youtu.be/vg-h_Kk2Wos</video>

Глядя на эту видеозапись, я завидую людям будущего. Моего интеллекта явно не хватает на то, чтобы играть даже на такой "микроскопической"  доске размером 2x2x2x2x2x2. Другая <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1525">крайность</a> более понятна. В отличии от <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=871">игр</a> на основе классических шахмат, варианты Сёги на досках ограниченного <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2336">размера</a> (и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=991">размерности</a>) оказываются неожиданно интересны. Дело здесь не в доске. Практически все варианты <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> интересны, благодаря правилу сброса:

<video>https://youtu.be/xZ_nXFgpkJM</video>

Если бы речь шла лишь о досках с размерностью отличной от двух, на этом статью можно было бы и закончить, но есть другой способ использования в играх третьего измерения! Всем известные "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B5%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%BD%D0%BE%D0%BB%D0%B8%D0%BA%D0%B8">Крестики-нолики</a>" - не слишком интеллектуальная игра, но как она изменится если поставить доску вертикально? Помимо двух игроков, в игру вмешивается "третья сила" - сила гравитации. Фишки по прежнему требуется расположить "в одну линию" (4 в ряд), но добиться этого гораздо сложнее:

<img align="center" src="https://habrastorage.org/files/4b4/b9e/c11/4b4b9ec119534a1d8ebc2ce901668cad.jpg"/>

Игра обретает новое измерение. Фишки уже нельзя разместить в любом месте доски, они должны опираться на другие фишки, добавленные ранее. "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=882">Капитанская жёнушка</a>" - всё ещё играется на двумерной доске, но никто не мешает применить тот же принцип и к другим играм, таким как шашки или шахматы. Вот <a href="http://www.di.fc.ul.pt/~jpn/gv/towers.htm">здесь</a> имеется великолепная подборка, состоящая из 92 таких "башенных" игр.

В "<a href="http://www.di.fc.ul.pt/~jpn/gv/abchess.htm">Абстрактных шахматах</a>", все фигуры представляют собой стопки, состоящие из одинаковых фишек (кроме королевской фигуры, представляющей собой особую фишку). Одиночная фишка двигается как пешка, стопка из двух фишек - как шахматный конь, из трёх - как слон и т.д. Помимо обычных шахматных ходов, игроку разрешается брать верхнюю фишку из любой своей стопки и переносить её (ходом короля) на другую свою стопку (стоящую рядом). Свойства фигур изменяются в зависимости от текущего количества фишек в стопке.

<video>http://www.youtube.com/watch?v=A5jM6T9T5uI</video>

Не стоит думать, что этот принцип используется лишь в синтетических играх, придуманных недавно. "<a href="http://gamesofword.ru/article/view-35.html">Северные шашки</a>", упомянутые мной в <a href="http://habrahabr.ru/post/254947/">предыдущей статье</a> могут рассматриваться как вариант "<a href="http://skyruk.livejournal.com/328070.html">Многоэтажных шашек</a>", описанных ещё в 1961 году. Еще более почтенную историю имеют "<a href="http://skyruk.livejournal.com/322288.html">Столбовые шашки</a>".

<video>https://youtu.be/YW3M-C5ckFI</video>

В этой игре, "башня" может захватывать фишки противника, "перепрыгивая" через них, по правилам "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Русских шашек</a>". При выполнении прыжка, под низ стопки берётся самая верхняя фишка из атакуемой башни. Таким образом, выполняя взятие, можно освобождать свои фишки, захваченные "башней" противника ранее. Также как и в "Русских шашках", прохождение через последнюю горизонталь превращает верхнюю фигуру стопки в дальнобойную дамку. Дамки захватываются и освобождаются наравне с обычными фигурами, не теряя своих качеств.

<img align="center" src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"/>

Существует и вариант "столбовых" шахмат. Также как в "Столбовых шашках", фигуры в "<a href="http://cyclowiki.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Таврелях</a>" могут устанавливаться друг на друга (на короля устанавливать другие фигуры запрещается). Принадлежность и допустимые ходы такой "башни" определяются фигурой, находящейся сверху. Превращённая пешка, захваченная "башней", теряет свой статус и вновь превращается в обычную. Допускается построение "башен" и на фигурах своего цвета. В отличии от "Столбовых шашек", разделение "башни" происходит по желанию игрока. Игрок может даже освободить фигуру противника, захваченную им ранее (такой ход может оказаться полезным при возникновении угрозы <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82">пата</a>).

В <a href="http://habrahabr.ru/post/234587/">Ритмомахии</a> состав "башни" определяет список доступных ей ходов и это единственная известная мне игра, в которой фигуру можно "убивать по частям". Ещё более сложная, в этом отношении, игра описана <a href="http://abstractstrategygames.blogspot.nl/2010/11/battle-of-towers-12.html">здесь</a>. Выстраивание фишек "друг на друга" не является прерогативой шашек и шахмат. Эта возможность востребована и в других играх, например, в различного вида "<a href="http://skyruk.livejournal.com/290069.html">боевых гонках</a>". В "<a href="http://habrahabr.ru/post/225631/">Урской игре</a>" (в её <a href="http://skyruk.livejournal.com/231444.html?thread=4494868">варианте</a> от <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрия Скирюка</a>), фишка, поставленная сверху, блокирует движение всех фишек, оказавшихся под ней. Встречаются и игры, в которых, "оседлав" фишку противника, можно "покататься" на ней за чужой счёт.

Реализация "башенных" игр в ZoG никогда не была и не будет простой. Основная проблема связана с тем, что каждая ячейка доски, в этом "конструкторе игр" не может содержать более одной фигуры. Такой подход удобен в "шахматных" играх, поскольку переход на поле, занятое другой фигурой, означает автоматическое взятие последней (что позволяет сэкономить одну команду в описании хода), но как только в игре начинают фигурировать "башни", её описание превращается в кошмар. Впрочем, иногда удаётся выкрутиться.

<img align="center" src="https://habrastorage.org/files/158/754/d87/158754d873e047b2a9e5d0622f71ec08.PNG"/>
В Ритмомахии у каждого игрока всего по одной составной фигуре. Это позволяет держать на поле некую "фиктивную" фигуру, изображающую пирамиду, а где-то в стороне от доски выводить её "расшифровку". Разумеется, такой подход не избавляет от головных болей полностью. Возникает масса "интересных" моментов. Например, когда "поедается" последняя фигура в пирамиде, очень важно удалить с доски и её "маркер". В противном случае, на доске останется "пустая" фигура, не способная "ходить" и быть "взятой", но мешающая движению других фигур. С учётом сложности правил самой Ритмомахии, реализацию такой игры никак нельзя назвать простой.

В "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2262">Уре</a>" был применён аналогичный трюк. Выстраивать фишки "в стопки", в этой игре, можно лишь на определённых полях и высота "стопки" не может превышать четырёх фишек. Для этих специальных полей были созданы своего рода "карманы", в которые складывались заблокированные фишки, при их захвате. Когда верхняя фишка покидала "стопку", последнюю из захваченных фишек следовало переложить из "кармана" на поле доски. Описание игрового поля превратилось в настоящий лабиринт:

<spoiler title="Поле ''Урской игры''">
<source lang="lisp">
(define board-defs
  (image "images/Ur/ur.bmp")
  (grid
     (start-rectangle -483 27 -422 99)
     (dimensions
         ("i/j/k/l/m/n/o/z/a/b/c/d/e/f/g/h/y/x" (67 0)) ; files
         ("4/3/2/1/0" (0 68)) ; ranks
     )    
  )
  (dummy offboard)
  (links afree (z2 a4) (a4 b4) (b4 c4) (c4 d4) (d4 e4) (e4 f4) (f4 g4) (g4 offboard) )
  (links bfree (z2 a0) (a0 b0) (b0 c0) (c0 d0) (d0 e0) (e0 f0) (f0 g0) (g0 offboard) )
  (links anext (a0 d1) (b0 d1) (c0 d1) (d0 d1) (e0 d1) (f0 d1) (g0 d1)
               (d1 c1) (c1 b1) (b1 a1) (a1 a2) (a2 b2) (b2 c2) (c2 d2) 
               (d2 e2) (e2 f2) (f2 g2) (g2 g1) (g1 h1) (h1 h2) (h2 h3)
               (h3 g3) (g3 g2)
  )
  (links cnext (h2 h3) (h3 g3) (g3 g2) (g2 f2) (f2 e2) (e2 d2) (d2 c2)
               (c2 b2) (b2 a2) (a2 z2) 
  )
  (links bnext (a4 d3) (b4 d3) (c4 d3) (d4 d3) (e4 d3) (f4 d3) (g4 d3) 
               (d3 c3) (c3 b3) (b3 a3) (a3 a2) (a2 b2) (b2 c2) (c2 d2) 
               (d2 e2) (e2 f2) (f2 g2) (g2 g3) (g3 h3) (h3 h2) (h2 h1) 
               (h1 g1) (g1 g2)
  )
  (links dnext (h2 h1) (h1 g1) (g1 g2) (g2 f2) (f2 e2) (e2 d2) (d2 c2)
               (c2 b2) (b2 a2) (a2 z2)
  )
  (links next  (x1 x2) (x2 x3) (x3 offboard) )
  (links up    (b1 i1) (i1 i2) (i2 i3) (i3 offboard)
               (d1 j1) (j1 j2) (j2 j3) (j3 offboard)
               (b3 k1) (k1 k2) (k2 k3) (k3 offboard)
               (d3 l1) (l1 l2) (l2 l3) (l3 offboard)
               (g2 m1) (m1 m2) (m2 m3) (m3 offboard)
               (c2 n1) (n1 n2) (n2 n3) (n3 offboard)
               (f2 o1) (o1 o2) (o2 o3) (o3 offboard)
  )
  (symmetry Up  (anext bnext) (cnext dnext) (afree bfree))
  (symmetry ?Up (anext bnext) (cnext dnext) (afree bfree))
  (zone
     (name dices)
     (players ?Dice)
     (positions x1 x2 x3)
  )
  (zone
     (name dices-lock)
     (players ?Dice)
     (positions x0)
  )
  (zone
     (name promotion)
     (players Down)
     (positions h1)
  )
  (zone
     (name promotion)
     (players ?Up Up)
     (positions h3)
  )
  (zone
     (name rosette)
     (players ?Up Up Down)
     (positions a1 a3 d2 g1 g3)
  )
  (zone
     (name end)
     (players ?Up Up Down)
     (positions z2)
  )
)
</source>
</spoiler>
Это решение вряд ли можно считать идеальным. Игрокам приходится запоминать все фишки, заблокированные в "карманах", ведь на поле они никак не отображаются! Кроме того, человеку не знакомому с игрой, может быть сложно разобраться с тем, что происходит на доске - фишки исчезают и появляются без какой либо очевидной системы. В некоторых случаях, удобнее использовать другой подход. Если поле доски может содержать лишь одну фигуру - пусть фигурами будут сами "стопки", а не составляющие их фишки! Этот подход идеально работает для игр семейства "<a href="http://skyruk.livejournal.com/410114.html">Манкала</a>", но если порядок в наборе фишек важен и в "стопке" могут содержаться различные фигуры - начинается комбинаторика.

<spoiler title="Комбинаторика, как и было сказано">
<source lang="lisp">
(define merge-w
  (if (piece? w)    (add $1w)    else
  (if (piece? b)    (add $1b)    else

  (if (piece? ww)   (add $1ww)   else
  (if (piece? wb)   (add $1wb)   else
  (if (piece? bw)   (add $1bw)   else
  (if (piece? bb)   (add $1bb)   else

  (if (piece? www)  (add $1www)  else
  (if (piece? wwb)  (add $1wwb)  else
  (if (piece? wbw)  (add $1wbw)  else
  (if (piece? wbb)  (add $1wbb)  else
  (if (piece? bww)  (add $1bww)  else
  (if (piece? bwb)  (add $1bwb)  else
  (if (piece? bbw)  (add $1bbw)  else
  (if (piece? bbb)  (add $1bbb)  else

  (if (piece? wwww) (add $1wwww) else
  (if (piece? wwwb) (add $1wwwb) else
  (if (piece? wwbw) (add $1wwbw) else
  (if (piece? wwbb) (add $1wwbb) else
  (if (piece? wbww) (add $1wbww) else
  (if (piece? wbwb) (add $1wbwb) else
  (if (piece? wbbw) (add $1wbbw) else
  (if (piece? wbbb) (add $1wbbb) else
  (if (piece? bwww) (add $1bwww) else
  (if (piece? bwwb) (add $1bwwb) else
  (if (piece? bwbw) (add $1bwbw) else
  (if (piece? bwbb) (add $1bwbb) else
  (if (piece? bbww) (add $1bbww) else
  (if (piece? bbwb) (add $1bbwb) else
  (if (piece? bbbw) (add $1bbbw) else
  (if (piece? bbbb) (add $1bbbb) else

  (if (piece? wwwww) (r w) (add $1wwww) else
  (if (piece? wwwwb)       (add $1wwww) else
  (if (piece? wwwbw) (r w) (add $1wwwb) else
  (if (piece? wwwbb)       (add $1wwwb) else
  (if (piece? wwbww) (r w) (add $1wwbw) else
  (if (piece? wwbwb)       (add $1wwbw) else
  (if (piece? wwbbw) (r w) (add $1wwbb) else
  (if (piece? wwbbb)       (add $1wwbb) else
  (if (piece? wbwww) (r w) (add $1wbww) else
  (if (piece? wbwwb)       (add $1wbww) else
  (if (piece? wbwbw) (r w) (add $1wbwb) else
  (if (piece? wbwbb)       (add $1wbwb) else
  (if (piece? wbbww) (r w) (add $1wbbw) else
  (if (piece? wbbwb)       (add $1wbbw) else
  (if (piece? wbbbw) (r w) (add $1wbbb) else
  (if (piece? wbbbb)       (add $1wbbb) else
  (if (piece? bwwww) (r w) (add $1bwww) else
  (if (piece? bwwwb)       (add $1bwww) else
  (if (piece? bwwbw) (r w) (add $1bwwb) else
  (if (piece? bwwbb)       (add $1bwwb) else
  (if (piece? bwbww) (r w) (add $1bwbw) else
  (if (piece? bwbwb)       (add $1bwbw) else
  (if (piece? bwbbw) (r w) (add $1bwbb) else
  (if (piece? bwbbb)       (add $1bwbb) else
  (if (piece? bbwww) (r w) (add $1bbww) else
  (if (piece? bbwwb)       (add $1bbww) else
  (if (piece? bbwbw) (r w) (add $1bbwb) else
  (if (piece? bbwbb)       (add $1bbwb) else
  (if (piece? bbbww) (r w) (add $1bbbw) else
  (if (piece? bbbwb)       (add $1bbbw) else
  (if (piece? bbbbw) (r w) (add $1bbbb) else
  (if (piece? bbbbb)       (add $1bbbb)

  )))))))))))))))) ))))))))))))))))
  ))))))))))))))))
  ))))))))
  ))))
  ))
)
</source>
</spoiler>
Этот кошмарный макрос - всего лишь небольшой фрагмент моей реализации игры "Фокус", описанной Мартином Гарднером в его "<a href="http://www.twirpx.com/file/67840/">Математических досугах</a>" (полную версию кошмара можно смотреть <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/Focus.zrf">здесь</a>). Сложнее всего было найти и исправить все ошибки. Конечно, можно было бы автоматизировать кодогенерацию при помощи <a href="http://habrahabr.ru/post/214713/">prezrf</a>, но, на самом деле, ещё не известно, какое из этих "двух зол" злее. Впрочем, работает программа великолепно:

<video>http://www.youtube.com/watch?v=7cz8B2Zu-Qs</video>

<spoiler title="Кстати">
В процессе этого "праздника кодирования" выяснилось, что макросам ZoG крайне далеко до <a href="http://en.wikipedia.org/wiki/Higher-order_function">функций высшего порядка</a>. <a href="https://github.com/GlukKazan/ZoG/blob/d3f0d6905b7e345cff46cee0745039496d760a66/Rules/Focus.zrf">Первая версия</a> не работала из за реализации этого макроса:

<source lang="lisp">
(define add-piece 
   (if empty? 
       add 
    else 
       (merge-$1 $2) 
   ) 
) 
</source>
Подстановка параметра <b>$1</b> отрабатывала замечательно, но находить макрос по полученному имени (например <b>merge-w</b>) ZoG решительно отказывалась, хотя в исходном коде он, разумеется, был! Пришлось чуть больше поработать руками.
</spoiler>
Разумеется, этот подход не работает в более сложных случаях. В "Фокусе" размер "стопки" ограничен пятью фишками. Всё что не попадает в это "прокрустово ложе" либо переносится в резерв игрока, либо полностью удаляется с доски (в зависимости от принадлежности фишек игроку, выполняющему ход). В "Столбовых шашках" фигуры не покидают доску никогда! В процессе игры, все 24 фишки <b>могут</b> быть выстроены в одну "башню". При этом, часть фигур может быть дамками! Желающие могут сами подсчитать количество возможных вариантов и сравнить это число с 62 фигурами, использованными для реализации "Фокуса". В "Столбовых шашках" необходимо создавать настоящую трёхмерную доску:

<spoiler title="Описание доски в ''Столбовых шашках''">
<source lang="lisp">
(define Bdef
  (image "images\Bashne\bd8x8x2.bmp")
  (grid
     (start-rectangle 5 45 53 93)
     (dimensions
         ("a/b/c/d/e/f/g/h" (49 0)) ; files
         ("8/7/6/5/4/3/2/1" (0 49)) ; ranks
     )

     (directions 
        (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1)
     )
  )

  (grid
     (start-rectangle 407 89 455 93)
     (dimensions
         ("A/B/C/D/E/F/G/H" (49 0)) ; files
         ("8/7/6/5/4/3/2/1" (0 49)) ; ranks
         ("-1/-2/-3/-4/-5/-6/-7/-8/-9/-10/-11/-12/-13/-14/-15/-16" (0 -3)) ; ranks
     )
     (directions 
       (u 0 0 1)(u5 0 0 5)
       (r 1 0 0) ;scan
     )
  )
)
</source>
</spoiler>
Можно видеть, что Karl Scherer был слишком оптимистичен в отношении максимально возможной высоты "башен". Доска, в его реализации, состоит из двух <b>grid</b>-ов. Левый - представляет собой обычную двумерную доску, на которой игроки перемещают фигуры, но все ходы, выполненные на этой доске, дублируются в правом <b>grid</b>-е, содержащем детальное описание фигур. 

Это наиболее правильный подход к реализации таких игр, но даже с его помощью будет затруднительно реализовать "<a href="http://cyclowiki.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Таврели</a>". С учётом того, что на королевскую фигуру установка других фигур запрещается, "башня" максимальной высоты, в этой игре, может состоять из 31 фигуры (подсчёт количества возможных вариантов построения башен - интересная комбинаторная задача).

Из всего сказанного выше должно быть понятно, что разработка методов эффективного и лаконичного описания "башенных" игр является серьёзным вызовом для разработчика универсального игрового "движка". К сожалению, я не могу сказать, что решил эту проблему. Было бы заманчиво разрешить размещать на поле доски более одной фигуры, но это решение сразу же поднимает ряд острых вопросов. Упорядочен ли набор фигур размещенных на поле? Как определить владельца набора? Какие части набора могут выполнять ход как "единое целое" и по каким правилам? Я не вижу разумных решений на этом пути.

Более перспективной выглядит возможность объединения фигур в наборы, в процессе генерации хода. Можно объединять фигуры, расположенные друг над другом (ещё до выполнения основной фазы генерации хода), и перемещать этот набор как единое целое. Фигуры, расположенные "в стопке" независимы и мы всегда можем определить принадлежность отдельной фигуры и возможность выполнения ей хода. Самое главное, что такой подход универсален. Помимо "башенных" игр, он позволяет описывать все те игры, в которых разрешается перемещать группы фигур за один ход (такие как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2345">Ordo</a> или головоломка "<a href="http://puzzle15.ru/image/3/Упрямый_осел-2-2.jpg">Рыжий осёл</a>", описанная М.Гарднером в тех же "Математических досугах").

К сожалению, вопросы всё равно остаются. Фигуры, объединённые в набор, должны перемещаться "параллельно", в одном направлении, но выбранное направление может быть не определено для какой-то из начальных позиций набора! Также, перемещение может предусматривать выполнение проверок при прохождении промежуточных полей всеми фигурами набора (как в игре "<a href="http://www.iggamecenter.com/info/ru/ordo.html">Ордо</a>"). Совершенно непонятно как сформулировать такие проверки лаконичным и понятным для человека образом. Неясно, как реализовать групповые перемещения, отличные от "параллельного переноса", например такие, как поворот части доски в "<a href="http://boardgamegeek.com/boardgame/19569/turn-tables-checkers">Turn the Tables Checkers</a>". В общем, вопросов хватает. Надеюсь, мне удастся их решить.

<img align="center" src="https://habrastorage.org/files/63f/d1f/995/63fd1f995a044371a0d296c63cb0129e.jpg"/>

В заключение статьи, приведу цитату из замечательного <a href="http://gest.livejournal.com/1027592.html">блога</a> Григория (gest-а), посвящённую ещё одной многомерной <a href="http://www.chessvariants.org/3d.dir/timeline.html">игре</a>:
<blockquote>... У каждого игрока по четыре фигуры. За каждой фигурой остаётся след, отмечающий её перемещения. Можно убивать противника в прошлом, перерезая его темпоральную линию. Можно убивать вражескую фигуру в прошлом и этим воскресать собственную фигуру, в той точке, где противник её бы убил, если бы не был сам убит до этого. В ситуации, когда противник может перерезать темпоральную линию твоей фигуры и этим воскресить фигуру, ранее убитую тобой, можно использовать другую свою фигуру, чтобы убить уже убитую вражескую фигуру ещё раньше.</blockquote>Люди придумали много игр, над которыми можно поломать голову...
</habracut>

«Короли севера» — битва за геймплей

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/6af/80f/d5a/6af80fd5a365964f6326382b551b36bc.jpg"/><i><b>Могу я в Тафл играть
Девять умений я знаю
Забываю нечасто руны
Ведаю книги и счёт
Умею скользить я на лыжах
Гребу и стреляю неплохо
Из искусств мне ведомы оба...

"<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%B3%D0%B0_%D0%BE%D0%B1_%D0%BE%D1%80%D0%BA%D0%BD%D0%B5%D0%B9%D1%86%D0%B0%D1%85">Сага об оркнейцах</a>"</b></i>&nbsp;

История, которую я хочу рассказать, полна загадок, малопонятного кода, бессонных ночей, <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BB%D0%B5%D0%B9%D0%BF%D0%BD%D0%B8%D1%80">шума кошачьих шагов...</a> 
Это одна из тех историй, в которых процесс гораздо важнее результата. Если вам нужен результат, его можно найти <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2351">здесь</a>, но если вам интересны подробности, что же... я готов рассказать о своих мытарствах.
<habracut>
Начиналось всё как обычно. <a href="http://www.youtube.com/user/MrSultanRatrout">Sultan Ratrout</a>, большой любитель настольных игр, нашёл один из моих роликов на YouTube и попросил разработать для него коллекцию наиболее известных игр семейства <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>. Просьба меня удивила. Сказать, что таких программ много - означает лишь несколько преуменьшить. Шашки имеются на любой вкус и для множества различных платформ. В одном только <a href="http://www.zillions-of-games.com">ZoG</a> - более 20 наименований. Дьявол, по обыкновению, оказался скрыт в деталях.

Я уже <a href="http://habrahabr.ru/post/253397/">писал</a> о том, что реализовать шашки полностью корректно и аутентично совсем не просто. Правила превращения шашек в дамки (порой довольно сложные) и "правило большинства" (в его разнообразных трактовках) превращают такую разработку в настоящий тест на внимательность, а сложность реализации правила "турецкого удара", вообще заслуживает отдельного разговора. Увы, при более пристальном рассмотрении, "шашечные" программы для Zillions of Games оказались крайне далеки от идеала.

Первой ласточкой оказался баг, обнаруженный мной в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=218">коллекции</a> шашек от Uwe Wiedemann. В его реализации "Русских шашек", шашка, оказавшаяся в зоне превращения в ходе боя, не продолжала ход в случае, если следующую шашку можно было взять только ходом дамки. Я опубликовал исправление и думал было на этом успокоиться, но взглянув на другие варианты, понял, что проще разработать свой набор игр чем исправить все ошибки в существующих реализациях. Даже вариант от самих разработчиков ZoG, поставляемый вместе с программой, работал с чудовищными ошибками!

В результате, я решил создать свою коллекцию шашек. Разумеется, начал я с внимательного анализа существующих реализаций. Из них же взял и графические ресурсы, подправив мелкие огрехи в графическом редакторе (тот же набор ресурсов уже использовался ранее <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1363">несколькими</a> <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1432">авторами</a>). Из программного кода я узнал много нового. Например, в "Турецких шашках", дамке, в ходе боя, запрещается изменять направление движения на противоположное. Вот как элегантно это реализуется:

<spoiler title="Бой дамкой">
<source lang="lisp">
(define dama-king-jump (
  (while (empty? $1)
      $1
  )
  (verify (enemy? $1))
  $1
  (verify (empty? $1))
  $1
  (while empty?
      mark
      (while empty? 
        (opposite $1)
      ) 
      capture
      back
      (add-partial continuetype)
      $1
  )
))

(define dama-king-continue (
  (while (empty? $1)
      $1
      (verify not-last-from?)
  )
  (verify (enemy? $1))
  $1
  (verify (empty? $1))
  $1
  (while empty?
      mark
      (while empty? 
        (opposite $1)
      ) 
      capture
      back
      (add-partial continuetype)
      $1
  )
))

(game
  (title "Turkish Dama")
  ...
  (move-priorities jumptype normaltype)

  (piece
     (name King)
     (image First "images/wiedem/CheckerKingWhite.bmp"
            Second "images/wiedem/CheckerKingBlack.bmp")
     (moves
        (move-type jumptype)
           (dama-king-jump n)
           (dama-king-jump e)
           (dama-king-jump w)
           (dama-king-jump s)

        (move-type continuetype)
           (dama-king-continue n)
           (dama-king-continue e)
           (dama-king-continue w)
           (dama-king-continue s)

        (move-type normaltype)
           (king-shift n)
           (king-shift e)
           (king-shift w)
           (king-shift s)
     )
  )
)
</source>
</spoiler>
Предикат <b>last-from?</b> проверяет, является ли текущее поле начальным полем предыдущего (частичного) хода. Если мы пересекаем такое поле - значит направление движения дамки изменилось на противоположное и ход выполнять нельзя. Разумеется, такая проверка не должна выполняться в рамках самого первого частичного хода. Здесь на помощь приходят режимы выполнения хода. Первый ход осуществляется в рамках приоритетного режима <b>jumptype</b> и выполняет переключение в <b>continuetype</b>, в рамках которого должны выполняться все последующие ходы. Выяснилось (я не знал этого раньше), что назначаемый явно <b>continuetype</b> не требуется упоминать в списке приоритетов.

Другой приятной неожиданностью оказался способ расчёта "длинного" хода, при бое дамкой, когда дамка, может останавливаться не только на поле следующем непосредственно за сбитой фигурой (как в "<a href="http://thaichess.narod.ru/index/0-36">Тайских шашках</a>"), но и на любом следующем за ним свободном поле. Выяснилось, что необязательно писать портянки из "копи-паста":

<spoiler title="Возможное описание боя дамкой">
<source lang="lisp">
(define king-jump-1 (
  (while (empty? $1)
      $1
  )
  $1
  (verify enemy?)
  capture
  $1
  (verify empty?)
  (add-partial jumptype)
))

(define king-jump-2 (
  (while (empty? $1)
      $1
  )
  $1
  (verify enemy?)
  capture
  $1
  (verify empty?)
  $1
  (verify empty?)
  (add-partial jumptype)
))

(define king-jump-3 (
  (while (empty? $1)
      $1
  )
  $1
  (verify enemy?)
  capture
  $1
  (verify empty?)
  $1
  (verify empty?)
  $1
  (verify empty?)
  (add-partial jumptype)
))
...
</source>
</spoiler>
Напомню, что проблема заключается в том, что очевидная реализация приводит к ошибке, в процессе генерации хода:

<spoiler title="Этот код не работает!">
<source lang="lisp">
(define king-jump (
  (while (empty? $1)
      $1
  )
  $1
  (verify enemy?)
  capture
  $1
  (while empty?
      (add-partial jumptype)
      $1
  )
))
</source>
</spoiler>
<img align="center" src="https://habrastorage.org/files/31a/fc2/2b7/31afc22b7f7141918463b8f9c0588e95.PNG"/>
Правильная реализация чем-то напоминает алгоритм <a href="http://russian.joelonsoftware.com/Articles/BacktoBasics.html">маляра Шлемиэля</a>. От точки возможного завершения хода (в цикле их генерируется несколько), необходимо вернуться в противоположном направлении и удалить первую встреченную вражескую фигуру. Это смешно, но только такой способ и работает!

<spoiler title="Альтернативное решение">
<source lang="lisp">
(define king-jump (
  (while (empty? $1)
      $1
  )
  (verify (enemy? $1))
  $1
  (verify (empty? $1))
  $1
  (while empty?
      mark
      (while empty? 
        (opposite $1)
      ) 
      capture
      back
      (add-partial continuetype)
      $1
  )
))
</source>
</spoiler>
Если вы улыбаетесь, значит мы двигаемся в правильном направлении. Но погодите, мы еще не рассматривали "турецкий удар"! Для того, чтобы не "взять" фигуры противника повторно, их необходимо как-то пометить. Сделать это можно двумя способами. Можно изменить тип фигуры, либо использовать один из её атрибутов (последний способ недоступен в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>). По завершении составного хода, можно удалить все ранее помеченные фигуры.

<spoiler title="Турецкий удар (использование атрибутов)">
<source lang="lisp">
(define checker-captured-find
   mark
   (if (on-board? $1)  
      $1    
      (if (and enemy? (empty? $1) (not captured?)) 
          (set-flag more-captures true)
      )
   )
   back
)

(define checker-jump (
  $1
  (verify enemy?)
  (verify (not captured?))
  (set-attribute captured? true)
  $1
  (verify empty?)
  (set-flag more-captures false)
  (checker-captured-find $1)
  (checker-captured-find $2)
  (checker-captured-find $3)
  (if (not (flag? more-captures))
       mark  
       a0 
       (while (on-board? next) 
          next
          (if captured? capture)
       )
       back  
  )
  (if (in-zone? promotion)
      (add King)
   else
      (add-partial jumptype)
  )
))
...
  (piece
     (name Checker)
     (image First "images/wiedem/CheckerWhite.bmp"
            Second "images/wiedem/CheckerBlack.bmp")
     (attribute captured? false)
     (moves
        (move-type jumptype)
           (checker-jump nw sw ne)
           (checker-jump sw se nw)
           (checker-jump ne se nw)
           (checker-jump se ne sw)

        (move-type normaltype)
           (checker-shift nw)
           (checker-shift ne)
     )
  )
</source>
</spoiler>
Для простоты, здесь рассматривается <a href="http://en.wikipedia.org/wiki/English_draughts">английский вариант</a> шашек. Решение с "дальнобойными" дамками выглядит сложнее. Самый не очевидный момент в этом коде - определение момента завершения составного хода. Решение довольно прямолинейно - чтобы определить, имеет ли ход продолжение, просто выполняем поиск фигуры, которую мы можем "съесть" далее, в одном из трёх направлений (поскольку направления, с точки зрения ZoG, никак не взаимосвязаны, все три приходится передавать в макрос).  Это <b>должно</b> работать! Но это <b>не</b> работает:

<video>http://www.youtube.com/watch?v=cDeY4SXHNFg</video>

В чём дело? Возможно что-то не так с атрибутами? Попробуем изменять тип фигуры:

<spoiler title="Турецкий удар (изменение типа фигур)">
<source lang="lisp">
(define checker-captured-find
   mark
   (if (on-board? $1)  
      $1    
      (if (and enemy? (empty? $1) (not (piece? XChecker))) 
          (set-flag more-captures true)
      )
   )
   back
)

(define checker-jump (
  $1
  (verify enemy?)
  (verify (not (piece? XChecker)))
  (change-type XChecker)
  $1
  (verify empty?)
  (set-flag more-captures false)
  (checker-captured-find $1)
  (checker-captured-find $2)
  (checker-captured-find $3)
  (if (not (flag? more-captures))
       mark  
       a0 
       (while (on-board? next) 
          next
          (if (piece? XChecker) capture)
       )
       back  
  )
  (if (in-zone? promotion)
      (add King)
   else
      (add-partial jumptype)
  )
))
...
  (piece
     (name Checker)
     (image First "images/wiedem/CheckerWhite.bmp"
            Second "images/wiedem/CheckerBlack.bmp")
     (moves
        (move-type jumptype)
           (checker-jump nw sw ne)
           (checker-jump sw se nw)
           (checker-jump ne se nw)
           (checker-jump se ne sw)

        (move-type normaltype)
           (checker-shift nw)
           (checker-shift ne)
     )
  )
  (piece
     (name XChecker)
     (image First "images/wiedem/CheckerWhite.bmp"
            Second "images/wiedem/CheckerBlack.bmp")
  )
</source>
</spoiler>
<video>http://www.youtube.com/watch?v=31DTN-I04D4</video>

Уже лучше! По крайней мере, этот зомби не пытается нас съесть! Именно так и выглядит эта ошибка в официальной редакции "Русских шашек" от разработчиков Zillions of Games. Последняя взятая фигура не удаляется с доски. Ходить она конечно не может, но мешает движению других фигур! Для того, чтобы разобраться, в чём тут дело, выгрузим протокол этой "мини-игры" в ZSG-файл:

<spoiler title="ZSG-лог">
1. partial 2 Checker a5 - c7 = XChecker on b6
1. partial 2 Checker c7 - e5 = XChecker on d6
1. partial 2 Checker e5 - g7 = XChecker on f6 x b6 x d6
</spoiler>
Всё дело в последнем ходе. Мы "помечаем" фигуру на поле <b>f6</b> для удаления, но не удаляем её вместе с другими! Очевидно, что программа просто не может этого сделать. При использовании атрибутов, лог выглядит сложнее, но суть остаётся неизменной. Мы не можем удалить фигуру, с которой что-то делали в рамках того же частичного хода. Меняли ли мы атрибут или тип фигуры - неважно. Немедленное удаление такой фигуры - несовместимо с возможностями ZSG-нотации!

Решение проблемы очевидно, хотя и не делает код более "читабельным". Последнюю фигуру "помечать" не нужно, её надо просто "брать":

<spoiler title="Бой в русских шашках">
<source lang="lisp">
(define russian-checker-jump (
  (verify (not captured?))    
  $1
  (verify enemy?)
  (verify (not captured?))
  $1
  (verify empty?)
  (set-flag more-captures false)
  (if (in-zone? promotion)
      (king-captured-find $1)
      (king-captured-find $2)
      (king-captured-find $3)
   else
      (checker-captured-find $1)
      (checker-captured-find $2)
      (checker-captured-find $3)
  )
  (if (flag? more-captures)
      (opposite $1)
      (markit)
      $1
  )
  (if (not (flag? more-captures))
      (opposite $1) 
      (if enemy?
          capture
      )
      $1
      (capture-all)
  )
  (if (in-zone? promotion)
      (if (flag? more-captures)
          (add-partial King jumptype)
       else
          (add King)
      )
   else
      (if (flag? more-captures)
          (add-partial jumptype)
       else
          add
      )
  )
))
</source>
</spoiler>
Разобравшись со всеми этими проблемами, я быстренько "наштамповал" джентельменский набор игр, включающий в себя обязательные <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">турецкие</a>, <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BC%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">армянские</a>, <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">английские</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">русские</a> шашки. Экзотика была представлена <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D0%BD%D1%8B">осетинскими</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%B1%D0%B8%D1%82">хакасскими</a> шашками, но коллекции всё ещё не хватало "изюминки". 

Эту позицию я решил застолбить за "<a href="http://gamesofword.ru/article/view-35.html">Северными шашками</a>". От привычных нам "Русских шашек" этот вариант отличается всего одним правилом: "съеденная" дамка не убирается с доски, а "понижается в звании" до обычной шашки. Это, казалось бы, небольшое отличие в корне меняет характер игры в эндшпиле. Достаточно сказать, что две дамки довольно легко ловят одну, даже в том случае, если она находится на "большаке" - главной диагонали доски!

Выбор был сделан, осталось воплотить его в жизнь. Первый вариант играл приблизительно так:

<video>http://www.youtube.com/watch?v=iSBLz_Qb7q4</video>

Очень брутально, но не совсем так как хотелось. Когда в игре (как в <a href="http://en.wikipedia.org/wiki/Chu_shogi">Chu Shogi</a>) есть всего пара фигур, способных "съесть" любую фигуру противника и вернуться на место в течение одного хода, это может быть забавно, но когда таких фигур много и они дальнобойные... геймплей серьёзно страдает. Стало понятно, что надо как-то запрещать возможность повторного "поедания" фигуры в течение одного хода, но как это сделать?

В ZoG выбор невелик. Предикат <b>last-from?</b>, не позволит решить проблему, так как дамка, способна "съесть" фигуру на возвратном движении и не дойдя до стартового поля предыдущего хода. Позиционные флаги, позволяющие привязать булевское значение к произвольному полю, увы, не подошли. Было большое искушение воспользоваться ими, поскольку документация гарантирует их автоматическую очистку в начале каждого хода. 

К сожалению, эта очистка происходит в начале каждого <b>частичного</b> хода и, как средство передачи информации между частичными ходами, позиционные флаги совершенно бесполезны! Остались атрибуты. Можно помечать "взятые" фигуры установкой атрибутов, но, в этом случае, мы должны позаботится об их очистке между составными ходами.

<video>http://www.youtube.com/watch?v=mhw8se370fE</video>

С этим и был связан очередной баг (заметить и локализовать его было непросто). Хотя очистка атрибутов и выполнялась при перемещении фигур, атрибут той фигуры, которая выполняла ход, похоже не очищался. Разобраться с этим вновь помог ZSG-лог (в списке ходов, отображаемых программой, информация об изменении значений атрибутов скрывается):

<spoiler title="ZSG-лог">
1. partial 3 King d8 - a5 = Checker on c7 @ c7 0 1
1. partial 3 King a5 - e1 = Checker on c3 @ c3 0 1
1. Checker c7 - b6 @ c3 0 0 @ c7 0 0
2. partial 3 King e1 - a5 x c3
2. Checker b6 - c5 @ b6 0 0
</spoiler>
В третьей строке можно видеть, что очистка атрибутов производится, но атрибут очищается на позиции <b>c7</b>, в то время как фигура уже переместилась с этого поля на <b>b6</b>! После внесения необходимых исправлений, всё стало работать так, как планировалось:

<spoiler title="north-shift">
<source lang="diff">
(define clear-all
   mark  
   a0 
   (while (on-board? next) 
      next
      (if (piece? Checker)
          (set-attribute captured? false)
      )
   )
   back  
)

(define north-shift (
  (clear-all)
  $1
  (verify empty?)
  (if (in-zone? promotion)
      (add King)
   else
+     (set-attribute captured? false)
      add
  )
))
</source>
</spoiler>
<video>http://www.youtube.com/watch?v=Vz_GEFCWeA0</video>

Оставалась ещё одна проблема. В начале игры, "Северные шашки" ничем не отличались от "русских", а до дамок надо было ещё дожить. Так родился вариант "Северные короли", в котором игра начиналась с дамок! Массовая доступность дальнобойных дамок в самом начале игры, а также их феноменальная живучесть обеспечили игре совершенно уникальный, "взрывной" геймплей. Эту игру я считаю "жемчужиной" своей коллекции:

<video>http://www.youtube.com/watch?v=FmqjnYi_MuM</video>

На этой радостной ноте можно было бы и закончить. В самом деле, коллекция готова, всё работает, в ней есть пара-тройка уникальных игр. Но несколько моментов серьёзно омрачают мою радость. Во первых, эти постоянные "танцы на граблях" делают код таким запутанным, что я не поручусь за то, что в нём совсем не осталось ошибок (и это гложет меня по ночам). Кроме того, часть проблем мне так и не удалось решить. 

В "Ossetian Kena" шашки могут перепрыгивать через дружественные фигуры. Хочется иметь возможность перемежать такие ходы с боем вражеских фигур в произвольном порядке, но это не работает! Даже без учёта того, что для таких ходов (<a href="http://habrahabr.ru/post/253397/">даже теоретически</a>) сделать взятие обязательным невозможно, сама попытка "зациклить" ходы таким образом приводит к немедленной ошибке.

<spoiler title="Осетинские Кены">
<source lang="lisp">
  (piece
     (name Checker)
     (image First "images/wiedem/CheckerWhite.bmp"
            Second "images/wiedem/CheckerBlack.bmp")
     (moves
        (move-type jumptype)
           (checker-jump n)
           (checker-jump e)
           (checker-jump w)
           (checker-jump s)

        (move-type continuetype)
           (checker-jump n)
           (checker-jump e)
           (checker-jump w)
           (checker-jump s)
;          (ken-jump-variant n)
;          (ken-jump-variant e)
;          (ken-jump-variant w)
;          (ken-jump-variant s)

        (move-type normaltype)
           (checker-shift n)
           (checker-shift e)
           (checker-shift w)
           (ken-jump-variant n)
           (ken-jump-variant e)
           (ken-jump-variant w)
           (ken-jump-variant s)
     )
  )
</source>
</spoiler>
Стоит убрать эти комментарии и всё ломается! Даже если помечать дружественные фигуры, запрещая повторные прыжки через них, это не помогает. Если говорить о "пометках", то большой удачей является то, что ни в одном из вариантов шашек не требуется запрещать повторное прохождение через пустые поля. Это удача, поскольку реализовать такой запрет в ZoG нельзя (во всяком случае простым способом). Позиционные флаги могли бы помочь в этом, но... видимо не в нашей вселенной.

ZoG, в свою очередь, всегда готова подложить новый сюрприз:

<video>http://www.youtube.com/watch?v=P0sRU19KCTA</video>

Да, да, программа ведёт себя по разному в зависимости от того, выполняется ли она под управлением AI или в ручном режиме! Дальнобойные дамки, правило большинства и турецкий удар - когда все "три всадника" собираются вместе... AI может начать вести себя странно. Причём, даже когда я снимал этот ролик, ошибка проявлялась не детерминированно - иногда бралась одна шашка, иногда две. Я не знаю как с этим бороться. Приходится идти на компромисс с совестью и отключать одну из трёх опций. Например, в "Международных шашках" пришлось отказаться от "правила большинства". 

В любой, даже самой большой, бочке мёда всегда найдётся место для маленькой ложечки дёгтя...
</habracut>

Dagaz: Пинки здравому смыслу (часть 4)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>Пусть же вихрем сабля свищет!
Мне Костаки не судья!
Прав Костаки, прав и я!
...

<a href="https://ru.wikiquote.org/wiki/%D0%9A%D0%BE%D0%B7%D1%8C%D0%BC%D0%B0_%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2">Козьма Прутков</a> "<a href="http://www.klassika.ru/stihi/prutkov/spit-zaliv-ehllada.html">Новогреческая песнь</a>"</i></b>&nbsp;

<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">Мат</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82">пат</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировки</a> и <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a>. Может ли какая-то другая игра (кроме Шахмат) доставить большую головную боль разработчикам? Конечно же да! И я уверен, что большинство из вас <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">эту игру</a> знает...
<habracut>
<h4><b>7. Турецкий удар</b></h4>
В основе проблемы вновь лежат форсированные ходы. Играть в большинство из <a href="http://www.di.fc.ul.pt/~jpn/gv/checkers.htm">вариантов шашек</a>, без выполнения правила обязательного взятия, было бы совсем не интересно. Если можешь съесть фигуру игрока - надо её есть (даже если тебе это очень невыгодно)! Этот принцип лежит в основе всей комбинационной игры в шашки. Я знаю всего одну игру из этого семейства, в которой правило обязательного взятия не используется (и это хороший пример исключения лишь подтверждающего правила).

<img align="left" src="https://habrastorage.org/files/7c0/09e/da6/7c009eda6cf5482fa00cf9abe2070aad.gif"/><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1800">Осетинские шашки</a>, по всей видимости, являются одной из древнейших шашечных игр. Хотя в ней и используется "шашечный" принцип боя (перепрыгиванием через фигуру противника), отличий от привычных нам шашек пожалуй больше чем сходства. В игре не используется шахматная доска. Отсутствует превращение фигур. Фигуры ходят "только вперёд" (по вертикали или диагоналям) на одну клетку и, дойдя до последней линии, теряют возможность выполнять "тихие ходы". Из этой позиции фигуры всё-таки могут продолжать двигаться, поскольку бить фигуры противника разрешается в любом направлении. Самым важным отличием от других шашечных игр является тот факт, что взятие в "Осетинских шашках" не является обязательным. А главным объединяющим фактором является то, что одним ходом можно брать несколько фигур противника сразу! Взятие осуществляется "по цепочке" - выполнив "ударный" ход, фигура может продолжить движение, при условии, что на следующем шаге она возьмёт ещё одну фигуру.&nbsp;

<spoiler title="К вопросу о ''Кенах''">
В настоящее время, на территории Осетии, распространена другая интересная шашечная игра. В <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D0%BD%D1%8B">Кены</a> играют на привычной нам доске 8x8. Начальная расстановка аналогична "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Турецким шашкам</a>". На последней горизонтали происходит превращение фигур в дальнобойные дамки (Перец). Ходы фигур также осуществляются по правилам, сходным с применяемыми в "Турецких шашках", за исключением того, что не превращенной фигуре (Кену) разрешено бить назад, а также перепрыгивать через дружественные кены (без боя, конечно), стоящие рядом (аналогичного правила нет ни в одной другой из традиционных шашечных игр).

Правило перепрыгивания через дружественные фигуры может быть понято по разному. Можно ли прыгать назад (если взятие назад разрешено)? Разрешается ли перепрыгивать несколько своих фигур "по цепочке" и, если да, то можно ли перемежать перепрыгивание через свои фигуры со взятием вражеских? К сожалению, все описания "Кенов", которые мне удалось найти, обходят эти вопросы стороной. Единственное, в чём они солидарны - это то, что такое перепрыгивание не разрешается превращенным дамкам (через свои дамки перепрыгивать тоже нельзя). Чтобы как-то разобраться в этом вопросе, я разработал свою реализацию "Кенов" и выложил ролик на YouTube:

<video>http://www.youtube.com/watch?v=1GKtBh-uA3U</video>

Несколько дней назад моё ожидание увенчалось успехом. <a href="http://www.youtube.com/user/MrSultanRatrout">Sultan Ratrout</a> снабдил меня подробнейшими комментариями по этой игре. Вот что он пишет:

<blockquote>
<i>There are some similarities between the two checkers games "Kena" and "Kens" Your implementation of the game is correct. It’s called Ossetian Kena or simply Kena.  
...
Kens is a game influenced by the Osseitan Kena. As for Kens rules, they are found on the websites “di.fc and boardgamsgeek”. Kens has the same rules of Turkish checkers except that Kens cant jump a friendly piece backwards and kens cant jump more than one friendly piece consecutively.
...</i></blockquote>
Выяснилось, что существует не одна а две похожих игры "Kens" и "Kena" (не исключено, что это разделение произошло именно по причине недостаточно детального описания правил). В одной из них, перепрыгивать назад и "по цепочке" нельзя, в другой - разрешается. По всей видимости, и в том и другом варианте взятие является обязательным.

Наличие подробных описаний игр в общедоступных источниках - это действительно больной вопрос. Мы практически потеряли <a href="http://skyruk.livejournal.com/244920.html">Петтейю</a> и <a href="http://skyruk.livejournal.com/246450.html">Латрункули</a> просто из за того, что древние греки и римляне, при всей своей любви к этим играм, просто не удосужились описать их правила! Хоть как-то (и скорее всего неправильно) мы можем играть в <a href="http://skyruk.livejournal.com/246910.html">Хнефатафл</a> лишь благодаря запискам <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%BD%D0%B5%D0%B9,_%D0%9A%D0%B0%D1%80%D0%BB">Карла Линнея</a>. Попытки реконструкций древних игр напоминают запутанный <a href="http://skyruk.livejournal.com/231444.html">детектив</a>.

Мы уже потеряли множество настольных игр и продолжаем их терять. Полные правила "<a href="http://skyruk.livejournal.com/459139.html">Воздушного боя</a>" известны теперь лишь одному безымянному коллекционеру. Мы знаем, что <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BB%D0%B8%D0%BD,_%D0%98%D0%BE%D1%81%D0%B8%D1%84_%D0%92%D0%B8%D1%81%D1%81%D0%B0%D1%80%D0%B8%D0%BE%D0%BD%D0%BE%D0%B2%D0%B8%D1%87">Сталин</a>, по всей видимости, любил настольные игры, но похоже, что теперь уже никто не вспомнит как ходят <a href="http://skyruk.livejournal.com/459330.html">эти фигуры</a>. Я обращаюсь ко всем читателям. Если вам известны правила экзотических и даже самых обычных настольных игр - делитесь с ними. Уточняйте описания в <a href="https://www.wikipedia.org/">Wikipedia</a> и других общедоступных источниках. Пишите людям, собирающим правила игр, не стесняйтесь их поправлять, если они ошибаются. Не дайте этим знаниям пропасть безвозвратно!
</spoiler>
Итак, взятие в шашечных играх является составным ходом, в процессе выполнения которого позиция на доске может изменяться. Если вы не видите в этом проблемы, внимательно посмотрите еще раз. В наиболее древних вариантах игры (осетинском и турецком) взятые фигуры просто убираются с доски, по мере выполнения хода. При этом, одно и то же поле доски может посещаться несколько раз. Единственное ограничение, действующее в "Турецких шашках", заключается в том, что в процессе боя фигур, дамка не может изменять направление движения на противоположное. Такой способ боя (в честь породившей его игры) назвали "турецким ударом" и его мощь (особенно в исполнении дальнобойной дамки) ужасает:

<video>http://www.youtube.com/watch?v=fAzYFoXMqfQ</video>

В большинстве современных вариантов игры, действуют специальные правила, делающие выполнение "турецкого удара" невозможным. Взятые фигуры остаются на доске до завершения хода и не могут быть взяты повторно (чтобы отличать их от других фигур, в процессе выполнения "ударного" хода, их обычно переворачивают, а по его завершении убирают с доски все разом). Другой важный вопрос касается того, как именно должно трактоваться правило обязательного взятия, при выполнении составного хода. И здесь возможны варианты...

Проще всего считать, что на любом этапе выполнения хода, взятие является обязательным. Начав "ударный" ход одной из фигур, мы обязаны продолжать его до тех пор, пока имеется возможность боя вражеских фигур. Иными словами, "цепочку взятий" нельзя прерывать, её необходимо пройти до конца. В семействе шашечных игр мне известна всего одна игра (с обязательным взятием) где это правило не действует. Для нас это экзотика, но на Мадагаскаре <a href="http://en.wikipedia.org/wiki/Fanorona">Фанорона</a> весьма популярна.

<video>http://www.youtube.com/watch?v=64ar37WY2Uc</video>

Первым, в глаза бросается совершенно непривычный для нас способ взятия фигур. Фанорона относится к редкой разновидности "контактных" шашек (другой интересный представитель этого направления - современная игра <a href="http://www.mindsports.nl/index.php/arena/bushka/81-rules?showall=&start=3">Bushka</a>). Для того чтобы удалить фигуру противника с доски, нужно подойти к ней вплотную, либо отойти от неё. Удаляется не только атакованная фигура, но и все вражеские фигуры, стоящие за ней по направлению атаки. Пожалуй, этот момент лучше <a href="http://www.boardgamesoftheworld.com/fanorona.html">проиллюстрировать</a>:

<img align="center" src="https://habrastorage.org/files/8d9/415/61a/8d941561af494e89bafc5c735d32f453.jpg"/>

Взятие в Фанороне, также как и в шашках, является составным ходом. Атакующая фигура может продолжать брать всё новые и новые фигуры противника, если она имеет такую возможность. Единственное что ей запрещено - это, в процессе боя, менять направление движения на противоположное (почти как в "Турецких шашках"). Уникальным отличием Фанороны от других шашечных игр является то, что игрок может прервать цепочку взятий в любой момент, по своему усмотрению (досадно, что в некоторых <a href="https://play.google.com/store/apps/details?id=org.thibault.android.fanoronafree">реализациях</a> игры под Android упущен столь важный элемент игровой механики). При этом, первое взятие является обязательным. Нельзя выполнить "тихий" ход, если есть возможность боя фигур противника.

Одни элементарные правила, соединяясь с другими, образуют всё новые и новые разновидности игр. В большинстве из вариантов шашек, серия взятий должна быть завершена. Во многих из них, на последней горизонтали, происходит превращение обычных фигур в дамки. Но как быть, если превращение произошло в процессе "рубки"? Различные варианты игры подходят к решению этого вопроса по разному.

В армянских и русских шашках, превращение происходит в процессе боя - фигура, ставшая дамкой, продолжает взятие уже по новым правилам. В турецких, старофранцузских и английских шашках превращение происходит лишь по завершении хода. В турецких шашках, фигура может продолжать бой (если есть такая возможность), но поскольку "рубка" назад запрещена, фигура остаётся в зоне превращения. В старофранцузском и английском вариантах, простая шашка на последней горизонтали просто не может продолжать движение и останавливается.

<spoiler title="Кстати">
<img align="left" src="https://habrastorage.org/files/413/67a/413/41367a4133f443769889be7d02ee8091.jpg"/>Оригинальным образом решается эта проблема в другой древнейшей игровой системе - "<a href="http://posle-raboti.msk.ru/index/drugie_igry_s_shashkami/0-62">Сенегальских шашках</a>". Превращения фигур, в этой игре, не происходит. Рубка и ходы назад запрещены - фигуры могут двигаться и "рубить" только вперёд и вбок. Шашки, дошедшие до последней горизонтали - просто снимаются с доски! Это правило совершенно лишает игроков стимула к продвижению фигур. Выгодно как можно дольше вести игру в центре доски! Как только фигуры теряют возможность рубить друг друга - игра заканчивается. Побеждает тот игрок, у которого осталось больше фигур.
</spoiler>
Забавную метаморфозу претерпевает это правило в международных, 100-клеточных шашках. Превращение, по прежнему, происходит лишь по завершении хода, но "рубка" назад не только разрешена, но и обязательна! Фигура должна продолжать бой и если в его процессе она покидает последнюю горизонталь - никакого превращения не будет, она останется простой фигурой!

Мы не рассмотрели ещё один, последний вопрос, но он даст фору всем предыдущим. Игрок обязан завершить "цепочку" взятий, но как поступить, если таких "цепочек" несколько? Какой из возможных ходов выбрать? Здесь мнения также расходятся. Наиболее либеральных правил придерживаются "Русские шашки". В них игрок может выбрать любой из возможных вариантов взятий. В турецких и международных шашках действует "правило большинства" в его классической трактовке: из всех возможных вариантов взятия, игрок обязан выбрать тот, при котором берётся наибольшее количество фигур противника (простые это фигуры или дамки - не имеет значения).

Во всей своей красе "социальное неравенство" предстаёт в "Итальянских шашках". В этой игре, простая шашка не только не может бить дамку, но и ценится ниже! Требуется бить максимально возможное количество фигур соперника, а при равном их количестве, брать максимальное количество дамок. Своего апогея эта дискриминация достигает в другой итальянской игре. В <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1260">Damone</a>, помимо дамок есть еще и "императоры", неприкосновенные для всех нижестоящих фигур. Этим игра напоминает <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1267">Dablot</a>, но, в отличии от последнего, превращения в ней всё же возможны. Простые шашки могут превратится в дамок, а дамки в императоров (повторные превращения запрещены - простая шашка никогда не станет императором).

<img align="center" src="https://habrastorage.org/files/38b/f2c/3d9/38bf2c3d9a9f4b099a8ada4c8f6bd995.JPG"/>

Приоритет другого рода действует в "Португальских шашках" - если имеется выбор между взятием дамкой или простой шашкой, игрок должен рубить дамкой. Самая сложная формулировка "правила большинства" действует в "Старофранцузских шашках". Позволю себе <a href="http://skyruk.livejournal.com/256132.html#cutid1">цитату</a>:

<blockquote>
<ul>
	<li><i>Первоначально выбор из двух вариантов взятия был добровольным, вне зависимости от качества и количества шашек, и только в 1653 году было введено Правило большинства (при серийном взятии игрок должен рубить максимально возможное количество).</i></li>
	<li><i>Если при серии взятий можно рубить одинаковое количество шашек простой шашкой или дамкой, игрок обязан брать дамкой. Однако если количество снимаемых шашек одинаково в обоих случаях, но в одной «ветке» есть дамки противника (или их там больше), игрок обязан выбрать именно этот вариант, даже если тогда придется рубить простой шашкой, а не дамкой.</i></li>
	<li><i>Кроме того, ранг снимаемых шашек не имеет значения, серийное взятие подчиняется количеству: брать шашки нужно по максимуму. При выборе взять или 3 простых шашки или 2 дамки игрок обязан взять 3 простых.</i></li></ul></blockquote>
 Думаю, вы уже поняли, что, в плане реализации, шашечные игры ничуть не проще шахмат. Что предоставляет <a href="http://www.zillions-of-games.com/">Zillions of Games</a>, чтобы облегчить жизнь разработчикам? Рассмотрим эти возможности:

<ul>
	<li>Частичные ходы, реализуемые командой <b>add-partial</b></li>
	<li>Приоритеты ходов, определяемые <b>move-priorities</b></li>
	<li>Ряд хитрых настроек настроек, поддерживаемых командой <b>option</b></li>
</ul>
Без поддержки частичных ходов ни о какой реализации шашек речи бы не было. Команда <b>add-partial</b> позволяет объединить последовательность взятий в длинный составной ход. Кроме того, эта команда позволяет выполнить превращение фигуры (например, шашки в дамку) при завершении любого частичного хода (эта возможность пригодится в "Русских шашках"). Единожды выполнив взятие, фигура в шашках не может продолжить ход "тихим" перемещением. Она должна продолжать брать фигуры противника. Очевидно, что требуется какая-то возможность для разделения частичных ходов по типам. И такая возможность есть:

<spoiler title="Типы ходов">
<source lang="lisp">
(define man-jump-add (
   if (not-in-zone? promotion-zone)
      (add-partial jumptype)
   else
      (add-partial King jumptype)
))
...
(piece
   (name Man)
   ...
   (moves
      (move-type jumptype)
      (man-capture nw) (man-capture ne)(man-capture sw)(man-capture se)

      (move-type nonjumptype)
      (man-shift nw) (man-shift ne)
   )
)
</source>
</spoiler>
Если в команде <b>add-partial</b> указан тип хода (<b>jumptype</b> в примере), составной ход может быть продолжен только ходами этого типа. Типы же используются и для задания приоритета ходов:

<source lang="lisp">
(move-priorities jumptype nonjumptype)
</source>
Эта запись означает, что если существует возможность взятия, "тихий" ход выполнять нельзя. В списке приоритетов можно перечислять и более двух типов, но возможность выполнения хода какого-либо типа полностью запрещает все ходы, типы которых следуют далее по списку. Как определяется "правило большинства"? Очень просто и "хардкорно":

<source lang="lisp">
(option "maximal captures" true)
</source>
Можно указать, что при равном количестве фигур следует брать большее количество дамок:

<source lang="lisp">
(option "maximal captures" 2)
</source>
На этом возможности заканчиваются. Например, нельзя указать, что следует брать минимальное количество фигур (зачем это может понадобиться - другой вопрос). Команда <b>option</b> пригодится и в реализации Фанороны:

<source lang="lisp">
(option "pass partial" true)
</source>
Дело в том, что игрок не может просто взять и прекратить выполнение составного хода. Такую возможность необходимо явно разрешить. Мне очень не нравится как сама "магия" команды <b>option</b> так и реализация, с её помощью, пропуска ходов (в данном случае, частичных), но это, пожалуй, тема для отдельного разговора.

<spoiler title="А как быть с ''Турецким ударом''?">
С этим всё сложно. Взятые, в процессе выполнения составного хода, фигуры необходимо помечать (чтобы исключить возможность их повторного взятия), используя атрибуты или превращение фигур. По завершении составного хода, все помеченные фигуры удаляются с доски. Проблема в том, что генератор ходов ZoG не предоставляет какой-либо возможности постобработки. В результате, приходится определять, какой из частичных ходов выполняется последним. 

Код получается очень запутанным (а в случае Фанороны, например, вообще не реализуемым, поскольку решение о завершении хода принимает игрок). Неудивительно, что в таких реализациях полно ошибок. Я часто видел, как часть взятых фигур не удаляется с доски, по завершении составного хода. Встречаются и более сложные случаи. Сможете ли вы найти ошибку в следующем ниже коде?

<spoiler title="Русские шашки">
<source lang="lisp">
(define international-checker-add
   (if (not-flag? more-captures-found?)
       (if (in-zone? promotion-zone) (change-type King) )
       add
      else  
         (add-partial jumptype)    
   ) 
)

(define international-checker-jump-find
   mark
   (if (on-board? $1)  
     $1    
     (if (and enemy? (empty? $1)(not captured?) ) 
        (set-flag more-captures-found? true)
     )
   )
   back
)

(define shashki-jump   
 (
   $1 
   (verify enemy?) 
   (verify (not captured?))    
   (set-attribute captured? true)
   (set-flag more-captures-found? false)              
   (set-flag short-jump? true)              
   $1                                   
   (international-checker-jump-find $1)
   (international-checker-jump-find $2)
   (international-checker-jump-find $3)           
   (opposite $1)               
   (if (flag? more-captures-found?)                    
       (set-attribute captured? true)     
    else  
       mark  
       capture                            
       a0 
       (while (on-board? nxt) 
         nxt
         (if captured? capture (set-flag short-jump? false))           
       )
       back  
     )

   $1 to
   (verify empty?) 
   (verify (or (not-flag? short-jump?) (flag? more-captures-found?)))
   (if (in-zone? promotion-zone) (change-type King))
   (international-checker-add) 
 ) 
)

...
(variant
   (title "Shashki (Russian Draughts)")
   ...
   (piece
      (name Checker)
      ...
      (attribute captured? false)
      (moves
         (move-type jumptype)
             (shashki-jump nw ne sw)
             (shashki-jump ne nw se)
             (shashki-jump sw nw se)
             (shashki-jump se sw ne)

        (move-type nonjumptype)
             (checker-shift nw)
             (checker-shift ne)
      )
   )
   ...
)
</source>
</spoiler>
Это часть весьма удачного <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=218">пакета</a> "шашечных" игр, включающего в себя <a href="http://www.gambiter.ru/checkers/item/276-chess-checkers.html">Белорусские шахматы</a>" (с корректно работающим "матом королём") и "Либерийские шашки" (с очень остроумным запретом завершения игры при трёхкратном повторении позиции), но реализация "Русских шашек" в нём содержит досаднейшую ошибку.

<spoiler title="Ответ">
<img align="center" src="https://habrastorage.org/files/9a5/672/9f2/9a56729f201741fb99bc580bf6112e8b.PNG"/>
В первом случае, всё нормально. Белая шашка берёт две чёрных и превращается в дамку. Вторая диаграмма иллюстрирует ошибку. Белая шашка берёт чёрную, превращается в дамку и остаётся на последней линии, хотя и <b>должна</b>, по правилам "Русских шашек", взять следующую фигуру ходом дамки. 

Локализовав ошибку, исправить её просто. Всё дело в проверках <b>international-checker-jump-find</b>, определяющих, имеется ли у хода продолжение. Этот макрос проверяет, можно ли взять следующую фигуру из целевой позиции, но делает это по правилам не превращённой фигуры. Это работает для "Международных шашек", но в "Русских шашках" не учитывает все возможности. Моё исправление не слишком изящно, но решает проблему:

<spoiler title="Исправление">
<source lang="diff">
+(define shashki-checker-jump-find
+   mark
+   (while (and (on-board? $1) (empty? $1))
+     $1
+   )
+   (if (on-board? $1)  
+     $1    
+     (if (and enemy? (empty? $1)(not captured?) ) 
+        (set-flag more-captures-found? true)
+     )
+   )
+   back
+)

(define shashki-jump   
 (
   $1 
   (verify enemy?) 
   (verify (not captured?))    
   (set-attribute captured? true)
   (set-flag more-captures-found? false)              
   (set-flag short-jump? true)              
   $1                                   
+   (if (in-zone? promotion-zone)
+       (shashki-checker-jump-find $1)
+       (shashki-checker-jump-find $2)
+       (shashki-checker-jump-find $3)           
+    else
       (international-checker-jump-find $1)
       (international-checker-jump-find $2)
       (international-checker-jump-find $3)           
+   )
   (opposite $1)               
   (if (flag? more-captures-found?)                    
       (set-attribute captured? true)     
    else  
       mark  
       capture                            
       a0 
       (while (on-board? nxt) 
         nxt
         (if captured? capture (set-flag short-jump? false))           
       )
       back  
     )

   $1 to
   (verify empty?) 
   (verify (or (not-flag? short-jump?) (flag? more-captures-found?)))
   (if (in-zone? promotion-zone) (change-type King))
   (international-checker-add) 
 ) 
)
</source>
</spoiler>
Если фигура находится в зоне превращения, используем специальную проверку, с пропуском пустых полей по направлению до вражеской фигуры. Следующий частичный ход будет рассчитываться уже по правилам хода дамки, так что там никаких изменений не потребуется.
</spoiler>
Кстати, я уже упоминал, в предыдущих статьях, что описания ходов дамок выглядят просто чудовищно. По какой-то причине, команда <b>add-partial</b> не работает внутри цикла (происходит аварийный останов программы), а дамка, во всех вариантах шашек с дальнобойными дамками (кроме "<a href="http://thaichess.narod.ru/index/0-36">Тайских</a>"), должна иметь выбор, на какое свободное поле, после взятой фигуры, ей приземляться. Конечно, выход был найден:

<spoiler title="Ход дамок">
<source lang="lisp">
(define international-king-jump1      
 ( 
   (international-king-work) 
   to
   (verify (position-flag? allowed?)) 
   (verify (or (not-flag? short-jump?) (flag? more-captures-found?)))
   (international-checker-add)
 )  
)

(define international-king-jump2      
 ( 
   (international-king-work)
    $1 (verify empty?) to
   (verify (position-flag? allowed?)) 
   (verify (or (not-flag? short-jump?) (flag? more-captures-found?)))
   (international-checker-add)
 )  
)

(define international-king-jump3      
 ( 
   (international-king-work)
    $1 (verify empty?) $1 (verify empty?) to
   (verify (position-flag? allowed?)) 
   (verify (or (not-flag? short-jump?) (flag? more-captures-found?)))
   (international-checker-add)
 )  
)
...
(variant
   (title "Shashki (Russian Draughts)")
   ...
   (piece
      (name King)
      ...
      (moves
         (move-type jumptype)
           (international-king-jump1 nw se ne sw)
           (international-king-jump1 ne sw se nw)
           (international-king-jump1 sw ne nw se)
           (international-king-jump1 se nw sw ne)
           (international-king-jump2 nw se ne sw)
           (international-king-jump2 ne sw se nw)
           (international-king-jump2 sw ne nw se)
           (international-king-jump2 se nw sw ne)
           (international-king-jump3 nw se ne sw)
           (international-king-jump3 ne sw se nw)
           (international-king-jump3 sw ne nw se)
           (international-king-jump3 se nw sw ne)
           (international-king-jump4 nw se ne sw)
           (international-king-jump4 ne sw se nw)
           (international-king-jump4 sw ne nw se)
           (international-king-jump4 se nw sw ne)
           (international-king-jump5 nw se ne sw)
           (international-king-jump5 ne sw se nw)
           (international-king-jump5 sw ne nw se)
           (international-king-jump5 se nw sw ne)
           (international-king-jump6 nw se ne sw)
           (international-king-jump6 ne sw se nw)
           (international-king-jump6 sw ne nw se)
           (international-king-jump6 se nw sw ne)
           ...
      )
   )
)
</source>
</spoiler>
Выбор поля, на котором останавливается дамка, переносится на верхний уровень, непосредственно в цикл генерации хода. Это работает, но обилие "копипаста" вылезает за все разумные пределы. Конечно, лекарство от этого тоже есть, но оно ещё <a href="http://habrahabr.ru/post/214713/">хуже болезни</a>.
</spoiler>
В целом, механизмы предоставляемые Zillions of Games вполне работоспособны, если бы не одно но. Реализовать с их помощью "Ossetian Kena", упомянутую под первым спойлером в этой статье, невозможно. Проблема в том, что начиная составной ход мы не знаем, будут ли в процессе его выполнения "съедены" фигуры противника. Кен может перепрыгивать через дружественные кены и бить враждебные, чередуя эти частичные ходы в произвольном порядке, в рамках составного хода.

Очевидно, что "перепрыгивание" и "бой" кеном должны иметь одинаковый тип хода (иначе не удастся построить составной ход, поскольку <b>add-partial</b> может принять только один тип), но этому типу хода не может быть задан более высокий приоритет, поскольку, в противном случае, простые перемещения не будут выполняться практически никогда. Это означает, что правило "обязательного взятия" определить не удастся.

Менее очевидно то, что опцию "<b>pass partial</b>" придётся установить в <b>true</b> (возможность прерывания составного хода игроком). При "перепрыгивании" дружественный кен не удаляется. Обнаружив первый же замкнутый цикл, программа будет прыгать по нему вечно. В редуцированном виде, правила становятся совершенно не играбельными. Обе стороны предпочитают проводить бессмысленные манёвры, а не рисковать своими фигурами, подставляя их под бой противника (это можно видеть в ролике под первым спойлером).

Разумеется, я бы не затевал весь этот разговор, если бы не знал как всё исправить. Для начала, стоит разобраться с тем, что нам мешает в ZRF. Я вижу несколько проблем:

<ul>
	<li>Отсутствие пред- и постобработки при генерации ходов (усложняет логику, мешает реализовать противодействие "Турецкому удару" в играх подобных Фанороне)</li>
	<li>Совмещение функций завершения генерации хода и перемещения фигур в командах <b>add</b> и <b>add-partial</b> (одна из причин, по которой <b>add-partial</b> не может принять несколько типов ходов)</li>
	<li>Использование типов ходов как для управления построением составного хода, так и для задания приоритетов (механизм приоритетов действует лишь на первый частичный ход, но не на составной ход в целом)</li>
	<li>Отсутствие универсального механизма реализации "правила большинства" (используя ZRF, корректно реализовать "Старофранцузские шашки" вряд ли получится)</li>
</ul>
В ZRF определение алгоритма генерации хода монолитно. Нет никакой возможности для выполнения некоего единого кода (до или после выполнения основного алгоритма), в рамках генерации произвольного хода (возможно из некоторой группы), но фактическая потребность в этом есть! Противодействие "турецкому удару" - прекрасная тому иллюстрация. 

Из за необходимости определения последнего частичного хода (в рамках составного хода) код становится совершенно нечитаемым и подверженным разнообразным ошибкам. Мало того, этот подход не совместим с досрочным прерыванием составного хода (опция "<b>pass partial</b>"). Конечно, в Фанороне бороться с "турецким ударом" не требуется (в силу специфики механизма взятия фигур, он невозможен), но игры, в которых такая возможность может понадобиться, вполне имеют право на жизнь.

По поводу того, что совмещение функций перемещения фигур и завершения генерации хода - не самая удачная мысль, я уже неоднократно писал ранее. К счастью, в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> это исправлено. Что касается приоритетов, то я вообще считаю это решение крайне неудачным. Существует более универсальный подход, позволяющий реализовать и приоритеты и "правило большинства" и многое другое. Посмотрим, как определение "Ossetian Kena" могло бы выглядеть в идеальном мире:

<spoiler title="Нарушаемый инвариант">
<source lang="lisp">
(define invariant
   (check (>= capturing-count max-capturing-count))
   (set! max-capturing-count capturing-count)
)

(define goals
   (check-loss no-moves?)
)

(define check-promotion
   (if (in-zone? promotion)
       (promote King)
   )
)

(define check-friend
   (check is-friend?)
   take-piece
)

(define (man-move direction)
   (check direction)
   (check is-empty?)
   drop-piece
   add-move
)

(define (man-jump direction)
   (check direction)
   (check is-friend?)
   (check direction)
   (check is-empty?)
   drop-piece
   (add-move-part jump-type)
)

(define (man-capture direction)
   (check direction)
   (check is-enemy?)
   (increment! capturing-count)
   capture
   (check direction)
   (check is-empty?)
   drop-piece
   (add-move-part jump-type)
)
...
(game
   (title "Ossetian Kena")
   ...
   (pieces
      (attribute capturing-count 0)
      (pre  goals)
      (post invariant)
      (piece 
            (name Man)
            (pre  check-friend)
            (post check-promotion)
            (moves
                (mode normal-type)
                (man-move n)  (man-move w)  (man-move e)
            )
            (moves
                (mode jump-type)
                (man-jump n) (man-jump w) (man-jump e) (man-jump s)
                (man-capture n) (man-capture w) (man-capture e) (man-capture s)
            )
      )
      (piece 
            (name King)
            ...
      )
   )
)
</source>
</spoiler>
Пред- и пост- действия позволяют разбить логику на относительно независимые фрагменты. Например, проверка на превращение в дамку, в этом варианте шашек, должна выполняться по завершении любого частичного хода ещё не превращённой фигурой (<b>Man</b>). Хоть это и небольшой кусок кода, совершенно незачем захламлять им реализацию трёх различных типов ходов. Повторяя один и тот же фрагмент трижды, допустить ошибку в три раза легче (конечно можно использовать макросы, но в данном случае, использование фразы <b>post</b>, в описании типа фигуры, выглядит логичнее).

Иного рода проверки расположены в глобальном разделе описания <b>pieces</b>. Этот код выполняется до и после завершения всего составного хода (именно здесь должно выполняться превращение фигур в "Международных шашках"). Здесь же, фразой <b>attribute</b> можно определять переменные, доступные на любом этапе выполнения составного хода. В <b>capturing-count</b> мы подсчитываем общее количество взятых фигур. Инвариант заключается в том, что это значение не должно быть меньше максимального количества фигур, взятых во всех сгенерированных ходах.

Но как это может работать? Хорошо, если ходы будут генерироваться в направлении уменьшения количества взятых фигур (тогда новые варианты будут отбрасываться при проверке), но мы не можем гарантировать такой порядок генерации ходов! Здесь можно пойти на маленькую хитрость. Помимо проверки, можно сформировать отложенное условие, ассоциированное с каждым сгенерированным ходом. Если, при генерации последующего хода, значение <b>max-capturing-count</b>  изменится, потребуется вновь перепроверить все ранее сгенерированные ходы (их не придётся перегенерировать заново) и отсеять те из них, для которых условие более не выполняется.

Этот механизм подобен тому, который я предлагал для "оптимизированного" вычисления условия завершения <b>no-moves?</b>. Слишком накладно каждый раз выполнять генерацию ходов лишь для того, чтобы определить проигрыш игрока. Гораздо разумнее зарегистрировать отложенную проверку, сгенерировать ходы обычным образом и зафиксировать поражение постфактум, если полученный список ходов пуст. В случае инвариантов, этот механизм используется не в целях оптимизации, а для обеспечения корректного их вычисления. Это то, что я называю "<b>нарушаемым инвариантом</b>" и я считаю, что эта концепция будет мне очень полезна при разработке генератора ходов. Во всяком случае, она гораздо универсальнее механизмов предлагаемых Zillions of Games и Axiom Development Kit.
</habracut>

Dagaz: Пинки здравому смыслу (часть 3)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><b><i>– Ах ты подлец, – задумчиво сказал Воланд. 
– Мессир, я вновь обращаюсь к логике, – заговорил кот, прижимая лапы к груди, – если игрок объявляет шах королю, а короля между тем уже и в помине нет на доске, шах признается недействительным. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Михаил Булгаков "Мастер и Маргарита"</i></b>&nbsp;

"Мат королю!" - многие из нас впитали эти слова с молоком матери. Сама концепция шаха (и мата) кажется очевидной людям знакомым с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматами</a> с детства, но так ли она проста на самом деле? После лёгкой <a href="http://habrahabr.ru/post/248821/">разминки</a> с превращениями фигур, я предлагаю заняться действительно сложными вопросами. 
<habracut>
<h4><b>8. Шах и мат</b></h4>
Главным отличием шахматных игр (помимо характерного способа взятия фигур) является наличие на доске "главной" фигуры - короля. Если игрок теряет короля - он проигрывает, независимо от того, сколько других его фигур осталось на доске. Подобное правило "внезапной смерти" существенно обогащает игру в тактическом плане. Игра становится более комбинационной, игроки пытаются заманить друг друга в ловушку.

Завершение игры по правилу "внезапной смерти" не является шахматным изобретением. В той или иной форме, этот принцип используется во множестве игр. Во всем знакомых "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B5%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%BD%D0%BE%D0%BB%D0%B8%D0%BA%D0%B8">Крестиках-ноликах</a>", для победы, необходимо выстроить свои фигуры "в линию" (и помешать сделать это сопернику). Игра стала бы совсем скучной без этого правила. Просто представьте себе "крестики-нолики" продолжающиеся до тех пор, пока остаётся возможность хода (есть пустые позиции на доске)...

Пример кажется странным, поскольку сама суть "крестиков-ноликов" заключается в выстраивании линий? Вот вам менее очевидный пример: в <a href="http://en.wikipedia.org/wiki/Hasami_shogi">Hasami Shogi</a> фигуры могут двигаться и "поедать" друг друга. Для того, чтобы убрать фигуру противника с доски, её необходимо "взять в клещи", окружив своими фигурами с двух сторон (на самом деле, правила взятия в Hasami Shogi более сложные, но об этом я расскажу как-нибудь в другой раз). Это правило роднит Hasami Shogi с древнейшими игровыми системами "окружных шашек", такими как <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B4%D0%B6%D0%B0">Seega</a>.

Логично предположить, что, как и в Seega, в Hasami Shogi, для победы, необходимо "съесть" все фигуры. Действительно, такой вариант игры существует, но и в нём достаточно взять не все, а лишь ограниченное количество (обычно 5) фигур. Дело в том, что используемый способ взятия (зажиманием "в клещи") весьма медлителен. Для того, чтобы взять фигуру противника, необходимо должным образом разместить <b>две</b> своих фигуры (разумеется, это не отменяет того факта, что одним ходом можно брать несколько фигур сразу). В Seega ситуацию спасает ограниченная подвижность фигур, но в Hasami Shogi фигуры дальнобойные и противник практически всегда может избежать угрозы.

<img align="center" src="https://habrastorage.org/files/b8f/9d4/571/b8f9d457173d4733aec3cbe3da8e69e2.PNG"/>
Правило "внезапной смерти" оказывается как нельзя кстати. В большинстве вариантов Hasami Shogi, победа достигается выстраиванием "в ряд" 5 своих фигур (за пределами их первоначального расположения, иначе было бы не интересно). Взятие фигур противника в них является не целью игры, а лишь тактическим приёмом, помогающим победить. Здесь, как и в "Крестиках-ноликах", условием победы является <b>относительное</b> расположение фигур.

Относительное расположение фигур не обязательно должно быть простым. Например, в игре "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1471">Гекс</a>", для победы, требуется соединить две противоположные стороны доски непрерывной цепочкой фигур своего цвета (не обязательно прямой), а в "<a href="http://habrahabr.ru/post/234587/">Ритмомахии</a>", для достижения "славной победы", фигуры (свои и противника) необходимо связать ещё и арифметическими отношениями (в дополнение к их взаимному расположению).

<img align="center" src="https://habrastorage.org/files/752/682/f5a/752682f5a7c142ee8c98cc62c9d811a4.png"/>
Условие "внезапной смерти" может быть связано и с <b>абсолютным</b> расположением фигур. Так, в китайской игре <a href="http://skyruk.livejournal.com/427724.html">Доу-шу-ци (Джунгли)</a>, для победы, необходимо привести любую из своих фигур в "Логово" противника (отмеченное место на доске). Аналогичное правило вносит тактическое разнообразие в японскую игру <a href="http://geektimes.ru/post/246506/">Doubutsu Shogi</a>. В ней для, для победы, достаточно провести своего короля на последнюю горизонталь доски (при этом, потеря короля - означает поражение). Сходные правила действуют в играх семейства <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%BD%D0%B5%D1%84%D0%B0%D1%82%D0%B0%D1%84%D0%BB">Тафл</a>, но там королевская фигура есть лишь у одной из сторон (это несимметричные игры).

Как я уже говорил выше, наиболее привычная нам трактовка "правила внезапной смерти" связана с потерей главной фигуры или группы фигур. Именно в таком виде оно использовалось в древнейших шахматных играх, таких как <a href="http://en.wikipedia.org/wiki/Chaturanga">Чатуранга</a>. В этой игре требовалось "съесть" вражеского короля ("оголение" короля, то есть взятие всех остальных фигур, также считалось победой). Если говорить о <a href="http://en.wikipedia.org/wiki/Chaturaji">варианте</a> игры для четырёх игроков, то подобная трактовка правил завершения игры является, пожалуй, наиболее разумной. До победы одного из игроков играть гораздо интереснее чем до первого проигрыша.

С этим было связано одно недавнее изменение, которое Howard McCay внёс в мою реализацию <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2273">Yonin Shogi</a> (вариант японских шахмат для четырёх игроков). Помимо адаптации игры под более раннюю версию <a href="http://www.zillions-of-games.com/">Zillions of Games</a> 1.0, он изменил условие победы. Теперь игра не заканчивается взятием одного из вражеских королей. Для победы, необходимо "съесть" их всех! Более того, взятых королей можно выставлять на доску как свои фигуры! В таком виде игра стала гораздо интереснее.

<img align="center" src="https://habrastorage.org/files/f28/465/a54/f28465a5457e49f5bffe74c289a2fd7d.jpg"/>
В четверном варианте Чатуранджи со взятием королей всё тоже не просто. Часто в эту игру играли "пара на пару". Игроки сидевшие друг напротив друга составляли коалицию. Игрок, у которого взяли короля, пропускал ходы (его фигуры как бы "замерзали" на месте), но его напарник мог вернуть взятого короля, забрав одного из королей противников и "обменяв пленных"! Ещё в большей степени этот принцип был развит в "<a href="https://ru.wikipedia.org/wiki/%D0%95%D0%BD%D0%BE%D1%85%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Енохианских шахматах</a>". В этой игре, игрок мог "взять управление" над армией, оставшейся без короля, заняв своим королём "престол" (начальную позицию) последнего.

Другой составляющей понятия шаха (и мата) являются форсированные ходы. Это также не шахматное изобретение. Без понятия форсированных ходов не было бы привычных нам <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашек</a>. В этом семействе игр, игрок, у которого имеется возможность взять фигуру противника, <b>обязан</b> это сделать. Именно это правило делает игру интересной. Подставляя свою фигуру под удар, игрок ограничивает количество возможных ответных ходов противника. Он может строить сложные тактические комбинации, изменяя позицию на доске при помощи жертв.

Честь изобретения (почти) современной шахматной игры принадлежит персам. По всей видимости, именно в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандже</a> были объединены понятия "главной фигуры" и форсированных ходов. Так появилось понятие <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шаха</a> - король не должен оставаться под ударом по завершении хода того игрока, которому он принадлежит. Ход, избавляющий короля от угрозы, является форсированным (не важно, взятие ли это угрожающей фигуры или просто уход в более спокойное место).

Концепция <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_%28%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B%29">мата</a> является естественным логическим продолжением. Если игрок не может избавиться от угрозы своему королю завершив ход - он проиграл. Появилась и ещё одна новая концепция - <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%82">пат</a>, положение в котором король не находится под ударом, но игрок не может сделать ни одного хода, из за угрозы шаха. В Шатрандже, в отличии от современных Шахмат, такое положение (как и "оголение" короля) также приводило к поражению.

<img align="center" src="https://habrastorage.org/files/9a6/1c1/dd9/9a61c1dd91b74ddda5c9b25ab61b79be.jpg"/>
До сих пор всё выглядело вполне логично, но что будет если усложнить правила? Например, как поставить мат нескольким королям? В "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B_%D0%A2%D0%B0%D0%BC%D0%B5%D1%80%D0%BB%D0%B0%D0%BD%D0%B0">Шахматах-Тамерлана</a>" игрок может получить до трёх королей, выполнив превращение королевской пешки и двойное превращение "пешки пешек". В "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%8E_%D1%81%D1%91%D0%B3%D0%B8">Тю Сёги</a>" ситуация аналогична - "Пьяный слон" может превратиться в "Крон-принца" (фактически второго короля).

Японцы, в этой ситуации, не стали мудрить. Королей в "Тю Сёги" можно (и нужно) "есть". В "Шахматах Тамерлана" всё немного сложнее. В этой игре, для победы необходимо поставить мат. Матовать трёх королей одновременно теоретически возможно, но на практике вряд ли осуществимо. Пока на доске два и более короля одного цвета, королей разрешается "брать" (порядок взятия не важен, поскольку все короли взаимозаменяемы), как только на доске остаётся последний король, ему необходимо поставить мат. Фактически, это означает, что королям <b>разрешается</b> находится под шахом, пока на доске есть их "заместители".

Не менее интересны метаморфозы понятия шаха при игре более чем двух игроков. Я уже упоминал выше о Yonin Shogi. Единственное её отличие от традиционных <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> - участие в игре четырёх игроков (и, как следствие, другая начальная расстановка фигур). Результатом этого "небольшого" отличия стала совершенно неадекватная обработка шахов в Zillions of Games версии:

<video>http://www.youtube.com/watch?v=OR74gUlfQNY</video>

И это больше чем просто баг одной конкретной реализации! Давайте немного подумаем. Допустим игрок "Юг" ставит своего короля под удар одной из фигур игрока "Восток", но пока до того дойдёт ход (по часовой стрелке), угроза может быть ликвидирована "Западом" или "Севером" (вероятнее последним, если игра идёт "пара на пару"). Следовательно никакой угрозы не было и "Юг" имел право сделать такой ход! А если "Север" и "Запад" не стали предпринимать <b>ничего</b> в отношении этой угрозы? Как можно видеть, в такой игре понятия шаха и мата имеют мало смысла.

Могут существовать и другие правила, влияющие на возможность матования. Например, существует вариант Сёги, отличающийся от оригинальной игры лишь тем, что игрок не может держать "в руке" более 5 фигур. Это означает, что он не может взять никакую фигуру, если в резерве их уже пять (предварительно он должен сбросить на доску одну из фигур резерва). Это правило ведёт к совершенно анекдотичным матовым ситуациям. Даже если считать угрозу королю абсолютной (не зависящей от заполнения резерва), оно может помешать защититься от шаха, как в показанной ниже позиции (в оригинальной <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%B1%D1%83%D1%86%D1%83_%D1%81%D1%91%D0%B3%D0%B8">Добуцу Сёги</a> нет ограничения на количество фигур в резерве, но я решил его оставить, чтобы сделать реализацию более забавной):

<img align="center" src="https://habrastorage.org/files/9c8/59d/806/9c859d80600f453eb9f64e4b460cd594.JPG"/>
Если до сих пор были цветочки, то сейчас начнутся ягодки. В "<a href="http://www.gambiter.ru/checkers/item/276-chess-checkers.html">Белорусских шахматах</a>" мат можно ставить королём! Дело в том, что помимо шахматных фигур в этой игре действуют шашки. Все фигуры играют по привычным правилам, то есть для шашек взятие обязательно! Причём, даже более обязательно, чем спасение своего короля от шаха! Так и получается, что если противник имеет возможность выполнить взятие одной из своих шашек, можно смело подходить своим королём и матовать его! Очень забавная игра.

Игра может вводить и дополнительные ограничения на мат. Так в Сёги нельзя ставить <a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D1%84%D1%83%D0%B4%D0%B7%D1%83%D0%BC%D1%8D">мат сбросом пешки</a> из резерва (при этом шаховать сбросом пешки не запрещается и матовать обычным ходом тоже). Ещё дальше в плане запретов идёт монгольский вариант шахмат (Шатар). В этой игре мало поставить мат, важно сделать это идеологически правильно (от этого зависит результат игры)! Позволю себе небольшую <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">цитату</a>:

<blockquote>
Различают следующие различные формы шаха: шак — дается ферзём, ладьёй или конём, тук — слоном, цод — пешкой. 
Матовать можно только шаком (то есть ферзём или ладьёй), или же непрерывной серией шахов, включающей, по крайней мере, 
один шак, причем если шак объявляется последним, то это не должен быть шах конём. 
Например, если даётся следующая серия шахов (последний шах — мат) — конём, пешкой и слоном, то это выигрыш. 
Если же мат ставится только слоном/слонами и/или пешкой/пешками, то это ничья — нёл. 
Если у одного игрока остается только один король («голый король»), то это также ничья — робадо.
</blockquote>
Уфф... В этом и разобраться то непросто, не то что реализовать. Кстати говоря, с реализацией шахов и матов в <a href="http://www.zillions-of-games.com">ZoG</a> всё довольно печально. В условиях завершения игры (победы, ничьей или поражения) могут применяться лишь следующие предикаты:

<ul>
	<li><b>stalemated</b> - Отсутствие возможности хода</li>
	<li><b>repetition</b> - Троекратное повторение позиции</li>
	<li><b>captured</b> - Взятие фигуры определённого типа (например короля)</li>
	<li><b>checkmated</b> - Мат фигуре заданного типа</li>
	<li><b>absolute-config</b> - Абсолютное расположение фигур (например достижение заданной позиции)</li>
	<li><b>relative-config</b> - Относительное расположение фигур (например "5 в ряд")</li>
	<li><b>pieces-remaining</b> - Оставшееся количество фигур (например, в "<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_(%D0%B8%D0%B3%D1%80%D0%B0)">Мельнице</a>" - две оставшиеся фигуры означают поражение)</li>
	<li><b>total-piece-count</b> - Аналогично предыдущему, но без учёта принадлежности фигур игроку</li>
</ul>
Всё это жёстко "зашито" в ядро программы и минимально управляется другим "хардкодом" - командой <b>option</b> (доступной лишь в версии 2.0). Например, при помощи опции "<b>include off-pieces</b>" можно заставить систему учитывать в предикате <b>pieces-remaining</b> не только фигуры размещённые на доске, но и те, что находятся "в резерве". Какой либо системы в наборе доступных опций нет.

Понятно, что одного единственного ключевого слова <b>checkmated</b> совершенно недостаточно для адекватной обработки всевозможных матовых ситуаций, описанных в статье. Часть проблем можно решить добавив дополнительные проверки в "ручном" режиме. Вот так, например, выглядит проверка на мат сбросом пешки в Сёги:

<spoiler title="Утифудзумэ вручную">
<source lang="lisp">
(define safe 
   (and (on-board? $1) 
        (not-defended? $1) 
        (not-enemy? $1)
   )
)

(define no-mate 
   (or (not-piece? Gyokusho n) 
       (not-enemy? n) 
       not-defended? (attacked? no-king) 
       (safe e) 
       (safe w) 
       (safe ne) 
       (safe nw) 
       (safe nne) 
       (safe nn) 
       (safe nnw)
   )
)

(define drop-Fu (
 (verify-first Fu)
  END next
  (while on-board?
    mark 
    (set-flag friendly-Fu false)
    (while (and (not-flag? friendly-Fu) (on-board? n))
      (if (and friend? (piece? Fu)) (set-flag friendly-Fu true))
      n)
    back
    (if (not-flag? friendly-Fu)
	mark
	(while (on-board? n)
	  (if (and empty? (no-mate)) add)
	  n)
	back)
    e)
))
</source>
</spoiler>
Это работает, но понять, что делает этот код, крайне сложно. При этом, используется тот факт, что пешка в Сёги атакует вплотную, всего одно поле. От её шаха нельзя закрыться, а можно лишь отойти либо "съесть" пешку. Совершенно не представляю каким образом подобный комплект "ручных" проверок выглядел бы в случае реализации Шатар. Для реализации форсированных ходов используется механизм приоритетов (либо жестко закодированная "магия", при использовании предиката <b>checkmated</b>).

<spoiler title="Приоритеты">
<source lang="lisp">
...
(moves
    (move-type noncapture-type)
    (man-shift ne)
    (man-shift nw)

    (move-type capture-type)
    (man-jump ne)
    (man-jump nw)
    (man-jump se)
    (man-jump sw)
    (move-type nomove-type)
)
...
(move-priorities capture-type noncapture-type)
</source>
</spoiler>
Таким образом в шашках реализована "обязательность" взятия. Если есть возможность выполнить ход, берущий фигуру противника, необходимо выполнить его, а не "тихий" ход. Этот механизм также не кажется мне достаточно гибким. И приоритетные ходы и действия под шахом могут быть реализованы с использованием единого универсального механизма <b>инвариантов</b>. Если по завершении <b>любого</b> своего хода король не должен находится под шахом, почему бы именно так и не сказать?

<spoiler title="Реализация проверок на шах в Dagaz">
<source lang="lisp">
(define invariant
  (check 
      (not-exists?
         any-position
         (check is-friend?)
         (check (is-piece? King))
         (check is-attacked?)
      )
  )
)

(define goals
   (check-loss no-moves?)
)

(pieces
   ...
   (pre  goals)
   (post invariant)
   ...
)
</source>
</spoiler>
<spoiler title="Кстати">
Вычисление предиката <b>is-attacked?</b> - довольно таки трудоёмкая операция (именно поэтому она выполняется в конце списка проверок). Дело в том, что далеко не во всех играх атакуются те поля, на которых фигуры заканчивают свой ход. Примером являются всем известные Шашки, в которых атакуемое поле "перепрыгивается".

В более сложных случаях, результат вычисления <b>is-attacked?</b> зависит от того, какой тип фигуры атакуется. Например "Хамелеон" в игре <a href="http://www.chessvariants.org/other.dir/ultima.html">Ультима</a> атакует каждую фигуру по тем правилам, по которым ходит она сама. Если бы в подобной игре была предусмотрена <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>, пришлось бы уточнять для какого именно типа фигуры выполняется проверка (для проверки на шах этого делать не требуется, поскольку фигура уже установлена на доске, а не просто проходит через поле):

<spoiler title="Рокировка в Dagaz">
<source lang="lisp">
(define O-O
   (check (not is-moved?))
   (check not-attacked?)
   (take-piece-to-head current-pieces)
   (check w)
   (check is-empty?)
   (check (not-attacked? King))
   (check w)
   (check is-empty?)
   (check (not-attacked? King))
   (drop-pieces current-pieces)
   (check w)
   (check (not is-moved?))
   (set! is-moved? true)
   (take-piece-to-head current-pieces)
   e e
   (drop-pieces current-pieces)
   add-move
)
</source>
</spoiler>
</spoiler>
Это немного длиннее простого <b>checkmated</b>, но и невероятно гибче! В случае, если все возможные ходы нарушают инвариант, список сгенерированных ходов оказывается пустым. Срабатывающий в этой ситуации предикат <b>no-moves?</b> определяет условие завершения игры (поражения). 

<spoiler title="Маленький хак">
Вычисление предиката <b>no-moves?</b> также может быть трудоёмким (для проверки необходимо полностью сгенерировать хотя бы один ход), но здесь можно схитрить.  До начала генерации ходов можно зарегистрировать отложенную проверку. Если множество ходов, по завершении генерации, пусто, проверка срабатывает и фиксируется поражение.
</spoiler>
Инварианты, в том виде как они определены в этой статье, не кажутся какой-то "ракетной наукой", но мы ещё не дали им развернуться в полную силу. В следующей главе, постараемся выжать из них максимум того, на что они способны.
</habracut>

Звериные Сёги

<img align="left" src="https://habrastorage.org/files/b55/f51/fb6/b55f51fb669042339ff9d6c1189e01f2.PNG"/>Не стану скрывать, что я неравнодушен к японской культуре. В детстве я увлекался <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B3%D0%B0%D0%BC%D0%B8">оригами</a>, став постарше, пошёл на <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D0%B0%D1%82%D0%B5">карате</a>. Я взахлёб читал <a href="http://rutracker.org/forum/viewtopic.php?t=1183194">Вурдова</a>, пытаясь уловить смысл заложенный в <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D0%B4%D0%B7%D0%B8">кандзи</a> и хотя бы немного понять японский язык. С годами, мои увлечения стали менее экстремальными (хотя <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B9%D0%BA%D0%B8%D0%B4%D0%BE">айкидо</a> я продолжаю заниматься до сих пор). В настоящее время, меня более всего интересуют настольные игры, и это та область, в которой японцам тоже есть чем порадовать. Я уже писал <a href="http://geektimes.ru/post/240456/">здесь</a> про <a href="https://ru.wikipedia.org/wiki/%C3%EE">Го</a> (и возможно продолжу писать), но сегодня я хочу рассказать о другой замечательной игре. Эта игра была придумана для детей (от 2 лет), но её нельзя назвать простой. Как в капле воды, в ней причудливо отразились все особенности её более взрослой <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">сестры</a>. Небольшой размер делает её похожей на головоломку, а возможность продолжительной игры (более 70 ходов, при идеальной игре) внушает уважение.&nbsp;
<habracut>
Эту игру разработала профессиональная сёгистка Мадока Китао (2 женский дан) в соавторстве с Майко Фудзита (1 женский кю), специально для обучения детей игре в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>. Это не самый минимальный <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B_%D1%81%D1%91%D0%B3%D0%B8">вариант</a> игры (<a href="https://en.wikipedia.org/wiki/Gufuu_shogi">Гуфуу Сёги</a> играется на доске 2x3, а <a href="http://en.wikipedia.org/wiki/Bushi_shogi">Буси Сёги</a> - на доске 1x2), но, пожалуй, наиболее понятный из всех мини-вариантов. 

Здесь нет сложных для восприятия правил превращения фигур (как в <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D0%BE%D1%82%D0%BE_%D1%81%D1%91%D0%B3%D0%B8">Киото Сёги</a>). Превращается только пешка (цыплёнок), дойдя до последней горизонтали доски. В отличии от Сёги, превращение является обязательным во всех случаях (а не только когда не превращённая фигура не может продолжать движение). Также нет превращения других фигур. Такие правила роднят <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%B1%D1%83%D1%86%D1%83_%D1%81%D1%91%D0%B3%D0%B8">Добуцу Сёги</a> с <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматами</a>, но, в отличии от последних, превращение осуществляется лишь в одну фигуру - "Петуха" (аналог золотого генерала в Сёги).

В игре нет дальнобойных фигур (на такой малой доске от них мало толку). Обычным дизайнерским решением является указание на фигурах направлений, по которым они могут ходить. Подобное оформление и малый размер доски делают игру оптимальной для восприятия детьми. На фигурах, обычно, изображаются стилизованные фигурки зверей. Другое название игры - "Поймай льва" или "Звериные сёги". Как должно быть понятно из названия, цель игры - поймать (съесть) "Льва" противника.

<spoiler title="Ребятам о зверятах">
"Звериные сёги" не следует путать с китайскими "<a href="http://skyruk.livejournal.com/427724.html">Джунглями</a>" (Доу-Шоу-Ци), являющимися (как и многое другое в Китае) вполне самобытной игрой, в которой фигуры бьют друг друга по принципу, сходному с используемым в игре "<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C,_%D0%BD%D0%BE%D0%B6%D0%BD%D0%B8%D1%86%D1%8B,_%D0%B1%D1%83%D0%BC%D0%B0%D0%B3%D0%B0">Камни-ножницы-бумага</a>". Слон бьёт льва, лев - тигра, ... кошка бьёт крысу. Крыса замыкает круг боя - она бьёт слона. Всё это осложняется рельефом местности, с наличием "водоёмов" и "ловушек", а также различными для фигур правилами по пересечению этого рельефа. Взрослые, обычно, играют в гораздо более сложную игру - "<a href="http://skyruk.livejournal.com/428408.html">Китайские военные шахматы</a>" (Лю-жань-ци), построенную по сходному принципу, но относящуюся к категории игр с неполной информацией. Впрочем, и последняя рассматривается исключительно как игра развлекательная, гораздо менее серьёзная чем "<a href="http://skyruk.livejournal.com/274836.html">Китайские шахматы</a>" (Сянцы).
</spoiler>
Несмотря на то, что игра была придумана для детей, она набирает всё большую и большую популярность не только в Японии, но и во всем мире (например, в 2013 году проводился <a href="http://shogi.by/tournaments/84/">турнир в Минске</a>). Очевидно, что она не так проста как кажется. Разумеется, она гораздо проще Шахмат и Сёги и для неё проведён полный компьютерный анализ, но играть в неё интересно! Во первых, как и в Сёги, в ней действует правило сброса. Съеденные фигуры не покидают игру, а могут быть возвращены на доску взявшим их игроком.

Второй фактор более коварен. Дело в том, что в Добуцу Сёги победить можно <b>разными</b> способами (в качестве другого примера подобной игры можно привести гораздо более тяжеловесную <a href="http://habrahabr.ru/post/234587/">Ритмомахию</a>). Для победы необходимо съесть короля противника или... добраться своим королём до последней горизонтали доски! Причём, если следующим ходом противник может этого короля съесть, то победа "не считается". 

Как только я включил это правило в свою <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2336">реализацию</a> игры, я резко перестал у неё выигрывать. Когда я пытался поймать короля противника, он прорывался на последнюю горизонталь, а когда пытался прорваться сам - подставлял собственного короля. Да... к этой игре надо привыкнуть. Сама реализация получилась совсем неплохой:

<video>http://www.youtube.com/watch?v=1irQ8Bys5Ig</video>

К сожалению, чтобы её запустить, необходим платный <a href="http://www.zillions-of-games.com/orders.html">ZoG</a>, но на нём свет клином не сошёлся. В Google Play имеется масса бесплатных Android-реализаций, найти которые можно по словосочетанию "Animal Shogi". К слову сказать, в процессе поиска, я набрёл на другую замечательную <a href="https://play.google.com/store/apps/details?id=com.ocastudios.shogi4">игру</a>. Я затрудняюсь сказать, какой из вариантов Сёги реализовал автор (я такого не знаю), но результат получился замечательным во всех отношениях. Всячески рекомендую эту игру всем поклонникам жанра, а также их детям.

В своей версии я незначительно изменил правила. Во первых, я вернул в игру концепцию <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">мата</a> (вариант в котором короля можно "есть" тоже оставил). В этом режиме AI ZoG ведёт себя гораздо более осмысленно. Далее, нигде в правилах я не нашёл упоминания о том, можно ли сбрасывать пешку на последнюю горизонталь. Можно было превращать пешку при сбросе, но я счёл эту возможность слишком "читерской". Я запретил такой сброс по аналогии с Сёги. <a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D1%84%D1%83%D0%B4%D0%B7%D1%83%D0%BC%D1%8D">Мат сбросом пешки</a> запрещать не стал, поскольку, опять же, не нашёл этого в правилах. Имеется ещё один курьёзный момент:

<img align="center" src="https://habrastorage.org/files/9c8/59d/806/9c859d80600f453eb9f64e4b460cd594.JPG"/>
В это трудно поверить, но здесь изображён самый натуральный мат королю "Зелёных". Поскольку все места "в руке" заняты, он не может "съесть" атакующую фигуру. Подобный вариант игры в Сёги (в нём запрещается держать "в руке" более 5 фигур) также существует и имеет своих сторонников. Я не стал увеличивать размер "резерва" поскольку считаю, что в таком виде игра стала лишь более интересной (кроме того, это сломало бы "картинку").

На этой позитивной ноте, заканчиваю. 
<b>Всем счастья и радости, а дам поздравляю с наступающим праздником!</b>
</habracut>

Из Oracle да в Postgres

<img align="left" src="https://habrastorage.org/files/e23/3ac/7ff/e233ac7ffe814a80a9f360c443b45aa0.jpg"/>Так уж случилось, что с Oracle организация наша работает давно и плотно. Сам я познакомился с Oracle Database ещё во времена 6-ой версии и, с тех пор, какого либо дискомфорта не испытывал. Всё испортили рыночные отношения. С недавних пор, мы начали замечать, что Заказчик гораздо благосклоннее смотрит на наши проекты если в них используются бесплатные <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B1%D0%B0%D0%B7%D0%B0%D0%BC%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">СУБД</a>. О портации одного из таких проектов и будет мой рассказ...&nbsp;
<habracut>
Выбор бесплатной СУБД был, для меня, делом долгим и непростым, но, в конечном итоге, свёлся к двум всем известным альтернативам. <a href="https://ru.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a> привлекал богатой (и всё ещё развивающейся) функциональностью, в то время как <a href="https://ru.wikipedia.org/wiki/MySQL">MySQL</a> заманивал производительностью и "нулевым" администрированием. Поскольку Oracle нас разбаловал и <a href="https://ru.wikipedia.org/wiki/SQL">SQL</a> мы все знали и любили, многочисленные и новомодные <a href="https://ru.wikipedia.org/wiki/NoSQL">NoSQL</a> варианты отпали ещё в полуфинале.

Сложно сказать, на какой из СУБД я бы остановился в конечном итоге, если бы не одна шабашка, давшая мне возможность "вживую" пощупать и PostgreSQL и MySQL, не спеша сравнить их и принять, на мой взгляд, вполне обоснованное решение. Помимо функционала, разумеется, сравнивалась и производительность. Я не буду рассказывать деталей, но одним из принципиальных моментов "шабашки" была возможность быстро и надёжно (<a href="https://ru.wikipedia.org/wiki/ACID">ACID</a>, да) вставлять в базу данных большое количество записей. На эту тему и был проведён тест:

<img align="center" src="https://habrastorage.org/files/ca9/c21/525/ca9c2152598b4505829addb71bd757ec.PNG"/>
По оси ординат отложено количество записей фиксированной длины, сохраняемых в БД ежесекундно. Число в "легенде" означает размер транзакции. Здесь следует заметить, что MySQL замерялся "как есть", а PostgreSQL с использованием небольшой <a href="http://habrahabr.ru/post/177957/">нашлёпки</a>, обеспечивавшей возможность работы с привычными мне <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">партиционированными таблицами</a> и <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">материализованными представлениями</a>. Поскольку речь шла о "надёжном" хранении, <a href="https://ru.wikipedia.org/wiki/MyISAM">MyISAM</a> на графике представлен исключительно для полноты картины и понимания того, где находится "теоретический максимум" искомой производительности на используемом "железе".

Поскольку само тестирование проводилось довольно давно и никакими <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B2%D0%B5%D1%80%D0%B4%D0%BE%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BD%D0%B0%D0%BA%D0%BE%D0%BF%D0%B8%D1%82%D0%B5%D0%BB%D1%8C">SSD</a> на имеющемся в наличии железе даже не пахло, к абсолютным значениям, показанным на графике, не стоит относиться как к догме. Безусловно, можно сохранять данные ещё быстрее, но меня интересовало соотношение производительности различных СУБД, работавших в (почти) одинаковых условиях. Для меня стало сюрпризом, что PostgreSQL, даже утяжелённый триггерами партиционирования, работает почти также быстро как MySQL, с использованием <a href="https://ru.wikipedia.org/wiki/InnoDB">InnoDB</a>, а на больших транзакциях (1000 записей и больше) начинает догонять MyISAM!

Как легко догадаться, показанный выше график окончательно убедил меня в том, что переходить следует на PostgreSQL. Пересоздание таблиц с переопределением типов столбцов (number в numeric и integer, varchar2 в varchar и text ...) было делом тривиальным. В переносе данных помог <a href="https://ru.wikipedia.org/wiki/XML">XML</a> и <a href="https://ru.wikipedia.org/wiki/XSLT">XSLT</a>. 

<spoiler title="О пользе XML">
Строго говоря, XML помог ещё раньше. Одной из особенностей нашего продукта является хранение в БД описаний бизнес-сущностей в форме обычных табличных данных (не думаю, что он сильно оригинален в этом). Сравнение таких "метаданных" для двух различных схем было настоящей головной болью, до тех пор, пока я не написал небольшой пакет, выгружающий их в XML-описания. Сортировка тегов внутри описаний позволяла сравнивать их как обычные текстовые файлы. XSLT дополнил картину, обеспечив автоматическую генерацию SQL-скриптов из файлов описаний.
</spoiler>
Осталось обеспечить работоспособность всего SQL-кода, написанного для Oracle. Большая часть запросов работала, часть - заработала после небольших косметических изменений. Первым делом, я создал таблицу <a href="http://en.wikipedia.org/wiki/DUAL_table">dual</a>:

<source lang="sql">
create table dual (
  x    varchar(1) not null
);

insert into dual(x) values('x');
</source>
Не то, чтобы без неё нельзя было обойтись, но в наших запросах она использовалась так часто, что переписывать их было просто нецелесообразно. Чтобы PostgreSQL "был доволен", пришлось добавить в запросы больше строгости:

<spoiler title="Oracle-версия">
<source lang="sql">
select b.id id, b.name name
from   ( select list_value
         from   acme_obj_list_value
         group by list_value ), acme_list_value b
where b.id = list_value
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
select b.id id, b.name as name
from   ( select list_value
         from   acme_obj_list_value
         group by list_value ) a, acme_list_value b
where b.id = a.list_value
</source>
</spoiler>
Все <a href="http://www.orafaq.com/wiki/Inline_view">inline view</a> необходимо именовать, а перед псевдонимами столбцов крайне желательно использовать ключевое слово '<b>as</b>'. Для большинства столбцов его можно опускать, но при использовании таких имён как 'name' или 'value' это ведёт к ошибке. Следующим шагом, стала замена платформозависимого кода на соответствующие конструкции, поддерживаемые как в Oracle, так и в PostgreSQL. Речь идёт об <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions105.htm">nvl</a> и <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions040.htm">decode</a>, а также об устаревшем синтаксисе <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/queries006.htm#SQLRF52338">внешнего соединения</a>. Первые две легко заменяются на стандартные (и более гибкие) <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/functions023.htm#SQLRF00617">coalesce</a> и <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/expressions004.htm">case</a>, в случае же использования внешнего соединения, запрос должен быть переписан:

<spoiler title="Oracle-версия">
<source lang="sql">
select ot.name, mv.str_value
from   acme_object o, acme_meta_value mv, acme_obj_type ot
where  o.id = :object_id
and    ot.id = o.obj_type_id
and    mv.owner_id(+) = ot.id
and    mv.param_id(+) = 9520
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
select ot.name, mv.str_value
from   acme_object o 
left   join acme_meta_value mv on (mv.owner_id = ot.id and mv.param_id = 9520)
inner  join acme_obj_type ot on (ot.id = o.obj_type_id)
where  o.id = :object_id
</source>
</spoiler>
<a href="http://oracle-base.com/articles/9i/ansi-iso-sql-support.php">ANSI Join</a> поддерживается Oracle с 9-ой версии и, на мой взгляд, является более удобным (хотя и менее лаконичным), чем устаревший вариант с использованием <b>(+)</b>. Не стоит пытаться сочетать различные формы соединения в одном SQL-запросе. Если мы использовали outer join, то для внутренних соединений вполне логично использовать <a href="http://www.orafaq.com/wiki/Inner_join">inner join</a>, а не перечисление таблиц в фразе <b>from</b> через запятую.

Основная часть работы по миграции SQL-кода оказалась связана с переписыванием иерархических запросов. Фраза <a href="http://www.adp-gmbh.ch/ora/sql/connect_by.html">connect by</a> в PostgreSQL, естественно, не поддерживается. Между тем, в наличии имелось большое количество запросов следующего вида:

<spoiler title="Пример использования иерархического запроса">
<source lang="sql">
select t.id as value 
from   acme_object t, acme_obj_ref_value rv
where  rv.object_id = t.id
and    rv.attr_id = 220102
and    rv.ref_value = :object_id
and    t.obj_type_id in ( select  ot.id 
                          from    acme_obj_type ot 
                          connect by prior ot.id = ot.parent_id 
                          start   with ot.id = 200335 )
</source>
</spoiler>
Простое переписывание таких запросов, с использованием <a href="http://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression">CTE</a> не позволило бы привести их к платформонезависимому виду. Хотя Oracle (начиная с версии 11.2) <a href="http://citforum.ru/database/oracle/recursive/">поддерживает</a> рекурсивные запросы, синтаксис их отличается от используемого в <a href="http://www.postgresql.org/docs/9.2/static/queries-with.html">PostgreSQL</a>. В частности, в PostgreSQL, использование ключевого слова recursive является обязательным, Oracle же его "не понимает". К счастью, в большинстве случаев, иерархическую часть запроса удавалось "спрятать" в <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)">представление</a>.

<spoiler title="Oracle-версия">
<source lang="sql">
create  or replace view acme_arm(id) as
select  ot.id 
from    acme_obj_type ot 
connect by prior ot.id = ot.parent_id 
start   with ot.id = 200335
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
create or replace view acme_arm(id) as
with recursive t(id) as (
     select id
     from   acme_obj_type
     where  id = 200335
     union  all
     select a.id
     from   acme_obj_type a
     inner  join t on (t.id = a.parent_id)
)
select id from t
</source>
</spoiler>
Переписывание операторов <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9016.htm#SQLRF01606">merge</a> оказалось более "головоломным" (к счастью, они использовались не так часто, как иерархические запросы). PostgreSQL этот оператор не поддерживает, но зато он поддерживает использование фраз <b>from</b> и <b>returning</b> в операторе <b>update</b>, причём последняя - возвращает полноценный resultset (аналогично оператору <b>select</b>), что позволяет использовать его в фразе <b>with</b>. Я просто оставлю это здесь:

<spoiler title="Oracle-версия">
<source lang="sql">
merge into acme_obj_value d
using ( select object_id
        from   acme_state_tmp
      ) s
on (d.object_id = s.object_id)
  when matched then
    update set d.date_value = least(l_dt, d.date_value)
  when not matched then
    insert (d.id, d.object_id, d.date_value)
    values (acme_param_sequence.nextval, s.object_id, l_dt)
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
with s as (
     select object_id
     from   acme_state_tmp
),
upd as (
     update acme_obj_value
     set    date_value = least(l_dt, d.date_value)
     from   s
     where  acme_obj_value.object_id = s.object_id
     returning acme_obj_value.object_id
)
insert into acme_obj_value(id, object_id,  date_value)
select nextval('acme_param_sequence'), s.object_id, l_dt
from   s
where  s.object_id not in (select object_id from upd)
</source>
</spoiler>
В этом примере можно заметить, что работа с <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28310/views002.htm#ADMIN11793">последовательностями</a> в PostgreSQL также отличается от принятой в Oracle. Конечно, в Oracle можно было определить функцию, аналогичную той, что получает значения из последовательностей в PostgreSQL, но переписывания Oracle-кода (также как и Java-кода) хотелось избежать. Кроме того, такой подход мог быть связан с дополнительными накладными расходами.

Много радости доставила работа с <a href="http://www.postgresql.org/docs/9.2/static/functions-datetime.html">датой и временем</a>. Дело в том, что широко используемый в Oracle тип <a href="http://psoug.org/reference/date_func.html">date</a> приучил к некоторой неряшливости при обращении с его значениями. Можно считать, что такое значение представляет собой число, целая часть определяет количество дней, прошедших с некоторой "магической" даты, а дробная - время, с точностью до секунды. После некоторого привыкания (как и к большинству особенностей Oracle), это довольно удобно, но PostgreSQL гораздо строже в том, что касается типов данных.

<source lang="sql">
date '2001-09-28' + interval '1 hour'
</source>
Добавить, таким образом, к дате константный интервал можно, но что делать, если необходимо добавить переменное значение? Искомое выражение совсем не очевидно:

<source lang="sql">
date '2001-09-28' + (to_char(p_hours, '99') || ' hour')::interval
</source>
Пробел в строке перед '<b>hour</b>' обязателен! Также, можно заметить, что строгость PostgreSQL распространяется и на преобразование числовых значений в строковые (и наоборот, конечно). Маска обязательна, даже если она состоит из одних девяток. Неявные преобразования, столь привычные после работы с Oracle, не работают.

Оставшиеся запросы подверглись менее радикальным изменениям. Пересмотра потребовал весь код работающий со строками, просто потому, что соответствующие функции в <a href="http://psoug.org/reference/string_func.html">Oracle</a> и <a href="http://www.postgresql.org/docs/9.2/static/functions-string.html">PostgreSQL</a> выглядят по разному. Столбец <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/pseudocolumns009.htm#SQLRF00255">rownum</a>, там, где он ещё оставался, пришлось заменить на оконный <a href="http://www.postgresql.org/docs/9.2/static/functions-window.html">row_number()</a>. В тех случаях, когда условие на rownum использовалась для ограничения количества выводимых строк, запросы переписывались с использованием фразы <a href="http://www.postgresql.org/docs/9.2/static/queries-limit.html">limit</a>.

Отдельно стоит рассказать о табличных функциях. И в <a href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28425/pipe_paral_tbl.htm">Oracle</a> и в <a href="http://www.postgresql.org/docs/9.2/static/functions-srf.html">PostgreSQL</a> они есть. Реализация разумеется различна, но обращение к ним, из SQL-запроса выглядит сходным образом. К сожалению, как и в случае с рекурсивным CTE, всё портит наличие одного ключевого слова:

<spoiler title="Oracle-версия">
<source lang="sql">
select * from table(acme_table_fuction(...))
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
select * from acme_table_fuction(...)
</source>
</spoiler>
Осталось разобраться с <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6006.htm">пакетами</a>. В PostgreSQL такого понятия нет, но, при ближайшем рассмотрении, оказывается, что ему оно не очень то и нужно. Действительно, для чего нужны пакеты в Oracle? Если отбросить в сторону глобальные переменные и инициализационный код (которыми мы не пользуемся), главным достоинством пакетов является то, что они разрывают цепочки зависимостей. При изменении объектов БД, инвалидируются лишь реализации зависимых пакетов, но не их заголовки. Возможность выполнения рекурсивных вызовов внутри пакетов является одним из следствий этого факта.

В PostgreSQL механизм зависимостей не реализован. С рекурсивными вызовами хранимых функций (процедур в PostgreSQL нет) также всё в порядке. Для того, чтобы в клиентский код пришлось вносить минимум изменений, достаточно обеспечить лишь видимость того, что мы продолжаем работать с пакетами. <a href="http://www.postgresql.org/docs/9.2/static/ddl-schemas.html">Схемы</a> PostgreSQL подходят для этого как нельзя лучше. Разумеется, в таком "пакете", не удастся реализовать "приватные" функции, но это не очень большая проблема. Вот как будет выглядеть код:

<spoiler title="Эмуляция пакетов в PostgreSQL">
<source lang="sql">
drop function acme_utils.get_str_res(numeric);
drop function acme_utils.c_str_res_ot();
drop function acme_utils.c_str_res_id_attr();

drop schema acme_utils;

create schema acme_utils;

create or replace function acme_utils.c_str_res_ot()
returns numeric
as $$
begin
  return 20069;
end;
$$ language plpgsql IMMUTABLE;

create or replace function acme_utils.c_str_res_id_attr()
returns numeric
as $$
begin
  return 20070;
end;
$$ language plpgsql IMMUTABLE;

create or replace function acme_utils.get_str_res(in p_res_id numeric)
returns text
as $$
declare
  res text;
begin
  select o.name
  into   strict res
  from   acme_object o
  inner  join acme_obj_value rid on (rid.object_id = o.id and rid.attr_id = acme_utils.c_str_res_id_attr())
  where  o.obj_type_id = acme_utils.c_str_res_ot()
  and    rid.num_value = p_res_id;
  return res;
end;
$$ language plpgsql STABLE;
</source>
</spoiler>
Необходимость удаления всех объектов перед "пересозданием" схемы немного утомляет, но жить можно. Можно заметить в тексте непривычное слово '<b><a href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html">strict</a></b>'. Оно обеспечивает привычное по Oracle поведение, при попытке выборки нуля или более одной записи. Из других запомнившихся моментов, могу упомянуть <a href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html">странную конструкцию</a>, вычисляющую количество строк, изменённых последним запросом:

<spoiler title="Oracle-версия">
<source lang="sql">
insert into acme_resource_tmp(id, device_id, profile_id, owner_id, type_id, res_num, name)
select acme_main_sequence.nextval, t.device_id, t.profile_id, r.id, p.type_id, t.num, t.value
from   acme_state_tmp t
inner  join acme_profile_detail p on (p.profile_id = t.profile_id and p.param_id = t.param_id)
inner  join acme_resource r on (r.device_id = t.device_id and r.owner_id is null);
l_ic := sql%rowcount;
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
insert into acme_resource_tmp(id, device_id, profile_id, owner_id, type_id, res_num, name)
select nextval('acme_main_sequence'), t.device_id, t.profile_id, r.id, p.type_id, t.num, t.value
from   acme_state_tmp t
inner  join acme_profile_detail p on (p.profile_id = t.profile_id and p.param_id = t.param_id)
inner  join acme_resource r on (r.device_id = t.device_id and r.owner_id is null);
get diagnostics l_ic = row_count;
</source>
</spoiler>
Реализации всех пакетов пришлось, конечно, переписать, благо их оказалось не так много. Из моего предыдущего повествования можно понять, что весь переписанный SQL-код поделился на три категории:

<ol>
	<li>Запросы, которые путём небольшого переписывания удалось привести к платформонезависимому виду</li>
	<li>Запросы, в которых платформозависимые фрагменты удалось скрыть в представлениях</li>
	<li>Безусловно платформозависимый код</li>
</ol> 
С первыми двумя никаких сложностей нет. Последняя категория может доставить некоторые проблемы, если платформозависимые конструкции присутствуют в запросах, формируемых клиентом. Дело в том, что Java-код не хочется переписывать. Ещё меньше желания разделять исходники на две версии, работающие с различными СУБД. К сожалению, полностью исключить платформозависимые конструкции из клиентского кода не удалось. По большей части, мешало ключевое слово <b>table</b> в запросах к табличным функциям. Также имелись обращения к последовательностям и немного иерархических запросов.

Было принято решение - хранить все платфомозависимые запросы в БД, загружая их в программный кэш, при первом обращении. Первоначально предполагалась, что каждая из БД будет хранить свои версии запросов, но оказалось удобнее хранить запросы одновременно во для всех используемых СУБД. В Oracle, для хранения текста запросов использовалось <a href="http://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html">CLOB</a> поле, в PostgreSQL - <a href="http://www.postgresql.org/docs/9.2/static/datatype-character.html">text</a>. Для обеспечения единообразия, было использовано преобразование CLOB в varchar2, что <a href="https://docs.oracle.com/cd/B28359_01/server.111/b28320/limits001.htm#i287903">ограничило</a> максимальный размер запроса 4000 символов (один запрос всё-таки вылез за пределы этого размера, но поскольку он предназначался для PostgreSQL версии, "ужимать" его не пришлось). Само преобразование <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions179.htm">to_char</a> пришлось скрыть с использованием представления:

<spoiler title="Oracle-версия">
<source lang="sql">
create or replace view acme_query(name, sql) as
select a.name, to_char(c.clob_value)
from   acme_object a
inner  join acme_obj_list_value b on (b.object_id = a.id and b.attr_id = 10061)
inner  join acme_obj_value c on (c.object_id = a.id and c.attr_id = 10062)
where  a.obj_type_id = 10004
and    b.list_value = 10061;
</source>
</spoiler>
<spoiler title="PostgreSQL-версия">
<source lang="sql">
create or replace view acme_query(name, sql) as
select a.name, c.clob_value
from   acme_object a
inner  join acme_obj_list_value b on (b.object_id = a.id and b.attr_id = 10061)
inner  join acme_obj_value c on (c.object_id = a.id and c.attr_id = 10062)
where  a.obj_type_id = 10004
and    b.list_value = 10062;
</source>
</spoiler>
Резюмируя, могу сказать, что работа оказалась совсем не такой страшной, какой она казалась в начале. Большая её часть была связана с переписыванием иерархических запросов и пакетов Oracle, а большая часть проблем - с более строгим синтаксисом SQL и отсутствием привычных неявных преобразований в PostgreSQL. Объем работ мог бы быть меньше если бы мы изначально использовали более строгий и платфомонезависимый код в Oracle.

</habracut>

Dagaz: Пинки здравому смыслу (часть 2)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/><i><b>Я еще чуток добавил прыти - &nbsp;
Все не так уж сумрачно вблизи:
В мире шахмат пешка может выйти - &nbsp;
Если тренируется - в ферзи!

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Владимир Высоцкий "<a href="http://www.kulichki.com/vv/pesni/tolko-prileteli-srazu-seli.html">Честь шахматной короны</a>"</b></i>&nbsp;

Правила, особенно такие сложные, как <a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a> или "<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятие на проходе</a>", не появляются на пустом месте. Никто не придумывает их просто так, чтобы позлить разработчика (во всяком случае, я надеюсь на это). В таких "устоявшихся" играх как Шахматы или Шашки, каждое из правил выстрадано десятилетиями. Тысячами игр, в десятках стран, по всему миру. Это бесценный материал для анализа. Неудачные решения отмирают, успешные - расцветают в сотнях различных вариантов (среди которых также есть как удачные, так и не очень). Сегодня, мы поговорим о двух особенно удачных находках...&nbsp;
<habracut>
<h4><b>9. Превращения и сброс</b></h4>
Во многих играх есть фигуры, которые движутся "только вперёд". Это очень хорошее дизайнерское решение, не позволяющее фигурам "топтаться на месте", а также обостряющее борьбу сторон (поскольку это самое "вперёд", обычно, расположено на территории противника). Но что делать с фигурами дошедшими до конца своего пути? Одним из возможных решений является перерождение фигуры, с обретением ей новых свойств. Часто, появление в игре таких превращённых фигур переводит её на принципиально новый уровень. Хорошим примером является превращение в "дамку" обычной "шашки" в такой игре как "<a href="https://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Русские шашки</a>".

<spoiler title="Итальянский вариант">
Своё виденье игры предложили <a href="http://en.wikipedia.org/wiki/Italian_draughts">итальянцы</a>. Их дамка почти ничем не отличается от английской, но не может быть "съедена" обычной фигурой. Сила её статуса в неприкосновенности. Одолеть её может лишь равная фигура. Конечно, привилегированное положение дамки не мешает ей "разбираться" с обычными фигурами. Этот вариант игры, по всей видимости, унаследовал правило "неприкосновенности" дамок от более древней итальянской игры <a href="http://en.wikipedia.org/wiki/Italian_Damone">Damone</a>, в которой иерархические отношения были еще более сложными (помимо обычных дамок, в игре присутствовал "Император") . Как всегда, правила игры могут очень многое рассказать о её создателях.
</spoiler>
В отличии от <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">английского варианта</a>, в котором дамки получают лишь возможность хода (в том числе со взятием) назад, появление "летающей" дамки в "Русских шашках" буквально взрывает игру. Благодаря своей манёвренности, она превращается в настоящее "оружие судного дня", с устрашающей эффективностью "вырубая" толпы обычных шашек. Противник, не имеющий дамок в своём арсенале, обречён на поражение. Плохим моментом, является то, что даже при наличии дамок на своей стороне, поймать одиночную дамку противника можно далеко не всегда. Обилие возможных "ничейных" результатов, конечно, не идёт на пользу игре. Предоставляя фигуре супервозможности, важно не перестараться.

<spoiler title="Кстати говоря">
Имеется очень интересный способ борьбы с "ничейной смертью" русских шашек. Дело в том, что дальнобойная дамка становится неуязвимой лишь на главной диагонали доски. Если дамке удалось "встать на большак" одолеть её не смогут даже три дамки противника (в противном случае, им поможет "<a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%9F%D0%B5%D1%82%D1%80%D0%BE%D0%B2%D0%B0">треугольник Петрова</a>"). Если главная диагональ даёт дамке такую силу, почему бы не лишить доску главной диагонали? Простое добавление к доске ещё двух вертикалей <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#80-.D0.BA.D0.BB.D0.B5.D1.82.D0.BE.D1.87.D0.BD.D1.8B.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">решает проблему</a>. 

Другой подход можно почерпнуть в "<a href="http://www.mindsports.nl/index.php/on-the-evolution-of-draughts-variants/draughts-variants/500-thai">Тайских шашках</a>". В этом варианте игры, дамка сохраняет свою дальнобойность, но обязана останавливаться на следующем свободном поле, после "битой" фигуры. Такую дамку могут одолеть всего лишь две дамки противника (независимо от её расположения на доске).
</spoiler>
В играх шахматного семейства, главный кандидат на превращение - безусловно пешка. Не во всех шахматных играх пешка превращается в другую фигуру. В <a href="http://skyruk.livejournal.com/274836.html">Сянцы</a>, например, "перейдя через реку" и оказавшись на территории противника, она лишь получает возможность хода по горизонтали, в том числе, со взятием (в корейской <a href="http://skyruk.livejournal.com/275411.html">Чанги</a> пешка изначально имеет такую возможность). Ещё более причудливым образом изменяются правила хода пешки в <a href="http://skyruk.livejournal.com/339712.html">Алтай Шатра</a>:

<video>http://www.youtube.com/watch?v=XvmG5kbHHMI</video>

Пожалуй, это самая безумная (в хорошем смысле) помесь шашек и шахмат, из тех, что я видел. Из своей начальной позиции, пешка, расположенная не в "крепости", движется только вперёд, причем, первым ходом, может "прыгнуть" через одну клетку, также как в Шахматах. Взятие "на проходе" работает, но выглядит несколько причудливо, поскольку все взятия осуществляются "по шашечному", перепрыгиванием через фигуру противника. Подойдя к середине доски, пешка получает дополнительные ходы по диагоналям вперёд, а перейдя через "ров" получает ещё и возможность движения по горизонтали.

Ходы пешки, в этой игре, определяются не статусом фигуры, а лишь её расположением на доске, но в отличии от Сянцы, в Шатра пешка <b>может</b> переместиться назад, поскольку взятия назад возможны (и для пешки обязательны). В этом случае, пешка может потерять часть из своих возможных ходов. Дойдя до последней горизонтали (расположенной в "крепости" противника), пешка всё таки может превратиться, но лишь в фигуру "срубленную" ранее. Пока комплектность фигур сохранена, игрок может держать пешку в "крепости" (возможно "срубая" ей фигуры противника) либо выставить её на любое из свободных полей на половине противника, откуда она может повторить остаток своего пути.

Правило "превращения" пешки существует в шахматах давно. В <a href="http://skyruk.livejournal.com/274559.html">Чатуранге</a> (в её парном варианте) и в <a href="http://skyruk.livejournal.com/292733.html">Шатрандже</a> пешка, дойдя до последней горизонтали, превращалась в ферзя (слабую фигуру, ходившую на одно поле по диагонали). В тайском варианте (<a href="http://skyruk.livejournal.com/275784.html">Макрук</a>) пешка также превращается в слабого ферзя, но на 6 горизонтали (дойдя до "лагеря" противника). Кроме того, в этой игре, пешки изначально расположены на 3 горизонтали. Разумеется, при такой расстановке необходимость начального "прыжка" пешки, а также "взятия на проходе", отсутствует.

Весьма оригинален бирманский <a href="http://skyruk.livejournal.com/278047.html">Ситтуйин</a>. Задолго до "<a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B-960">Шахмат Фишера</a>" в нём применялась свободная расстановка фигур. Пешки расположены очень своеобразно и не менее оригинально их "превращение". Пешка, стоящая на одной из главных диагоналей (на стороне противника), в любой момент игры, может быть превращена в слабого ферзя, но лишь при условии, что ферзь был потерян. Подобное "отсроченное" превращение считается ходом и игрок не в праве двигать другие фигуры.

<img align="center" src="https://habrastorage.org/files/114/1a9/d7e/1141a9d7e2a64133a7e6dad3a4bfba55.jpg"/>

Ещё более причудливо превращение пешки в малазийских шахматах (<a href="http://skyruk.livejournal.com/278047.html">Майн Чатор</a>). Достигнув последней горизонтали в любом месте, кроме угловых полей, пешка должна двигаться назад, до одной из главных диагоналей. Там она может превратиться в ту фигуру, перед которой стояла в начальной расстановке (королевская пешка превращается в ферзя). Сходным образом происходит превращение в современном варианте "четверной" <a href="http://skyruk.livejournal.com/274559.html">Чатуранджи</a>, но здесь действуют дополнительные ограничения:

<ul>
	<li>Пешка превращается, дойдя до последней горизонтали</li>
	<li>Каждая пешка может превратиться только в ту фигуру, по линии которой она достигла края доски с учётом их расстановки в начале партии, и только в случае, когда хотя бы одна из <b>пешек</b> уже снята с доски</li>
	<li>Если у игрока на доске все четыре пешки, превращения вообще не происходит</li>
	<li>Если у игрока одна или две пешки, он может превратить пешку в коня или слона</li>
	<li>Если у игрока остались пешка, ладья и король – и больше ничего, пешка может стать любой фигурой, независимо от поля превращения</li>
	<li>Если пешка не может превратиться, она остаётся на этом поле, пока не появится возможность превращения</li>
</ul>
Своё дальнейшее развитие эта идея получает в "<a href="http://skyruk.livejournal.com/283735.html">Шахматах Тамерлана</a>". Помимо пешек-фигур, в этой игре, есть пешка, превращающаяся в короля (к чему приводит в шахматной игре наличие нескольких королей я расскажу в одной из следующих частей), а также "Пешка пешек", чей жизненный путь представляет собой настоящий эпос. 

Дойдя по поля превращения в первый раз, она может оставаться на месте неограниченно долго (противник не имеет права её рубить). Затем, её можно выставить на доску в любое место, где она будет угрожать двум фигурам, либо фигуре, которая не может сделать ход. Сделать это можно даже в том случае, если нужное поле занято своей фигурой (досадная помеха просто убирается с доски). Дойдя до поля превращения повторно, "Пешка пешек" перемещается на стартовую позицию королевской пешки, откуда она может вновь повторить свой путь. Проведя многострадальную пешку через всю доску в третий раз, игрок может получить в своё распоряжение третьего короля.

Японцы, как всегда, развили идею "превращения" и довели её до логического завершения. В <a href="http://skyruk.livejournal.com/286841.html">Сёги</a> любая фигура, кроме короля и "Золотого генерала" может быть превращена в лагере противника (три последних горизонтали, также как при игре в Макрук). Для фигур, не способных далее продолжать своё движение (пешка, конь, пика), превращение является обязательным. Остальные фигуры, могут быть превращены любым ходом, на территории "лагеря" противника. Все фигуры, кроме "драконов", превращаются в "Золото" (аналог "Золотого генерала"). Драконы (аналоги шахматных ладьи и слона) превращаются в свои усиленные версии. Я расскажу о Сёги подробнее ниже, в конце этой части.

Привычные нам Шахматы отличаются от всех перечисленных (за исключением "Алтай Шатра") тем, что у превращающейся пешки имеется выбор. В некоторых позициях бывает более выгодно получить, например, коня, а не более сильного ферзя. С точки зрения реализации это приводит к небольшой проблеме пользовательского интерфейса. Вместо одного хода, появляется множество сходных ходов. <a href="http://www.zillions-of-games.com/">ZoG</a> решает эту проблему просто, универсально, но не всегда удачно (почему - расскажу позже). Если из исходной позиции в целевую имеется несколько возможных ходов, открывается всплывающее окно, позволяющее выбрать один ход из списка.

Разумеется, изобретатели современных вариантов шахмат не могли пройти мимо такой замечательной возможности как превращение фигур. Первое, что приходит в голову - превращение фигуры "по требованию". Фигура, сделав "ход на месте", превращается в другую, по желанию игрока. <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1777">Too Much Chess</a> - прекрасный образчик подобной игры. Все фигуры в ней (кроме короля и ферзя) двойные. Нижняя фигура определяет перемещения, верхняя - ударные ходы. Щёлкнув по фигуре, можно поменять её верхнюю и нижнюю часть местами:

<video>http://www.youtube.com/watch?v=Tq3q2rrtV2w</video>

Больше всего, в этой игре, мне нравится пешка. Её альтер-эго - "Берлинская пешка" может ходить на одну клетку по диагонали вперёд и "есть" ходом на одну клетку вперёд. С начальной позиции, "Берлинская пешка" может прыгать по диагонали на две клетки. Жаль, что правило "взятия на проходе" на неё не действует. Было бы забавно.

Другой пример успешного использования  превращения фигур - семейство <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=53">Fusion Chess</a>. В играх этого семейства, фигура приобретает свойства "битой" фигуры (своей или чужой, в зависимости от типа игры). Так, побив слона, ладья превращается в аналог ферзя, а король, соединившись со слоном или ладьёй, превращается в чрезвычайно мобильного монарха. В Fusion Chess, где слияние происходит со своими фигурами, комбинированные фигуры могут впоследствии разделяться, по желанию игрока:

<video>http://www.youtube.com/watch?v=ebGy4q8aM2Q</video>

Интересным развитием идеи являются игры с "направленными" фигурами, такие как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=776">Rotary</a>. Каждая фигура может ходить и бить по указанным на ней направлениям и может "поворачиваться" по желанию игрока. Пешки, дойдя до последней горизонтали, превращаются в одну из фигур (кроме короля), на выбор:

<video>http://www.youtube.com/watch?v=MelLUGsSz7g</video>

В похожей игре <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=865">Stations</a> эксплуатируется "космическая" тематика. "Корабли" в ней могут не только летать в ту сторону, куда смотрят "турели", но также и защищаются по этим направлениям (в конце хода, фигуру можно повернуть на произвольный угол). Побить "дредноут", защищённый по 5 направлениям из 6 возможных, практически невозможно. "Станцию", свободно перемещающуюся по полю, можно бить с любого направления. 

<video>http://www.youtube.com/watch?v=8OrhD1bZTQg</video>

К сожалению, играть в такие игры с ZoG не очень удобно. Выбор из множества вариантов ходов, связанных с поворотом фигур на различные углы, выводится игроку во всплывающем окне, с использованием ZSG-нотации. Понять, какой из списка ходов соответствует желаемому углу поворота совсем непросто. 

Превращения могут происходить и независимо от желания игрока. Например по завершении хода на вертикаль соответствующей фигуры. Фигура может превращаться в съеденную фигуру или изменять свой цвет, возможных вариантов множество. Фигуры могут просто превращаться друг в друга циклически, при каждом ходе, так, как это происходит в <a href="http://en.wikipedia.org/wiki/Kyoto_shogi">Kyoto Shogi</a> (извиняюсь за иероглифы, более понятные варианты оформления в реализации игры отсутствуют):

<spoiler title="Кстати">
Вариант шахмат, в котором фигура, выполняющая бой, изменяет свой цвет на цвет съеденной фигуры и имеющий звучное название <a href="http://en.wikipedia.org/wiki/Andernach_chess">Andernach</a>, после продолжительных мучений, мне всё же удалось <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2257">реализовать</a> в ZoG. Нельзя сказать, что он очень играбельный. Любой бой на доске приводит к потере собственной фигуры и возможному усилению фигуры противника (бить сильными фигурами, понятно, проще чем слабыми). Не всё, что выглядит интересным в композиции, пригодно для полноценной игры двух игроков.
</spoiler>
<video>http://www.youtube.com/watch?v=bFLFBx5-9qU</video>

Интересным (и крайне быстротечным) является вариант шахмат, под названием <a href="http://www.chessvariants.org/difftaking.dir/benedict.html">Benedict Chess</a>. В этой игре боя нет вообще! Любая фигура, попавшая под удар противника, немедленно изменяет свой цвет. Игра заканчивается "перекрашиванием" вражеского короля:

<video>http://www.youtube.com/watch?v=y2BoyJtbOcE</video>

Фигуры могут изменять свои свойства, в зависимости от расположения и  поведения других фигур. Это не совсем превращение, поскольку фигура лишь временно изменяет свой статус, но что то очень на него похожее. В качестве примера, приведу один очень удачный <a href="http://en.wikipedia.org/wiki/Annan_shogi">вариант</a> Shogi. Фигура находящаяся "на голове" другой фигуры (общепринятый в Shogi термин, означающий расположение фигуры на одно поле выше), временно обретает свойства последней. Начальное расположение пешек вызвано тем, что было бы неразумно с первого хода придавать четырём пешкам качества "драконов":

<video>http://www.youtube.com/watch?v=sCAldoAwXVM</video>

Очень интересной фигурой является "Хамелеон" из упоминавшийся мной ранее <a href="http://www.chessvariants.org/other.dir/ultima.html">Ультимы</a>, который бьёт фигуры таким образом, каким бьют они сами. Играть по таким правилам в шахматы тоже возможно. Например в "Inverse Capture Chess" Ральфа Бетца, каждая фигура бьётся тем ходом, которым ходит она сама. Атаковать короля издалека, в этой игре, просто невозможно. В Ультиме, с её разнообразными правилами взятия, этот принцип буквально расцветает, превращая хамелеона в экстремально сильную фигуру:

<img align="center" src="https://habrastorage.org/files/b81/8a8/cb3/b818a8cb347a4580920fbac46cd30a75.gif"/>

Другая фигура-пересмешник используется в расширенном варианте <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BC%D0%B5%D0%B3%D0%B0-%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Омега-шахмат</a>. Шут не имеет своей начальной позиции и может быть установлен игроком (один раз за игру) на начальное поле любой фигуры, совершившей свой первый ход в партии. Ходы шута копируют ход последней сходившей фигуры противника. Кроме того, эта фигура обездвиживает все фигуры противника, расположенные на прилегающих к нему полях. Шут противника, в свою очередь, может "снять заморозку", подойдя к блокированной фигуре вплотную.

"Заморозка" фигуры также является одним из вариантов изменения её "поведения". Фигуры, обездвиживающие фигуры противника, при приближении к ним, подобные "Василиску" из трёхмерной <a href="http://en.wikipedia.org/wiki/Dragonchess">Dragonchess</a> реализуются довольно легко. Более сложная фигура используется в монгольской игре <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Хиашатар</a>. В этой игре помимо привычных шахматных фигур, используется фигура "Телохранитель" (Хиа), способная остановить "на скаку" любую дальнобойную фигуру, кроме коня:

<img align="center" src="https://habrastorage.org/files/9cb/7a8/1b6/9cb7a81b6f8d43a283d7d8442aa28944.png"/>

Входя в область его действия, любая фигура может перемещаться лишь на одну клетку за ход. Такое качество неплохо защищает и самого телохранителя. Ферзь не может съесть его одним ходом. Он должен приблизиться, встав под удар. Телохранитель превосходно выполняет свои защитные функции. Он не защищает от атак коня, но ставить мат конём в Шатар и Хиашатар запрещено. В "<a href="http://skyruk.livejournal.com/274836.html">Сянцы семи царств</a>" существовала другая защитная фигура (Дипломат), но она могла лишь перекрыть линию атаки. Телохранители в Хиашатар намного эффективнее.

Наверняка вы уже заметили, что в роликах, посвященных Сёги, "съеденные" фигуры не покидают игру, а перемещаются в резерв игрока. Впоследствии, игрок может выставлять эти фигуры на доску, для игры на "своей стороне". Такой ход, "из резерва", называется сбросом. Фигура "из резерва" может быть установлена почти на любое свободное поле доски (имеется ряд ограничивающих правил). Такая фигура (даже пешка) гораздо сильнее, чем если бы она стояла на своей начальной позиции. Кроме того, фигурам, находящимся в резерве, никто не угрожает. Игрокам становятся крайне выгодны равные размены, поскольку, в их результате, вместо фигур на доске, игроки получают те же фигуры, но уже в резерве.

Ограничения сброса в Сёги просты и логичны. Прежде всего, все фигуры сбрасываются на доску в не превращённом состоянии. Следующим ходом, фигуры, сброшенные в лагерь противника, могут быть превращены, по желанию игрока. Далее, нельзя выполнять сброс фигур на те поля, с которых они не смогут сделать ход (в противном случае, они так и оставались бы на этих полях, поскольку не смогли бы превратиться). Для пик и пешек - это последняя горизонталь, для коней - две последних горизонтали. Это правило не рассматривает возможность ограничения хода другими фигурами, речь идёт о местах, из которых фигуры не могут сделать ход, на пустой доске. Есть ещё два правила, связанные с пешками. Запрещается "сдваивать" пешки (то есть ставить две не превращенных пешки на одну вертикаль) и ставить мат сбросом пешки (об этом правиле я расскажу подробнее в следующем разделе).

В тактическом плане, правило сброса ведёт к двум последствиям. Первое очевидно - фаза <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BD%D0%B4%D1%88%D0%BF%D0%B8%D0%BB%D1%8C">эндшпиля</a> в Сёги не связана с уменьшением количества фигур на доске, поскольку все фигуры остаются в игре. Помимо этого, правило сброса, в совокупности с относительно малым количеством дальнобойных фигур, превращает Сёги в шахматы "ближнего боя". В самом деле, если "в руке" игрока есть хотя бы одна фигура, поставить мат издалека практически невозможно. От такой угрозы почти всегда можно защититься сбросом фигуры.

Правила сброса - главный вклад Японии в шахматную игру, но таким образом в Сёги играли не всегда. В период <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B8%D0%BE%D0%B4_%D0%A5%D1%8D%D0%B9%D0%B0%D0%BD">Хэйан</a> - время расцвета в Японии различного рода искусств, существовало большое количество различных вариантов этой игры. В Сёги играли на больших досках, огромным количеством разнообразных фигур. Привычная сегодня доска 9x9 называлась "малой" доской. В самом большом, из известных вариантов, <a href="https://en.wikipedia.org/wiki/Taikyoku_shogi">Taikyoku Shogi</a> использовалась 1296-польная доска (36x36) и набор из 402 фигур 209 различных типов. Большинство из этих фигур могло превращаться.

<img align="center" src="https://habrastorage.org/files/16d/c46/6b4/16dc466b4bd546f2a53fabe2e48bd8e9.jpg"/>
Порядок в этом зверинце был наведён в XVI веке императором <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%93%D0%BE-%D0%9D%D0%B0%D1%80%D0%B0">Го-Нара</a>. Фактически, император утвердил тот набор правил (включая правило сброса), по которому в Сёги играют по сей день. Правило сброса вдохновило разработчиков на создание новых игр, таких как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=45">Chessgi</a>, <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=52">Fusion Chessgi</a> и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=49">Crazyhouse</a>, использующих более привычные нам наборы фигур. В свою очередь, традиционное Сёги также развивается, заимствуя новые фигуры, такие как пушки из китайских шахмат, используемые в <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=152">Cannon Shogi</a>.

Правило сброса может работать и без явно выделенного резерва. Например, в <a href="http://genesischess.com/">Genesis Chess</a> игра начинается с пустой доски. Игрок, своим ходом, может добавить на поле новую фигуру, либо переместить одну из своих фигур, ранее установленных на доску. Съеденные фигуры в резерв не возвращаются. При добавлении фигур на доску, желательно иметь возможность для установки приоритетности ходов. Так, например, король должен быть выставлен на доску самым первым ходом, до размещения других фигур. 

Интересный вариант этой игры используется в одной из миссий кампании Хаоса в игре <a href="http://www.battlevschess.com/en/">Battle vs Chess</a>. В этой миссии, одинокий чёрный король противостоит целому войску. Каждым ходом, чёрные могут добавлять новые фигуры на доску. При этом, фигуры должны добавляться в порядке старшинства: сначала все пешки, затем лёгкие фигуры, ладьи и лишь последним - ферзь. Реализация правила сброса в <a href="http://www.zillions-of-games.com/">ZoG</a> довольно сложна. В ZRF имеется возможность определения <b>drop</b>-ходов, добавляющих фигуры на доску. Назначив этим ходам необходимые приоритеты, можно реализовать Genesis Chess:

<spoiler title="Фрагмент возможной реализации Genesis Chess">
<source lang="lisp">
   (board-setup
      (White
         (Pawn off 8)
         (Knight off 2)
         (Bishop off 2)
         (Rook off 2)
         (Queen off 1)
         (King off 1)
      )
      (Black
         (Pawn off 8)
         (Knight off 2)
         (Bishop off 2)
         (Rook off 2)
         (Queen off 1)
         (King off 1)
      )
   )
   (move-priorities kingdroptype normaltype)
   (piece
      (name Pawn)
      (image White "images\Chess\SHaag\wpawn.bmp" "images\Chess\wpawn.bmp"
             Black "images\Chess\SHaag\bpawn.bmp" "images\Chess\bpawn.bmp")
      (moves
         (move-type normaltype)
         (Pawn-capture nw)
         (Pawn-capture ne)
         (Pawn-move)
         (En-Passant e)
         (En-Passant w)
      )
      (drops 
          (move-type normaltype)
          (add-to-empty)
      )
   )
   ; ...
   (piece
      (name King)
      (image White "images\Chess\SHaag\wking.bmp" "images\Chess\wking.bmp"
             Black "images\Chess\SHaag\bking.bmp" "images\Chess\bking.bmp")
      (attribute never-moved? true)
      (moves
         (move-type normaltype)
         (king-shift n)
         (king-shift e)
         (king-shift s)
         (king-shift w)
         (king-shift ne)
         (king-shift nw)
         (king-shift se)
         (king-shift sw)
         (O-O)
         (O-O-O)
      )
      (drops 
          (move-type kingdroptype)
          (add-to-empty)
      )
   )

</source>
</spoiler>
Ключевое слово <b>off</b>, используемое в разделе <b>board-setup</b> означает, что фигуры ещё не размещены на доске (указывается количество фигур, доступных для использования игроком). Фраза <b>drops</b> определяет ходы сброса, а <b>move-priorities</b> гарантирует, что король будет добавлен на доску самым первым ходом, каждым из игроков. 

К сожалению, в определяемый таким образом резерв, невозможно добавить фигуры (взятые у противника). Резерв в реализации Сёги должен определяться как полноценная часть доски, наподобие "крепости" в Алтай Шатра, только без возможности хода фигурой из него через "ворота". Реализация такой логики в ZoG крайне многословна. Требуется вручную управлять логикой расстановки фигур в резерве, искать фигуры заданного типа и т.п. Вот как выглядит поиск свободного места в резерве (для доски <a href="http://en.wikipedia.org/wiki/Minishogi">5x5</a>):

<spoiler title="Фрагмент реализации Сёги">
<source lang="lisp">
(define first-empty
   to-prison
   (while not-empty? next-prison)
)
; ...
(links to-prison
			(5i pb0) (4i pb0) (3i pb0) (2i pb0) (1i pb0)
			(5ii pb0) (4ii pb0) (3ii pb0) (2ii pb0) (1ii pb0)
			(5iii pb0) (4iii pb0) (3iii pb0) (2iii pb0) (1iii pb0)
			(5iv pb0) (4iv pb0) (3iv pb0) (2iv pb0) (1iv pb0)
			(5v pb0) (4v pb0) (3v pb0) (2v pb0) (1v pb0)
)
(links next-prison
			(pb0 pb9) (pb9 pb8) (pb8 pb7) (pb7 pb6) (pb6 pb5) (pb5 pb4) (pb4 pb3) (pb3 pb2) (pb2 pb1)
			(pw1 pw2) (pw2 pw3) (pw3 pw4) (pw4 pw5) (pw5 pw6) (pw6 pw7) (pw7 pw8) (pw8 pw9) (pw9 pw0)
)
</source>
</spoiler>
Превращения фигур могут потребовать использования нескольких различных механизмов, предоставляемых ZoG. В том случае, если изменяются лишь аспекты поведения фигуры, а не её внешний вид, могут быть использованы атрибуты (подобно тому как в реализации Шахмат используется атрибут для определения неподвижности короля и ладьи до выполнения блокировки). Если ходы фигуры зависят лишь от её расположения на доске (как ходы пешки до превращения в "Алтай Шатра"), достаточно выполнять проверку нахождения фигуры в некоторой зоне.

Если внешний вид фигуры должен изменяться - выбора нет, должен быть изменён тип фигуры или её владелец. Изменение типа фигуры, перемещаемой в рамках выполнения хода, осуществляется расширенной командой <b>add</b>, завершающей в ZoG формирование хода. Её аргумент представляет собой тип фигуры, в которую должна превратиться фигура, выполняющая ход. Если список содержит более одного элемента, формируется несколько однотипных ходов и ZoG выводит меню выбора хода из списка. Превращаемая фигура может никуда не ходить (как в Too Mach Chess). Вот как выглядит фрагмент реализации этой игры, связанный с превращением фигур:

<spoiler title="Фрагмент реализации Too Mach Chess">
<source lang="lisp">
(define Pawn-add
   (if (in-zone? promotion-zone)
   		(add Knight-on-Bishop Knight-on-Rook
   			 Bishop-on-Knight Bishop-on-Rook
   			 Rook-on-Knight Rook-on-Bishop
   			 Queen) 
   	else add))

(define Pawn-move
   (  $1  (verify empty?)
      (Pawn-add)
      (verify (in-zone? third-rank))
      $1  (verify empty?)
      add   ))
      
(define Pawn-capture
   (  $1   (verify enemy?)  (Pawn-add)   ))
   
(define flip-pawn
(to
(if (in-zone? promotion-zone)
   		(add Knight-on-Bishop Knight-on-Rook Bishop-on-Knight Bishop-on-Rook
   			 Rook-on-Knight Rook-on-Bishop ) else (add Berolina-Pawn))))
   			 
(define flip-berolina
(to
(if (in-zone? promotion-zone)
   		(add Knight-on-Bishop Knight-on-Rook Bishop-on-Knight Bishop-on-Rook
   			 Rook-on-Knight Rook-on-Bishop ) else (add Pawn))))
; ...
   (piece
      (name Pawn)
      (image White "images\TooMuchChess\set1\WP.bmp" "images\TooMuchChess\set2\WP.bmp" 
             Black "images\TooMuchChess\set1\BP.bmp" "images\TooMuchChess\set2\BP.bmp")
      (moves
         (Pawn-capture nw)         
         (Pawn-capture ne)
         (Pawn-move n)
         (Pawn-En-Passant e)         
         (Pawn-En-Passant w)
         (flip-pawn)      
      )   
   ) 
</source>
</spoiler>
Для изменения владельца фигуры, можно использовать команды <b>change-owner</b> и <b>flip</b>. Командой <b>change-type</b> можно изменить тип фигуры не выполнявшей ход (в качестве побочного эффекта хода). К сожалению, целевой владелец фигуры в командах <b>не указывается</b>, в результате чего, изменение владельца фигуры будет корректно работать только в играх двух противостоящих игроков. На мой взгляд, это крайне досадная недоработка дизайна ZRF. Вот как используется команда <b>flip</b>, в реализации Benedict Chess:

<spoiler title="Фрагмент реализации Benedict Chess">
<source lang="lisp">
(define step-flip (if (enemy? $1) (flip $1)))

(define step-flip-all
	(step-flip n)
	(step-flip e)
	(step-flip s)
	(step-flip w)
	(step-flip ne)
	(step-flip nw)
	(step-flip se)
	(step-flip sw)
)

(define king-step 
	($1 (verify empty?) 
	(set-attribute never-moved? false) 
	(step-flip-all) 
	add)
)
</source>
</spoiler>
Из анализа этого кода понятно (и это легко проверяется), что Benedict Chess не отслеживает "вскрытые" угрозы. Изменения касаются лишь фигур, попавших под удар фигуры, совершившей ход. Если ход одной фигуры открывает атаку другой, это игнорируется. Оставим в стороне вопрос об играбельности подобного варианта и рассмотрим лишь возможность его реализации. Чтобы отслеживать "вскрытые" атаки, нам потребовалось бы выполнять перебор всех дружественных фигур (что в ZoG само по себе не тривиальная задача), а затем всех их атак, изменяя владельца фигур противника, попавших под удар. При этом, список дружественных фигур будет пополняться и потребуется отслеживать вновь добавляемые фигуры, чтобы не выполнять проверок для них. В общем, это довольно сложная задача. Что касается аналога Benedict Chess для более чем 2 игроков, он, увы, не реализуем средствами ZRF.

Есть ещё одна проблема, связанная с изменением владения, с которой я столкнулся при реализации Andernach. Команда <b>change-owner</b> позволяет "переключить" владельца любой фигуры на доске, но с той фигурой, которая выполняет ход, возникает проблема. С одной стороны, мы должны завершить ход своей фигурой, но, по нашему замыслу, эта фигура должна изменить владение до завершения хода! <b>change-owner</b> здесь не поможет. К счастью, есть ещё одна команда (<b>create</b>), позволяющая создать на доске фигуру с требуемым типом и владельцем (в реализации <a href="http://en.wikipedia.org/wiki/Circe_chess">Цирце</a> эта команда тоже оказалась не лишней).

<spoiler title="Фрагмент реализации Andernach Chess">
<source lang="lisp">
(define a-rook-slide-wc (
  $1
  (while empty? (set-attribute never-moved? false) $1)
  (verify enemy?)
  (set-attribute never-moved? false)
  (create $2 $3)
  add
))

   (piece
      (name WhiteRook)
      (image White "images\Chess\SHaag\wrook.bmp" "images\Chess\wrook.bmp")
      (attribute never-moved? true)
      (moves
         (move-type with-capture)
         (a-rook-slide-wc n Black BlackRook)
         (a-rook-slide-wc e Black BlackRook)
         (a-rook-slide-wc s Black BlackRook)
         (a-rook-slide-wc w Black BlackRook)
         (move-type without-capture)
         (a-rook-slide n)
         (a-rook-slide e)
         (a-rook-slide s)
         (a-rook-slide w)
      )
   )
</source>
</spoiler> 
Реализация получилась крайне многословной, но работающей. Меня спасла одна неочевидная особенность ZRF. В том случае, если на целевом поле, командой <b>create</b>, создаётся новая фигура, она более приоритетна, чем фигура совершающая ход. Фигура, выполнившая ход, удаляется автоматически, поскольку две фигуры не могут одновременно занимать одно поле. Превращения и сброс фигур не те задачи с которыми ZoG или Axiom не могли бы справиться, но, в некоторых случаях, над реализацией приходится сильно поломать голову и много поработать руками. У ZRF имеются и более серьёзные проблемы, но о них я расскажу в следующих частях.
</habracut>

Dagaz: Пинки здравому смыслу (часть 1)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/>Важной частью работы над универсальной игровой системой является систематизация правил. За тысячи лет своего развития, человечество придумало невероятное количество настольных игр. Их правила, по большей части, похожи, но некоторые могут поставить разработчика в тупик. Эти правила столь же важны, как и все остальные. Здесь не действует <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%9F%D0%B0%D1%80%D0%B5%D1%82%D0%BE">принцип Парето</a> - либо мы реализуем игру полностью, на все 100%, либо ... &nbsp;
это будет совсем другая игра. В процессе работы над проектом Dagaz, я решил составить свой рейтинг правил, наиболее неожиданных или неудобных для разработчика. Встречайте...&nbsp;
<habracut>
<h4><b>10. Странные ходы</b></h4>
<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> - это, пожалуй, первая игра, про которую мы вспоминаем говоря о настольных играх, но они далеко не сразу обрели знакомые нам черты. В <a href="http://skyruk.livejournal.com/292733.html">Шатрандже</a>, их непосредственном предшественнике, ферзь был очень слабой фигурой! Он ходил всего на одно поле, по любой из диагоналей. Слон также не был дальнобойным, но умел перепрыгивать через фигуры. Пешка, дойдя до последней горизонтали превращалась лишь в ферзя (а не в любую фигуру на выбор, как сейчас). Ладья ходила по привычным нам правилам, но её ещё требовалось вывести на "оперативный простор". В целом, игра получалась весьма неторопливой, но это компенсировалось наличием огромного количества <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%B8%D1%8F">табий</a> - начальных позиций, с которых игроки, по договорённости, могли начинать игру.

<spoiler title="Первый пинок">
По всей видимости, не зная о табиях, жители Эфиопии решили по своему преодолеть медлительность Шатранджа. В их <a href="http://en.wikipedia.org/wiki/Senterej">варианте</a> этой игры первые ходы выполнялись игроками независимо друг от друга (кто сколько успел). Лишь после первого взятия, устанавливалось нормальное чередование ходов. Этот удар по здравому смыслу выступает сегодня вне конкурса, поскольку я просто не представляю себе как реализовать подобное требование в универсальной игровой системе. Кстати говоря, подобная игра "на скорость" весьма характерна для жителей африканского континента и встречается не только при игре в шахматы.
</spoiler>
Конь - ещё одна фигура, практически не претерпевшая изменений со времён <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%82%D1%83%D1%80%D0%B0%D0%BD%D0%B3%D0%B0">Чатуранги</a>. Он разучился перепрыгивать фигуры (как свои так и противника) в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8">Сянцы</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D0%BD%D0%B3%D0%B8">Чанги</a>, а в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> умеет двигаться только вперёд (что, по своему, многое говорит о менталитете японцев), но эта фигура, по-прежнему, остаётся самой узнаваемой во всех играх шахматного семейства. Именно на основе коня были впервые "сконструированы" новые типы фигур, таких как <a href="http://en.wikipedia.org/wiki/Capablanca_chess">канцлер и архиепископ</a>. Впоследствии, поток подобных <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B8%D0%BC%D0%B5%D1%80%D0%B0">химер</a> стал столь интенсивным, что потребовалась специальная <a href="http://en.wikipedia.org/wiki/Fairy_chess_piece">система классификации</a> для вновь изобретённых фигур, но не конь, на мой взгляд, является самой странной фигурой.

Пешка - единственная фигура в Шахматах, взятия которой отличаются от обычного хода. Привычный нам "шахматный" принцип (фигура, выполняющая взятие, устанавливается на место взятой фигуры), пока, остаётся неизменным, но ходит пешка на одно поле вперёд, а бьёт по диагонали. Это самая малая проблема для разработчика, неприятности начинаются дальше. 

С целью максимально быстрого захвата центра доски, пешкам было дано право двойного хода из начальной позиции (в некоторых вариантах шахмат, с досками большего размера, пешка прыгает ещё дальше). Поскольку такой прыжок позволял прорвать пешечный строй противника, как следствие, появилось правило "<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a>", и вот это уже форменное безобразие. Шахматный принцип здесь нарушается. Атакуется не то поле, на котором стоит вражеская фигура, а поле, через которое она прошла. Более того, выполнить такой ход можно только на следующем ходу после "прыжка" пешкой противника. Посмотрим, как это отразилось на разработчиках:

<spoiler title="En-Passant (ZoG)">
<source lang="lisp">
(define En-Passant
   (
      $1
      (verify enemy?)
      (verify last-to?)
      (verify (piece? Pawn))
      capture
      n
      to
      n
      (verify last-from?)
      add
   )
)
</source>
выглядит несколько сложнее обычного взятия:

<source lang="lisp">
(define Pawn-capture
   (
      $1
      (verify enemy?)
      (Pawn-add)
   )
)
</source>
</spoiler>
Шаманство с перемещениями - малая часть проблемы. Разработчикам <a href="http://www.zillions-of-games.com/">ZoG</a> пришлось ввести в ядро новый предикат <b>last-from?</b>,  выполняющий проверку того факта, что предыдущий ход (противника) выполнялся с текущего поля. Такое решение сложно расценить иначе чем поспешный и не очень удачный "костыль". Оно не универсально и не работает в более сложных случаях. Например, в <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D1%82%D0%B2%D0%B5%D1%80%D0%BD%D1%8B%D0%B5_%D0%BD%D0%B5%D0%BC%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">четырёхсторонних шахматах</a>, правило взятия на проходе может быть применено к игроку, сидящему напротив, но предыдущий ход выполняется не им, а игроком, сидящим сбоку, в результате чего <b>last-from?</b> не работает! Пришлось подумать о более универсальном решении:

<spoiler title="En-Passant (Dagaz)">
<source lang="lisp">
(define pawn-jump
  (check (not is-moved?))
  (set! turn-jumped turn-number)
  (check-source Pawn)
  (check n)
  (check is-empty?)
  (check n)
  (check is-empty?)
  (drop-pieces current-pieces)
  add-move
)

(define (en-passant piece-type direction)
  (check-source piece-type)
  (check direction)
  (check is-enemy?)
  (check (<= 1 (- turn-number turn-jumped)))
  capture
  (check n)
  (check is-empty?)
  (drop-pieces current-pieces)
  add-move
)
</source>
</spoiler>
Если вы думаете, что "взятием на проходе" странности привычных нам Шахмат ограничиваются, подумайте ещё раз. В Шахматах есть ход, во время которого двигается сразу несколько фигур! Да, это <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>. Она тоже появилась не сразу и не на пустом месте. С историей вопроса можно ознакомится в этой замечательной <a href="http://skyruk.livejournal.com/420321.html">статье</a>. Идея - одним ходом спрятать короля в "крепость" и, заодно, ввести в бой тяжёлую фигуру прекрасна, но страдают опять разработчики:

<spoiler title="Рокировка (ZoG)">
<source lang="lisp">
(define O-O
	 ( (verify never-moved?)
	   e ; KB1
	   (verify empty?)
	   e ; KN1
	   (verify empty?)
	   cascade
	   e ; KR1
	   (verify (and friend? (piece? Rook) never-moved?) )
	   from
	   back ; K1
		 ; Save expensive not-attacked?s for last
	   (verify not-attacked?)
	   e ; KB1
	   (verify not-attacked?)
	   to
	   (set-attribute never-moved? false)
		 ; We could check if KN1 is attacked too, but this isn't
		 ; really necessary since Zillions doesn't allow any moves
		 ; into check
	   e ; KN1
	   (set-attribute never-moved? false)
	   add
	 )
)
</source>
</spoiler>
И это только короткая! Длинную я приводить не стал, из соображений гуманности. Я благодарен небу и всему цивилизованному шахматному сообществу, за то, что, до сегодняшнего дня, не сохранилась "свободная рокировка", столь любимая, в своё время, итальянцами. Специально для реализации рокировки, разработчикам пришлось ввести в ядро ZoG команду <b>cascade</b>, позволяющую вовлечь в выполнение хода несколько фигур. Здесь, я ничего плохого не скажу, хорошее универсальное решение, но себя я решил вообще не ограничивать глупыми условностями. Рокировка начинается с перемещения короля, но кто сказал, что ходить должна всего одна фигура?

<spoiler title="Рокировка (Dagaz)">
<source lang="lisp">
(define O-O
   (check (not is-moved?))
   (check not-attacked?)
   (take-piece-to-head current-pieces)
   (check w)
   (check is-empty?)
   (check (not-attacked? King))
   (check w)
   (check is-empty?)
   (check (not-attacked? King))
   (drop-pieces current-pieces)
   (check w)
   (check (not is-moved?))
   (set! is-moved? true)
   (take-piece-to-head current-pieces)
   e e
   (drop-pieces current-pieces)
   add-move
)
</source>
</spoiler>
Возможность выполнения рокировки связана с выполнением ряда интересных условий. Так рокировка невозможна, если:

<ul>
	<li>король или ладья уже ходили в партии</li>
	<li>король находится под шахом</li>
	<li>король в результате рокировки попадает под шах</li>
	<li>поле, через которое должен пройти король, атаковано фигурой противника</li>
	<li>между королём и ладьёй, в сторону которую переставляется король, находятся другие фигуры</li>
</ul>
Проверка последнего условия выполняется тривиально. Для того, чтобы проверять первое условие, в ZoG были введены атрибуты фигур (очень полезная возможность, правда я считаю, что было бы ещё полезнее, если бы атрибуты могли хранить не только булевские значения). Что касается остального - то это тема для отдельного и очень серьёзного разговора в одном из следующих разделов.

Как можно видеть, в реализации классических Шахмат, есть над чем поломать голову, но настоящее веселье начинается в шахматах не классических. Что будет, если собрать вместе <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%BD%D0%B5%D1%84%D0%B0%D1%82%D0%B0%D1%84%D0%BB">Хнефатафл</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашки</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанорону</a>, добавить одну уникальную, ни на что не похожую фигуру, тщательно перемешать, но не взбалтывать? Не знаю как у вас, а у <a href="http://tesera.ru/person/5102/">Роберта Эббота</a>, в 1962 году, получилась <a href="http://www.chessvariants.org/other.dir/ultima.html">Ультима</a>. 

В этой игре всё непривычно. Пожалуй, только король продолжает придерживаться шахматных принципов. Вот <a href="http://www.chessvariants.org/other.dir/ultimapieces.html">здесь</a> можно посмотреть иллюстрированное руководство правил, по которым ходят фигуры. Для разработчика, в этом празднике жизни, важнее всего то, что, в этой игре, чаще всего, атакуется совсем не то поле, на которое ходит фигура, а иногда даже несколько полей сразу. Этот факт имеет далеко идущие последствия, но это вновь тема для разговора в одном из последующих разделов. Другим примером подобной "проблемной" игры является <a href="http://habrahabr.ru/post/234587/">Ритмомахия</a>.

Dagaz: Факториал — это просто!

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image"/>Скриптинг - пожалуй наиболее важная (хотя и не самая сложная) часть задуманного мной <a href="http://habrahabr.ru/post/242547/">проекта</a>. Для того, чтобы всё заработало, мне потребуется язык общего назначения, с переменными, условным выполнением, циклами и исключениями. Мне не требуется что-то сложное, вроде <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">анонимных функций</a> или <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">замыканий</a>. Скорее всего, мне не пригодится даже <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F#.D0.92_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B8">рекурсия</a>, во всяком случае, пока, для неё не нашлось применений, ни в одном из моих <a href="https://github.com/GlukKazan/Dagaz/tree/master/src/drf">case</a>-ов. В этом языке совсем не будет <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80">синтаксического сахара</a>, поскольку все задачи метапрограмирования возьмёт на себя <a href="http://habrahabr.ru/post/245849/">XSLT</a>. В общем, этот язык будет прост настолько, насколько это возможно, но ... не проще.&nbsp;
<habracut>
Напомню, что скрипт, в моём понимании, содержит не только определение ряда функций, задающих "поведение" участвующих в игре объектов, но, помимо этого, должен определять структуру довольно таки сложных объектов, таких как "доска", "фигуры" и т.п. Вот <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/drf/senet.drf">пример</a> подобного описания:

<spoiler title="Определение ''доски''">
<source lang="lisp">
   (board
      (grid (dimensions "A_J" "1")
            (direction (name forward)   1 0)
            (direction (name backward) -1 0)
      )
      (grid (dimensions "A_J" "2")
            (direction (name forward)  -1 0)
            (direction (name backward)  1 0)
      )
      (grid (dimensions "A_K" "3")
            (direction (name forward)   1 0)
            (direction (name backward) -1 0)
      )
      (grid (dimensions "a_d"))
      (link (name forward)  (J1 J2) (A2 A3) (K3 K3))
      (link (name backward) (J2 J1) (A3 A2) (K3 K3))
      (zone (name rebirth)  (positions F2))
      (zone (name protect)  (positions F3 G3 H3 I3 J3))
      (zone (name beauty)   (positions F3))
      (zone (name water)    (positions G3))
      (zone (name truth)    (positions H3))
      (zone (name ra)       (positions I3))
      (zone (name stop)     (positions F3 K3))
      (zone (name end)      (positions K3))
      (zone (name dices)    (positions a b c d))
   )
</source>
</spoiler>
Это определение - своего рода "карта" настольной игры и оно может быть очень сложным. Именно для разбора таких иерархических структур мне понадобился <a href="https://ru.wikipedia.org/wiki/XPath">XPath</a>, что, в свою очередь, привело к необходимости использования <a href="https://ru.wikipedia.org/wiki/XML">XML</a>, для внутреннего представления скрипта в памяти. Разбор таких структур <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/BoardConfigurator.java">многословен</a>, но довольно прямолинеен. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/tests/scripting/drf/factorial.drf">Код</a> - другое дело.

<source lang="lisp">
(define (factorial n a)
  (if (<= n 1)
     a
   else
     (factorial (- n 1) (* a n))
  )
)

(define (factorial n)
  (factorial n 1)
)

(define main
  (set! out (factorial 5))
)
</source>
Надеюсь, вы его узнали. Да, здесь вычисляется значение <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B0%D0%BB">факториала</a>, с использованием "хвостовой рекурсии", и нет, я не собираюсь заниматься оптимизацией "хвостовой рекурсии". Как я уже говорил, мне и рекурсия то вряд ли понадобится. Тем, кто вдруг не знает, что такое "хвостовая рекурсия" и зачем её может понадобиться оптимизировать, я рекомендую почитать <a href="http://newstar.rinet.ru/~goga/sicp/sicp.pdf">эту замечательную книгу</a>. 

Этот код - просто компактный тест, максимально покрывающий весь интересующий меня, в данный момент, функционал. В нём используется условный оператор, вызовы и определения функций, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80_%D0%B8_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9">перегрузка</a> и работа с параметрами. Поскольку операторы ввода/вывода в языке не предусмотрены (они и не потребуются), в тесте, вывод будет эмулироваться присвоением итогового значения "переменной" <b>out</b>.

<spoiler title="Кстати говоря">
Сложность выбранного теста вполне себя оправдала. Вычисляя факториал трёх я обратил внимание на то, что полученное значение "2" несколько отличается от ожидаемого. Расследование этой ситуации привело к следующему <a href="https://github.com/GlukKazan/Dagaz/commit/f5064b98e3e8a950f4b6fc4aa3486f52d7995995">фиксу</a>. Я вполне мог не заметить эту ошибку, используя более простой тест.
</spoiler>
Можно заметить, что все управляющие конструкции языка являются функциями, в том смысле, что они всегда возвращают некое <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/api/src/main/java/com/gluk/dagaz/api/rules/runtime/IValue.java">значение</a>. Например, результатом выполнения <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/SeqExpression.java">последовательности</a> выражений является результат последнего выполненного выражения. Отдельно стоит упомянуть об <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9">исключениях</a>:

<source lang="lisp">
(define dice-drop
   (check (in-zone? dices))
   (check is-empty?)
   drop-pieces
   add-move
)
</source>
В любой момент, может быть выполнена проверка истинности некоего булевского выражения. В случае, если полученное значение окажется ложным, выполнение должно быть немедленно прервано. Мне неизвестен инструмент, более подходящий для этой задачи, чем исключения. <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/CheckExpression.java">CheckExpression</a> вычисляет значение своего аргумента в булевском контексте и "бросает" <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/api/src/main/java/com/gluk/dagaz/api/exceptions/CheckException.java">CheckException</a>, при нарушении условия (очевидно, что эта функция будет возвращать истинное значение всегда, если только до возврата значения вообще дойдёт дело). 

Значения аргументов функций будут вычисляться <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F#.D0.90.D0.BF.D0.BF.D0.BB.D0.B8.D0.BA.D0.B0.D1.82.D0.B8.D0.B2.D0.BD.D1.8B.D0.B9_.D0.BF.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA">строго</a>, до передачи управления функциям. Тотальной "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">ленивости</a>" вычислений не будет, но такие функции как <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/IfExpression.java">if</a>, <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/AndExpression.java">and</a> или <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/OrExpression.java">or</a> будут вычислять значения своих аргументов лишь при необходимости. Для вызова произвольных функций (определённых в теле скрипта), предназначена конструкция <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/ApplyExpression.java">ApplyExpression</a>. Полученные значения аргументов представляют собой ни что иное, как локальные переменные, область видимости которых ограничена вызываемой функцией. Доступ ко всем переменным осуществляется через интерфейс <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/api/src/main/java/com/gluk/dagaz/api/rules/runtime/IEnvironment.java">IEnvironment</a>, передаваемый каждому вычисляемому выражению:

<source lang="Java">
public interface IEnvironment {
	...
	void   letValue(String name, IValue value) throws EvaluationException;
	void   setValue(String name, IValue value) throws EvaluationException;
	IValue getValue(String name, boolean isQuoted) throws ValueNotFoundException;
	...
}
</source>
Используя этот интерфейс, можно создавать локальные переменные (функцией <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/LetExpression.java">let</a>), изменять их значение (функцией <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/SetExpression.java">set!</a>), а также получать значение по имени. Для <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/GetExpression.java">последней</a> их этих операций, специальной функции не предусмотрено. Любой <a href="http://www.cardarmy.ru/proekt/lisp/art2.htm">атом</a>, не являющийся строковым или числовым литералом, будет рассматриваться как обращение к переменной (или параметру функции), при условии того, что в скрипте не была определена функция с тем же именем и <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C">арностью</a>.

<spoiler title="Подробности для любознательных">
Коллизий между вызовами функций и обращениями к переменным можно было бы избежать, всегда обрамляя вызовы функций скобками, следующим образом:

<source lang="lisp">
(define dice-drop
   ...
   (drop-pieces)
   (add-move)
)
</source>
Я посчитал подобную запись излишне громоздкой. Кроме того, возникла проблема с <a href="http://habrahabr.ru/post/245849/">внутренним представлением</a> подобных структур в XML. Другой не реализованной возможностью является вычисление имени вызываемой функции:

<source lang="lisp">
((if (< a b) "+" else "-") a b)
</source>
В любом случае, я не считаю, что использование подобных конструкций необходимо. 
</spoiler>
С целью максимального упрощения языка, я не стал реализовывать оператор <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF#.D0.91.D0.B0.D0.B7.D0.BE.D0.B2.D1.8B.D0.B5_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B.2C_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D1.8B_.D0.B8_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8">QUOTE</a> явно (поэтому написать <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D0%B0%D0%B9%D0%BD_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">Quine</a> на этом языке вряд ли удастся). Цитирование в языке есть, но оно неявное. Например, такие выражения как <b>let</b> и <b>set!</b> "знают", что первый аргумент вычислять не надо (за это отвечает переопределённый метод <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/api/src/main/java/com/gluk/dagaz/api/rules/runtime/IExpression.java">IExpression.isQuoted</a>). Таким образом, первый аргумент, в этих выражениях, воспринимается как имя переменной, а не попытка получения её значения.

<spoiler title="Ещё больше подробностей">
В прикладном коде могут встречаться и более сложные ситуации, связанные с неявным цитированием:

<source lang="lisp">
(define (piece-move direction)
   (check up)
   (check direction)
   ...
)
...
(moves 
   (piece-move north)
   (piece-move south)
   (piece-move east)
   (piece-move west)
   ...
)
</source>
Подобный код будет встречаться очень часто. Здесь, атомы <b>north</b>, <b>south</b>, <b>east</b> и <b>west</b> должны интерпретироваться как <b>имена</b> направлений, но лишь при условии, что такие направления на доске определены (в противном случае, это обращение к переменным). Таким образом, параметр <b>direction</b> будет  содержать строку с именем соответствующего направления. 

Позиционирование и навигация осуществляются путем обращения к псевдопеременным с соответствующими именами. Обращение к "переменной" <b>up</b> (при условии определения такого направления на доске) переместит маркер текущей позиции (в качестве побочного эффекта), а также вернёт значение <b>true</b>, если это перемещение было выполнено успешно.

Но что произойдёт при обращении к параметру <b>direction</b>? Если не предпринимать дополнительных действий, будет получено не пустое строковое значение, которое, в булевском контексте, будет интерпретировано как <b>true</b>. Это явно не то, чего бы нам хотелось. Чтобы исправить ситуацию, модуль, предоставляющий доступ к состоянию расчёта хода, должен проверить не является ли полученная строка именем позиции или направления. Если это так, операция <b>get</b> должна быть выполнена повторно и уже её результат должен быть возвращён в точку вызова. Это является хорошей иллюстрацией тезиса о том, что упрощение языка может вести к усложнению его реализации.
</spoiler>
С учётом всего сказанного выше, кодогенерация становится довольно <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/CodeConfigurator.java">тривиальной</a>. Требуется лишь найти определения функций в XML и рекурсивно построить иерархии соответствующих им выражений. Сами выражения создаются <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/runtime/ExpressionFactory.java">ExpressionFactory</a>, что позволяет легко расширять список поддерживаемых системных функций (вплоть до реализации новых конструкций языка).

Разумеется, это не конец пути. Чтобы от такого скриптинга была польза, необходимо связать его с навигацией в игровом пространстве и изменением состояния расчёта хода. Потребуется определить массу системных функций, работающих в терминах предметной области, таких как <b>is-friend?</b> или <b>is-empty?</b>. Наконец, для реализации генератора ходов, потребуется реализовать возможность <a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%9D%D0%B5%D0%B4%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">недетерминированных вычислений</a>. По сравнению со всеми этими вещами, факториал - это действительно просто.
<habracut>

Dagaz: Вновь об XSLT

<img align="left" src="https://habrastorage.org/files/c97/a13/699/c97a13699b5b4bb98ffe09c0be6860fe.PNG"/>Ранее я уже писал небольшую <a href="http://habrahabr.ru/post/203004/">статью</a> о программировании на <a href="http://ru.wikipedia.org/wiki/XSLT">XSLT</a>, но она носила несколько синтетический, учебный характер. В самом деле, если кому-то вдруг и понадобиться найти одну из возможных расстановок "8 ферзей", для решения этой задачи найдётся с десяток других, более удобных, языков, чем XSLT. Я часто использую XSLT в работе, но эти примеры его использования какие-то скучные и не особо интересные. Совсем недавно я нашёл для этого языка более забавное применение. Именно об этом, а также о том "как я докатился до мысли такой" я и собираюсь рассказать.&nbsp;
<habracut>
Вот уже на протяжении некоторого, весьма продолжительного, времени, я буквально одержим идеей создания универсального "движка", предназначенного для разработки абстрактных логических игр (таких как <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашки</a>, <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматы</a> или <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>). Разумеется, я не оригинален. Подобные проекты <a href="http://www.zillions-of-games.com/">существуют</a>, но все они, на мой взгляд, <a href="http://habrahabr.ru/post/221779/">имеют</a> <a href="http://habrahabr.ru/post/242547/">недостатки</a> (помимо "<a href="http://k-press.ru/cs/2001/1/clr/clr.asp">фатального</a>"). Впрочем, достоинств у этих разработок заметно больше и едва ли не главным является декларативность используемых описаний. Вот так, например, выглядит описание игры на языке <a href="http://www.doc.ic.ac.uk/~sgc/papers/browne_cig11.pdf">GDL</a>:

<source lang="lisp">
(game Tic-Tac-Toe
   (board
      (tiling square)
      (size 3 3)
   )
   (win (in-a-row 3))
)
</source>
Такая запись компактна и самодостаточна. Её можно использовать как "сырьё" для работы <a href="http://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC">генетических алгоритмов</a>, разрабатывающих новые виды логических игр. В отличии от проекта <a href="http://www.doc.ic.ac.uk/~sgc/papers/browne_cig11.pdf">Ludi</a>, я не ставлю перед собой такой цели, но компактность описания и для меня будет не лишней. Вот так, на сегодняшний день, выглядит описание одной из известных <a href="http://skyruk.livejournal.com/241051.html">игр</a> в моём <a href="https://github.com/GlukKazan/Dagaz/tree/master/src/drf">репозитории</a>:

<spoiler title="Мельница">
<source lang="lisp">
(define variables
   (let hash 0)
)

(define invariant
   (check (not-situation-repeated? hash 1 1))
)

(define goals
   (check-loss 
      (and (> mans-left 0)
           (>= 2 (count (check is-friend?))
      )
   )
   (check-loss
      (not-exists? try-moves)
   )
)

(define man-drop
   (check (decrement! mans-left))
   (check is-empty?)
   (drop-pieces Man)
   (set! unique mans-left)
   add-move
)

(define (man-move direction)
   (check (= 0 mans-left))
   (check (< flying-mans-count (count (check is-friend?))))
   (check is-friend?)
   (take-piece-to-head current-pieces)
   (check direction)
   (check is-empty?)
   (drop-pieces current-pieces)
   add-move
)

(define man-random
   (check (= 0 mans-left))
   (check (>= flying-mans-count (count (check is-friend?))))
   (check is-friend?)
   (take-piece-to-head current-pieces)
   (any
      (check is-empty?)
      (drop-pieces current-pieces)
      add-move
   )
)

(define (check-line direction)
   (check (exists?
              (check is-friend?)
              (add-to-zobrist-hash hash)
              (check direction)
              (check is-friend?)
              (add-to-zobrist-hash hash)
              (check direction)
              (check is-friend?)
              (add-to-zobrist-hash hash)
          )
   )
)

(define capturing
   (if (or (check-line strong-n) (check-line strong-e) (check-line strong-ne) (check-line strong-se))
       (any (check is-enemy?) capture)
   )
)

(game
   (title "Nine Men's Morris")
   (players White Black)
   (board
      (positions A1 A4 A7 B2 B4 B6 C3 C4 C5 D1 D2 D3 D5 D6 D7 E3 E4 E5 F2 F4 F6 G1 G4 G7)
      (link (name strong-n) (A1 A4) (A4 A7) (B2 B4) (B4 B6) (C3 C4) (C4 C5) (D1 D2) (D2 D3)
                            (D5 D6) (D6 D7) (E3 E4) (E4 E5) (F2 F4) (F4 F6) (G1 G4) (G4 G6)
      )
      (link (name weak-s)   (A4 A1) (A7 A4) (B4 B2) (B6 B4) (C4 C3) (C5 C4) (D2 D1) (D3 D2)
                            (D6 D5) (D7 D6) (E4 E3) (E5 E4) (F4 F2) (F6 F4) (G4 G1) (G6 G4)
      )
      (link (name strong-e) (A1 D1) (D1 G1) (B2 D2) (D2 F2) (C3 D3) (D3 E3) (A4 B4) (B4 C4)
                            (E4 F4) (F4 G4) (C5 D5) (D5 E5) (B6 D6) (D6 F6) (A7 D7) (D7 G7)
      )
      (link (name weak-w)   (D1 A1) (G1 D1) (D2 B2) (F2 D2) (D3 C3) (E3 D3) (B4 A4) (C4 B4)
                            (F4 E4) (G4 F4) (D5 C5) (E5 D5) (D6 B6) (F6 D6) (D7 A7) (G7 D7)
      )
      (link (name weak-ne)  (A1 B2) (B2 C3) (E5 F6) (F6 G7))
      (link (name weak-sw)  (B2 A1) (C3 B2) (F6 E5) (G7 F6))
      (link (name weak-se)  (A7 B6) (B6 C5) (E3 F2) (F2 G1))
      (link (name weak-nw)  (B6 A7) (C5 B6) (F2 E3) (G1 F2))
      (attribute (name mans-left) (players White Black) 9)
      (attribute (name flying-mans-count) 4)
   )
   (pieces
      (pre  variables)
      (pre  goals)
      (post invariant)
      (piece 
            (name Man)
            (attribute unique 0)
            (moves
               (post capturing)
               (man-drop)
               (man-move strong-n) (man-move strong-nw)
               (man-move strong-s) (man-move strong-se)
               (man-move strong-w) (man-move strong-sw)
               (man-move strong-e) (man-move strong-ne)
               (man-move weak-n) (man-move weak-nw)
               (man-move weak-s) (man-move weak-se)
               (man-move weak-w) (man-move weak-sw)
               (man-move weak-e) (man-move weak-ne)
               (man-random)
            )
      )
   )
)
</source>
</spoiler>
При всей своей декларативности, такому описанию требуется парсер и это именно та задача, которой я занимаюсь в настоящее время. Как и в <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">Lisp</a>-е, в этом языке практически полностью отсутствует какой бы то ни было "синтаксический сахар". Задача разбора исходного текста на лексемы <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/Scaner.java">тривиальна</a>, но что делать дальше? Очевидно, что требуется какое-то внутреннее представление, предоставляющее удобный доступ к описаниям таких объектов, как доска и фигуры.

Я долго думал над этим вопросом, пока не поймал себя на мысли, что собираюсь разрабатать упрощённый аналог <a href="https://ru.wikipedia.org/wiki/XPath">XPath</a>. Попытка разработки подобного "велосипеда" безусловно является "тревожным звоночком". В самом деле, если понадобилось что-то, ведущее себя как XPath, почему бы его и не использовать? Достаточно всего лишь преобразовать данные в <a href="https://ru.wikipedia.org/wiki/XML">XML</a>, например следующим образом:

<spoiler title="XML-представление">
<source lang="xml">
<r>
  <n>
    <a>define</a>
    <a>variables</a>
    <n>
      <a>let</a>
      <a>hash</a>
      <v>0</v>
    </n>
  </n>
  ...
</r>
</source>
</spoiler>
Парсер, формирующий такое представление, чуть менее <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/Parser.java">тривиален</a>, чем рассмотренный ранее сканер (на самом деле ещё <a href="https://github.com/GlukKazan/Dagaz/blob/f34255c1968a4da65094b0830d7a3917d3444afb/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/Parser.java">проще</a>, если не рассматривать реализацию <b>include</b>). Его задача - сформировать поток <a href="https://ru.wikipedia.org/wiki/SAX">SAX</a>-событий, в порядке поступления на вход соответствующих лексем. После получения <a href="https://ru.wikipedia.org/wiki/Document_Object_Model">DOM</a>-представления, задача навигации, по загруженному описанию, решается <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/StateConfigurator.java">элементарно</a>. Но есть одно "но": для более удобной работы, желательно иметь XML-описание в незначительно отличающемся формате:

<spoiler title="Преобразованное XML-представление">
<source lang="xml">
<r>
  <define>
    <variables/>
    <let>
      <hash/>
      <v>0</v>
    </let>
  </define>
  ...
</r>
</source>
</spoiler>
Здесь, жизнь вносит свои коррективы. В приведённом мной выше исходном тексте, можно видеть такие строки как "<b>decrement!</b>", "<b>is-empty?</b>" или "<b>>=</b>" и это явно не те "идентификаторы", которые можно помещать в имена XML-тэгов. После некоторого размышления, я решил размещать их в атрибутах, следующим образом:

<spoiler title="Скорректированное XML-представление">
<source lang="xml">
<r>
  <n t="define">
    <n t="variables"/>
    <n t="let">
      <n t="hash"/>
      <v>0</v>
    </n>
  </n>
  ...
</r>
</source>
</spoiler>
Конечно, такая запись куда менее интуитивна, но ведь она не для человека предназначена! Как получить такую форму? Можно переписать парсер... Но есть способ проще! Для преобразования XML из одной формы в другую, предназначен <a href="https://ru.wikipedia.org/wiki/XSLT">XSLT</a>. Его мы и <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/xslt/drf-to-internal.xsl">используем</a>. Можно видеть, что это очень простое преобразование (во всяком случае, изменения в исходном коде парсера выглядели бы куда менее очевидными). Загрузка же из SAX в DOM с попутно выполняемой трансформацией мало чем отличается от такой же загрузки без неё.

Аппетит приходит во время еды. Там где есть одна трансформация можно выполнить и несколько. Достаточно просто объединить их в "<a href="https://github.com/GlukKazan/Dagaz/blob/master/src/java/rules/src/main/java/com/gluk/dagaz/rules/parser/Configuration.java">конвейер</a>". Для чего могут понадобиться дополнительные преобразования? Да для чего угодно! В ZRF, <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/YoninShogi.zrf">например</a>, имеется замечательная возможность. Один файл может содержать описания сразу нескольких похожих друг на друга игр, различающихся лишь деталями. При этом имеется одно главное описание "<b>game</b>" и несколько наследующих его "<b>variant</b>":

<spoiler title="Вариант Мельницы">
<source lang="lisp">
(variant
   (title "Three Men's Morris")
   (board
      (grid (dimensions "A_C" "3_1")
            (direction (name strong-n)  0 -1)
            (direction (name weak-s)    0  1)
            (direction (name strong-e)  1  0)
            (direction (name weak-w)   -1  0)
      )
      (link (name strong-ne) (A1 B2) (B2 C3))
      (link (name weak-sw)   (B2 A1) (C3 B2))
      (link (name strong-se) (A3 B2) (B2 C1))
      (link (name weak-nw)   (B2 A3) (C1 B2))
      (attribute (name mans-left) (players White Black) 3)
   )
)
</source>
</spoiler>
Требуется описать лишь те объекты, которые изменились. Остальное будет унаследовано от единственного в файле тэга <b>game</b>. Вот <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/xslt/variants.xsl">трансформация</a>, реализующая эту "магию". Идея преобразования проста. Раскрывая очередной <b>variant</b>, мы создаём переменную, содержащую как подтэги как самого тэга <b>variant</b>, так и соответствующего ему тэга <b>game</b> (порядок следования подтэгов значения не имеет): 

<source lang="xml">
<xsl:variable name="u">
  <xsl:copy-of select="n"/>
  <xsl:copy-of select="/r/n[*[position()=1 and name()='a']='game']/n"/>
</xsl:variable>
</source>
Далее просто убираем дубликаты:

<source lang="xml">
<xsl:for-each select="exsl:node-set($u)/n">
  <xsl:variable name="pos" select="position()"/>
  <xsl:if test="$pos=1 or not(*[position()=1 and name()='a'] = preceding-sibling::n/*[position()=1 and name()='a'])">
    <xsl:copy-of select="."/>
  </xsl:if>
</xsl:for-each>
</source>
Единственное, о чем здесь следует помнить, это то, что, по спецификации XSLT 1.0, "фрагмент результирующего дерева", сохраненный в переменную, нельзя использовать напрямую (кроме тривиальных случаях использования в <b>copy-of</b>). Необходимо использовать функцию расширения <b>node-set</b>, для преобразования его в набор узлов.

Можно создать и ещё более изощренное оружие для борьбы с "копипастом". Эта <a href="https://github.com/GlukKazan/Dagaz/blob/master/src/xslt/macro.xsl">трансформация</a> посложнее. Мне удалось реализовать её правильно лишь с <a href="https://github.com/GlukKazan/Dagaz/commits/master/src/xslt/macro.xsl">третьей</a> попытки, но результат того стоил. Дело в том, что в ZRF ключевое слово <b>define</b> определяет, по сути, макрос, который можно встроить абсолютно в любое место описания. Иногда это бывает очень удобно и спасает от большого объема писанины. В макросах ZRF можно использовать параметры <b>$1</b>, <b>$2</b> и т.д. Мы сделаем лучше! Наши параметры будут иметь нормальные имена:

<source lang="lisp">
(macro (plus a b)
  (+ a b)
)

(plus (* 2 3) (* 5 6))
</source>
После выполнения преобразования <b>macro.xsl</b>, в исходном коде получим следующее:

<source lang="lisp">
(+ (* 2 3) (* 5 6))
</source>
Разумеется, и сам макрос и его аргументы могут быть гораздо более сложными. В теле макроса, допускается вызов вложенных макросов. Пока нельзя реализовать рекурсивный вызов макроса, но лишь по причине отсутствия механизма останова рекурсии. Пока я не нашёл ни одного практичного примера использования рекурсивных макросов и встраивание в преобразование возможности выполнения арифметических вычислений лишь усложнит его, без необходимости.

XSLT может быть применено и для более сложных преобразований исходного кода. Трансформации, преобразующая описание игры на языке <b>GDL</b> или <b>ZRF</b> в исходный код <b>Dagaz</b> должны получиться сложными, но в них нет ничего фантастического. При желании, можно реализовать даже макросы <a href="http://habrahabr.ru/post/214713/">PREZRF</a> (впрочем, думаю, что это уже лишнее). Таким образом, XSLT обеспечит обратную совместимость, без необходимости непосредственной обработки устаревших (с точки зрения <b>Dagaz</b>) форматов. Не удастся обеспечить лишь поддержку формата описаний <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>, но лишь по той причине, что это потребовало бы реализации в XSLT-преобразовании полноценной <a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Forth</a>-машины.
</habracut>

Dagaz: Новое начало

<img align="left" src="https://habrastorage.org/files/c97/a13/699/c97a13699b5b4bb98ffe09c0be6860fe.PNG"/><b><i>Бежит на юг и кружит на север, кружит, кружит на бегу своем ветер,
И на круги свои возвращается ветер;
Бегут все реки в море, - а море не переполнится,
К месту, куда реки бегут, -
Туда они продолжают бежать;

<a href="http://lib.ru/HRISTIAN/ekkleziast.txt">Книга Экклезиаста</a>.</i></b>

В 1998 году, было разработано совершенно уникальное, для своего времени, приложение, позволяющее свести процесс разработки абстрактной настольной игры (или головоломки) к небольшому текстовому описанию на языке, отдалённо напоминающем <a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">Lisp</a>. Этот проект получил название <a href="http://www.zillions-of-games.com/">Zillions of Games</a> и произвел настоящий фурор в среде любителей настольных игр. В настоящее время, создано более 2000 приложений, с использованием этой технологии.

Очень быстро выяснилось, что <b>ZoG</b> обладает множеством недостатков. Я уже <a href="http://habrahabr.ru/post/221779/">писал</a> об этом на Хабре и не буду повторяться. Скажу лишь, что разработчики не учли особенностей огромного количества уже существующих игр, а часть важных опций "захардкодили" таким образом, что их изменение стало крайне проблематичным. Грэг Шмидт, в 2007 году, постарался исправить ситуацию, выпустив <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a>, но тесная интеграция этого решения с <b>ZoG</b> не позволила решить все проблемы.

Проект <a href="http://www.cameronius.com/cv/publications/ciaig-browne-maire-19.pdf">Ludi</a> обозначил новые рубежи, используя универсальный игровой "движок" и <a href="http://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC">генетические алгоритмы</a> для автоматизации самого процесса разработки новых настольных игр. К сожалению, этот подход изначально предусматривал сознательное упрощение как игровых механик так и уровня используемого AI. Обсуждение целей этого проекта выходит за рамки настоящей статьи, но отдельные его технические решения, бесспорно, послужили отправной точкой для начала моей собственной разработки.

Моей целью является разработка более универсального и удобного в использовании "движка" для создания абстрактных настольных игр. Уже почти год я изучаю возможности <b>ZoG</b> и <b>Axiom</b> и узнал очень многое об их ограничениях. Я думаю, что смогу решить их проблемы, создав более универсальное и кроссплатформенное решение. О ходе работы над этим проектом я и собираюсь рассказать.
<habracut>
<h4><b>Открытость и модульность</b></h4>
Пожалуй, главным недостатком <b>ZoG</b> является его закрытость. Продукт собран "раз и навсегда" под одну единственную платформу - Windows. Будь исходные коды открытыми, можно было бы попытаться портировать их под Linux, Android, iOS... Другой проблемой является монолитность.

В <b>ZoG</b> имеются зачатки модульности, позволяющие подключать к играм <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0">DLL</a>, содержащие кастомные реализации AI. <b>Axiom</b> идёт чуть дальше, позволяя запускать приложения в режиме <b>autoplay</b>, без использования ядра <b>ZoG</b>. Даже несмотря на серьёзное ограничение этого решения (поддерживаются приложения только для двух игроков), этот пример наглядно показывает, насколько модульность была бы полезна! Возможность организовать игру двух ботов (использующих различные настройки AI) и собрать статистику по большому количеству их игр трудно переоценить. Но насколько было бы лучше, если бы продукт был полностью модульным!

<ul>
	<li>Модуль генерации ходов</li>
	<li>Модуль выполнения хода</li>
	<li>Управляющий модуль</li>
	<li>Модуль AI</li>
	<li>Модуль визуализации</li>
</ul>
Вся работа с описанием игр должна выполняться модулем генерации ходов. Это "сердце" проекта. Перенос всей не связанной с его задачами функциональности в другие модули позволит сделать его максимально простым. Можно улучшать этот модуль, не оглядываясь на вопросы AI и взаимодействия с пользователем. Можно полностью изменить формат описания игр или добавить поддержку описаний в формате <b>ZoG</b>, <b>Axiom</b> и <b>Ludi</b>. Модульность - основа гибкости решения!

Модуль выполнения хода - это хранитель игрового состояния. Информация о текущем игровом состоянии передаётся всем остальным модулям по требованию. По причинам, о которых я скажу ниже, выполнение хода должно проходить через модуль генерации, задачей которого является формирование команды в терминах модуля выполнения хода. Также, задачей модуля генерации является первичное конфигурирование игрового пространства, на основании описания игры.

Управляющий модуль - это, по сути, само приложение. Он запрашивает у модуля генерации списки возможных ходов и изменяет игровое состояние, передавая выбранный ход в модуль выполнения хода. Управляющий модуль может подключить к игре один или несколько AI ботов. Столько, сколько требуется (и возможно различных)! Тип используемого управляющего модуля определяется решаемыми задачами. Это может быть <b>autoplay</b> для сбора игровой статистики, игровой сервер (он может управлять сразу несколькими хранилищами состояния, ведя большое количество игровых сессий) или индивидуальное приложение для игры в offline.

Возможность подключения различных реализаций AI позволит улучшить качество игры. Понятно, что модули для игры в Шахматы и Го должны использовать различные подходы. Игры с неполной информацией и игры использующие случайные данные также требуют индивидуального подхода. Универсальная реализация AI будет одинаково плохо играть во все игры! Модульное подключение AI позволит сравнивать "силу" используемых алгоритмов, включая их в режиме игры "между собой". Поскольку AI архитектурно отделён от хранилища игрового состояния, одна реализация игрового бота сможет поддерживать неограниченное количество игровых сессий одновременно.

Визуализация игрового процесса также может быть различной. Первое, что приходит в голову - это 2D и 3D реализации. Платформа, для которой разрабатывается приложение, также имеет значение. Менее очевидно, что визуализация может быть важной частью игрового процесса! Так например, в игре <a href="http://www.iggamecenter.com/info/ru/surakarta.html">Суракарта</a>, взятие фигур будет совершенно неочевидным при отсутствии правильной анимации ходов. 

<img align="center" src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"/>
В целом, модульность видится хорошей идеей для подобного проекта, а открытые исходные коды позволят участвовать в нём всем желающим. В настоящее время, я не ставлю перед собой коммерческих целей, но думаю, что, при желании, я найду способ заработать, без закрытия исходных кодов.

<h4><b>Игровое пространство</b></h4>
Прежде чем начинать спектакль, необходимо подготовить сцену. Доска - это не просто место, на котором размещаются фигуры. Помимо этого, могут определяться направления перемещения фигур (фактически, связи полей доски между собой), игровые зоны (например, зоны превращения фигур), запрещенные поля и т.д. Вот как выглядит определение доски в <b>ZoG</b>-реализации шахмат:

<spoiler title="Определение доски в ZoG">
<source lang="lisp">
(define Board-Definitions
  (image "images\Chess\SHaag\Chess8x8.bmp" "images\Chess\Chess8x8.bmp")
  (grid
     (start-rectangle 5 5 53 53)
     (dimensions
         ("a/b/c/d/e/f/g/h" (49 0)) ; files
         ("8/7/6/5/4/3/2/1" (0 49)) ; ranks
     )
     (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0)
			     (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1)
     )
  )
  (symmetry Black (n s)(s n) (nw sw)(sw nw) (ne se)(se ne))
  (zone
     (name promotion-zone)
     (players White)
     (positions a8 b8 c8 d8 e8 f8 g8 h8)
  )
  (zone
     (name promotion-zone)
     (players Black)
     (positions a1 b1 c1 d1 e1 f1 g1 h1)
  )
  (zone
     (name third-rank)
     (players White)
     (positions a3 b3 c3 d3 e3 f3 g3 h3)
  )
  (zone
     (name third-rank)
     (players Black)
     (positions a6 b6 c6 d6 e6 f6 g6 h6)
  )
)
</source>
</spoiler>
Можно заметить, что помимо собственно игровых настроек, здесь имеются настройки, связанные с визуализацией. Я твёрдо убеждён в том, что этим настройкам здесь не место. Реализаций модуля визуализации может использоваться несколько и настройки им потребуются различные. Более того, игровая симуляция может работать и без модуля визуализации вообще (как <b>autoplay</b> в <b>Axiom</b>). Действительно, поскольку <b>Axiom</b> использует для визуализации <b>ZoG</b>, определение не содержит ничего лишнего:

<spoiler title="Определение доски в Axiom">
<source lang="lisp">
{board
	8 8 {grid}
board}

{directions
	-1  0  {direction} n
	 1  0  {direction} s
	 0  1  {direction} e
	 0 -1  {direction} w
	-1 -1  {direction} nw
	 1 -1  {direction} sw
	-1  1  {direction} ne
	 1  1  {direction} se
directions}

{symmetries 
	Black {symmetry} n s
	Black {symmetry} nw sw
	Black {symmetry} ne se
symmetries}
</source>
</spoiler>
К сожалению, определения игровых зон оно также не содержит (расположение игровых зон приходится определять в коде вручную). Это не единственное упрощение, на которое идёт <b>Axiom</b>. Определение доски в этом проекте не может содержать более одного <b>grid</b>-а и этот <b>grid</b> должен быть двумерным. Доска, определённая таким образом, представляет собой одномерный массив, но для удобства программиста, определяются синонимы для каждого из полей, по следующей схеме:

<img align="center" src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"/>
По сравнению с более гибкой схемой определения <b>grid</b>-ов в <b>ZoG</b>, эти ограничения довольно неудобны (особенно с учетом того, что навязанная схема именования полей используется и при визуализации). К счастью, имеется возможность определения доски произвольной формы. И <b>Axiom</b> и <b>ZoG</b> предоставляют возможность поэлементного определения каждой позиции доски с возможностью определения связей между произвольными парами позиций. Используя этот подход, можно определить доску любой топологии. Единственный его минус - крайняя многословность и трудоёмкость описания.

Помимо расположения фигур на доске и в резерве, должна иметься возможность хранения атрибутов как для отдельных фигур, так и для полей доски. Хорошим примером необходимости использования атрибутов является правило "<a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировки</a>" в <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахматах</a>. Это сложный ход, включающий в себя одновременное перемещение короля и одной из ладей, возможный при условии, что ни одна из этих фигур, до выполнения этого хода, не передвигалась. Атрибут может быть использован для хранения булевского признака того, что фигура перемещалась когда либо. Атрибутам полей можно также найти довольно интересные применения.

Следует отметить, что атрибуты - не просто переменные, а часть игрового состояния. Значение атрибута может быть изменено при выполнении хода (в том числе модулем AI) и должно быть доступно для всех последующих ходов, но не для ходов, выполняемых в другой ветви игры. В настоящее время, <b>ZoG</b> поддерживает хранение булевских атрибутов фигур. <b>Axiom</b> хранение атрибутов не поддерживает, но позволяет добавлять в определение доски описание переменных и массивов. Такие переменные могут быть использованы, например, как счетчики количества съеденных фигур:

<source lang="lisp">
{board
	5 18 {grid}
	{variable}	WhitePieces
	{variable}	BlackPieces
board}
</source>
Ещё одним ограничением как <b>ZoG</b>, так и <b>Axiom</b> является правило, по которому каждое поле доски может содержать не более одной фигуры. Если какая либо фигура завершает ход на поле, занятом другой фигурой, фигура ранее занимавшая поле, автоматически считается "съеденной". Это правило хорошо сочетается с "шахматным" принципом взятия фигур и позволяет упростить описания использующих его игр, но затрудняет реализацию таких игр как "<a href="http://www.iggamecenter.com/info/ru/bashni.html">Столбовые шашки</a>" и "<a href="http://www.iggamecenter.com/info/ru/tavreli.html">Таврели</a>".

<img align="center" src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"/>
В этих играх, фигуры могут выстраиваться в "столбики". Такой "столбик" может перемещаться целиком, как единая фигура. После некоторого размышления, я решил, что лучше не отказываться от автоматической реализации "шахматного" взятия, а усовершенствовать механизмы перемещения групп фигур. Действительно, для реализации "столбиков", всегда можно добавить к доске ещё одно измерение (это тем более просто, поскольку модуль визуализации будет отделён от модулей генерации ходов и AI и в нём можно будет использовать любую логику отображения трехмерной доски на её двумерную визуализацию). Дополнительным доводом, в пользу этого решения, явилось то, что "столбовое" перемещение фигур не является единственным видом группового перемещения. Например в "<a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf">Пентаго</a>" фрагменты доски могут поворачиваться, вместе с установленными на них фигурами.

<img align="center" src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"/>
Резюмируя, можно сказать, что для своего игрового framework-а, я решил взять всё лучшее, что было придумано в <b>ZoG</b>, <b>Axiom</b> и <b>Ludi</b> и добавить то, чего, по моему мнению, им не хватает.

<h4><b>Ходогенерация</b></h4>
Генерация хода сродни <a href="http://en.wikipedia.org/wiki/Nondeterministic_programming">недетерминированному программированию</a>. Задача генератора ходов - предоставление, по требованию, списка всех возможных ходов, из текущей позиции. Какой именно ход, из этого списка, будет выбран игроком или AI - не его дело. Рассмотрим, как именно выполняется генерация ходов в <b>ZoG</b>. В качестве примера, возьмём макрос генерации хода дальнобойной фигурой (ферзём или слоном). Вот как он используется в определении фигуры:

<source lang="lisp">
(piece
      (name Bishop)
      (image White "images\Chess\SHaag\wbishop.bmp" "images\Chess\wbishop.bmp"
             Black "images\Chess\SHaag\bbishop.bmp" "images\Chess\bbishop.bmp")
      (moves
         (slide ne)
         (slide nw)
         (slide se)
         (slide sw)
      )
)
</source>
В качестве параметра, в макрос передаётся направление перемещения по доске. Если не рассматривать возможность установки новых фигур на доску, генерация хода выглядит просто. Для каждой из фигур на доске, выполняется перебор всех определённых правилами ходов. Дальше начинается магия...

Каждое из определений может добавить в список несколько возможных ходов! Добавление хода в список осуществляется командой <b>add</b> (по совместительству устанавливающей перемещаемую фигуру на доску). Я уже <a href="http://habrahabr.ru/post/221779/">писал</a> о том, что такое архитектурное решение крайне неудачно. Команда формирования хода должна быть отделена от команд, манипулирующих фигурами (так, как это было сделано в <b>Axiom</b>). Посмотрим, как работает макрос:

<source lang="lisp">
(define slide (
    $1 
    (while empty? 
        add 
        $1
    ) 
    (verify not-friend?) 
    add
))
</source>
Сначала, выполняется перемещение на одну клетку, в заданном направлении, после чего, в цикле, достигнутое поле проверяется на отсутствие в нём фигур, формируется ход и происходит перемещение еще на одну клетку в том же направлении. Если остановиться на этом, фигура сможет "скользить" по пустым клеткам, но как брать вражеские фигуры?

Очень просто! Выполнив, командой <b>verify</b>, проверку того, что поле не занято дружественной фигурой, мы формируем ещё одну команду <b>add</b>, завершая ход. Если на этой клетке размещалась вражеская фигура, она будет взята автоматически (поскольку на одном поле доски, единовременно, не может размещаться более одной фигуры). Если фигура была дружественная, расчёт хода прервётся командой <b>verify</b> (нарушение условия, указанного в этой команде, немедленно прерывает расчёт текущего хода).

И в <b>ZoG</b> и в <b>Axiom</b> ходить можно только своими фигурами (вернее ходить фигурами противника можно, но только в том случае, если это указано в режиме расчёта хода). Я нахожу это ограничение крайне неудобным, поскольку имеется множество игр, в которых ходить фигурами противника можно (в "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A1.D1.82.D0.B0.D0.B2.D1.80.D0.BE.D0.BF.D0.BE.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Ставропольских шашках</a>", например). Более последовательным было бы выполнять расчёт хода для всех фигур, независимо от их принадлежности. В макрос, определяющий ход, понадобилось бы добавить всего одну проверку, для того, чтобы ходить можно было только своими фигурами:

<source lang="lisp">
(define slide (
    (verify friend?) 
    $1 
    (while empty? 
        add 
        $1
    ) 
    (verify not-friend?) 
    add
))
</source>
Важной является возможность выполнения хода, состоящего из нескольких "частичных" ходов. В реализациях шашках, эта возможность используется для выполнения "цепочек" взятий:

<source lang="lisp">
(define checker-jump
    ($1 (verify enemy?)
        capture
        $1
        (verify empty?)
        (if (not-in-zone? promotion-zone)
            (add-partial jumptype)
         else
            (add-partial King jumptype)
        )
    )
)
</source>
Частичный ход формируется командой <b>add-partial</b> (для неё, как и для команды <b>add</b>, существует вариант хода, с "превращением" фигуры). Такой ход всегда является частью большего, "составного" хода. Как правило, для последующих ходов, устанавливается "режим", в котором должно осуществляться продолжение. Так в шашках, взятие можно продолжить лишь последующими взятиями, но не "тихим" ходом.

<spoiler title="Примечание">
В <b>ZoG</b>, реализация частичных ходов оставляет желать лучшего. Попытка выполнения команды <b>add-partial</b> в цикле приводит к ошибке. В результате, взятие выполняемое дамкой, может быть реализовано лишь следующим, весьма неуклюжим образом:

<source lang="lisp">
(define king-jump-1
    ($1 (while empty?
            $1
        )
        (verify enemy?)
        capture
        $1
        (verify empty?)
        (add-partial jumptype)
    )
)

(define king-jump-2
    ($1 (while empty?
            $1
        )
        (verify enemy?)
        capture
        $1
        (verify empty?)
        $1
        (verify empty?)
        (add-partial jumptype)
    )
)
</source>
И так далее, вплоть до king-jump-7! Напомню, что в большинстве разновидностей шашек, с "дальнобойными" дамками, дамка, выполнив взятие, может остановиться на <b>любом</b> поле, из непрерывной цепочки пустых полей, следующих за взятой фигурой. Есть, впрочем, один <a href="http://thaichess.narod.ru/index/0-36">вариант</a> этой игры, в котором правило "цепочки" взятий формулируется иначе. Именно это мне и нравится в шашках - каждый может найти вариант по своему вкусу.
</spoiler>
Такая система описания правил очень гибкая, но иногда требуется более сложная логика. Например, если фигура, при  выполнении "частичного" хода не должна повторно проходить через ранее пройденные поля, логично использовать флаги, связанные с позициями на доске. Посетив поле, мы взводим флаг, чтобы впоследствии не зайти на это поле повторно:

<source lang="lisp">
(verify (not-position-flag? my-flag))
(set-position-flag my-flag true)
</source>
Помимо "позиционных", в <b>ZoG</b> можно использовать и глобальные флаги. Эти возможности не следует путать с атрибутами фигур. В отличии от последних, они не являются частью игрового состояния. К сожалению, и атрибуты фигур и флаги в <b>ZoG</b> могут быть только булевскими (в <b>Axiom</b> атрибуты и вовсе не поддерживаются). Это ограничение затрудняет выполнение операций, связанных с различного рода подсчётами. Например, в <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2233">этой</a> небольшой головоломке, мне пришлось использовать для "подсчёта" фигур, попавших в "вилку", пару булевских флагов (точное количество мне было не нужно, главное, чтобы фигур было больше одной).

Другая вещь, которую стоит исправить - отсутствие внятного "жизненного цикла" выполнения хода. Все флаги автоматически сбрасываются перед началом выполнения хода, но было бы удобнее выделить фазы инициализации явно. По моему мнению, при расчёте хода, должны выполняться следующие фазы:

<ol>
	<li>Инициализация переменных и проверка предусловий составного хода</li>
	<li>Инициализация переменных и проверка предусловий частичного хода</li>
	<li>Генерация частичного хода</li>
	<li>Проверка постусловий частичного хода</li>
	<li>Генерация завершения и проверка постусловий составного хода</li>
	<li>Проверка выполнения условий завершения игры</li>
</ol>
Группа шагов со второго по четвёртый, при выполнении составного хода, может повторяться многократно. Идею пред- и постусловий, называемых мной инвариантами, я взял из проекта <b>Ludi</b>. Впрочем, об использовании инвариантов я подробнее расскажу в дальнейшем.

<h4><b>О важности нотации</b></h4>
Генерация всех возможных из позиции ходов - это только половина дела. Для управления игровым состоянием, требуется компактная форма представления сгенерированных ходов. В <b>ZoG</b>, для этой цели, используется <b>ZSG</b>-нотация. Вот как выглядит запись возможного начала шахматной партии в этой форме:

<source lang="lisp">
1. Pawn e2 - e4
1. Pawn e7 - e5
2. Knight g1 - f3
2. Knight b8 - c6
3. Bishop f1 - c4
3. Knight g8 - f6
4. King e1 - g1 Rook h1 - f1 @ f1 0 0 @ g1 0 0
4. Pawn d7 - d5
5. Pawn e4 x d5
5. Knight f6 x d5
</source>
Такая запись близка к привычной <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F">шахматной нотации</a> и, в целом, понятна пользователю. Некоторое недоумение может вызвать лишь четвёртый ход белых. Так в <b>ZSG</b> выглядит <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a>. Часть описания хода до символа '<b>@</b>' вполне понятна - это одновременное перемещение ладьи и короля, но что следует далее? Таким образом, в <b>ZSG</b>, выглядит сброс атрибутов фигур, выполнение которого необходимо для того чтобы не дать возможность выполнить рокировку повторно.

<spoiler title="Примечание">
<b>ZoG</b> использует <b>ZSG</b>-нотацию ещё и для того, чтобы показать ход игры в форме, понятной игроку. Справа от изображения доски, может быть открыто вспомогательное окно "Moves List". Этот список может использоваться для навигации по записи партии (не очень удобной, поскольку древовидное представление альтернативных ветвей игры не поддерживается). Часть записи ходов, связанная с изменением атрибутов фигур, пользователю не отображается.
</spoiler>
Запись хода в <b>ZSG</b>-нотации должна содержать полную информацию, достаточную для корректного изменения игрового состояния. Если бы информация об изменении атрибутов не сохранялась, партия, по такой записи, могла бы быть воспроизведена некорректно (например, у игрока имелась бы возможность повторного выполнения рокировки). К сожалению, в DLL-расширения (такие как <b>Axiom</b>), расширенная информация может не передаваться.

Работая с DLL-расширениями, <b>ZoG</b> вынуждена производить довольно хитрую манипуляцию при выполнении позиционирования на выбранный ход (например, при откате хода). Из предыдущей позиции, генерируются <b>все</b> возможные ходы, после чего, в списке, выполняется поиск выбранного хода по его <b>ZSG</b>-представлению. Сгенерированный ход применяется к игровому состоянию, возможно выполняя побочные действия, не отражённые в его <b>ZSG</b>-представлении.

Ситуация усугубляется ещё и тем, что единственным способом получения игрового состояния, на момент какого-то хода в прошлом, является последовательное применение всех ходов, с начала партии, к начальному состоянию доски. В действительно <a href="http://habrahabr.ru/post/234587/">сложных случаях</a>, подобная навигация происходит не быстро. Другой недостаток <b>ZSG</b>-нотации может проиллюстрировать запись следующего хода из партии <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%BE">Го</a>:

<source lang="lisp">
1. White Stone G19 x A19 x B19 x C19 x D19 x E19 x F19
</source>
Здесь, в позицию G19, устанавливается белый камень, что приводит к снятию группы чёрных камней. Поскольку все фигуры, задействованные при выполнении хода, должны быть упомянуты в <b>ZSG</b>-представлении, запись хода может оказаться очень длинной (в Го, одним ходом может быть снято до 360 камней). К чему это может привести, я уже писал <a href="http://habrahabr.ru/post/235483/">ранее</a>. Размера буфера, выделяемого <b>ZoG</b> под запись хода, может и не хватить. Кроме того, если по каким-то причинам порядок снятия камней изменится (в процессе разработки игры такое бывает), попытка применения хода, со старым порядком взятий, закончится ошибкой.

К счастью, имеется простой способ борьбы со всеми этими проблемами. Посмотрим на то, как определяются ходы фигур в <b>ZRF</b>:

<source lang="lisp">
(piece
     (name Pawn)
     (image White "images\Chess\SHaag\wpawn.bmp" "images\Chess\wpawn.bmp"
            Black "images\Chess\SHaag\bpawn.bmp" "images\Chess\bpawn.bmp")
     (moves
        (Pawn-capture nw)
        (Pawn-capture ne)
        (Pawn-move)
        (En-Passant e)
        (En-Passant w)
     )
)
</source>
Имена ходов, определяемых в <b>ZoG</b> макросами, генератору ходов недоступны. Но что нам мешает отказаться от макросов и сделать описания ходов именованными? Вот как будет выглядеть запись шахматной партии:

<source lang="lisp">
1. e2 - e4 Pawn-move
1. e7 - e5 Pawn-move
2. g1 - f3 leap2 n nw
2. b8 - c6 leap2 n ne
3. f1 - c4 slide nw
3. g8 - f6 leap2 n nw
4. e1 - g1 O-O
4. d7 - d5 Pawn-move
5. e4 x d5 Pawn-capture nw
5. f6 x d5 leap2 w nw
</source>
<spoiler title="Примечание">
Внимательные читатели могут заметить, что в ходах "за чёрных" я использовал направления, не соответствующие направлениям на шахматной доске. Это связано с тем, что для чёрных определена "симметрия":

<source lang="lisp">
(symmetry Black (n s)(s n) (nw sw)(sw nw) (ne se)(se ne))
</source>
Грубо говоря, то, что для белых является "севером", для чёрных является "югом", и наоборот.
</spoiler>
Польза от такой записи не очевидна, но у неё есть одно важное достоинство. Все ходы описаны в единой форме и эти описания не содержат ничего лишнего (имена описаний ходов, конечно, можно было бы сделать и более "говорящими"). В описании рокировки удалось избавиться и от изменения атрибутов и даже от описания хода ладьи (такое описание больше не зависит от подробностей реализации хода). Еще более наглядна полезность такой записи в случае игры Го:

<source lang="lisp">
1. G19 drop-to-empty White Stone
</source>
И это всё! Если камни противника забираются, в соответствии с правилами игры, нет никакой необходимости перечислять их все в описании хода. Достаточно указать начальное и конечное поле перемещения (возможно с признаком взятия), имя выполняемого хода и строку передаваемых ему параметров. Разумеется, чтобы выполнить ход, по такому описанию, за расшифровкой, придётся обратиться к модулю генерации ходов, но <b>ZoG</b> и так это делает!

<spoiler title="Примечание">
В очень редких, можно сказать, экзотических <a href="http://www.chessvariants.org/other.dir/ultima.html">случаях</a>, может потребоваться выполнение хода, заключающегося лишь во взятии фигуры (своей или противника). Запись такого хода, в новой нотации, будет выглядеть следующим образом:

<source lang="lisp">
1. x G19 capture-piece
</source>
</spoiler>
Ещё одной возможностью, которую следует поддерживать, является функциональность "частичных" ходов. Вот пример из "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A0.D1.83.D1.81.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Русских шашек</a>":

<source lang="lisp">
1. Checker g3 - f4
1. Checker f6 - g5
2. Checker e3 - d4
2. partial 2 Checker g5 - e3 = XChecker on f4
2. Checker e3 - c5 = XChecker on d4 x d4 x f4
</source>
Здесь чёрные, на втором ходу, берут две фигуры на d4 и f4. Предварительное "превращение" фигур в <b>XChecker</b> является особенностью реализации и служит для предотвращения возможности повторного взятия "битых" фигур на том же ходу. Фраза "<b>partial 2</b>" описывает начало "составного" хода, состоящего из двух "частичных" ходов. Такая форма описания неудобна, поскольку на момент генерации первого хода, длина последовательности "частичных" ходов может быть неизвестна. Вот как будет выглядеть это описание в новом формате:

<source lang="lisp">
1. g3 - f4 checker-shift nw
1. f6 - g5 checker-shift ne
2. e3 - d4 checker-shift nw
2. + g5 - e3 checker-jump nw
2. + e3 - c5 checker-jump sw
2. +
</source>
Подробности реализации, связанные с "превращением" фигур излишни. Взятие фигур также не следует указывать, поскольку, в шашках, взятие выполняется как "побочный эффект" хода фигуры, а не по "шахматному принципу". Частичный ход будет кодироваться символом "<b>+</b>" в начале строки. Одиночный "<b>+</b>" означает завершение "составного хода" (на самом деле, это обычный "частичный" ход, содержащий в себе пропуск хода - пустую строку). 

Таким образом, используя именованные правила выполнения ходов, удалось создать универсальную нотацию, полностью удовлетворяющую нашим требованиям. Разумеется, она не имеет ничего общего ни с общепринятой шахматной ни с какой либо другой нотацией, но так уж сложилось, что общепринятые нотации для шахмат, шашек и прочих игр тоже не имеют ничего общего между собой. Модуль визуализации всегда может выполнить преобразование записи хода в более привычную форму, принятую для конкретной игры. Также, может быть выполнено преобразование в какую либо иную универсальную форму, например <a href="http://ru.wikipedia.org/wiki/Smart_Game_Format">SGF</a>.

<h4><b>Жизненный цикл игры</b></h4>
Наряду с информацией о размещении фигур на доске, очередность хода является составной частью состояния, изменяемого в процессе игры. В простейшем (и наиболее распространённом) случае, для хранения этой информации достаточно одного бита, но <b>ZoG</b> предоставляет чуть больше возможностей, для реализации более сложных случаев. Вот как могло бы выглядеть описание последовательности ходов для игры <a href="http://www.iggamecenter.com/info/ru/splut.html">Splut!</a>:

<source lang="lisp">
(players South West North East)
(turn-order
    South
    West West
    repeat
    North North North
    East East East
    South South South
    West West West
)
</source>
В этой игре, каждый из игроков делает по три хода за раз, но если первому игроку дать возможность сделать три хода из начальной позиции, он сможет уничтожить одну из фигур противника, что даст ему серьёзное преимущество. По этой причине, первый игрок должен делать один ход (это даёт возможность подготовиться к атаке игрока, расположенного напротив, но не атаковать его), второй - два хода (этого также недостаточно для нападения на противостоящего игрока), после чего, каждый игрок всегда делает по три хода.

<img align="center" src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"/>
Метка <b>repeat</b> обозначает начало циклически повторяющейся последовательности ходов. Если она отсутствует, циклически повторяется всё описание. <b>ZoG</b> позволяет использовать метку <b>repeat</b> не более одного раза. Другой важной возможностью является определение <b>режима</b> хода. Вот как может выглядеть описание последовательности ходов игры, в которой каждый из игроков выполняет по два хода (первый ход - перемещение фигуры, второй - взятие фигуры противника):

<source lang="lisp">
(players White Black)
(turn-order
    (White normal-move)
    (White capture-move)
    (Black normal-move)
    (Black capture-move)
)
</source>
Есть ещё одна возможность, связанная с описанием ходов чужими фигурами, но она крайне неудобна в использовании. Дело в том, что такое описание безальтернативно. Если в описании указано, что ход должен осуществляться фигурой противника, игрок обязан выполнить такой ход! В <b>ZoG</b> невозможно описать ход "<b>на выбор</b>" своей или чужой фигурой. Если такая возможность в игре необходима (как например в "<a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2247">Ставропольских шашках</a>"), приходится делать нейтральными все фигуры (создавая для этой цели игрока, не участвующего в игре) и определять для всех игроков возможность хода нейтральными фигурами. Выше, я уже говорил о том, что гораздо проще изначально разрешить игрокам возможность хода любыми фигурами (как своими так и противника), добавив необходимые проверки в алгоритмы генерации хода.

Как можно видеть, набор возможностей, предоставляемых <b>ZoG</b>, для описания последовательности ходов, крайне ограничен. <b>Axiom</b> также не добавляет новых возможностей, поскольку (обычно) выполняется поверх <b>ZoG</b>. <b>Ludi</b>, в этом отношении, еще беднее. С целью максимальной унификации игровых правил (необходимой для возможности использования генетических алгоритмов), в этом проекте, сознательно упрощаются все описательные возможности, что приводит к отсечению целых пластов игр.

<img align="center" src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"/>
"<a href="http://skyruk.livejournal.com/390109.html">Бао суахили</a>" является хорошим примером игры со сложным жизненным циклом. В этой игре две фазы, правила выполнения хода в которых существенно различаются. В начале игры, часть камней находится "в руке" каждого из игроков. Пока камни "в руке" не кончились, происходит вброс камней в лунки, по одному камню. Когда камни "в руке" заканчиваются, начинается вторая фаза игры, связанная с перераспределением вброшенных камней. Нельзя сказать, что эту игру невозможно описать на <b>ZRF</b> (языке описания <b>ZoG</b>), но из за ограничений <b>ZoG</b>, подобная реализация получилась бы крайне запутанной (что безусловно не лучшим образом отразилось бы на качестве работы AI). Посмотрим, как описание подобной игры могло бы выглядеть в "идеальном мире":

<source lang="lisp">
(players South North)
(turn-order
    (turn-order 
         (South p-i-move)
         (North p-i-move)
    )
    (label phase-ii)
    (turn-order 
         (South p-ii-move)
         (North p-ii-move)
    )
)
</source>
Здесь, каждый список <b>turn-order</b> определяет свою повторяющуюся последовательность ходов (различающуюся режимом выполнения хода). Ключевое слово <b>label</b> определяет метку, переход по которой может быть сформирован при генерации очередного хода. Можно заметить, что здесь мы исходим из неявного предположения о том, что такой переход всегда происходит после хода второго игрока (в противном случае будет нарушена последовательность ходов). Как выполнить переход к следующей фазе в произвольный момент времени?

<source lang="lisp">
(players South North)
(turn-order
    (turn-order 
         (South p-i-move)
         (North p-i-move)
    )
    (turn-order 
         (labels - phase-ii)
         (South p-ii-move)
         (labels phase-ii -)
         (North p-ii-move)
    )
)
</source>
Здесь метки перенесены в тело цикла и содержат по два имени. Имена меток, в списках <b>labels</b> перечисляются в соответствии с порядком перечисления игроков в списке <b>players</b>. Имя, используемое для перехода, определяется в зависимости от того, какой из игроков выполнил ход последним. Если это был <b>North</b>, будет выполнен переход к первой метке, в противном случае - ко второй. Если какое либо из имён в <b>labels</b> не будет использоваться, соответствующую позицию можно заполнить прочерком.

<img align="center" src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"/>
Важным моментом, в управлении чередованием ходов, является возможность выполнения повторного хода. В играх семейства <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%80%D0%B4%D1%8B">Нард</a>, таких как <a href="http://skyruk.livejournal.com/231444.html?thread=4494868">Ур</a>, например, возможность выполнения повторных ходов является важным элементом игровой тактики. В <b>ZoG</b> можно использовать пропуск хода, для эмуляции этой возможности, но такой подход существенно запутывает описание игры (особенно при участии нескольких игроков). Гораздо логичнее использовать метку для повторения хода:

<source lang="lisp">
(players South North)
(turn-order
    (label repeat)
    South
    (label repeat)
    North
)
</source>
Выполнив переход к <b>repeat</b>, игрок вернётся к повторению последнего хода (при этом будет действовать метка, ближайшая к текущему положению в списке ходов). Мне нравится подход <a href="https://ru.wikipedia.org/wiki/Perl">Perl</a> в части неявных определений. Неявная генерация управляющих структур может существенным образом упростить описание. Поскольку повторные ходы могут быть использованы во многих играх, метки <b>repeat</b>, предваряющие каждый ход, можно формировать неявно:

<source lang="lisp">
(players South North)
(turn-order
    South
    North
)
</source>
Более того, поскольку последовательность ходов полностью соответствует перечислению игроков в <b>players</b>, автоматически можно формировать всю фразу <b>turn-order</b>:

<source lang="lisp">
(players South North)
</source>
Чем проще получится описание - тем лучше.

<h4><b>Нарушаемый инвариант</b></h4>
Главное, что мне не нравится в <b>ZoG</b> можно выразить одним словом - <b>checkmated</b>. На первый взгляд, это просто условие (весьма распространённое в играх шахматного семейства), связывающее завершение игры с образованием <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">матовой ситуации</a>. Увы, при более пристальном рассмотрении, простота оказывается обманчивой. Использование этого ключевого слова подразумевает не только выполнение, после каждого хода, проверок завершения игры, но и навязывает игроку определённое "поведение". 

И модуль генерации ходов и AI должны учитывать, что после выполнения хода, свой король не должен оказываться под <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)">шахом</a>. При этом, недостаточно выполнять проверку только для сходившей фигуры, шах вполне может быть "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85_(%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B)#.D0.92.D1.81.D0.BA.D1.80.D1.8B.D1.82.D1.8B.D0.B9_.D1.88.D0.B0.D1.85">открытым</a>". Правильно реализовать все необходимые проверки непросто (во всяком случае, в <b>ZoG</b> этого сделать не удалось):

<video>http://www.youtube.com/watch?v=OR74gUlfQNY</video>

От обычного <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> эта игра отличается только количеством игроков. К сожалению, этого отличия достаточно, чтобы сделать работу <b>checkmated</b> (и всей связанной с этим словом "магии") некорректной. Правильная проверка нахождения под шахом выполняется лишь по отношению к одному из игроков. В результате, король вполне может оказаться под ударом и быть съеденным! Разумеется это не лучшим образом отражается и на работе AI.

Если эта проблема кажется незначительной, стоит вспомнить о коалициях, обычно образуемых в играх четырёх игроков "пара на пару". В случае образования коалиций, мы должны учитывать, что дружественные фигуры королю не угрожают! Так, например, два дружественных короля вполне могут размещаться на соседних полях доски.

<img align="center" src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"/>
Еще больше всё усложняется если королей у игрока может быть несколько. В "<a href="http://skyruk.livejournal.com/283735.html">Шахматах Тамерлана</a>", королевская пешка превращается в принца (фактически, во второго короля). Если такое произошло, победить можно лишь съев первого короля (любого из двух) и заматовав второго. В этой игре, можно получить и третьего короля, дважды проведя на поле превращения "пешку пешек"! Выразительных возможностей "<b>checkmated</b>" недостаточно для адекватного описания этой ситуации.

Другой сложностью может стать сам процесс матования. Так в монгольском варианте шахмат (<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Шатар</a>), результат матования зависит от порядка, в котором фигуры выполняют последовательные "шахи". Результатом может оказаться и победа и ничья (например при мате пешкой) и даже поражение (конём матовать запрещено, но можно ставить шах). Чуть менее экзотичны, в этом плане, японские Сёги. В этой игре, запрещено ставить мат сбросом пешки, но можно шаховать сбросом пешки, а также матовать ходом пешки.

<spoiler title="Примечание">
Стоит упомянуть о ещё одном важном моменте. В некоторых играх, таких как <a href="http://habrahabr.ru/post/234587/">Ритмомахия</a>, вариантов завершения может быть несколько. Наиболее очевидный способ одержать победу, связанный с уничтожением фигур противника, в то же время, является наименее предпочтительным. Для более значимой победы, следует выстроить фигуры, на территории противника, определённым образом. 

Следует различать типы побед (а также поражений и ничьих) на уровне описания игры, поскольку тип завершения игры может потребоваться игроку. Кроме того, должна иметься возможность назначения числовых приоритетов различным вариантам завершения. При одновременном выполнении различных условий завершения, должно рассматриваться то из них, которое имеет максимальный приоритет.
</spoiler>
Очевидно, что необходимо отделять логику проверки завершения игры от проверки попадания короля под шах, являющейся, по сути, <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)">инвариантом</a>, проверяемым после выполнения каждого хода. Нарушение инварианта делает выполнение хода невозможным (ход изымается из списка доступных ходов). Вот так (упрощенно) может выглядеть проверка попадания короля под шах для "Шахмат Тамерлана":

<source lang="lisp">
(verify
    (or
        (> (count (pieces my? (is-piece? King))) 1)
        (= (count (pieces my? (is-piece? King) is-attacked?)) 0)
    )
)
</source>
Важно понимать, что эта проверка должна выполняется только для собственных королей (я использовал предикат <b>my?</b>, поскольку, при поддержке коалиций, атрибут <b>friend?</b> будет удовлетворяться не только для собственных фигур, но и для фигур дружественного игрока). Допустима (и желательна) ситуация, в которой вражеский король попадает под шах, после выполнения хода, но в отношении собственного короля, такая ситуация должна быть невозможной! При условии поддержки проверки подобных инвариантов, проверка завершения игры матом становится тривиальной. Если нет возможных ходов и король находится под шахом - игра проиграна:

<source lang="lisp">
(loss-condition
    (and
        (= (count moves) 0)
        (> (count (pieces my? (is-piece? King) is-attacked?)) 0)
    )
)
</source>
Возможность определения инвариантов будет полезной и в других играх, например в <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">шашках</a>. Наибольшая сложность, в реализации игр этого семейства, связана с реализацией "правила большинства". Практически во всех шашечных играх, ход со взятием является обязательным. Также, для большинства игр этого семейства, характерно выполнение "цепочек взятий", в рамках одного хода. Фигура, выполнившая взятие, продолжает брать другие фигуры, если это возможно. В большинстве игр, игрок обязан довести цепочку взятий до конца, но есть и исключения из этого правила, например <a href="http://www.iggamecenter.com/info/ru/fanorona.html">Фанорона</a>.

<img align="center" src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"/>
Используя механизм частичных ходов, "цепочки взятий" реализовать довольно просто. Сложности начинаются, когда, в дополнение к этому, накладывается условие, по которому, из всех возможных вариантов, требуется выбрать цепочку, берущую максимальное количество фигур. В <b>ZoG</b> эта логика вновь реализована на уровне "хардкода":

<source lang="lisp">
(option "maximal captures" true)
</source>
Такая настройка подходит для "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.9C.D0.B5.D0.B6.D0.B4.D1.83.D0.BD.D0.B0.D1.80.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Международных шашек</a>", но в "<a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.98.D1.82.D0.B0.D0.BB.D1.8C.D1.8F.D0.BD.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Итальянских шашках</a>" правило большинства формулируется иначе. В этом варианте игры, если имеется несколько вариантов с одинаковым количеством взятий, требуется выбрать вариант, в котором берётся больше превращенных шашек (дамок). Разработчики <b>ZoG</b> предусмотрели это, введя следующее значение настройки:

<source lang="lisp">
(option "maximal captures" 2)
</source>
При использовании этой настройки, учитывается не только количество взятых фигур, но и их тип. К сожалению, всего предусмотреть невозможно. Вот как формулируется "правило большинства" в "<a href="http://skyruk.livejournal.com/256132.html">Старофранцузских шашках</a>": 
<blockquote><b><i>Если при серии взятий можно рубить одинаковое количество шашек простой шашкой или дамкой, игрок обязан брать дамкой. Однако если количество снимаемых шашек одинаково в обоих случаях, но в одной <ветке> есть дамки противника (или их там больше), игрок обязан выбрать именно этот вариант, даже если тогда придется рубить простой шашкой, а не дамкой</i></b>.</blockquote>Конечно, в настоящее время, в этот вариант шашек почти никто не играет, но само его существование наглядно демонстрирует недостатки "хардкодной" реализации. Использование механизма инвариантов позволяет реализовать все возможные варианты "правила большинства" универсальным образом. Для "Старофранцузских шашек" реализация будет следующей:

<source lang="lisp">
(verify 
    (>= capturing-count max-capturing-count)
)
(if (> capturing-count max-capturing-count)
    (let max-capturing-count capturing-count)
    (let max-capturing-sum capturing-sum)
    (let max-attacking-value attacking-value)
)
(verify 
    (>= capturing-sum max-capturing-sum)
)
(if (> capturing-sum max-capturing-sum)
    (let max-capturing-sum capturing-sum)
    (let max-attacking-value attacking-value)
)
(verify 
    (>= attacking-value max-attacking-value)
)
(let max-attacking-value attacking-value)
</source>
Здесь, мы исходим из предположения, что правила генерации хода корректным образом заполняют локальные переменные:

<ul>
	<li><b>capturing-count</b> - количество взятых фигур</li>
	<li><b>capturing-sum</b> - суммарное достоинство взятых фигур</li>
	<li><b>attacking-value</b> - достоинство фигуры, выполняющей ход</li>
</ul>
С каждой из этих переменных связано значение-аккумулятор, сохраняемое в переменной с префиксом <b>max</b>. Последовательно выполняются три проверки. Нарушение любого из условий <b>verify</b> немедленно прерывает генерацию очередного хода (ход не сохраняется в списке возможных ходов). Поскольку выполняемые проверки связаны с изменяемыми значениями, этого недостаточно для корректной работы условий. Каждая такая проверка формирует "нарушаемый инвариант", связанный со сгенерированным ходом. После каждого изменения значения аккумулятора, повторно проверяются все связанные с ним инварианты. При нарушении любого из условий, ранее сгенерированный ход удаляется из списка возможных ходов.

<spoiler title="Примечание">
Есть еще одна возможность <b>ZoG</b>, используемая в реализации шашек. В случае если есть возможность взятия или "тихого хода", ход, выполняющий взятие, считается более приоритетным:

<source lang="lisp">
(move-priorities jumptype nonjumptype)

(piece
      (name Checker)
      (image Red "images\Checkers\Shaag\chkrRM.bmp" "images\Checkers\chkrRM.bmp"
             Black "images\Checkers\Shaag\chkrBM.bmp" "images\Checkers\chkrBM.bmp")
     (moves
         (move-type jumptype)
         (checker-jump nw)
         (checker-jump ne)

         (move-type nonjumptype)
         (checker-shift nw)
         (checker-shift ne)
      )
)
</source>
Подобное объявление приоритетов также становится излишним, при использовании механизма нарушаемых инвариантов.
</spoiler>
<h4><b>Заключение</b></h4>
В этой статье я постарался рассказать о своих планах по созданию нового универсального "движка" для разработки абстрактных логических игр и головоломок. Я отдаю себе отчёт в том, что работа эта не на один месяц (возможно даже и не на год), но, в данном случае, процесс, для меня, намного важнее результата. Я не планирую извлекать из этой работы какой либо выгоды и уж, тем более, не планирую закрывать исходные коды проекта. Если и будет использоваться какая-то лицензия, то я постараюсь найти самый либеральный вариант. Я буду рад, если к моей работе кто-то присоединится, но если таковых не найдётся, тоже сильно переживать не буду.

<i><b>Viam supervadet vadens</b></i>.
</habracut>

Анатомия меланхолии

<img align="left" src="https://habrastorage.org/files/562/b61/a75/562b61a75bd84112bf2b407727913339.PNG"/><i><b>Знание - сила.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Фрэнсис Бэкон.

... во многой мудрости много печали; 
&nbsp;&nbsp;&nbsp;&nbsp;и кто умножает познания, умножает скорбь.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Книга Экклезиаста.
</b></i>
Игры живут своей жизнью. Они возникают из ниоткуда, развиваются, порождают новые игры, забываются всеми и, порой, вновь возвращаются из забвения. В истории немало примеров игр, потерпевших поражение в этом процессе естественного отбора. Таковы разнообразные варианты <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B_%D1%81%D1%91%D0%B3%D0%B8">Сёги</a>, дошедшие до наших дней лишь благодаря трепетному отношению жителей Японии к своему культурному наследию. Партия в игру, подобную <a href="http://en.wikipedia.org/wiki/Taikyoku_shogi">Taikyoku shogi</a>, могла затянуться на месяцы (если не на годы). Но эти шахматные динозавры эпохи <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B8%D0%BE%D0%B4_%D0%A5%D1%8D%D0%B9%D0%B0%D0%BD">Хэйан</a> не являются самыми яркими представителями "ископаемого" мира настольных игр.
<habracut>
Я хочу рассказать о поистине удивительной игре. Угрозы в ней не очевидны, а цели не тривиальны. Победить можно множеством способов, но играть совсем не легко. Её нельзя отнести ни к семейству Шашек ни к шахматному семейству. Происхождение её туманно. Для среднестатистического обывателя, эта игра примерно столь же увлекательна, сколь и составление <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82">магических квадратов</a>. Она полностью оправдывает одно из своих названий - играть в неё могут только <a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84">философы</a>.

Впервые, <a href="https://en.wikipedia.org/wiki/Rithmomachy">Rithmomachia</a>, также известная как "Битва чисел" или "Игра философов" была описана, приблизительно, в 1030 году монахом по имени Asilo. Авторство, по всей видимости безосновательно, приписывается <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D1%82%D0%BE%D0%BD">Платону</a>, а правила игры основаны на арифметической теории <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D1%8D%D1%86%D0%B8%D0%B9">Боэция</a>. Впоследствии, правила игры были незначительно изменены другим монахом, по имени <a href="https://en.wikipedia.org/wiki/Hermannus_Contractus">Hermannus Contractus</a>, добавившим примечания, посвященные теории музыки. Продолжительное время Ритмомахия использовалась в качестве учебного пособия, при обучении студентов математике. Интеллектуалы того времени играли в Ритмомахию для удовольствия (одно время она была даже более популярна чем Шахматы), <a href="https://ru.wikipedia.org/wiki/%D0%91%D1%91%D1%80%D1%82%D0%BE%D0%BD,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82_(%D1%83%D1%87%D1%91%D0%BD%D1%8B%D0%B9)">Роберт Бёртон</a> упоминал её в "<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B0%D1%82%D0%BE%D0%BC%D0%B8%D1%8F_%D0%BC%D0%B5%D0%BB%D0%B0%D0%BD%D1%85%D0%BE%D0%BB%D0%B8%D0%B8">Анатомии меланхолии</a>", а <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D1%80,_%D0%A2%D0%BE%D0%BC%D0%B0%D1%81">Томас Мор</a> считал эту игру хорошим досугом для обитателей своей "<a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%BE%D0%BF%D0%B8%D1%8F_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)">Утопии</a>". Затем, внезапно, всё кончилось. Интересы математики и Ритмомахии разошлись и игра была забыта. Разумеется, это не означает, что мы не можем её вспомнить.

<h4><b>Правила игры</b></h4>
В Ритмомахию играют два игрока на прямоугольной доске 8x16 клеток. Ходы совершаются поочерёдно. За каждый ход перемещается одна фигура. В результате хода, может быть взята (снята с доски) одна или более фигур противника. Определены следующие типы фигур:

<ul>
	<li><b>Круг</b></li>
	<li><b>Треугольник</b></li>
	<li><b>Квадрат</b></li>
	<li><b>Пирамида</b></li>
</ul>
<img src="https://habrastorage.org/files/653/7ba/59d/6537ba59df4e4c739edbc882305adf51.PNG"/>

Не обращая внимания на числовые пометки на фигурах (о них я скажу ниже), можно заметить, что допускается два типа ходов. В первом случае, фигура движется по прямой и может быть остановлена любой другой фигурой (своей или противника), находящейся на пути. Таким образом перемещается Круг (на одну клетку по диагонали), а также Треугольник (строго две клетки по ортогонали) и Квадрат (строго три клетки по ортогонали). Другой возможностью является "прыжок" фигуры на целевую клетку, наподобие хода Коня в Шахматах. Так может ходить Треугольник или Квадрат. Любой ход должен выполняться только на пустую клетку.

Уникальной фигурой является Пирамида. Собственно это не фигура, а набор фигур. Каждая фигура в наборе (Круг, Треугольник или Квадрат) даёт возможность Пирамиде выполнять соответствующий тип хода. На рисунке выше, показаны возможные ходы Пирамиды в "максимальной комплектации". Как легко догадаться, к концу игры, "комплектность" может быть сильно нарушена (к слову сказать, Пирамида из Ритмомахии - это единственная известная мне фигура, которую можно "убивать по частям").

Остановлюсь подробнее на способах "убийства". В Ритмомахии их четыре:

<ul>
	<li><b>Capture by Siege</b></li>
	<li><b>Capture by Equality</b></li>
	<li><b>Capture by Ambush</b></li>
	<li><b>Capture by Eruption</b></li>
</ul>
<img src="https://habrastorage.org/files/6ff/dd7/df2/6ffdd7df204948a9961d493d5ab2066c.PNG"/>

Наиболее радикальным является взятие фигуры "в осаду". Фигура будет снята, если после очередного хода она окажется блокирована по всем диагональным или ортогональным направлениям. Если фигура расположилась у края доски или в углу - блокировать придётся меньшее количество направлений. Это простейший (но не единственный) способ взять Пирамиду всю сразу - целиком. Взятие "в осаду" - единственный способ, не использующий числовые значения фигур.

Другим способом является взятие фигуры с совпадающим числовым значением. Если, после выполнения хода, на поле, куда следующим своим ходом могла бы переместиться фигура (если бы это поле было пустым, разумеется) расположена фигура противника, с тем же числовым значением, она будет взята. Следует отметить, что этот способ боя может быть несимметричным. Так (на рисунке выше), после хода белых, Круг, с числовым значением 16, может взять чёрный Треугольник с тем же значением, но Треугольник, на своём ходу, этого сделать не может, поскольку ходит на другие клетки. В то же время, белый и чёрный треугольники с числовыми значениями 25 бьют друг друга симметрично (то какая фигура будет снята - определяется очередностью хода).

Усовершенствованным вариантом предыдущего является следующий способ. В этот раз, "из засады", нападают две фигуры. Если сумма, разность, произведение или частное их числовых значений совпадёт с числовым значением на фигуре противника - фигура снимается. Это наиболее часто используемая возможность боя фигур в игре, но увидеть все такие угрозы, в более менее сложной позиции, может быть совсем не просто.

Последний способ позволяет бить фигуры на дальнем расстоянии. Если результат произведения или частного числового значения фигуры и расстояния до фигуры противника (по ортогонали) совпадает с числовым значением фигуры противника - фигура снимается. Другие фигуры, расположенные по направлению боя, не препятствуют угрозе. При расчёте расстояния, учитываются начальная и конечная позиции. Это симметричный способ боя (поскольку он не зависит от правил перемещения фигур). Очередность хода определяет, какая из фигур будет снята.

Осталось рассказать о том, как эти правила распространяются на Пирамиды. С этим всё просто - в любых подсчётах на взятие фигур, Пирамида может выступать либо как самостоятельная фигура (её числовое значение совпадает с суммой числовых значений всех её компонентов), либо как любая из её частей. Аналогично этому, Пирамида может быть взята как целиком (по её суммарному значению), так и по частям (уязвим каждый из её компонентов в отдельности). С учетом правил перемещения Пирамиды, о которых я говорил выше, это делает Пирамиду самой сильной (и самой уязвимой) фигурой.

<img src="https://habrastorage.org/files/158/754/d87/158754d873e047b2a9e5d0622f71ec08.PNG"/>

Начальная расстановка фигур связана с еще одной важной особенностью игры. Хотя набор фигур одинаков, числовые значения различаются. Также, различна "комплектация" пирамид (показана сбоку от доски, для каждого из игроков). Это делает игру ассиметричной. Тактические приемы и стратегии, для чёрного игрока не годятся для белых (и наоборот). Это делает игру более интересной.

<h4><b>Славные победы</b></h4>
Описанных выше правил достаточно, чтобы начать играть в Ритмомахию, но если бы целью игры было простое взятие всех фигур противника, игра не была бы столь интересной. Да, победить можно и таким образом, но это не единственный (и не лучший) способ одержать победу! Мне очень нравятся игры, целью которых не является прямолинейное "убийство" фигур противника. Так в Шахматах, для победы, совсем не обязательно "есть" все фигуры, достаточно поставить мат Королю! В некоторых вариантах <a href="http://brainking.com/ru/GameRules?tp=73">Hasami Shogi</a>, цель игры еще более неожиданная (для победы необходимо построить линию из 5 своих фишек "в ряд"). Ритмомахия не разочаровывает и в этом отношении. Вот список способов одержать победу в этой игре (в порядке возрастания их "славности"):

<ul>
	<li><b>De Corpore</b> ("by body"): Взять заданное (или большее) количество фигур противника (обычно 15)</li>
	<li><b>De Bonis</b> ("by goods"): Взять фигуры противника с заданным (или большим) суммарным значением (обычно 1315 для белых и 984 для чёрных)</li>
	<li><b>De Lite</b> ("by lawsuit"): Взять фигуры противника с заданным (или большим) суммарным значением, при условии, что количество цифр, на захваченных фигурах, не превышает заданного</li>
	<li><b>De Honore</b> ("by honour"): Взять фигуры противника с заданным (или большим) суммарным значением, при условии, что количество захваченных фигур не превышает заданного</li>
	<li><b>De Honore Liteque</b> ("by honour and lawsuit"): Взять фигуры противника с заданным (или большим) суммарным значением, при условии, что количество захваченных фигур не превышает заданного и количество цифр, на захваченных фигурах, не превышает заданного</li>
	<li><b>Victoria Magna</b> ("great victory"): Расположить три фигуры (на территории противника) в арифметической прогрессии</li>
	<li><b>Victoria Major</b> ("greater victory"): Расположить четыре фигуры (на территории противника) так, чтобы в них имелись две (но не более) групп из трёх фигур, размещенных в различных видах прогрессии (<a href="http://en.wikipedia.org/wiki/Arithmetic_progression">арифметической</a>, <a href="http://en.wikipedia.org/wiki/Geometric_progression">геометрической</a> или <a href="http://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)">гармонической</a>)</li>
	<li><b>Victoria Excellentissima</b> ("most excellent victory"): Расположить (на территории противника) четыре фигуры так, чтобы имелось все три вида прогрессии</li>
</ul>
Здесь можно различить два принципиально различных вида целей игры. <b>Common Victories</b> связаны с захватом фигур противника (с возможным ограничением количества захватываемых фигур, с целью защиты от агрессивной игры). <b>Proper Victories</b> считаются более достойным завершением и связаны с воссозданием некой "гармонии" на территории противника (что не исключает возможности боя фигур противника).

<img src="https://habrastorage.org/files/b77/f07/014/b77f070140ed4c8f93e191de5aad02c9.png"/>

Примеры выше иллюстрируют, что в "гармонию" могут (и должны) вовлекаться фигуры противника. В первом случае, построена арифметическая прогрессия (16, 36, 56). Второй пример сочетает геометрическую (4, 12, 36) и гармоническую (4, 6, 12) прогрессии. В третьем случае, присутствуют все три вида прогрессии (вы сами можете найти их). На случай, если имеются сложности с устным счётом, построены таблицы всех возможных в Ритмомахии <a href="http://www.boardspace.net/rithmomachy/english/Rithmomachy%20Glorious%20Victories.html">решений</a> (впрочем, людей, имеющих проблемы с устным счётом, Ритмомахия вряд ли заинтересует).

<h4><b>Возможны варианты</b></h4>
В период своего расцвета, Ритмомахия уже претерпела немало изменений. Последующие реконструкции не улучшили ситуацию. Имеется множество разночтений в описаниях правил этой игры. Некоторые источники дают альтернативные варианты первоначальной расстановки фигур (мне попадался даже вариант, описывающий игру на доске 8 x 14):

<img src="https://habrastorage.org/files/79e/f2b/412/79ef2b4129944de68d0f29edf39c3e83.PNG"/>

Имеются варианты с упрощенными правилами перемещения фигур. По этим правилам, фигуры движутся по прямой (ортогоналям и диагоналям) на заданное число клеток. Любая фигура, на пути движения, останавливает перемещение. Прыжки, наподобие хода Коня в Шахматах, отсутствуют. Пирамида, как обычно, сочетает ходы присутствующих в её наборе фигур. 

<img src="https://habrastorage.org/files/801/6eb/a13/8016eba135434885a27e1fcbe9eca3f7.png"/>

Помимо этого, имеется вариант с обычными правилами движения фигур, в котором добавляется специальный ход Пирамиды на 3 клетки по диагонали. Такой ход возможен при условии, что не взята ни одна из фигур, первоначально входящих в состав Пирамиды. С сохранностью первоначального набора фигур Пирамиды связан и другой вариант. В нём разрешается использовать суммарное значение Пирамиды, только при условии, что ни одна из её фигур ещё не была "съедена". Есть и более простые варианты, в которых Пирамида убирается полностью, если атакован любой из её компонентов.

Часть вариантов связана с изменениями правил взятия фигур. Так, в одном из вариантов, для взятия фигуры "<b>by Siege</b>" (осада), необходимо блокировать все направления её "естественного" перемещения. При этом, не обязательно располагать свои фигуры вплотную к блокируемой (примеры ниже иллюстрируют концепцию). Это довольно интересное правило.

<img src="https://habrastorage.org/files/7b3/b0a/a89/7b3b0aa8919445709549b8fa09b97000.png"/>

Есть вариант, в котором взятие "<b>by Ambush</b>" (засада) осуществляется подобно играм "зажимного" типа (при этом, правила перемещения фигур игнорируются):

<img src="https://habrastorage.org/files/585/d3b/43e/585d3b43e9924c9994fcd1cf10a5d482.png"/>

Имеется большое количество расхождений в определениях "<b>Glorious Victories</b>". Часто, в условия таких побед, включается предварительное уничтожение Пирамиды противника. Также, существует условие завершения игры, ограничивающееся взятием Пирамиды. Вариантов этой игры много. Ознакомление с нюансами правил, перед началом игры, в любом случае, будет совсем не лишним.

<h4><b>Подробности для любознательных</b></h4>
Реализация игры естественным образом разделилась на несколько этапов. Проще всего было реализовать перемещение фигур. С этого я и начал. Вот как выглядит перемещение Квадратов:

<spoiler title="Перемещение Квадратов">
<source>
: leap-n ( 'leap-dir 'shift-dir count ? -- )
	IF
		BEGIN
			OVER EXECUTE IF
				on-board? IF
					1- DUP 0> IF
						FALSE
					ELSE
						2DROP TRUE TRUE
					ENDIF
				ELSE
					2DROP FALSE TRUE
				ENDIF
			ELSE
				2DROP FALSE TRUE
			ENDIF
		UNTIL
		IF
			EXECUTE IF
				on-board? empty? AND IF
					from
					here DUP last-position !
					move
					capture-all
					add-move
				ENDIF
			ENDIF
		ELSE
			DROP
		ENDIF
	ELSE
		2DROP DROP
	ENDIF
;

: shift-n ( 'shift-dir count ? -- )
	IF
		BEGIN
			OVER EXECUTE IF
				on-board? empty? AND IF
					1- DUP 0> IF
						FALSE
					ELSE
						2DROP TRUE TRUE
					ENDIF
				ELSE
					2DROP FALSE TRUE
				ENDIF
			ELSE
				2DROP FALSE TRUE
			ENDIF
		UNTIL
		IF
			from
			here DUP last-position !
			move
			capture-all
			add-move
		ENDIF
	ELSE
		2DROP
	ENDIF
;

: s-move-n ( -- ) ['] North 3 TRUE shift-n ;
: s-move-s ( -- ) ['] South 3 TRUE shift-n ;
: s-move-w ( -- ) ['] West  3 TRUE shift-n ;
: s-move-e ( -- ) ['] East  3 TRUE shift-n ;

: s-move-nw ( -- ) ['] Northwest ['] North 2 TRUE leap-n ;
: s-move-ne ( -- ) ['] Northeast ['] North 2 TRUE leap-n ;
: s-move-sw ( -- ) ['] Southwest ['] South 2 TRUE leap-n ;
: s-move-se ( -- ) ['] Southeast ['] South 2 TRUE leap-n ;
: s-move-wn ( -- ) ['] Northwest ['] West  2 TRUE leap-n ;
: s-move-ws ( -- ) ['] Southwest ['] West  2 TRUE leap-n ;
: s-move-en ( -- ) ['] Northeast ['] East  2 TRUE leap-n ;
: s-move-es ( -- ) ['] Southeast ['] East  2 TRUE leap-n ;

{moves s-moves
	{move} s-move-n
	{move} s-move-s
	{move} s-move-w
	{move} s-move-e
	{move} s-move-nw
	{move} s-move-ne
	{move} s-move-sw
	{move} s-move-se
	{move} s-move-wn
	{move} s-move-ws
	{move} s-move-en
	{move} s-move-es
moves}
</source>
</spoiler>
Некоторая сложность возникла с Пирамидами, поскольку их набор ходов определяется тем, какие фигуры входят в них, в настоящий момент. Пришлось описывать для них все возможные ходы, а при выполнении хода, проверять наличие в наборе соответствующей фигуры:

<spoiler title="Перемещение Пирамид">
<source>
: is-correct-type? ( piece-type -- ? )
	not-empty? IF
		piece-type PYRAMID > IF
			here SWAP a1 to
			BEGIN
				friend-p IF
					DUP is-piece-type? IF
						DROP TRUE TRUE
					ELSE
						FALSE
					ENDIF
				ELSE
					DROP FALSE TRUE
				ENDIF
			UNTIL
			SWAP to
		ELSE
			DROP FALSE
		ENDIF
	ELSE
		DROP FALSE
	ENDIF
;

: pr-move-ne ( -- ) ['] Northeast ROUND is-correct-type? leap-0 ;
: pr-move-se ( -- ) ['] Southeast ROUND is-correct-type? leap-0 ;
: pr-move-nw ( -- ) ['] Northwest ROUND is-correct-type? leap-0 ;
: pr-move-sw ( -- ) ['] Southwest ROUND is-correct-type? leap-0 ;

{moves p-moves
	{move} pr-move-ne
	{move} pr-move-se
	{move} pr-move-nw
	{move} pr-move-sw
	...
moves}
</source>
</spoiler>
Реализация боя фигур обернулась настоящей "гонкой на выживание". Требовалось реализовать четыре совершенно различных (и весьма нетривиальных) способа взятия. При этом, хотелось ограничить количество просмотров полей, чтобы минимизировать накладные расходы на вычисления (ход и так рассчитывается безобразно долго). В результате, я остановился на идее предварительного заполнения нескольких массивов, с выполнением последующих проверок условий боя фигур:

<spoiler title="Способы боя">
<source>
MAXV []		attacking-values[]
MAXS []		current-positions[]
MAXS []		current-values[]
MAXS []		eruption-values[]

: fill-current ( pos -- )
	1 current-count !
	DUP 0 current-positions[] !
	DUP piece-type-at PYRAMID > IF
		a1 to 0
		BEGIN
			enemy-p IF
				not-empty? IF
					piece piece-value
					current-count @ MAXS < IF
						here current-count @ current-positions[] !
						DUP  current-count @ current-values[] !
						current-count ++
					ENDIF
					+
				ENDIF
				FALSE
			ELSE
				TRUE
			ENDIF
		UNTIL
	ELSE
		DUP piece-at piece-value
	ENDIF
	0 current-values[] !
	to
;

: get-eruption-values ( n -- )
	0 sum-value !
	PYRAMID is-piece-type? IF
		here a1 to
		BEGIN
			friend-p IF
				not-empty? eruption-count @ MAXE < AND IF
					OVER piece piece-value 
					DUP sum-value @ + sum-value !
					*
					eruption-count @ eruption-values[] !
					eruption-count ++
				ENDIF				         
				FALSE
			ELSE
				TRUE
			ENDIF
		UNTIL
		to
		sum-value @
	ELSE
		piece piece-value
	ENDIF
	eruption-count @ MAXE < IF
		*
		eruption-count @ eruption-values[] !
		eruption-count ++
	ELSE
		2DROP
	ENDIF
;

: get-attacking-values ( piece-type -- )
	0 sum-value    !
	FALSE sum-flag !
	PYRAMID is-piece-type? IF
		here a1 to
		BEGIN
			friend-p IF
				not-empty? attacking-count @ MAXV < AND IF
					piece piece-value
					sum-value @ + sum-value !
					OVER is-piece-type? IF
						TRUE sum-flag !
						piece piece-value
						attacking-count @ attacking-values[] !
						attacking-count ++
					ELSE
					ENDIF
				ENDIF				         
				FALSE
			ELSE
				TRUE
			ENDIF
		UNTIL
		to DROP
		sum-flag @ attacking-count @ MAXV < AND IF
			sum-value @
			attacking-count @ attacking-values[] !
			attacking-count ++
		ENDIF
	ELSE
		is-piece-type? attacking-count @ MAXV < AND IF
			piece piece-value
			attacking-count @ attacking-values[] !
			attacking-count ++
		ENDIF
	ENDIF
;

: check-siege-od ( 'dir -- )
	EXECUTE IF
		predict-move
		on-board? NOT friend? OR IF
			siege-counter --
		ENDIF
		on-board? friend? AND IF
			2 get-eruption-values
		ENDIF
		to
	ELSE
		siege-counter --
	ENDIF
;

: check-siege-dd ( 'dir -- )
	EXECUTE IF
		predict-move
		on-board? NOT friend? OR IF
			siege-counter --
		ENDIF
		on-board? friend? AND IF
			ROUND get-attacking-values
			ROUND check-equality-piece
		ENDIF
		to
	ELSE
		siege-counter --
	ENDIF
;

: check-siege ( pos -- )
	4 siege-counter !
	DUP to ['] North check-siege-od
	DUP to ['] South check-siege-od
	DUP to ['] West  check-siege-od
	DUP to ['] East  check-siege-od
	siege-counter @ 0= IF
		TRUE is-captured? !
	ENDIF
	4 siege-counter !
	DUP to ['] Northeast check-siege-dd
	DUP to ['] Southeast check-siege-dd
	DUP to ['] Northwest check-siege-dd
	DUP to ['] Southwest check-siege-dd
	siege-counter @ 0= IF
		TRUE is-captured? !
	ENDIF
	to
;

: check-equality-dd ( 'second-dir count 'first-dir -- )
	EXECUTE on-board? AND IF
		BEGIN
			1- DUP 0< IF
				TRUE			
			ELSE
				OVER EXECUTE on-board? AND IF
					predict-move
					friend? IF
						OVER count-to-piece-type
						DUP get-attacking-values
						check-equality-piece
					ENDIF
					to
	                                FALSE
				ELSE
					TRUE
				ENDIF
			ENDIF
		UNTIL
		2DROP
	ELSE
		2DROP
	ENDIF
;

: check-equality-od ( 'second-dir count 'first-dir -- )
	EXECUTE on-board? AND empty? AND IF
		BEGIN
			1- DUP 0< IF
				TRUE			
			ELSE
				OVER EXECUTE on-board? AND IF
					predict-move
					friend? IF
						OVER count-to-factor get-eruption-values
						OVER count-to-piece-type
						DUP get-attacking-values
						check-equality-piece
						TRUE
					ELSE
						not-empty?
					ENDIF
					SWAP to
				ELSE
					TRUE
				ENDIF
			ENDIF
		UNTIL
		2DROP
	ELSE
		2DROP
	ENDIF
;

: check-equality ( pos -- )
	DUP to ['] North 2 ['] North     check-equality-od
	DUP to ['] North 2 ['] Northwest check-equality-dd
	DUP to ['] North 2 ['] Northeast check-equality-dd
	DUP to ['] South 2 ['] South     check-equality-od
	DUP to ['] South 2 ['] Southwest check-equality-dd
	DUP to ['] South 2 ['] Southeast check-equality-dd
	DUP to ['] West  2 ['] West      check-equality-od
	DUP to ['] West  2 ['] Northwest check-equality-dd
	DUP to ['] West  2 ['] Southwest check-equality-dd
	DUP to ['] East  2 ['] East      check-equality-od
	DUP to ['] East  2 ['] Northeast check-equality-dd
	DUP to ['] East  2 ['] Southeast check-equality-dd
	to
;

: check-ambush-prod ( value -- ? )
	value-1 @ value-2 @ * OVER = IF
		DROP TRUE
	ELSE
		DUP value-1 @ * value-2 @ = IF
			DROP TRUE
		ELSE
			value-2 @ * value-1 @ = IF
				TRUE
			ELSE
				FALSE
			ENDIF
		ENDIF
	ENDIF
;

: check-ambush-cond ( value -- ? )
	value-1 @ value-2 @ + OVER = IF
		DROP TRUE
	ELSE
		DUP value-1 @ + value-2 @ = IF
			DROP TRUE
		ELSE
			DUP value-2 @ + value-1 @ = IF
				DROP TRUE
			ELSE
				check-ambush-prod
			ENDIF
		ENDIF
	ENDIF
;

: check-ambush-pair ( -- )
	current-count @
	BEGIN
		1-
		DUP current-positions[] @ 0< NOT IF
			DUP current-values[] @ check-ambush-cond IF
				DUP 0> IF
					DUP current-positions[] @ 
					DUP enemy-at? IF
						DUP ChangePieces
						capture-at
					ELSE
						DROP
					ENDIF
					-1 OVER current-positions[] !
				ELSE
					TRUE is-captured? !
				ENDIF
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL
	DROP
;

: check-ambush ( -- )
	attacking-count @
	BEGIN
		1-
		attacking-count @
		BEGIN
			1-
			2DUP < IF
				2DUP 
				attacking-values[] @ value-1 !
				attacking-values[] @ value-2 !
				check-ambush-pair
			ENDIF
			DUP 0> NOT
		UNTIL
		DROP
		DUP 0> NOT
	UNTIL
	DROP
;

: fill-eruption-values ( 'dir pos n -- )
	value-1 ! to 1
	BEGIN
		1+ OVER EXECUTE IF
			predict-move
			OVER value-1 @ > on-board? friend? AND AND IF
				OVER get-eruption-values
			ENDIF
			to
			FALSE
		ELSE
			TRUE
		ENDIF
	UNTIL
	2DROP
;

: check-eruption-pair ( -- )
	current-count @
	BEGIN
		1-
		DUP current-positions[] @ 0< NOT IF
			DUP current-values[] @ value-1 @ = IF
				DUP 0> IF
					DUP current-positions[] @ 
					DUP enemy-at? IF
						DUP ChangePieces
						capture-at
					ELSE
						DROP
					ENDIF
					-1 OVER current-positions[] !
				ELSE
					TRUE is-captured? !
				ENDIF
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL
	DROP
;

: check-eruption-values ( -- )
	eruption-count @
	BEGIN
		1-
		DUP eruption-values[] @ value-1 !
		check-eruption-pair
		DUP 0> NOT
	UNTIL
	DROP
;

: check-eruption ( pos -- )
	['] North OVER 4 fill-eruption-values
	['] South OVER 4 fill-eruption-values
	['] West  OVER 4 fill-eruption-values
	['] East  OVER 4 fill-eruption-values
	to
	check-eruption-values
;

: capture-all ( -- )
	here ROWS COLS *
	BEGIN
		1-
		DUP on-board-at? OVER enemy-at? AND IF
			0 attacking-count  !
			0 eruption-count   !
			FALSE is-captured? !
			DUP fill-current
			DUP check-siege
 			is-captured? @ NOT IF
				DUP check-equality
			ENDIF
			is-captured? @ NOT IF
				check-ambush
			ENDIF
			is-captured? @ NOT IF
				DUP check-eruption
			ENDIF
			is-captured? @ IF
				capture-piece
			ENDIF
		ENDIF
		DUP 0> NOT
	UNTIL
	DROP to
;
</source>
</spoiler>
Взятие фигур в Пирамиде, как и перемещение, пришлось обрабатывать особым образом:

<spoiler title="Взятие фигур">
<source>
: capture-piece ( -- )
	current-count @
	BEGIN
		1- DUP 0> IF
			DUP current-positions[] @
			DUP 0< NOT IF
				DUP enemy-at? IF
					DUP ChangePieces
					capture-at
				ELSE
					DROP
				ENDIF
			ELSE
				DROP
			ENDIF
			FALSE
		ELSE
			DUP current-positions[] @
			DUP enemy-at? IF
				DUP ChangePieces
				capture-at
			ELSE
				DROP
			ENDIF
			TRUE
		ENDIF
	UNTIL
	DROP
;
</source>
</spoiler>
Уже в процессе отладки, я понял, что все проверки выполняются на момент до выполнения хода. Пришлось написать небольшую функцию, имитирующую перемещение фигуры (это не совсем полноценный перерасчёт позиции на доске, но мне удалось обойтись малой кровью):

<spoiler title="Изменение позиции">
<source>
: predict-move ( -- pos )
	here 
	DUP from = IF
		last-position @ to
	ELSE
		DUP last-position @ = IF
			from to
		ENDIF
	ENDIF
;
</source>
</spoiler>
На фоне всех этих ужасов, проверка условий завершения игры показалась тривиальной задачей. Не обошлось без небольшого количества магии Axiom, но здесь нет ничего такого, что я боялся бы показать родителям:

<spoiler title="Проверка завершения">
<source>
15	CONSTANT	WINC
1315	CONSTANT	WINW
984	CONSTANT	WINB

: WhitePieces++ ( -- ) WhitePieces ++ ;
: BlackPieces++ ( -- ) BlackPieces ++ ;
: WhiteValues++ ( -- ) WhiteValues ++ ;
: BlackValues++ ( -- ) BlackValues ++ ;

: ChangePieces ( pos -- )
	DUP piece-at piece-value SWAP
	player-at White = IF
		COMPILE WhitePieces++
		BEGIN
			1-
			COMPILE WhiteValues++
			DUP 0> NOT
		UNTIL
		DROP
	ELSE
		COMPILE BlackPieces++
		BEGIN
			1-
			COMPILE BlackValues++
			DUP 0> NOT
		UNTIL
		DROP
	ENDIF
;

: OnIsGameOver ( -- gameResult )
	#UnknownScore
	current-player White = IF
		WhitePieces @ WINC >= IF
			DROP
			#LossScore
		ENDIF
		WhiteValues @ WINW >= IF
			DROP
			#LossScore
		ENDIF
	ENDIF
	current-player Black = IF
		BlackPieces @ WINC >= IF
			DROP
			#LossScore
		ENDIF
		BlackValues @ WINB >= IF
			DROP
			#LossScore
		ENDIF
	ENDIF
;
</source>
</spoiler>
Начиная с этого момента, программа уже могла играть (правда делала это довольно пассивно). Дело в том, что, в отсутствии оценочной функции (и кастомной реализации AI), Axiom пытается выполнять полный перебор, до терминальной позиции. Понятно, что завершение партии находится далеко за горизонтом возможной глубины перебора, в результате чего, найденные ходы не отличаются особой осмысленностью. В общем, осталось добавить AI зубы:

<spoiler title="Оценочная функция">
<source>
: OnEvaluate ( -- score )
	current-player material-balance
;
</source>
</spoiler>
Здесь использована очень удобная функция <b>material-balance</b> (предоставляемая Axiom), использующая весовые значения заданные фигурам (эти же значения использованы для реализаций правил Ритмомахии):

<spoiler title="Описание фигур">
<source>
{pieces
	{piece}		R0	{moves} r-moves	0   {value}
	{piece}		R1	{moves} r-moves	1   {value}
	{piece}		R2	{moves} r-moves	2   {value}
	{piece}		R3	{moves} r-moves	3   {value}
	{piece}		R4	{moves} r-moves	4   {value}
	{piece}		R5	{moves} r-moves	5   {value}
	{piece}		R6	{moves} r-moves	6   {value}
	{piece}		R7	{moves} r-moves	7   {value}
	{piece}		R8	{moves} r-moves	8   {value}
	{piece}		R9	{moves} r-moves	9   {value}
	{piece}		R16	{moves} r-moves	16  {value}
	{piece}		R25	{moves} r-moves	25  {value}
	{piece}		R36	{moves} r-moves	36  {value}
	{piece}		R49	{moves} r-moves	49  {value}
	{piece}		R64	{moves} r-moves	64  {value}
	{piece}		R81	{moves} r-moves	81  {value}
	{piece}		T0	{moves} t-moves	0   {value}
	{piece}		T6	{moves} t-moves	6   {value}
	{piece}		T9	{moves} t-moves	9   {value}
	{piece}		T12	{moves} t-moves	12  {value}
	{piece}		T16	{moves} t-moves	16  {value}
	{piece}		T20	{moves} t-moves	20  {value}
	{piece}		T25	{moves} t-moves	25  {value}
	{piece}		T30	{moves} t-moves	30  {value}
	{piece}		T36	{moves} t-moves	36  {value}
	{piece}		T42	{moves} t-moves	42  {value}
	{piece}		T49	{moves} t-moves	49  {value}
	{piece}		T56	{moves} t-moves	56  {value}
	{piece}		T64	{moves} t-moves	64  {value}
	{piece}		T72	{moves} t-moves	72  {value}
	{piece}		T81	{moves} t-moves	81  {value}
	{piece}		T90	{moves} t-moves	90  {value}
	{piece}		T100	{moves} t-moves	100 {value}
	{piece}		S0	{moves} s-moves	0   {value}
	{piece}		S15	{moves} s-moves	15  {value}
	{piece}		S25	{moves} s-moves	25  {value}
	{piece}		S28	{moves} s-moves	28  {value}
	{piece}		S36	{moves} s-moves	36  {value}
	{piece}		S45	{moves} s-moves	45  {value}
	{piece}		S49	{moves} s-moves	49  {value}
	{piece}		S64	{moves} s-moves	64  {value}
	{piece}		S66	{moves} s-moves	66  {value}
	{piece}		S81	{moves} s-moves	81  {value}
	{piece}		S120	{moves} s-moves	120 {value}
	{piece}		S121	{moves} s-moves	121 {value}
	{piece}		S153	{moves} s-moves	153 {value}
	{piece}		S169	{moves} s-moves	169 {value}
	{piece}		S225	{moves} s-moves	225 {value}
	{piece}		S289	{moves} s-moves	289 {value}
	{piece}		S361	{moves} s-moves	361 {value}
	{piece}		P0	{moves} p-moves	0   {value}
	{piece}		P91	{moves} p-moves	91  {value}
	{piece}		P190	{moves} p-moves	190 {value}
pieces}
</source>
</spoiler>
Этой реализации многого не хватает (например проверки завершения игры по <b>Glorious Victories</b>). Я постараюсь добавить недостающий функционал в будущем. Актуальную версию исходников всегда можно посмотреть <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/Rithmomachy/Rithmomachy.4th">здесь</a>.

<h4>Что в итоге?</h4>
Ритмомахия заинтересовала меня, в первую очередь, своей сложностью. Разумеется, и мыслей не было реализовать её на <a href="http://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a>. Мне пришлось освоить <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a>, для этого! В настоящий момент, имеется упрощенная <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2282">реализация</a>, не поддерживающая <b>Glorious Victories</b>. Также, нет твердой уверенности в том, что я нашёл все ошибки в коде (1000 строк на ForthScript - это серьёзно). Это бета-версия, но, в целом, она работает:

<video>http://www.youtube.com/watch?v=-GogR14dizc</video>

Можно заметить, что игра заканчивается очень быстро. Это действительно так. В случае, если оба игрока играют агрессивно, по условиям <b>Common Victories</b> (и без ограничения на количество взятых фигур), средняя продолжительность партии составляет ~10 ходов. При этом, первый игрок имеет серьёзное преимущество:

<source>
Cumulative results following game 13 of 100:
Player 1 "Eval", wins = 13.
Player 2 "Eval", wins = 0.
Draws = 0
</source>
Забавно, что если агрессивен лишь один из игроков, партия затягивается до более чем 300 ходов (агрессивный игрок практически всегда выигрывает).

<source>
Cumulative results following game 22 of 100:
Player 1 "Rithmomachy", wins = 1.
Player 2 "Eval", wins = 21.
Draws = 0
</source>
Человеку с компьютером играть сложно. Даже с подсветкой фигур, находящихся под боем, бывает непросто сообразить, какой именно фигурой следует сделать ход, чтобы выполнить взятие (при этом, желательно еще и не подставить свои фигуры). В наше время, эта игра вряд ли будет популярна, но одного у неё не отнять. Она здорово развивает навык устного счёта.
</habracut>

Программирование «для души»

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/87b/46b/0cb/87b46b0cb8c89f77895c30c6b47da5e8.png"/><i><b>Полно, голубь, не греши!
Убери свои гроши.
Я ведь это не для денег.
Я ведь это для души.

Леонид Филатов "<a href="http://lyakhov.kz/library/filatov/fedot.shtml#1">Сказка про Федота-стрельца, удалого молодца</a>"

Just for Fun.

Linus Torvalds</b></i>

Не секрет, что люди получают удовольствие по-разному. Одним нравится смотреть телевизор, другие собирают квадрокоптеры. Я хочу поделиться своим рецептом. Вряд ли он будет полезен всем, но возможно кого-то заинтересует. Мне нравится писать программы (и думаю, что это не редкость, даже среди профессиональных программистов), но мне не очень нравится, когда этот процесс превращается в унылую рутину. 

Чтобы быть интересным, программирование должно представлять собой, своего рода "зарядку для ума". Хорошим примером такого (полезного) развлечения является, известный многим <a href="http://www.sql-ex.ru">ресурс</a>, посвященный совершенствованию навыков составления SQL-запросов. Но не SQL-ем единым жив программист! Недавно, я нашел отличный способ усовершенствовать свои навыки владения <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Фортом</a>. <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom</a> позволяет напрограммироваться на Форте вволю!

Мой рецепт получения Fun-а, при помощи Axiom, прост:

<ol>
	<li>Выбираем <a href="http://www.iggamecenter.com/info/en/rules.html">любую</a> игру, с правилами позаковыристее, из числа ещё не реализованных ZoG-сообществом</li>
	<li>Пытаемся её воплотить в жизнь, используя Axiom</li>
	<li>Получаем <b>удовольствие</b>, в процессе решения возникающих при этом задач</li>
	<li>В случае, если в полученное приложение интересно играть, выработанный Fun автоматически удваивается!</li>
</ol>
<habracut>
С выполнением первого пункта этого плана мне, обычно, помогает Internet. В этот раз, объектом для своих бесчеловечных экспериментов я выбрал <a href="http://www.toco.be/splut/">Splut!</a>. Вот его <a href="http://www.iggamecenter.com/info/en/splut.html">описание</a> на IG Game Center. Не вдаваясь в пересказ правил, постараюсь объяснить, чем меня привлекла эта игра:

<ul>
	<li>В неё играют более двух игроков (что является, в определённой степени, вызовом, для алгоритмов AI)</li>
	<li>Ход игрока включает в себя последовательное перемещение нескольких (от 1 до 3) фигур</li>
	<li>Ходы, ведущие к выигрышу, не прямолинейны (нельзя просто взять и съесть фигуру, требуется выполнить последовательность ходов, объединенных одной целью)</li>
	<li>Правила этой игры весьма продуманны и очень оригинальны</li>
</ul>
<spoiler title="Ремарка">
Вот что пишет автор, по поводу прав на свою игру:

<blockquote>The SPLUT game idea and design are copyrighted. You cannot use any of the ideas or contents of this publication for commercial purposes without written authorization of the designer Tommy De Coninck.</blockquote>
Поскольку я не собираюсь использовать идею или дизайн игры в коммерческих целях, с этим пунктом всё в порядке.
</spoiler>
<h4>Магия с разоблачением</h4>
Приступим к выработке Fun-а. Начнем с простого - с ходов Тролля. Обычный ход фигуры никаких сложностей не представляет. Его реализация очевидна и хорошо подходит для объяснения концепций Axiom:

<spoiler title="Тихий ход">
<source>
: one-step ( 'dir -- )
        EXECUTE verify                     \ Шаг вперёд
        empty? verify                      \ Пусто?
        from                               \ Из исходной точки
        here                               \ Сюда
        move                               \ Ходим
        add-move                           \ Ход завершён
;
</source>
</spoiler>
Сразу хочу посоветовать, обращать внимание на комментарии (в круглых скобках). Они помогут не запутаться в том, что происходит на стеке (это действительно важно в Форте). Также стоит обращать внимание на пробелы. Пробел, <b>не</b> поставленный, в неудачном месте, может заставить вас потратить немало времени. 

По самому коду, думаю, всё понятно. Мы выполняем переход в направлении (взятом со стека), командой <b>EXECUTE</b>, после чего проверяем булевский результат перехода (если не <b>TRUE</b>, завершаем расчет хода). Затем, выполняем проверку того, что целевая клетка пуста, после чего, перемещаем фигуру. Команда <b>move</b>, выполняющая перемещение, берёт со стека два значения - точку начала хода (<b>from</b>) и позицию, в которой мы находимся, после перемещения (<b>here</b>). Команда <b>add-move</b> завершает формирование хода.

Чуть более сложен ход, с перемещением камня:

<spoiler title="Перетаскивание камня">
<source>
: drag ( 'dir 'opposite -- )
        EXECUTE verify                     \ Шаг назад
        is-stone? verify                   \ Это камень?
        piece-type                         \ Кручу верчу
        SWAP here SWAP                     \ Запутать хочу
        DUP EXECUTE DROP EXECUTE verify    \ Два раза шагаем вперёд
        empty? verify                      \ Пусто?
        from                               \ Из исходной точки
        here                               \ Сюда
        move                               \ Перемещаем фигуру
        capture-at                         \ Удаляем Камень с позиции, запомненной ранее
        from create-piece-type-at          \ И создаём его там, откуда начинали ход
        add-move                           \ Это всё!
;

: drag-to-north ( -- ) ['] north ['] south drag ;
: drag-to-south ( -- ) ['] south ['] north drag ;
: drag-to-east  ( -- ) ['] east  ['] west  drag ;
: drag-to-west  ( -- ) ['] west  ['] east  drag ;
</source>
</spoiler>
Здесь мы кладём на стек сразу два направления - направление перемещения и противоположное ему. Сам код выглядит сложнее, из-за манипуляций со стеком, но к этому можно привыкнуть. Очень важно, что все "побочные" действия по захвату или созданию фигур должны выполняться <b>после</b> перемещения основной фигуры. Также важно помнить, что и в каком порядке лежит на стеке после каждой команды. Подробное описание самих команд всегда можно посмотреть в руководстве по Axiom.

На одном моменте, впрочем, стоит остановиться особо. Проверка того, что фигура в текущей клетке является Камнем, выполняется предикатом <b>is-stone?</b>. Разумеется, это не встроенная функция Axiom, а наша. Вот как выглядит её реализация:

<spoiler title="Камень?">
<source>
DEFER           SSTONE
DEFER           NSTONE
DEFER           WSTONE
DEFER           ESTONE

: is-stone? ( -- ? )
        piece-type SSTONE =
        piece-type NSTONE = OR
        piece-type WSTONE = OR
        piece-type ESTONE = OR
;

...
{pieces
        {piece}         lock    {moves} pass-moves
        {piece}         sstone  {drops} stone-drops
        {piece}         nstone  {drops} stone-drops
        {piece}         wstone  {drops} stone-drops
        {piece}         estone  {drops} stone-drops
        {piece}         wizard  {moves} wizard-moves
        {piece}         dwarf   {moves} dwarf-moves
        {piece}         troll   {moves} troll-moves
pieces}

' sstone                IS SSTONE
' nstone                IS NSTONE
' wstone                IS WSTONE
' estone                IS ESTONE
</source>
</spoiler>
Помните, в прошлой <a href="http://habrahabr.ru/post/226235/">статье</a>, я сетовал на то, что не удаётся использовать имена объектов (в данном случае фигур) до их определения? <b>DEFER</b> позволяет справится с этой проблемой. Плохо только то, что этот важный паттерн не описан в документации на Axiom.

Но почему у нас четыре типа камня? Разве нельзя было обойтись одним? Увы, правила Splut! составлены таким образом, что мы не можем обойтись без "индивидуальности" камней. Я покажу позже, для чего это нужно.

Теперь Тролль может двигаться и (опционально) таскать за собой Камень, но похоже мы что-то забыли. Дело в том, что единственный способ естественной убыли фигур в Splut! связан с тем, что Тролли будут кидаться в них камнями! Добавим недостающий функционал, собрав код воедино:

<spoiler title="Ходы Троллей">
<source>
DEFER           CONTINUE-TYPE

: one-step ( 'dir -- )
        check-continue? IF
                EXECUTE verify
                empty? verify
                from
                here
                move
                add-move
        ELSE
                DROP
        ENDIF
;

: step-to-north ( -- ) ['] north one-step ;
: step-to-south ( -- ) ['] south one-step ;
: step-to-east  ( -- ) ['] east  one-step ;
: step-to-west  ( -- ) ['] west  one-step ;

: drag ( 'dir 'opposite -- )
        check-continue? IF
                EXECUTE verify
                is-stone? verify
                piece-type
                SWAP here SWAP
                DUP EXECUTE DROP EXECUTE verify
                empty? verify
                from
                here
                move
                capture-at
                DUP lock-stone
                from create-piece-type-at
                add-move
        ELSE
                DROP DROP
        ENDIF
;

: drag-to-north ( -- ) ['] north ['] south drag ;
: drag-to-south ( -- ) ['] south ['] north drag ;
: drag-to-east  ( -- ) ['] east  ['] west  drag ;
: drag-to-west  ( -- ) ['] west  ['] east  drag ;

: take-stone ( 'dir -- )
        check-continue? IF
                EXECUTE verify
                is-stone? verify
                CONTINUE-TYPE partial-move-type
                from
                here
                move
                add-move
        ELSE
                DROP
        ENDIF
;

: take-to-north ( -- ) ['] north take-stone ;
: take-to-south ( -- ) ['] south take-stone ;
: take-to-east  ( -- ) ['] east  take-stone ;
: take-to-west  ( -- ) ['] west  take-stone ;

: drop-stone ( 'opposite 'dir -- )
        check-edge? check-wizard? OR 
        on-board? AND IF
                check-troll? piece-is-not-present? AND IF
                        player piece-type
                        drop
                        WIZARD = IF
                                drop-team
                        ELSE
                                DROP
                        ENDIF
                        lock-continue
                        current-piece-type lock-stone
                        add-move
                ENDIF
        ENDIF
;

: drop-to-north ( -- ) ['] north ['] south drop-stone ;
: drop-to-south ( -- ) ['] south ['] north drop-stone ;
: drop-to-east  ( -- ) ['] east  ['] west  drop-stone ;
: drop-to-west  ( -- ) ['] west  ['] east  drop-stone ;

{moves troll-moves
	{move} step-to-north {move-type} normal-type
	{move} step-to-south {move-type} normal-type
	{move} step-to-east  {move-type} normal-type
	{move} step-to-west  {move-type} normal-type
	{move} drag-to-north {move-type} normal-type
	{move} drag-to-south {move-type} normal-type
	{move} drag-to-east  {move-type} normal-type
	{move} drag-to-west  {move-type} normal-type
	{move} take-to-north {move-type} normal-type
	{move} take-to-south {move-type} normal-type
	{move} take-to-east  {move-type} normal-type
	{move} take-to-west  {move-type} normal-type
moves}

{moves stone-drops
	{move} drop-to-north {move-type} continue-type
	{move} drop-to-south {move-type} continue-type
	{move} drop-to-east  {move-type} continue-type
	{move} drop-to-west  {move-type} continue-type
moves}

' continue-type         IS CONTINUE-TYPE
</source>
</spoiler>
Я не буду описывать вспомогательные функции. Их реализацию можно посмотреть <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/splut/Splut.4th">здесь</a>. Остановлюсь лишь на бросках. Тролль может взять камень ходом <b>take-stone</b> (реализация этой функции тривиальна), после чего команда <b>partial-move-type</b> включает продолжение хода, с заданным типом (<b>continue-type</b>). Под этим типом зарегистрирован единственный тип хода - бросок (<b>drop</b>)  Камня на доску.

Бросать можно не абы как, а в строго определённые места! По правилам, камень летит от Тролля по прямой (вертикали или горизонтали), пролетая над головой Гномов, до препятствия (Мага, края доски или другого Тролля). Мага пришибает сразу, в других случаях, падает на доску. Если в этом месте оказался Гном - ему просто не повезло. Это сложное в реализации правило и будет удобнее воплотить его в жизнь, начав с другого конца. Будем искать поля, граничащие с препятствием и двигаться от них, в противоположном направлении, по пустым клеткам или клеткам занятыми Гномами. Если по дороге встретим своего Тролля, значит в то место, с которого мы начали движение, можно бросать камень.

Кроме того, в коде реализованы сопутствующие правила. Например то, что при убийстве Мага, с поля удаляется вся его команда, а также то, что после броска камня, ход сразу же переходит к другому игроку. Я не буду останавливаться на этом подробно.

Головоломкой несколько иного рода является специальный ход Гнома. Гном, своим ходом, может подвинуть любое количество фигур (в том числе Камней), расположенных перед ним в ряд. Для того чтобы хранить все эти фигуры, нам явно понадобится стек. Для всего остального можно использовать переменные:

<spoiler title="Ход Гнома">
<source>
VARIABLE        forward
VARIABLE        backward
VARIABLE        step-count
VARIABLE        here-pos

: push-step ( 'opposite 'dir -- )
        check-continue? IF
                0 step-count ! forward ! backward !
                forward @ EXECUTE verify not-empty? verify
                step-count ++
                player piece-type
                here here-pos !
                BEGIN
                        forward @ EXECUTE IF
                                empty? IF
                                        TRUE
                                ELSE
                                        step-count ++
                                        player piece-type
                                        FALSE
                                ENDIF
                        ELSE
                                BEGIN
                                        step-count @ 0> IF
                                                step-count --
                                                DROP DROP
                                                FALSE
                                        ELSE
                                                TRUE
                                        ENDIF
                                UNTIL
                                TRUE
                        ENDIF
                UNTIL
                step-count @ 0> verify
                from here-pos @ move
                BEGIN
                        step-count @ 0> IF
                                step-count --
                                DUP is-stone-type? IF
                                        DUP lock-stone
                                ENDIF
                                create-player-piece-type
                                backward @ EXECUTE DROP
                                FALSE
                        ELSE
                                TRUE
                        ENDIF		
                UNTIL
                add-move
        ELSE
                DROP DROP
        ENDIF
;
</source>
</spoiler>
Да, разобраться в этом сложнее, чем в предыдущем коде, но суть выполняемого действия проста. Мы двигаемся в одном направлении, складывая фигуры в стек, до пустой клетки, а потом возвращаемся, воссоздавая их на доске, сдвинутыми на один шаг (поскольку на одной клетке не может находиться более одной фигуры, об удалении фигур можно не заботиться - ZoG удалит их самостоятельно). Попробуйте понять, как работает этот код, это неплохая "гимнастика для ума".

Конечно, Маги не были бы Магами, если бы не доставили нам максимум неприятностей. Маги могут левитировать камни. Любые, но ... при определенных условиях. Например нельзя левитировать камень, который перемещался (любым образом) на предыдущем ходу. Здесь сразу возникает вопрос: что считать предыдущим ходом? К сожалению, правила не расшифровывают этот момент. В своём коде я реализовал очистку признаков перемещения камней (именно здесь нужна индивидуальность, у каждого камня свой флаг) сразу перед передачей хода первому игроку. Конечно, это даёт ему серьезное преимущество (он может двигать любые Камни, а следующие игроки только те, которые не двигал он), но другие возможные реализации этого правила также не безупречны.

<spoiler title="Левитируем Камни">
<source>
: fly-stone ( 'dir -- )
        check-continue? IF
                DUP EXECUTE empty? AND IF
                        a5 to
                        BEGIN
                                is-stone? not-locked? AND IF
                                        here here-pos !
                                        DUP piece-type SWAP
                                        EXECUTE SWAP
                                        can-fly? AND IF
                                                from to
                                                DUP EXECUTE DROP
                                                from
                                                here
                                                move
                                                here-pos @ to
                                                DUP piece-type SWAP capture
                                                EXECUTE DROP
                                                DUP lock-stone
                                                DUP begin-fly
                                                create-piece-type
                                                add-move
                                        ENDIF
                                        here-pos @ to
                                ENDIF
                                DUP next NOT
                        UNTIL
                ENDIF
                DROP
        ELSE
                DROP
        ENDIF
;
</source>
</spoiler>
Здесь легко допустить ошибку, посчитав, что мы реализовали всё необходимое. Но реализованы не все возможности! Может ли Маг двигаться на клетку, занятую Камнем, если далее за Камнем расположена пустая клетка? Правила игры говорят, что да, а код считает иначе. На самом деле, Маг может еще и "толкать" Камни перед собой. Это просто разновидность левитации!

<spoiler title="Толкаем Камни перед собой">
<source>
: push-stone ( 'dir -- )
	check-continue? IF
		DUP EXECUTE is-stone? not-locked? AND AND IF
			piece-type can-fly-lock? IF
				here SWAP
				piece-type SWAP
				EXECUTE empty? AND IF
					SWAP from SWAP move
					DUP lock-stone
					DUP begin-fly
					create-piece-type
					add-move
				ELSE
					DROP DROP DROP
				ENDIF
			ELSE
				DROP
			ENDIF
		ENDIF
	ELSE
		DROP
	ENDIF
;
</source>
</spoiler>
Этот код проще, поскольку не приходится искать Камни по всему полю. Если мы хотим встать на поле, занятое Камнем, то единственный Камень, который можно левитировать - это он и есть.

<h4>А и Б сидели на трубе</h4>
Как я уже говорил выше, реализация AI, для игр с участием более двух игроков, связана с некоторыми сложностями. Проблемы начинаются уже при определении условия завершения игры. Например, в разработанной мной недавно реализации игры <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=2273">Yonin Shogi</a> (вариант японских шахмат на 4 человек), было бы заманчиво определить условие поражения следующим образом:

<source lang="lisp">
(loss-condition (South North West East) (checkmated King))
</source>
Эта запись означает, что игра должна вестись до мата Королю любого из игроков. Увы, этот подход не работает! Я уже <a href="http://habrahabr.ru/post/221779/">писал</a> о том, что команда <b>checkmated</b>, несёт в себе слишком много "магии". В частности, она определяет, что Король всегда должен уходить из под шаха (и никогда не вставать под шах). В целом, это работает ... до тех пор пока в игре участвуют два игрока. Видео иллюстрирует проблему:

<video>http://www.youtube.com/watch?v=OR74gUlfQNY</video>

Как можно заметить, <b>checkmated</b> работает нормально лишь для одного из 4 игроков. Для остальных игроков, защита от шаха не считается обязательным ходом! Разумеется, на следующем ходу, такого короля <b>возможно</b> съедят, но этот факт лишь усугубляет ситуацию. Как ни крути, нормального мата в такой игре поставить не удастся.

В Splut! ситуация еще хуже. Игра должна вестись до тех пор, пока на доске не останется лишь одна команда. Но ZoG не позволяет изменять список очередности ходов во время игры! Это означает, что каждая выбывшая команда должна делать свой ход, когда до нее дойдет очередь (разумеется она будет пасовать, поскольку никакой другой возможности сделать ход нет). Кроме того, в Splut! каждая команда делает несколько ходов подряд (1-2 в начале игры и 3 в середине партии). В общем, для меня не стало сюрпризом то, что штатный AI Axiom не справился с этой игрой.

Он конечно работает, программа делает ходы (довольно глупые на мой взгляд), но, после выбывания одного из игроков начинаются проблемы. При расчёте каждого пропуска хода, программа начинает "думать" всё дольше и дольше, не укладываясь ни в какие из заданных временных рамок. Доопределение своей оценочной функции (<b>OnEvaluate</b>) никак не исправляет положение. В общем, я посчитал это достаточным поводом для того, чтобы попытаться реализовать собственный алгоритм AI, благо в Axiom такая возможность имеется (забегая вперёд, скажу, что получилось не очень здорово, но попробовать то стоило).

За основу я взял следующий, известный многим, алгоритм из книги Евгения Корнилова "Программирование Шахмат и других логических игр":

<spoiler title="Alpha-Beta отсечение с амортизацией отказов">
<source lang="cpp">
int AlphaBeta(int color, int Depth, int alpha, int beta)
{
    if (Depth == 0) return Evaluate(color);
    int score = -INFINITY;
    PMove move = GenerateAllMoves(color);

    while (move)
    {
        MakeMove(move);
        int tmp = -AlphaBeta(color==WHITE?BLACK:WHITE, Depth - 1, -beta, -alpha);
        UnMakeMove(move);
        if (tmp > score) score = tmp;
        if (score > alpha) alpha = score;
        if (alpha >= beta) return alpha;
        move = move -> next;
    }
    return score;
}
</source>
</spoiler>
Как легко заметить, в исходном виде, этот алгоритм нам совершенно не подходит. У нас больше двух игроков, да и с чередованием ходов все гораздо сложнее. Но этот алгоритм - хорошая отправная точка для разработки собственной версии.

Подумав немного, можно понять, что в самом худшем случае, три игрока, противостоящие тому, для которого мы рассчитываем ход, объединят свои усилия. Иными словами, для нас это <b>один</b> враждебный игрок (если они не объединятся - тем хуже для них). Другим важным моментом является вычисление оценочной функции. При расчете хода, оценочная функция должна всегда вычисляться "с точки зрения" одного и того-же игрока (того, для которого рассчитывается ход). Для враждебных игроков, оценка должна браться с обратным знаком (чем нам лучше - тем им хуже). Приняв во внимание эти соображения, можно переписать алгоритм следующим образом:

<spoiler title="Обобщенное Alpha-Beta отсечение">
<source>
VARIABLE        Depth

MaxDepth []     CurrMove[]
MaxDepth []     CurrTurn[]
MaxDepth []     CurrScore[]

: Score ( alpha beta turn -- score )
        Depth -- Depth @
        0< IF
                EvalCount ++
                SWAP DROP SWAP DROP
                Eval
                SWAP turn-offset-to-player
                current-player <> IF
	                NEGATE
                ENDIF
        ELSE
                DUP turn-offset-to-player FALSE 0 $GenerateMoves 
                Depth @ CurrTurn[] !
                $FirstMove Depth @ CurrMove[] !
                -10000 Depth @ CurrScore[] !
                BEGIN
                        $CloneBoard
                        Depth @ CurrMove[] @
                        .moveCFA EXECUTE
                        2DUP
                        Depth @ CurrTurn[] @ next-turn-offset
                        RECURSE
                        $DeallocateBoard
                        $Yield
                        DUP Depth @ CurrScore[] @ > IF
                                Depth @ CurrScore[] !
                        ELSE
                                DROP
                        ENDIF
                        Depth @ CurrTurn[] @ turn-offset-to-player
                        current-player <> IF
                                NEGATE SWAP NEGATE
                        ENDIF
                        OVER Depth @ CurrScore[] @ < IF
                                SWAP DROP
                                Depth @ CurrScore[] @
                                SWAP
                        ENDIF
                        2DUP >= IF
                                OVER Depth @ CurrScore[] !
                                TRUE
                        ELSE
                                Depth @ CurrTurn[] @ turn-offset-to-player
                                current-player <> IF
                                        NEGATE SWAP NEGATE
                                ENDIF
                                Depth @ CurrMove[] @
                                $NextMove
                                DUP Depth @ CurrMove[] !
                                NOT
                        ENDIF
                UNTIL
                $DeallocateMoves
                DROP DROP
                Depth @ CurrScore[] @
                Depth @ CurrTurn[] @ turn-offset-to-player
                current-player <> IF
                        NEGATE
                ENDIF
        ENDIF
        Depth ++
;
</source>
</spoiler>
Здесь очень много "магии" Форта и Аксиомы, связанной с генерацией ходов и позиций, но, при некотором напряжении, исходный алгоритм вполне просматривается. Для разгрузки стека пришлось эмулировать несколько стеков с переменными, используемыми в рекурсивных вызовах. На самом стеке, в процессе вычисления, лежат всего два значения <b>alpha</b> и <b>beta</b>. В рекурсивные вызовы (<b>RECURSE</b>) они всегда передаются в одном и том же порядке, но если расчет выполняется для враждебного игрока, мы меняем их знак, после чего, меняем эти значения местами. Также мы изменяем знак оценки, полученной при оценке позиции враждебным игроком.

Вызывается эта функция из уже знакомой нам, по прошлой статье, реализации Custom Engine:

<spoiler title="Custom Engine">
<source>
3  CONSTANT	MaxDepth

VARIABLE        BestScore
VARIABLE        Nodes

: Custom-Engine ( -- )
        -10000 BestScore !
        0 Nodes !
        $FirstMove
        BEGIN
                $CloneBoard
                DUP $MoveString 
                CurrentMove!
                DUP .moveCFA EXECUTE
                MaxDepth Depth !
                0 EvalCount !
                BestScore @ 10000 turn-offset next-turn-offset Score
                0 5 $RAND-WITHIN +
                BestScore @ OVER <
                IF
                        DUP BestScore !
                        Score!
                        0 Depth!
                        DUP $MoveString BestMove!
                ELSE
                        DROP
                ENDIF
                $DeallocateBoard
                Nodes ++
                Nodes @ Nodes!
                $Yield
                $NextMove
                DUP NOT
        UNTIL
        DROP
;
</source>
</spoiler>
Можно заметить, что в этом коде мы прибавляем к значению оценки случайное число от 1 до 5. Это делается для того, чтобы программа не ходила всегда одинаково в тех случаях, когда оценки ходов различаются незначительно.

Как обычно, главная сложность заключается в построении оценочной функции. Я не буду загружать статью листингом текущего ее варианта (желающие всегда могут посмотреть код на <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/splut/Engine.4th">GitHub</a>), скажу только, что в ней, в настоящее время, учитываются следующие моменты:

<ul>
	<li>Количество вражеских Магов (наша основная цель - уменьшение этого значения)</li>
	<li>Количество дружественных Магов (если эта величина изменится с 1 на 0, игра для нас закончится)</li>
	<li>Количество вражеских Гномов (всегда приятно связать противнику руки)</li>
	<li>Количество дружественных Гномов (не то чтобы мы без него не обошлись, но своя фигура все-таки)</li>
	<li>Штраф за нахождение дружественного Мага на одной линии с Камнем (это действительно опасно)</li>
	<li>Бонусы за нахождение вражеских Магов на одних линиях с Камнями (по той же причине)</li>
	<li>Суммарное количество шагов от Троллей до Камней (стараемся уменьшить для своих и увеличить для чужих)</li>
</ul>
Это конечно не идеальный вариант. Весовые значения стоит подобрать более оптимально, да и сам факт, к примеру, нахождения Мага на одной линии с Камнем, сам по себе, ни о чем не говорит. Линия броска может быть перекрыта, например Троллем, да и до камня надо еще добраться, чтобы его кинуть. Так или иначе, мы написали код и можем посмотреть, как он работает:

<video>https://www.youtube.com/watch?v=QSAjpj-j6KQ</video>

Как и ожидалось, AI не блещет интеллектом (и работает жутко медленно), но хотя бы пытается "сойти за умного". По крайней мере, в это уже можно играть. 

<h4>Подсчитали - прослезились</h4>
Конечно, чтобы оценить качество AI, можно сыграть с ним много раз и построить "экспертную оценку", но это не наш метод. В комплекте с Axiom поставляется замечательная утилита AutoPlay, позволяющая автоматизировать этот процесс. К сожалению, она пока не умеет работать с играми, рассчитанными более чем на 2 игроков, но это не проблема. Специально для неё, создадим конфигурацию с двумя игроками (камней оставим 4 штуки):

<spoiler title="Duel">
<source>
LOAD Splut.4th ( Load the base Splut game )

{players
	{player}	South	 {search-engine} Custom-Engine
	{neutral}	West
	{player}	North	 {search-engine} Custom-Engine
	{neutral}	East
	{player}	?Cleaner {random}
players}

{turn-order
	{turn}	South
	{turn}	North
	{turn}	North
	{repeat}
	{turn}  ?Cleaner {of-type} clear-type
	{turn}	South
	{turn}	South
	{turn}	South
	{turn}	North
	{turn}	North
	{turn}	North
turn-order}

{board-setup
	{setup}	South sstone e1
	{setup}	South wizard d2
	{setup}	South dwarf  e2
	{setup}	South troll  f2
	{setup}	South lock   f1

	{setup}	West  wstone a5

	{setup}	North nstone e9
	{setup}	North wizard f8
	{setup}	North dwarf  e8
	{setup}	North troll  d8
	{setup}	North lock   h1

	{setup}	East  estone i5
board-setup}
</source>
</spoiler>
Также, нам понадобится конфигурация, в которой игроки делают случайные ходы:

<spoiler title="Random">
<source>
LOAD Splut.4th ( Load the base Splut game )

{players
	{player}	South	 {random}
	{neutral}	West
	{player}	North	 {random}
	{neutral}	East
	{player}	?Cleaner {random}
players}

{turn-order
	{turn}	South
	{turn}	North
	{turn}	North
	{repeat}
	{turn}  ?Cleaner {of-type} clear-type
	{turn}	South
	{turn}	South
	{turn}	South
	{turn}	North
	{turn}	North
	{turn}	North
turn-order}

{board-setup
	{setup}	South sstone e1
	{setup}	South wizard d2
	{setup}	South dwarf  e2
	{setup}	South troll  f2
	{setup}	South lock   f1

	{setup}	West  wstone a5

	{setup}	North nstone e9
	{setup}	North wizard f8
	{setup}	North dwarf  e8
	{setup}	North troll  d8
	{setup}	North lock   h1

	{setup}	East  estone i5
board-setup}
</source>
</spoiler>
Результаты получились, на удивление, неплохими (хотя для расчета 100 партий потребовалась целая ночь):

<source>
Final results:
Player 1 "Random", wins = 13.
Player 2 "Duel", wins = 87.
Draws = 0
100 game(s) played
</source>
Почему программа работает так долго? Посмотрим, сколько раз, при вычислении хода, вызывается оценочная функция (данные расчета на 5 ходов в глубину):

<img src="https://habrastorage.org/getpro/habr/post_images/b9e/0be/896/b9e0be896f8d868ca25062ec5e940a71.jpg"/>

Да, 8000 вызовов оценочной функции это безусловно много, но почему здесь три ряда? Попробую объяснить. Вот как мы считаем количество вызовов Eval:

<spoiler title="Сбор статистики">
<source>
$gameLog        ON

VARIABLE        EvalCount

: Score ( alpha beta turn -- score )
        Depth -- Depth @
        0< IF
                EvalCount ++
                ...
	ELSE
...
;

: Custom-Engine ( -- )
        ...
	BEGIN
                ...
                0 EvalCount !
		BestScore @ 10000 turn-offset next-turn-offset Score
		0 5 $RAND-WITHIN +
		EvalCount @ . CR
                ...
        UNTIL
        DROP
        CR
;
</source>
</spoiler>
На выходе, получается следующая последовательность:

<spoiler title="Результат">
992 
655 
147 

3749 
22 
1 
22 
22 
22 
22 
1 
1 

336 
132 
50 

382 
42 
213 
35 
392 
21 
62 
40 
49 

1465 
189 
1 
1 
1 
1 
1 
1 
1 
52 
91 

122 
75 
50 

1509 
2074 
637 
492 
249 
800 
415 
877 
963 

5608 
90 
4 
4 
4 
4 
4 
4 
4 
4 
</spoiler>
Каждая группа чисел (отделенная пустой строкой) содержит результаты просмотра всех возможных ходов игрока из текущей позиции. В графике, представленном выше, первый ряд показывает минимальное значение в группе, второй - среднее, третий - максимальное. Разница между максимальным и минимальным значением определяется эффективностью альфа-бета отсечения. Среднее значение - определяет производительность, на которую мы можем рассчитывать, при заданной глубине перебора.

Можно заметить, что числа в группах, в основном, убывают, но иногда случаются нарушающие монотонное убывание "всплески". Попробуем подсчитать их количество:

<img src="https://habrastorage.org/getpro/habr/post_images/ca1/a65/4e2/ca1a654e2fb825c3d36c9a2d51351da1.jpg"/>

Слишком много! В некоторых группах более 16 нарушений монотонного убывания. Если бы было возможно просматривать ходы в более оптимальной последовательности, наверняка удалось бы улучшить показатели производительности (и возможно добиться большей глубины перебора). К сожалению, следующие два пункта мешают мне это сделать:

<ol>
	<li>У меня отсутствуют эвристики, позволяющие произвести предварительную оценку "качества" ходов в игре Splut!</li>
	<li>Даже если бы такие эвристики были, предварительная оценка и сортировка списка ходов в Axiom связана с определенными техническими сложностями (и издержками производительности)</li>
</ol>
Другим методом увеличения глубины перебора мог бы послужить "углубленный" перебор "форсированных" ходов. Также, было бы неплохо отсекать повторяющиеся позиции (с этим мог бы сильно помочь <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist hashing</a>).

Посмотрим, как изменяется количество просматриваемых позиций, при увеличении глубины перебора:

<img src="https://habrastorage.org/getpro/habr/post_images/20e/df3/179/20edf317997bc278310005176143b272.jpg"/>

Поскольку среднее время ожидания завершения ходов всех противников (при глубине просмотра 5 ходов) составляет около 1 минуты, очевидно, что это максимальная глубина перебора, на которую можно рассчитывать, при текущей реализации алгоритма (любое ее увеличение сделает игру человека с программой совершенно не комфортной). 

Но давайте подумаем, что такое 5 ходов в игре <b>Splut</b>? Этого недостаточно даже для того, чтобы рассчитать возможные ходы всех игроков! Даже в режиме Duel. Это все равно что рассчитывать игру в Шахматы всего на 1 ход вперед! Сложно ожидать особого интеллекта от такой программы.

Конечно в Splut! гораздо меньше фигур чем в Шахматах, но и ходы более сложные! Чтобы победить, программа должна уметь строить долгосрочные планы, на много ходов вперед. Пока я не знаю, как этого добиться, используя Axiom, но вероятно как то можно. 
Я работаю над этим.

<spoiler title="P.S.">
Я хочу выразить признательность разработчику Axiom. <b>Greg Schmidt</b> - настоящий энтузиаст компьютерной разработки настольных игр. Он поддерживает код Axiom уже почти 10 лет, постоянно улучшая его и добавляя что то новое. С того момента, как я выложил Axiom-реализацию игры Ур в ZoG, он ведёт со мной оживленную переписку, помогая и объясняя тонкости работы Axiom. Буквально вчера, с его помощью, мне удалось обнаружить и исправить весьма неприятную ошибку в реализации Ур-а. Я очень благодарен ему за поддержку!
</spoiler>
<spoiler title="P.P.S.">
При оформлении статьи, использован фрагмент работы известного российского художника-комиксиста <b>Даниила Кузьмичева</b>.
</spoiler>
</habracut>

Аксиома — повышаем градус!

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/98d/bc3/51e/98dbc351e979ce63c45242c7ddb798fd.jpg"/><i><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Старый серый ослик Иа-Иа стоял один-одинешенек в заросшем чертополохом уголке Леса, широко расставив передние ноги и свесив голову набок, и думал о Серьезных Вещах.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;А. Милн "Винни-Пух и все-все-все"

— Видите ослика? — спрашиваю я милиционера. — Вон там маленький серый ослик… Артикул 2908. Цена тридцать две копейки. У него великое будущее.
— У осликов это бывает, — соглашается милиционер. — У них иногда бывает очень большое будущее.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Генрих Альтов "Ослик и аксиома"
</b></i>

Что самое сложное в разработке настольных игр? Очевидно, не анимация перемещения фигур по доске. Сложно придумать разумные и интересные игровые правила. Бывает очень сложно обеспечить игровой баланс. Если мы занимаемся компьютерной разработкой, зачастую, безумно сложно реализовать качественный AI (для таких игр как Го или Сёги эта проблема не решена до сих пор). И даже если нам удалось реализовать работающий AI, приходится проделать очень большой объем работ, чтобы оценить качество его работы и выбрать из нескольких возможных вариантов наилучший.

Я хочу рассказать об инструменте, способном существенно упростить решение всех этих вопросов. <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a> задумывалась разработчиками как способ улучшения <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. В частности, она ориентирована на реализацию игр, связанных с захватом территории (таких как Го), с которыми AI ZoG справляется очень плохо. Кроме того, Аксиома существенно расширяет возможности ZoG-разработчиков, предоставляя массу возможностей, практически не реализуемых в рамках традиционного ZRF (языка описания правил). При всём этом, Аксиома может работать совершенно самостоятельно, даже если ZoG на компьютер никогда не устанавливался и не покупался. Но, обо всём по порядку...
<habracut>
<h4>По образу и подобию</h4>
Я уже <a href="http://habrahabr.ru/post/221779/">писал</a> о том, что у ZoG имеется множество недостатков. К счастью, разработчики предоставили механизм, позволяющий справиться с частью из них. Модуль расширения (engine) представляет собой динамически загружаемую библиотеку (DLL), берущую под своё управление все аспекты игры, кроме её визуализации. Вот <a href="http://www.zillions-of-games.com/progsample.html">здесь</a> можно посмотреть пример такого расширения.

Самостоятельная разработка собственного расширения может оказаться весьма трудоёмкой. Придётся разрабатывать AI (скорее всего на C++), поскольку, при подключении engine, штатный AI ZoG отключается. Axiom представляет собой <b>программируемый</b> engine, реализующий такие сложные для разработчика вещи, как алгоритмы AI и предоставляющий возможность сосредоточиться на игровой логике. 

Попробуем реализовать "Королевскую игру Ур". Для работы необходим минимальный ZRF-файл:

<spoiler title="Подключение engine">
<source lang="lisp">
(version "2.0")

(game
   (title "Ur")

   (engine "../Axiom/Ur/axiom.dll")

   (option "animate captures" false)
   (option "animate drops" false)
   (option "show moves list" false)
   (option "pass turn" forced)
   (option "highlight goals" false)
   (option "prevent flipping" true)
   (option "recycle captures" true)

   (drop-sound "Audio/Dice_cup.wav")
   (move-sound "Audio/Clack.wav")
   (capture-sound "")

   (players Black White ?Dice)

   (turn-order White ?Dice ?Dice ?Dice ?Dice Black ?Dice ?Dice ?Dice ?Dice)

   (board 
      (image "Images\Ur\board.bmp")
      (grid
         (start-rectangle -503 -13 -442 79)
         (dimensions
             ("a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q" (67 0)) ; files
             ("5/4/3/2/1" (0 66)) ; ranks
         )    
      )
   )

   (board-setup
          (?Dice (wdice q4) (bdice q3 q2) (lock q1) )
          (Black (init i5 j5 k5 l5 m5 n5 o5) )
          (White (init i1 j1 k1 l1 m1 n1 o1) )
   )

   (piece
	  (name lock)
          (image ?Dice "Images\Ur\invisible.bmp"
                 Black "Images\Ur\invisible.bmp"
                 White "Images\Ur\invisible.bmp")
   )
   (piece
	  (name  init)
          (image Black "Images\Ur\binit.bmp"
                 White "Images\Ur\winit.bmp")
   )
   (piece
	  (name  prom)
          (image Black "Images\Ur\bprom.bmp"
                 White "Images\Ur\wprom.bmp")
   )
   (piece
	  (name wdice)
          (image ?Dice "Images\Ur\wdice.bmp")
   )
   (piece
	  (name bdice)
          (image ?Dice "Images\Ur\bdice.bmp")
   )

   ; The following dummy piece is required in order to placate the Zillions engine.
   ; It appears as though Zillions must find at least one "moves" keyword somewhere
   ; in the zrf in order for it to be happy and thus allow "moves" to work correctly.
   (piece (name Dummy) (dummy) (moves (from)))
)
</source>
</spoiler>
Здесь осталось описание игроков, последовательности ходов, фигур, но нет описания правил, по которым ходят фигуры. Также отсутствуют определения направлений на доске, игровых зон, условий завершения игры и всего прочего, связанного с игровыми правилами. Всё это будет содержаться в скриптах Аксиомы. Грустным моментом является то, что интерфейс взаимодействия ZoG с engine не предусматривает передачи информации, содержащейся в ZRF-файле. Это означает, что все эти описания придётся продублировать в скриптах Axiom.

К счастью, в составе Axiom Development Kit поставляется утилита, позволяющая автоматизировать этот процесс. ZRF Converter довольно капризен в работе. Если ему что-то не понравилось в ZRF-файле (например описание доски вынесенное в макрос), процесс конвертации прерывается с загадочной диагностикой, заставляющей поломать голову. Если всё прошло нормально, на выходе мы получаем следующее описание:

<spoiler title="Ur.4th">
<source>
{board
	{position}	a5
	{position}	b5
	{position}	c5
	{position}	d5
	{position}	e5
	{position}	f5
	{position}	g5
	{position}	h5
	{position}	i5
	{position}	j5
	{position}	k5
	{position}	l5
	{position}	m5
	{position}	n5
	{position}	o5
	{position}	p5
	{position}	q5
	{position}	a4
	{position}	b4
	{position}	c4
	{position}	d4
	{position}	e4
	{position}	f4
	{position}	g4
	{position}	h4
	{position}	i4
	{position}	j4
	{position}	k4
	{position}	l4
	{position}	m4
	{position}	n4
	{position}	o4
	{position}	p4
	{position}	q4
	{position}	a3
	{position}	b3
	{position}	c3
	{position}	d3
	{position}	e3
	{position}	f3
	{position}	g3
	{position}	h3
	{position}	i3
	{position}	j3
	{position}	k3
	{position}	l3
	{position}	m3
	{position}	n3
	{position}	o3
	{position}	p3
	{position}	q3
	{position}	a2
	{position}	b2
	{position}	c2
	{position}	d2
	{position}	e2
	{position}	f2
	{position}	g2
	{position}	h2
	{position}	i2
	{position}	j2
	{position}	k2
	{position}	l2
	{position}	m2
	{position}	n2
	{position}	o2
	{position}	p2
	{position}	q2
	{position}	a1
	{position}	b1
	{position}	c1
	{position}	d1
	{position}	e1
	{position}	f1
	{position}	g1
	{position}	h1
	{position}	i1
	{position}	j1
	{position}	k1
	{position}	l1
	{position}	m1
	{position}	n1
	{position}	o1
	{position}	p1
	{position}	q1
board}

{players
	{player}	Black
	{player}	White
	{player}	?Dice	{random}
players}

{pieces
	{piece}		lock
	{piece}		init
	{piece}		prom
	{piece}		wdice
	{piece}		bdice
	{piece}		Dummy
pieces}

{turn-order
	{repeat}
	{turn}	White
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
	{turn}	Black
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
turn-order}

{board-setup
	{setup}	?Dice wdice q4
	{setup}	?Dice bdice q3
	{setup}	?Dice bdice q2
	{setup}	?Dice lock q1

	{setup}	Black init i5
	{setup}	Black init j5
	{setup}	Black init k5
	{setup}	Black init l5
	{setup}	Black init m5
	{setup}	Black init n5
	{setup}	Black init o5

	{setup}	White init i1
	{setup}	White init j1
	{setup}	White init k1
	{setup}	White init l1
	{setup}	White init m1
	{setup}	White init n1
	{setup}	White init o1
board-setup}
</source>
</spoiler>
Здесь нас поджидают первые сюрпризы. Axiom позволяет описывать доску более компактно, но с серьёзными ограничениями. Конструкция <b>grid</b> позволяет описывать только прямоугольные доски со "стандартным" именованием ячеек (кроме того, в описании доски может использоваться только один <b>grid</b>). В случае необходимости описания досок более сложной формы (например трёхмерных), придётся явно описывать каждую позицию так, как это сделал ZRF Converter. Поскольку, в нашем случае, все ограничения соблюдаются (мне пришлось переименовать столбцы и строки доски, по сравнению с ZRF-реализацией), используем более компактную запись:

<source>
{board
	5 17 		{grid}
board}
</source>
Далее, необходимо определить направления, по которым смогут двигаться фигуры. В таких играх как Шахматы или Шашки, мы могли бы использовать компактную запись, определяющую направления в терминах приращения координат:

<source>
{directions 
  -1  0 {direction}  North 
   1  0 {direction}  South 
   0  1 {direction}  East 
   0 -1 {direction}  West 
  -1  1 {direction}  Northeast 
   1  1 {direction}  Southeast 
  -1 -1 {direction}  Northwest 
   1 -1 {direction}  Southwest 
directions}
</source>
Увы, в нашем случае, этот способ не подходит. Поскольку траектория движения фишек по доске, в игре Ур, довольно причудлива, придётся явно определять связи между позициями:

<spoiler title="Направления">
<source>
{directions
	( Anext )
	{link}		Anext i1 l2
	{link}		Anext j1 l2
	{link}		Anext k1 l2
	{link}		Anext l1 l2
	{link}		Anext m1 l2
	{link}		Anext n1 l2
	{link}		Anext o1 l2
	{link}		Anext l2 k2
	{link}		Anext k2 j2
	{link}		Anext j2 i2
	{link}		Anext i2 i3
	{link}		Anext i3 j3
	{link}		Anext j3 k3
	{link}		Anext k3 l3
	{link}		Anext l3 m3
	{link}		Anext m3 n3
	{link}		Anext n3 o3
	{link}		Anext o3 o2
	{link}		Anext o2 p2
	{link}		Anext p2 p3
	{link}		Anext p3 p4
	{link}		Anext p4 o4
	{link}		Anext o4 o3

	( Bnext )
	{link}		Bnext i5 l4
	{link}		Bnext j5 l4
	{link}		Bnext k5 l4
	{link}		Bnext l5 l4
	{link}		Bnext m5 l4
	{link}		Bnext n5 l4
	{link}		Bnext o5 l4
	{link}		Bnext l4 k4
	{link}		Bnext k4 j4
	{link}		Bnext j4 i4
	{link}		Bnext i4 i3
	{link}		Bnext i3 j3
	{link}		Bnext j3 k3
	{link}		Bnext k3 l3
	{link}		Bnext l3 m3
	{link}		Bnext m3 n3
	{link}		Bnext n3 o3
	{link}		Bnext o3 o4
	{link}		Bnext o4 p4
	{link}		Bnext p4 p3
	{link}		Bnext p3 p2
	{link}		Bnext p2 o2
	{link}		Bnext o2 o3

	( Cnext )
	{link}		Cnext p3 p4
	{link}		Cnext p4 o4
	{link}		Cnext o4 o3
	{link}		Cnext o3 n3
	{link}		Cnext n3 m3
	{link}		Cnext m3 l3
	{link}		Cnext l3 k3
	{link}		Cnext k3 j3
	{link}		Cnext j3 i3
	{link}		Cnext i3 h3

	( Dnext )
	{link}		Dnext p3 p2
	{link}		Dnext p2 o2
	{link}		Dnext o2 o3
	{link}		Dnext o3 n3
	{link}		Dnext n3 m3
	{link}		Dnext m3 l3
	{link}		Dnext l3 k3
	{link}		Dnext k3 j3
	{link}		Dnext j3 i3
	{link}		Dnext i3 h3
directions}
</source>
</spoiler>
Чёрные и белые фишки движутся различными путями, поэтому пришлось определить направление <b>Anext</b> для белых и <b>Bnext</b> для чёрных фигур. Кроме того, для фишек, прошедших через поле превращения, необходимо доопределить направления <b>Cnext</b> и <b>Dnext</b>. Если этого не сделать, на поле <b>o3</b> образуется развилка и все фишки будут крутиться по кругу в малом блоке, выбирая первый из доступных маршрутов.

<source>
{symmetries 
	Black		{symmetry} Anext Bnext
	Black		{symmetry} Cnext Dnext
symmetries}
</source>
Эта конструкция позволяет определить "симметрию". Хорошей иллюстрацией может служить движение пешек в Шахматах. Пешки всегда двигаются "вперёд", но для белых это движение вверх по доске, а для чёрных - в противоположном направлении. Существуют и более сложные формы симметрии. Например в четырёхсторонних вариантах Шахмат, движение "вперёд", в зависимости от цвета, может происходить в направлении любой из четырёх "сторон света". Определив "симметрию", мы cможем всегда использовать одно и тоже направление (например <b>Anext</b>), не обращая внимания на цвет фигуры. Для чёрных, оно будет автоматически преобразовано в симметричное (<b>Bnext</b>).

<h4>Фортификация</h4>
Моё знакомство с <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Фортом</a> было ранним, но очень долгое время оставалось весьма шапочным. Впервые я увидел Форт во времена БК-шек и Микрош. У моего друга был <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80-06%D0%A6">Вектор 06Ц</a>, оттащить от которого нас удавалось только за уши, совместными усилиями всех родителей. К Вектору, периодически, докупались кассеты с играми, а на них, время от времени, обнаруживалась "неучтенка". Среди такой неучтенки, мы и нашли реализацию Форта. Вволю наигравшись со стеком, мы с другом сказали "ага", и установили основание системы счисления в ноль (есть в Форте такая забавная возможность). Форт естественно не смог этого перенести и мы про него, на некоторое время, забыли.

Впоследствии, уже в институте, Форт неоднократно всплывал на поверхность моего внимания, но заняться им серьезно никак не удавалось. В самом деле, мне так и не довелось столкнуться ни с программированием микроконтроллеров ни с каким либо другим полезным применением Форта. И вот теперь, благодаря разработчикам Axiom, у меня такая возможность появилась! Дело в том, что слово Forth фигурирует в их ForthScript не просто так. На самом деле, и сама Axiom-а и часть ForthScript-а реализованы на Форте, а в <b>axiom.dll</b> имеется интерпретатор, позволяющий их использовать. При необходимости, в <b>axiom.4th</b> и <b>CORE.4TH</b> можно посмотреть детали реализации, а возможно и что-то подправить.

Итак, программировать всю игровую логику придётся на Форте. Но с чего начать разработку? Для начала, было бы неплохо добиться простого движения фигур по доске. Каждая фигура должна иметь возможность двигаться на 1, 2, 3 или 4 клетки по своей траектории движения (пока не будем отвлекаться на выбрасывание случайных очков на "костях"):

<spoiler title="Движение фигур">
<source>
: common-move ( 'dir n -- )
	SWAP
	BEGIN
		DUP EXECUTE verify SWAP
		1-  DUP
		0=  IF
			DROP
			TRUE
		ELSE
			SWAP
			FALSE
		ENDIF
	UNTIL
	empty? IF
		from
		here
		move
		add-move
	ENDIF
;

: i-move-1 ( -- ) ['] Anext 1 common-move ;
: i-move-2 ( -- ) ['] Anext 2 common-move ;
: i-move-3 ( -- ) ['] Anext 3 common-move ;
: i-move-4 ( -- ) ['] Anext 4 common-move ;
: p-move-1 ( -- ) ['] Cnext 1 common-move ;
: p-move-2 ( -- ) ['] Cnext 2 common-move ;
: p-move-3 ( -- ) ['] Cnext 3 common-move ;
: p-move-4 ( -- ) ['] Cnext 4 common-move ;

{moves i-moves
	{move} i-move-1
	{move} i-move-2
	{move} i-move-3
	{move} i-move-4
moves}

{moves p-moves
	{move} p-move-1
	{move} p-move-2
	{move} p-move-3
	{move} p-move-4
moves}

{pieces
	{piece}		init	{moves} i-moves
	{piece}		prom	{moves} p-moves
pieces}
</source>
</spoiler>
Запустив ZRF-ку на выполнение, можно убедиться, что теперь фигуры можно двигать. Как всё это работает? Посмотрим на реализацию <b>common-move</b>. Комментарий (в стиле Форта), расположенный сразу после имени, показывает, что она принимает на стеке два параметра - скомпилированную команду перехода по направлению и количество шагов перемещения. Сама реализация состоит из двух частей. Сначала, в цикле, заданное количество раз, выполняется переход по направлению, затем, после проверки того, что целевое поле пусто, выполняется последовательность команд Axiom, формирующих ход (перемещение фишки). Самое главное, во время всей этой эквилибристики - не разрушить стек!

Описание каждой из выполняемых команд можно посмотреть в руководствах по ForthScript и Axiom, поставляемых в комплекте с Axiom Development Kit, я же хочу обратить ваше внимание на пару важных отличий этого кода от того, что можно было бы написать используя ZRF:

<ul>
	<li>В Axiom команда перехода по направлению (в скрипте выше она выполняется при помощи <b>EXECUTE</b>) формирует булевский код, используя который можно проверить успешность перехода (если направление в заданной клетке не определено, переход не производится и на стек кладётся <b>FALSE</b>)</li>
	<li>Команда завершения формирования хода <b>add-move</b> отделена от команды перемещения фигуры <b>move</b> (я уже писал, в одной из своих <a href="http://habrahabr.ru/post/221779/">статей</a>, почему это так важно)!</li>
</ul>
Поигравшись с этой версией некоторое время, можно заметить, что фишки, дойдя до малого блока, начинают ходить по кругу. Для того, чтобы фишка могла вырваться из этого "круга сансары", её необходимо перевернуть (для перевёрнутых фишек заданы направления <b>Cnext</b> и <b>Dnext</b>, ведущие к финишу). Напомню, что переворачивание фишек, в игре Ур, хитрое. Фишка переворачивается не встав на поле превращения, а проходя через него. Кроме того, поскольку теперь фишки смогут проходить весь путь до конца, не забудем об удалении с доски фишек, дошедших до финиша:

<spoiler title="Переворачивание фишек">
<source>
VARIABLE	isPromouted

: common-move ( 'dir n -- )
	FALSE isPromouted !
	SWAP
	BEGIN
		current-player White
		= IF
			here p2
		ELSE
			here p4
		ENDIF
		= IF TRUE isPromouted ! ENDIF
		DUP EXECUTE verify SWAP
		1-  DUP
		0=  IF
			DROP
			TRUE
		ELSE
			SWAP
			FALSE
		ENDIF
	UNTIL
	empty? IF
		from
		here
		move
		here h3 = IF
			capture
		ENDIF
		isPromouted @ IF
			current-piece-type 1+ change-type
		ENDIF
		add-move
	ENDIF
;
</source>
</spoiler>
Здесь стоит сказать пару слов о переменных в Форте. Мы определяем переменную <b>isPromouted</b>, используя ключевое слово <b>VARIABLE</b>. После того как переменная определена, любое её упоминание в коде кладёт на стек <b>адрес</b> этой переменной. Для извлечения значения, расположенного по заданному адресу, используется команда <b>@</b>, команда <b>!</b> перезаписывает значение переменной.

Некоторую сложность, в Axiom, представляют манипуляции с типами фигур. Дело в том, что определения фигур расположены <b>после</b> кода, управляющего их перемещением (поскольку они его используют). По этой причине, мы не можем использовать имена типов фигур в коде (так как в этом месте они ещё не определены). Как правило, из этой неприятной ситуации можно выкрутиться. Например, в нашем коде, для переворачивания фишки, мы просто инкрементируем тип фигуры, выполняющей ход.

Важной частью игрового процесса является возможность пропуска хода игроками. Игрок обязан выполнить ход, если есть такая возможность и пропустить ход, в противном случае. Если не позаботиться об этом специально, игра будет автоматически завершена вничью при первой же невозможности хода любым из игроков. Также, пропуском хода противника, логично реализовать повторный ход игрока после хода на "розетку". Сделаем это:

<spoiler title="Пропуск хода">
<source>
: is-rosette? ( -- ? )
	here i2 =
	here i4 = OR
	here l3 = OR
	here o2 = OR
	here o4 = OR
;

: common-move ( 'dir n -- )
	q5 enemy-at? NOT IF
		FALSE isPromouted !
		SWAP
		BEGIN
			current-player White
			= IF
				here p2
			ELSE
				here p4
			ENDIF
			= IF TRUE isPromouted ! ENDIF
			DUP EXECUTE verify SWAP
			1-  DUP
			0=  IF
				DROP
				TRUE
			ELSE
				SWAP
				FALSE
			ENDIF
		UNTIL
		empty? IF
			from
			here
			move
			here h3 = IF
				capture
			ENDIF
			isPromouted @ IF
				current-piece-type 1+ change-type
			ENDIF
			is-rosette? IF
				q1 piece-type-at q5 create-piece-type-at
			ELSE  
				q5 capture-at
			ENDIF
			add-move
		ENDIF
	ENDIF
;

: pass-move ( -- )
	q5 capture-at
	Pass
	add-move
;

{moves i-moves
	{move} i-move-1  {move-type} normal-type
	{move} i-move-2  {move-type} normal-type
	{move} i-move-3  {move-type} normal-type
	{move} i-move-4  {move-type} normal-type
	{move} pass-move {move-type} pass-type
moves}

{moves p-moves
	{move} p-move-1  {move-type} normal-type
	{move} p-move-2  {move-type} normal-type
	{move} p-move-3  {move-type} normal-type
	{move} p-move-4  {move-type} normal-type
	{move} pass-move {move-type} pass-type
moves}

{move-priorities
	{move-priority} normal-type
	{move-priority} pass-type
move-priorities}
</source>
</spoiler>
Первым в глаза бросается заковыристое определение <b>is-rosette?</b>. К сожалению, в Axiom, в отличии от ZRF, нет возможности определения игровых зон. Все поля приходится проверять индивидуально. 

Реализация пропуска хода также отличается от подхода, используемого в ZRF. Установка опции "<b>pass turn</b>" игнорируется Аксиомой. Вместо этого, пропуск хода должен формироваться явно, командой <b>Pass</b>. Это один из примеров более полного использования возможностей нотации записи ходов ZSG (используемой для передачи хода из engine в ZoG). Другим таким примером является возможность использования команд сброса (<b>drops</b>) при выполнении частичных ходов (<b>partial moves</b>), не реализованная в ZRF.

<spoiler title="Примечание">
Понимание ZSG-нотации очень важно при разработке собственных модулей расширения (<b>engines</b>). Возможность выполнения в ZoG какого либо хода полностью определяется тем, можно ли записать его в ZSG-нотации. ZoG не документирует этот формат, но в документации на Axiom имеется описывающий его раздел (Appendix B). Знакомство с этим разделом может избавить разработчика от продолжительных экспериментов с целью выяснения особенностей ZSG-нотации.
</spoiler>
Для того, чтобы пропуск хода работал только при отсутствии возможности какого либо другого хода, необходимо использовать приоритеты. Ход, имеющий более низкий приоритет, может быть выполнен только при отсутствии возможности хода с более высоким приоритетом. К сожалению, пропуск хода в стиле Axiom функционально не полностью эквивалентен поведению ZoG, при установке опции "<b>pass turn</b>" в <b>force</b>. В ZRF-реализации пропуск хода выполняется автоматически, в случае Axiom, придётся нажать на кнопку:

<img src="https://habrastorage.org/getpro/habr/post_images/6ab/c5e/9b4/6abc5e9b43e80614773c226c99399bae.png"/>

Должен сказать, это здорово сбивает с толку.

Для реализации пропуска хода после хода на "розетку", в позицию <b>q5</b>, не используемую в игре, помещается невидимая фигура <b>lock</b>. В самом начале <b>common-move</b>, выполняется проверка на наличие в этом поле вражеской фигуры. Если поле занято врагом - ход невозможен.

Теперь, пришло время научиться бросать "кости":

<spoiler title="Бросок костей">
<source>
{players
	{player}	White
	{player}	Black
	{player}	?Dice	{random}
players}

{turn-order
	{turn}	White
	{turn}	?Dice {of-type} clear-type
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
	{turn}	Black
	{turn}	?Dice {of-type} clear-type
	{turn}	?Dice
	{turn}	?Dice
	{turn}	?Dice
turn-order}

: drop-dices ( -- )
	q2 here = q3 here = OR q4 here = OR empty? AND IF
		drop
		add-move
	ENDIF
;

: count-dices ( -- n )
	q2 piece-at piece-value
	q3 piece-at piece-value +
	q4 piece-at piece-value +
	DUP 0= IF
		DROP
		4
	ENDIF
;

: clear-dices ( -- )
	q1 here = verify
	q2 not-empty-at? q3 not-empty-at? q4 not-empty-at?
	AND AND IF
		drop
		q2 capture-at
		q3 capture-at
		q4 capture-at
		add-move
	ENDIF
;

: i-move ( -- ) ['] Anext count-dices common-move ;
: p-move ( -- ) ['] Cnext count-dices common-move ;

{moves p-moves
	{move} p-move {move-type} normal-type
	{move} pass-move {move-type} pass-type
moves}

{moves drops
	{move} drop-dices {move-type} normal-type
	{move} pass-move {move-type} pass-type
moves}

{moves clears
	{move} clear-dices {move-type} clear-type
moves}

{pieces
	{piece}		lock	{moves} clears
	{piece}		init	{moves} i-moves
	{piece}		prom	{moves} p-moves
	{piece}		wdice	{drops} drops 1 {value}
	{piece}		bdice	{drops} drops 0 {value}
pieces}
</source>
</spoiler>
Бросок "костей" (<b>drop-dices</b>) выполняется элементарно. Просто проверяем, что целевое поле предназначено для броска костей, ставим фигуру командой <b>drop</b> и завершаем ход командой <b>add-move</b>. Несколько сложнее выполняется очистка (<b>clear-dices</b>). В ZoG отсутствует возможность сформировать ход, заключающийся лишь в удалении фигуры с доски. Ход очистки мы связываем со сбросом невидимой фигуры на неиспользуемое в игре поле <b>q1</b>. Удаление с доски "костей" является побочным эффектом этого хода. Осталось подсчитать выпавшие очки (<b>count-dices</b>) и передать это значение в <b>common-move</b>.

Для того, чтобы определить условие завершения игры, необходимо считать фишки, ушедшие с доски. Сама проверка завершения выполняется Аксиомой путём вызова переопределенного слова <b>OnIsGameOver</b>. Для выполнения первоначальных действий, при старте игры (например инициализации генератора псевдослучайных чисел), необходимо переопределить <b>OnNewGame</b>:

<spoiler title="Условие завершения">
<source>
{board
	5 17 		{grid}
	{variable}	WhitePieces
	{variable}	BlackPieces
board}

: WhitePieces++ WhitePieces ++ ;
: BlackPieces++ BlackPieces ++ ;

: common-move ( 'dir n -- )
	q5 enemy-at? NOT IF
		FALSE isPromouted !
		SWAP
		BEGIN
			current-player White
			= IF
				here p2
			ELSE
				here p4
			ENDIF
			= IF TRUE isPromouted ! ENDIF
			DUP EXECUTE verify SWAP
			1-  DUP
			0=  IF
				DROP
				TRUE
			ELSE
				SWAP
				FALSE
			ENDIF
		UNTIL
		empty? IF
			from
			here
			move
			here h3 = IF
				current-player White = IF
					COMPILE WhitePieces++
				ELSE
					COMPILE BlackPieces++
				ENDIF
				capture
			ENDIF
			isPromouted @ IF
				current-piece-type 1+ change-type
			ENDIF
			is-rosette? IF
				q1 piece-type-at q5 create-piece-type-at
			ELSE  
				q5 capture-at
			ENDIF
			add-move
		ENDIF
	ENDIF
;

: OnNewGame ( -- )
	RANDOMIZE
;

: OnIsGameOver ( -- gameResult )
	repetition-reset
	#UnknownScore
	current-player White = IF
		BlackPieces @
		7 - 0=  IF
			DROP
			#LossScore
		ENDIF
	ENDIF
	current-player Black = IF
		WhitePieces @
		7 - 0=  IF
			DROP
			#LossScore
		ENDIF
	ENDIF
;
</source>
</spoiler>
<spoiler title="Примечание">
Использование переменных, определяемых "на доске", описывается в разделе 3.9.4 "Updating Board Variables" документации по Axiom.
</spoiler>
Для получения полноценной игры осталось реализовать бой фигур и обработку специальных полей. Я не буду загромождать статью этими подробностями, поскольку, они не несут в себе ничего принципиально нового. Желающие могут посмотреть полную реализацию "Королевской игры Ур" на <a href="https://github.com/GlukKazan/ZoG/blob/master/Axiom/Ur/Ur.4th">GitHub</a>.

<h4>Основной инстинкт</h4>
Главной изюминкой ZoG является её универсальность. ZRF позволяет создать новую игру (или описать существующую), просто задекларировав её правила. Да, играет она заметно хуже чем специализированные программы, но подобная возможность <b>быстрого</b> создания прототипа почти любой игры дорогого стоит! <a href="http://www.zillions-of-games.com/games/index.html">Количество</a> разработанных для ZoG приложений говорит само за себя. 

Axiom также универсальна. Она снимает многие неприятные ограничения ZoG и позволяет описывать такие настольные игры, с которыми ZoG не справляется. Одна возможность использования полноценной арифметики, вместо манипуляций с булевскими флагами, выводит этот продукт на качественно более высокий уровень, но это не главное достоинство Axiom! Хорошо играет ZoG или плохо, но для нас её AI представляет собой чёрный ящик. Мы никак не можем повлиять на качество его игры! Axiom предоставляет нам возможность (но не требует этого) поучаствовать в разработке алгоритмов выбора оптимального хода.

Самая очевидная возможность вмешательства в работу AI Axiom - выбор весовой функции, при помощи которой оценивается каждая позиция. От нас требуется всего лишь переопределить <b>OnEvaluate</b>. Попробуем создать очень простую оценочную функцию, взяв за основу суммарное продвижение фишек от старта до финиша. Размещение фишки на стартовой позиции будем оценивать весом 0, а фишки, прошедшие полный путь, будем оценивать каким нибудь большим числом, например 100. Очевидно, что если какая-то фишка будет взята, значение оценки резко снизится (тем больше, чем дальше фишка успела продвинуться). Разумеется, для противника будем использовать ту же оценку, взятую с обратным знаком. Чем лучше позиция противника - тем наша хуже:

<spoiler title="Простая оценочная функция">
<source>
VARIABLE		whiteScored
VARIABLE		blackScored

: Score ( value piece-type player pos -- score )
	DUP not-empty-at? IF
		DUP player-at White = IF
			whiteScored --
		ELSE
			blackScored --
		ENDIF
		DUP ROT SWAP player-at =
		ROT ROT piece-type-at =
		AND NOT IF
			DROP 0
		ENDIF
	ELSE
		DROP DROP DROP DROP 0
	ENDIF
;

: OnEvaluate ( -- score )
	 7 	whiteScored !
	 7 	blackScored !

	 0	1 White i1 Score
	 0	1 White j1 Score +
	 0	1 White k1 Score +
	 0	1 White l1 Score +
	 0	1 White m1 Score +
	 0	1 White n1 Score +
	 0	1 White o1 Score +

	 0	1 Black i5 Score +
	 0	1 Black j5 Score +
	 0	1 Black k5 Score +
	 0	1 Black l5 Score +
	 0	1 Black m5 Score +
	 0	1 Black n5 Score +
	 0	1 Black o5 Score +

	 1	1 White l2 Score +
	-1	1 Black l4 Score +
	 2	1 White k2 Score +
	-2	1 Black k4 Score +
	 3	1 White j2 Score +
	-3	1 Black j4 Score +
	 4	1 White i2 Score +
	-4	1 Black i4 Score +
	 5	1 White i3 Score +
	-5	1 Black i3 Score +
	 6	1 White j3 Score +
	-6	1 Black j3 Score +
	 7	1 White k3 Score +
	-7	1 Black k3 Score +
	 8	1 White l3 Score +
	-8	1 Black l3 Score +
	 9	1 White m3 Score +
	-9	1 Black m3 Score +
	 10	1 White n3 Score +
	-10	1 Black n3 Score +
	 11	1 White o3 Score +
	-11	1 Black o3 Score +
	 12	1 White o2 Score +
	-12	1 Black o4 Score +
	 13	1 White p2 Score +
	-13	1 Black p4 Score +
	 14	2 White p3 Score +
	-14	2 Black p3 Score +
	 15	2 White p4 Score +
	-15	2 Black p2 Score +
	 16	2 White o4 Score +
	-16	2 Black o2 Score +
	 17	2 White o3 Score +
	-17	2 Black o3 Score +
	 18	2 White n3 Score +
	-18	2 Black n3 Score +
	 19	2 White m3 Score +
	-19	2 Black m3 Score +
	 20	2 White l3 Score +
	-20	2 Black l3 Score +
	 21	2 White k3 Score +
	-21	2 Black k3 Score +
	 22	2 White j3 Score +
	-22	2 Black j3 Score +
	 23	2 White i3 Score +
	-23	2 Black i3 Score +

	 1	1 White c2 Score +
	 1	1 White c3 Score +
	 1	1 White c4 Score +
	-1	1 Black d2 Score +
	-1	1 Black d3 Score +
	-1	1 Black d4 Score +

	 3	1 White a2 Score +
	 3	1 White a3 Score +
	 3	1 White a4 Score +
	-3	1 Black b2 Score +
	-3	1 Black b3 Score +
	-3	1 Black b4 Score +

	 7	1 White f2 Score +
	 7	1 White f3 Score +
	 7	1 White f4 Score +
	-7	1 Black f2 Score +
	-7	1 Black f3 Score +
	-7	1 Black f4 Score +

	 10	1 White g2 Score +
	 10	1 White g3 Score +
	 10	1 White g4 Score +
	-10	1 Black g2 Score +
	-10	1 Black g3 Score +
	-10	1 Black g4 Score +

	 11	1 White e2 Score +
	 11	1 White e3 Score +
	 11	1 White e4 Score +
	-11	1 Black e2 Score +
	-11	1 Black e3 Score +
	-11	1 Black e4 Score +

	 17	2 White e2 Score +
	 17	2 White e3 Score +
	 17	2 White e4 Score +
	-17	2 Black e2 Score +
	-17	2 Black e3 Score +
	-17	2 Black e4 Score +

	 18	2 White g2 Score +
	 18	2 White g3 Score +
	 18	2 White g4 Score +
	-18	2 Black g2 Score +
	-18	2 Black g3 Score +
	-18	2 Black g4 Score +

	 21	2 White f2 Score +
	 21	2 White f3 Score +
	 21	2 White f4 Score +
	-21	2 Black f2 Score +
	-21	2 Black f3 Score +
	-21	2 Black f4 Score +

	 whiteScored @ 100 * +
	 blackScored @ 100 * -

	 current-player Black = IF NEGATE ENDIF
;
</source>
</spoiler>
Конечно, Axiom не оставляет нас один на один с Фортом при разработке оценочной функции. Нам предоставляются удобные примитивы для оценки как материальной, так и позиционной составляющих. Например, следующая оценочная функция (с точностью до коэффициентов), взятая из официального руководства, будет неплохо работать для большинства игр, наподобие Шашек и Шахмат:

<source>
: Mobility ( -- mobilityScore ) 
	move-count                              \ Number of moves available to us. 
	current-player TRUE 0 $GenerateMoves    \ Generate moves for opponent 
	move-count                              \ Number of moves available to opponent. 
	-                                       \ #friendlyMoves - #unfriendlyMoves 
	$DeallocateMoves                        \ Deallocate the opponent's move list 
;

: OnEvaluate ( -- score ) 
	Mobility 
	current-player material-balance 3 * + 
;</source>
Здесь вызов <b>move-count</b> подсчитывает количество возможных ходов из текущей позиции, а <b>material-balance</b> вычисляет сумму весов, назначенных фигурам, при помощи атрибута <b>{value}</b> (в нашем коде, мы используем его для задания числовых значений "костям").

Всё это прекрасно, но как быть в тех случаях, когда само использование <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0_%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">минимаксного алгоритма</a> является избыточным? В той игре, которую пытаемся реализовать мы, заглядывание более чем на один ход вперёд, скорее всего, приведёт лишь к напрасной трате вычислительных ресурсов. Как я уже <a href="http://habrahabr.ru/post/225631/">писал</a>, здесь нам нужен не "Искусственный интеллект" , а скорее "Искусственный инстинкт"! Axiom предоставляет нам возможность вмешаться в алгоритм выбора хода на более глубоком уровне:

<spoiler title="Произвольный алгоритм выбора хода">
<source>
VARIABLE BestScore		\ Keep track of the best score found so far by our search engine.
VARIABLE Nodes			\ The number of possibilities explored by our search engine.
VARIABLE Eated
VARIABLE Rosettes

: enemy-value-at ( pos -- value )
	DUP
	empty-at?
	IF
		DROP 0
	ELSE
		0 SWAP
		player-at current-player <>
		IF DROP 1 ENDIF
	ENDIF
;

: friend-value-at ( pos -- value )
	DUP
	empty-at?
	IF
		DROP 0
	ELSE
		1 SWAP
		player-at current-player <>
		IF DROP 0 ENDIF
	ENDIF
;

: Make_enemy_p  ( pos -- ) <BUILDS , DOES> @ enemy-value-at ;
: Make_friend_p ( pos -- ) <BUILDS , DOES> @ enemy-value-at ;

i1 Make_enemy_p e0
j1 Make_enemy_p e1
k1 Make_enemy_p e2
l1 Make_enemy_p e3
m1 Make_enemy_p e4
n1 Make_enemy_p e5
o1 Make_enemy_p e6
i5 Make_enemy_p e7
j5 Make_enemy_p e8
k5 Make_enemy_p e9
l5 Make_enemy_p e10
m5 Make_enemy_p e11
n5 Make_enemy_p e12
o5 Make_enemy_p e13

i2 Make_friend_p r0
i4 Make_friend_p r1
l3 Make_friend_p r2
o2 Make_friend_p r3
o4 Make_friend_p r4

: CountEated ( -- count )
	e0 e1 + e2 + e3 + e4 + e5 + e6 + e7 + e8 + e9 + e10 + e11 + e12 + e13 +
;

: CountRosettes ( -- count )
	r0 r1 + r2 + r3 + r4 +
;

: Score ( -- score )
	Eated @ CountEated < IF 10 ELSE 0 ENDIF
	Rosettes @ CountRosettes < IF 5 ELSE 0 ENDIF +
;

: Custom-Engine ( -- )
	-1000 BestScore !				\ Keep track of the best score.
	0 Nodes !					\ Count the number of possibilities explored.
	CountEated Eated !
	CountRosettes Rosettes !
(
  Notes:
  1 - We do not need to invoke $GenerateMoves since they have already been generated for the
  current player { since ZoG has called DLL_GenerateMoves prior to calling DLL_Search}.

  2 - ZoG does not invoke the search engine if there are no moves, so we can safely assume.
  that at least one move exists.  Thus we can use BEGIN..UNTIL instead of BEGIN...WHILE..REPEAT
  for iterating moves.
)
	$FirstMove					\ Obtain the address of the first move.
	BEGIN
		$CloneBoard				\ Create a temporary copy of the current board.
		DUP $MoveString CurrentMove!		\ Inform ZoG of the current move being examined.
		DUP .moveCFA EXECUTE			\ Apply the move to the board by executing its code.
		Score					\ Calculate the score for the new board.
		BestScore @ OVER <			\ Have we found a better score?
		IF
			DUP BestScore !			\ Save the improved score.
			Score!				\ Inform ZoG of the improved score.
			DUP $MoveString BestMove!
		ELSE
			DROP 				\ We didn't find a better move, drop the score.
		ENDIF
		$DeallocateBoard			\ Done with the revised board.
		Nodes ++				\ Count one more node explored.
		Nodes @ Nodes!				\ Inform ZoG of the node count.
		$Yield					\ Allow ZoG to dispatch Windows messages.
		$NextMove				\ Advance to the next move.
		DUP NOT					\ No more moves?
	UNTIL
	DROP
;

{players
	{player}	White	{search-engine} Custom-Engine
	{player}	Black	{search-engine} Custom-Engine
	{player}	?Dice	{random}
players}
</source>
</spoiler>
Большая часть этого кода взята из документации. Как понятно из комментариев, мы перебираем все возможные ходы, и применяем к построенным временным позициям функцию оценки. В качестве оценочной функции, мы могли бы брать ту же функцию, которую написали для <b>OnEvaluate</b>, но это было бы не интересно. Я постарался сформулировать некую предельно агрессивную стратегию игры. Если есть возможность взять вражескую фигуру или встать на "розетку", этот ход считается предпочтительным, если такой возможности нет, выбирается первый попавшийся ход.

К слову сказать, предопределённые Axiom примитивные игровые стратегии <b>{first}</b> и <b>{random}</b> реализованы аналогичным образом. Вот как они описываются в axiom.4th:

<spoiler title="Примитивные игровые стратегии">
<source>
: $RandomMoveEngine
	$FirstMove
	0
	$movesList @ CELLSIZE + @ 1-
	$RAND-WITHIN

	BEGIN
	DUP 0>
	WHILE
		SWAP @ SWAP
		$Yield
		1-
	REPEAT
	DROP

	( move ) $MoveString DUP CurrentMove! BestMove!
	1 Nodes! 0 Score! 0 Depth!
;

: {random}
	['] $RandomMoveEngine $CompileEngine
;

: $FirstMoveEngine
	$FirstMove $MoveString DUP CurrentMove! BestMove!
	$Yield
;

: {first}
	['] $FirstMoveEngine $CompileEngine
;
</source>
</spoiler>
Как я уже говорил, открытый (пусть даже частично) исходный код - это прекрасно!

<h4>Ложь, наглая ложь и статистика</h4>
Хорошо, мы создали новую игру и можем в неё поиграть, используя ZoG. Мы реализовали несколько вариантов игры с различными алгоритмами выбора хода, но как нам определить, какой из них лучше? Конечно, можно собрать десяток "экспертов" и попросить каждого из них сыграть по сотне раз с каждым из вариантов. Как говорил один мой знакомый, "это может растянуться на годы". Есть способ лучше!

В составе Axiom предоставляется утилита AutoPlay, позволяющая автоматизировать процесс тестирования. Первое, что мы должны сделать, следуя по пути автоматизации - это создание <b>вариантов</b> игры:

<source>
(variant (title "Ur [random]"))
(variant (title "Ur [simple evaluation]"))
(variant (title "Ur [aggressive]"))
</source>
Дописав эти строки в конец ZRF-файла, заново запустим ZRF Converter, чтобы получить заготовки 4th-файлов вариантов игры. В эти файлы необходимо внести изменения, влияющие на стратегию, используемую программой. Вот так, например, выглядит один из простейших вариантов:

<source>
LOAD Ur.4th ( Load the base Ur game )

{players
	{player}	White   {random}
	{player}	Black   {random}
	{player}	?Dice	{random}
players}
</source>
Как легко видеть, мы можем переопределять отдельные секции описания, вынося весь совместно используемый код в подгружаемые файлы скриптов.

После того как варианты созданы, мы можем запустить игру в режиме игры одного варианта против другого. Это главное достоинство AutoPlay! Не требуется создавать варианты, в которых игроки играют, используя <b>различные</b> стратегии. Достаточно дать следующую команду:

<source>
AutoPlay Ur-[random] Ur-[random] 100
</source>
Всё максимально просто. Задаём варианты для первого и второго игроков (в текущей реализации AutoPlay большее количество игроков не поддерживается) и количество партий. Дальше программа работает сама. И делает она это гораздо быстрее, чем если бы эти партии игрались с использованием ZoG! На выходе формируется большой текстовый файл, содержащий описание всех сыгранных партий в ZSG-нотации. В самом конце, выводится итоговая статистика, по которой можно видеть, что при условии того, что ходы выбираются случайно, игрок делающий первый ход имеет небольшое преимущество (даже с учетом того, что он всегда ходит на "единичку"):

<source>
Final results:
Player 1 "Ur-[random]", wins = 52.
Player 2 "Ur-[random]", wins = 48.
Draws = 0
100 game(s) played
</source>
Наличие полного ZSG-описания позволяет нам, после небольшой обработки, загрузить любую из партий в ZoG и рассмотреть её пошагово. Кстати, именно таким образом были обнаружены и исправлены <a href="https://github.com/GlukKazan/ZoG/commit/dfa8daf536aca44696ecc524c218f390c2bddc74">эти</a> ошибки в реализации (не знаю чем я думал когда решил просто дропнуть результат перехода вместо того, чтобы его проверить).

Другим достоинством наличия полного ZSG-описания, является то, что мы, обработав данные, можем собрать любую необходимую статистику, если нас не устроит простое соотношение количества выигранных/проигранных партий. Следующий ниже скрипт выводит данные о продолжительности партий, итоговом счёте на конец партии, количестве пропусков хода и количестве фишек "срубленных" каждым из игроков:

 <spoiler title="Скрипт обработки данных">
<source lang="perl">
#!/usr/bin/perl -w

my @S = (0, 0, 0, 0, 0, 0);
my $ix = 0;
my $T;

while (<>) {
    if (/results/) {
        my $d = $S[0] - $S[1];
        print "$T, $d, $S[3], $S[2], $S[4], $S[5]\n";
        @S = (0, 0, 0, 0, 0, 0);
        $ix = 0;
    } else {
        if (/^(\d+)\.\s+[^?].*$/) {
             $T = $1;
             if (/x h3/) {
                 $S[$ix]++;
             }
             if (/Pass|^(\d+)\.\s+x\s+q5\s*$/) {
                 $S[$ix + 2]++;
             }
             if (/Black init [ijklmno]5/) {
                 $S[4]++;
             }
             if (/White init [ijklmno]1/) {
                 $S[5]++;
             }
             $ix++;
             if ($ix > 1) {
                 $ix = 0;
             }
        }
    }
}
</source>
</spoiler>
Теперь у нас есть всё необходимое для сравнения качества игры разработанных нами вариантов. Будем рассматривать три варианта:

<ul>
	<li>Со случайным выбором хода (<b>random</b>)</li>
	<li>С простой оценочной функцией (<b>simple</b>)</li>
	<li>С "агрессивным" алгоритмом выбора хода (<b>agressive</b>)</li>
</ul>
 <spoiler title="random vs random">
Продолжительность партии (если противники не стараются затянуть игру, в среднем, чуть больше 150 ходов):

<img src="https://habrastorage.org/getpro/habr/post_images/ee8/58f/3a3/ee858f3a3746fb301b090bf5aa820e49.png"/>

Количество фишек, оставшихся на доске (отрицательное значение - проигрыш первого игрока):

<img src="https://habrastorage.org/getpro/habr/post_images/9be/654/40b/9be65440bf3ce08f9e1b1dc5a5a996ed.png"/>

Количество "срубаемых" игроками фишек примерно одинаково:

<img src="https://habrastorage.org/getpro/habr/post_images/a98/d14/9dd/a98d149dd124be1844789442cfe603fa.png"/>

Мы видим, что игрок, начинающий первым, имеет незначительное преимущество:

<source>
Final results:
Player 1 "Ur-[random]", wins = 52.
Player 2 "Ur-[random]", wins = 48.
Draws = 0
100 game(s) played
</source>
</spoiler>
 <spoiler title="random vs simple">
Счёт:

<img src="https://habrastorage.org/getpro/habr/post_images/d9b/77e/c88/d9b77ec88da646a1d531b10c75e8fb70.png"/>

Противники играют на равных:

<source>
Final results:
Player 1 "Ur-[random]", wins = 50.
Player 2 "Ur-[simple-evaluation]", wins = 50.
Draws = 0
100 game(s) played
</source>
</spoiler>
 <spoiler title="simple vs random">
Партия несколько затягивается:

<img src="https://habrastorage.org/getpro/habr/post_images/abe/09f/203/abe09f20318267ae988b8a28897790a9.png"/>

Но более "умный" игрок уверенно ведёт в счете:

<img src="https://habrastorage.org/getpro/habr/post_images/f7f/d62/a5a/f7fd62a5ac885c7b76b4ff5c98561b50.png"/>

<source>
Final results:
Player 1 "Ur-[simple-evaluation]", wins = 87.
Player 2 "Ur-[random]", wins = 13.
Draws = 0
100 game(s) played
</source>
</spoiler>
 <spoiler title="random vs agressive">
Партия ещё больше затягивается:

<img src="https://habrastorage.org/getpro/habr/post_images/53c/241/56a/53c24156ae7c2aa6fafa869fc193654e.png"/>

Но <b>random</b> начинает проигрывать (даже когда он ходит первым):

<img src="https://habrastorage.org/getpro/habr/post_images/717/3be/b67/7173beb67106f384d3edc036eb176de0.png"/>

Чтобы понять, почему так происходит, посмотрим сколько фишек "срубает" каждый игрок:

<img src="https://habrastorage.org/getpro/habr/post_images/bf9/350/a7f/bf9350a7fcdb90877992651a8b70b8e9.png"/>

Агрессивный игрок "срубает" немало, но и сам подставляется также!

<source>
Final results:
Player 1 "Ur-[random]", wins = 25.
Player 2 "Ur-[aggressive]", wins = 75.
Draws = 0
100 game(s) played
</source>
</spoiler>
 <spoiler title="agressive vs random">
Партия вновь проходит быстрее:

<img src="https://habrastorage.org/getpro/habr/post_images/4cb/c8e/a8e/4cbc8ea8e171a51e2334117b967878ba.png"/>

Но "агрессивный" игрок громит "случайного" почти всухую!

<img src="https://habrastorage.org/getpro/habr/post_images/720/8c5/d00/7208c5d003c30afa3b178687c9018863.png"/>

Теперь, он "срубает" гораздо больше, чем противник:

<img src="https://habrastorage.org/getpro/habr/post_images/b73/e91/431/b73e91431f7fa0508750422762e2fdf8.png"/>

<source>
Final results:
Player 1 "Ur-[aggressive]", wins = 90.
Player 2 "Ur-[random]", wins = 10.
Draws = 0
100 game(s) played
</source>
</spoiler>
 <spoiler title="simple vs agressive">
К сожалению, нам не удалось найти идеальную стратегию. Начиная первым, <b>simple</b> вновь ведёт в счете:

<img src="https://habrastorage.org/getpro/habr/post_images/31a/eb7/5df/31aeb75df74c3b9423605015f5e52024.png"/>

Партия затягивается ещё больше!

<img src="https://habrastorage.org/getpro/habr/post_images/e6b/472/cbe/e6b472cbe0a921ce2bddfc91f9006410.png"/>

<source>
Final results:
Player 1 "Ur-[simple-evaluation]", wins = 73.
Player 2 "Ur-[aggressive]", wins = 27.
Draws = 0
100 game(s) played
</source>
</spoiler>
<spoiler title="agressive vs simple">
Партия <b>не</b> затягивается, если <b>agressive</b> начинает первым: 

<img src="https://habrastorage.org/getpro/habr/post_images/a4a/a7a/da7/a4aa7ada738b3c37b1cebc6ac6764860.png"/>

Он справляется с "простым" противником, но уже не так легко, как с "случайным":

<img src="https://habrastorage.org/getpro/habr/post_images/bb7/eee/768/bb7eee768c81086022c0c1b9179feaac.png"/>

<source>
Final results:
Player 1 "Ur-[aggressive]", wins = 64.
Player 2 "Ur-[simple-evaluation]", wins = 36.
Draws = 0
100 game(s) played
</source>
</spoiler>
Кстати, обратите внимание на следующую замечательную строку:

<source>
Draws = 0
</source>
Дело в том, что Axiom предлагает способ борьбы с "3-Time Repetition Draw!". Я тщательно проштудировал соответствующий раздел документации и предпринял все необходимые действия. Проблема в том, что в ZoG эта ситуация всё равно возникает. Обычно это происходит когда длинные цепочки (3-4 фишки подряд) белых и чёрных фишек блокируют друг друга. В "Королевском Ур", благодаря безопасным полям, способ разойтись для них всегда есть, но ZoG (даже под управлением Axiom) не дожидается пока фишки разойдутся! А вот AutoPlay, доигрывает все партии до конца. В принципе, как я уже говорил, его можно запускать даже без установленного и купленного ZoG, просто интерфейса графического не будет.

<h4>... и тысяча слонов!</h4>
Конечно, всего лишь в одной статье невозможно рассказать всё о таком сложном и многогранном продукте как Axiom Development Kit. Посмотрите, какие возможности заявлены разработчиками:

<spoiler title="Axiom Engine Features">
<ul>
	<li>Contains a universal game engine designed to play a large variety of games.  The search engine is not optimized for any particular class of games. </li>
	<li>Allows (actually requires) the game programmer to specify a custom game AI. This is one of the main benefits of Axiom. Some 'built-in' AI helpers are provided. For example, one helper is simply the difference between the number of available moves for each player, another takes into consideration material advantage.  The list is expected to grow over time. </li>
	<li>"Minimax with Alpha-Beta pruning" search algorithm. </li>
	<li>Iterative deepening with transposition table.  </li>
	<li>Zobrist hashing  </li>
	<li>Limited move reordering based on 'best move from previous iteration' stored in the transposition table. </li>
	<li>Full width searching.  </li>
	<li>Support for 'partial' and 'pass' moves. </li>
	<li>Supports 'teams'. </li>
	<li>Time management. </li>
	<li>Supports additional user-supplied custom engines.  </li>
	<li>Programmer controlled quiescence (currently experimental)</li>
</ul></spoiler>
Здесь есть и поддержка контроля времени, и поддержка командной игры, которых так не хватало в ZoG. Axiom предоставляет специальную структуру данных (Ring Buffer) для разработки игр на "соединение" и "захват территории". Несколько расстраивает тот факт, что не поддерживаются атрибуты фигур (с использованием которых в ZoG, например, реализована шахматная рокировка), но Axiom предоставляет достаточно возможностей, чтобы обойти это досадное ограничение.

Отдельных и очень тёплых слов заслуживает качество документации и примеров. Очень сложный материал преподнесён так, что его усвоение не связано с какими либо трудностями. И даже если этого материала окажется недостаточно, на сайте ZoG имеется <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?theme=39">более 60</a> интереснейших приложений, разработанных с использованием Axiom, доступных для анализа и изучения.
</habracut>

Как мы Ур делали

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/abf/f6a/1c6/abff6a1c62873e37de5f4ad635490766.png"/><i><b>This game has no name.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Виктор Пелевин "Generation П"
</b></i>
<i><b>Дорога в тысячу ли начинается с первого шага.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Лао Цзы
</b></i>

В отношении моей <a href="http://habrahabr.ru/post/224661/">предыдущей статьи</a>, Хабр-эффект сработал неожиданным образом. Самым первым комментарием к ней, уважаемый <hh user="Nomad1"/> <a href="http://habrahabr.ru/post/224661/#comment_7648091">поинтересовался</a>, не хочу ли я создать полноценную реализацию? Я, в тот момент, по обыкновению, думал о своём и не сразу его понял. Конечно же, речь шла не о создании универсального игрового движка (мысль о котором не даёт мне покоя), а о разработке реализации игры Ур для мобильных платформ. Хотя я слабо представлял себе, на тот момент, чем я могу оказаться полезен, я согласился помочь.
<habracut>
Разумеется, все мои <a href="https://github.com/GlukKazan/ZoG/commits/master/Rules/07.Ur.zrf">наработки</a> для ZoG оказались здесь совершенно бесполезны. ZRF настолько своеобразный язык, что все его решения и идиомы имеют ценность лишь для ZRF-разработчиков и ни для кого больше (по большей части, все они решают проблемы самого ZRF). По счастью, у Алексея уже был готовый framework, позволивший запрограммировать игровую логику в рекордно короткие сроки. Моей задачей стала сверка игровых правил и разработка принципов работы AI для этой игры.

Мы постарались как можно более точно воспроизвести <a href="http://skyruk.livejournal.com/231444.html">вариант правил</a>, предложенный <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрием Скирюком</a>, поскольку считаем его наиболее интересным (в игровом отношении) из всех предложенных на сегодняшний день.

<spoiler title="Напомню правила">
<img src="https://habrastorage.org/getpro/habr/post_images/b7f/59b/17f/b7f59b17f6e7449451eb7341498f58f0.png"/>

В вашем распоряжении 7 бойцов-новичков. Ваша задача - провести их через реку и вернуть домой. Боги помогут вам в пути.

<ul>
	<li>Если белый цвет выпал на одной из костей, вы можете сделать один шаг.</li>
	<li>Две белых кости означают, что любой из ваших бойцов может переместиться на два шага.</li>
	<li>Если белый цвет выпал на трёх костях, вы можете передвинуть любого из своих бойцов на три шага.</li>
	<li>Три чёрных кости дают право сходить на четыре шага вперёд.</li>
</ul>
Если ни один из ваших бойцов не может ходить, вы пропускаете ход.

Не все места, через которые вы пройдете одинаковы.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/467/5e4/ef9/4675e4ef9a972f4c331bc617708f702d.png"/>Это врата Иштар - покровительницы воинов. 
Остановившись здесь, вы имеете право сделать ещё один ход.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/1a5/d58/dd6/1a5d58dd645a7aad832deb4ccc39aada.png"/>Здесь можно разбить лагерь. В лагере могут находиться не более 4 ваших бойцов. 
Пока в лагере есть хотя бы один боец, враг не может войти в это место.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/acc/db8/536/accdb85365da62abf7d2dff774ff16cf.png"/>Это святое место. Враг не может напасть на вас здесь, но и вы не можете напасть на него. Не более 4 бойцов (ваших и вашего противника) могут пребывать в этом месте. Помните, первым уходит тот, кто вошёл последним!

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/43f/a13/ffc/43fa13ffcc5d460de03c107fa97419ba.png"/>Пройдя через это место, бойцы-новички превращаются в воинов-ветеранов. Новичек не может одолеть в бою ветерана, но и ветераны не нападают на новичков.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/b31/44c/78e/b3144c78e368b524fda3f73132656f29.png"/>Никто не может одолеть ветерана, пока он находится в этом месте.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

Выйдя из лагеря, вы встретитесь с врагом. Если один из ваших бойцов будет убит, вы получите ещё одного новичка.

Семь воинов должны перейти реку и вернуться домой.
Враг не должен вас опередить!
</spoiler>
Одной из "изюминок" этого варианта правил является процесс "переворачивания" фишек. Напомню, что фишки переворачиваются для того, чтобы игрок не запутался в направлении их движения. Обычные фишки двигаются по направлению к "малому" блоку, перевернутые - от него. Но "переворачивание" фишек влияет и на игровой процесс. Друг друга могут "рубить" только одинаковые фишки. Обычные фишки не могут "срубать" перевернутые и наоборот. Это весьма разнообразит игровой процесс, но создаёт угрозу "заторов". Например, в процессе отладки ZoG-приложения у меня возникла следующая ситуация:

<img src="https://habrastorage.org/getpro/habr/post_images/1e2/bdb/c82/1e2bdbc82ab0cdc32b179e237c486dc4.jpg"/>

Это реальная позиция, возникшая в процессе тестового прогона варианта игры "Simple Ur", в котором поля доски, кроме "розеток", не обладают никакими особыми свойствами. Этот затор совсем не просто разобрать (если бы в резерве не оставалось фишек, игра бы на этом и закончилась). Сколько бы очков не выкинул любой из игроков, ни одна из заблокировавших друг друга фишек не сможет сдвинуться с места. Я думаю, это главная причина, по которой Дмитрий ввёл в игру специальные поля. Поля c2 и f2 (в шахматной нотации) призваны разгрузить "трафик".

На этих полях, фишки любого цвета можно выстраивать "столбиком" друг на друга (но не более 4 штук). При этом нижние фишки не возвращаются в резерв, а просто остаются блокированными, пока верхняя фишка не пройдет дальше. Это простое изменение правил оказывает на игровой процесс волшебное действие. Затор перестаёт существовать. Столкнувшиеся фишки легко расходятся! Но на этом сюрпризы, связанные с переворачиванием фишек, не заканчиваются. Посмотрите на следующую позицию:

<img src="https://habrastorage.org/getpro/habr/post_images/498/2f0/732/4982f0732379537b20b7ef34ed7cfacd.jpg"/>

По правилам Дмитрия, фишка переворачивается не тогда, когда она встаёт на поле превращения (h1 для белых и h3 для чёрных), а проходя через него! В результате, белая фишка не может срубить чёрную на h3, поскольку она должна быть перевёрнута, сделав любой ход с h1. Зато она легко бьёт перевернутую черную фишку на h2, переворачиваясь в процессе хода! Это правило, фактически, делает безопасными поля g1, h1, g3 и h3. Эти поля - идеальное место для "засады". 

Также безопасно (но по другой причине) поле g2. На этом поле "с глазами" фишки также можно выстраивать "столбиком", но только фишки одного цвета! Пока это поле занято хотя бы одной нашей фишкой, вражеская фишка не может зайти на него. Аналогичные поля на b1, b3, d1 и d3 помогают более эффективно вводить в игру новые фишки.

Другой важной особенностью игры являются поля с "розетками", позволяющие при остановке на них, сделать дополнительный ход. Введение этих полей придаёт игре поистине ураганный характер. Если мы играем группой фишек, не обязательно каждый раз выкидывать "четверки" для того, чтобы "ходить по розеткам". Очень часто удаётся сделать по 2-3 хода, до того, как ход перейдёт к противнику.

Несколько особняком, на мой взгляд, стоит правило, не позволяющее "срубать" перевёрнутую фишку, дошедшую до a2. Можно долго спорить по поводу обоснованности или полезности этого правила, но то, что оно работает - неоспоримый факт. В процессе тестовых прогонов игры неоднократно возникали ситуации, когда выигрыш одной из сторон определялся тем, действует это правило или нет. Мы реализовали его ещё и потому, что оно вносит в игру интригу. Когда противник довёл свою последнюю перевёрнутую фишку до a2, должно очень сильно повезти, чтобы нам удалось у него выиграть. Срубить эту фишку мы никак не можем, а как только у противника выпадет "единичка", игра будет закончена.

Если вы думаете, что на этом сюрпризы игры из Ура заканчиваются, вы ошибаетесь! Почему для игры используются три "кости" D2, а не одна D4? Игровые кости типа <a href="http://skyruk.livejournal.com/pics/catalog/6819/167235">D4</a> (с четырьмя гранями) были широко распространены в древнем мире. Почему в игре не была использована одна "кость" вместо трёх? Это не очевидно на первый взгляд, но при использовании такой игровой схемы, выбрасываемые очки не равновероятны. Единички и двойки выпадают в три раза чаще чем тройки и четверки.

Это самым непосредственным образом влияет на игровой процесс. Позиции на удалении 3-4 клеток от догоняющей фишки противника, гораздо более безопасны, чем расстояние в 1-2 клетки. А ведь нас может догонять не одна, а несколько фишек, кроме того, надо учитывать "безопасные" поля. В общем, эта игра совсем не такая простая, какой кажется на первый взгляд.

Отдельно стоит поговорить об игровом AI. Очень важно, чтобы программа играла примерно на одном уровне с человеком. ZoG-овская реализация, например, играет очень слабо. Часто удаётся выиграть у неё "всухую". Играть с ней не очень интересно. Но если программа будет постоянно выигрывать, это также может "отпугнуть" пользователя. Мы постарались соблюсти баланс. В игре имеется четыре уровня сложности. На самом высоком уровне мне удаётся выиграть примерно в половине партий, с отрывом в 1-2 фишки. Низкий уровень сложности, возможно, будет интересен для "казуальщиков".

Первоначально мы хотели использовать <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%8C%D1%84%D0%B0-%D0%B1%D0%B5%D1%82%D0%B0_%D0%BE%D1%82%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">альфа-бета алгоритм</a> для реализации AI, но быстро отказались от этой идеи. Случайный характер генерации ходов имеет свою специфику. На самом деле, важно только то, чтобы тебя не "съели" (с высокой вероятностью) на следующем ходу. Заглядывать дальше - накладно и, в целом, бесполезно. Для этой игры требуется не "искусственный интеллект", а, скорее, "искусственный инстинкт", но "инстинкт" довольно-таки сложный. Вот какой псевдокод получился у меня в конечном итоге:

<spoiler title="Реализация игрового AI">
<source>
- Segment 1 вес = 0.5
  - level >= 3
    - level < 8
      - Если есть ходы на "розетки", выбрать из них ход, расположенный дальше от старта
    - level >= 8
      - Если есть ход на "розетку" не оставляющий g2 пустой, выбрать ход расположенный дальше от старта

- Segment 2 вес = 0.3
  - level >= 5
    - Если имеются ходы со срубанием перевернутых фишек, выбрать наиболее удаленный от старта
    - Если имеются ходы со срубанием обычных фишек, выбрать ближайший к старту
  - level = 4
    - Если имеются ходы со срубанием, выбрать из них ход, расположенный дальше от старта
  - level >= 8
    - Если есть возможность хода на g2 и поле пусто, идти туда
  - level >= 9
    - Если есть возможность занять g1 или h1, ходим туда
  - level >= 6
    - Если можно вывести фишку с поля, выбрать этот ход
  - level >= 5
    - Если на первых четырёх клетках нет фишек, выбрать ход со стартовой позиции
  - level >= 4
    - Если имеются ходы с блокированием, выбрать случайный из них

- Segment 3 вес = 0.2
  - level < 8
    - level >= 7
      - Если имеется ход на поле не под боем, выбрать любой из них
    - level >= 2
      - Xод фишкой, расположенной дальше от старта
    - level = 1
      - Ход случайно выбранной фишкой
  - level >= 8
    - level = 8
      - Ход на максимальном расстоянии от старта на поле не под боем, не оставляющий g2 пустой
      - Ход на максимальном расстоянии от старта, не оставляющий g2 пустой
    - level = 9
      - Ход на максимальном расстоянии от старта на поле не под боем, не оставляющий g2 пустой, не с g1 или h1
      - Ход на максимальном расстоянии от старта, не оставляющий g2 пустой, не с g1 или h1
    - Любой оставшийся ход
</source>
</spoiler>
Здесь определено 9 игровых уровней, учитывающих различные аспекты текущей позиции. Фактически, в более сложной игре, наподобие Шахмат, подобные эвристики управляли бы порядком перебора ходов (для просмотра "наилучших" ходов в первую очередь). Наша игра проще. В ней эвристики могут использоваться непосредственно для выбора "лучшего" хода. Как я уже говорил выше, этого вполне достаточно, чтобы программа играла примерно на одном уровне с человеком.

Вот она, "Забытая игра Ур", которую мы получили в результате:

<video>http://www.youtube.com/watch?v=WGzVWT5Jk5A&feature=youtu.be</video>

В эту игру действительно приятно играть! Она возвращает меня в те времена, когда мы ходили друг к другу в гости не только для того, чтобы выпить и закусить. Да, тогда и трава была зеленее, и деревья выше, но дело не в этом. Мы почти перестали играть в Шахматы и Шашки. Мы не собираемся семьями, чтобы сыграть в Бридж. Го и Сёги для большинства из нас - недостижимая экзотика. Даже старички-доминошники куда-то пропали со двора. <a href="http://ru.wikipedia.org/wiki/Homo_Ludens">Homo Ludens</a> - "Человек играющий" позабыл про настольные игры. Конечно, разработка всего одной игры под iOS и Android этого не исправит, но, возможно, в какой-то мере поможет вернуть интерес к настольным играм? Я надеюсь на это.
</habracut>

На подступах к Уру

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/ea1/289/aa7/ea1289aa7da247ac169f989d8f4380b1.png"/><i><b>В одном мгновенье видеть Вечность,
Огромный мир - в зерне песка,
В единой горсти - бесконечность,
И небо - в чашечке цветка.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Уильям Блейк

По одной капле воды... - человек, умеющий мыслить логически, может сделать вывод о возможности существования Атлантического океана или Ниагарского водопада, даже если он не видал ни того, ни другого и никогда о них не слыхал.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Артур Конан Дойл "<a href="http://lib.ru/AKONANDOJL/sh_scarl.txt_with-big-pictures.html">Этюд в багровых тонах</a>"</b></i>

Сегодня, я хочу поддержать <a href="http://habrahabr.ru/post/205732/">почин</a> уважаемого <hh user="Unlimion"/> и рассказать о попытке реставрации правил игры, считающейся, на сегодняшний день, древнейшей из известных игр, связанных с перемещением фишек по доске. Доски для этой игры были найдены в 1926-1927 г.г., знаменитым археологом сэром Леонардом Вулли, на раскопках развалин города-государства Ур в Месопотамии. Сама игра датируется 2600-2500 до н.э. Поскольку название игры до сих пор остаётся неизвестным, она именуется в честь города, в котором была найдена.
<habracut>
<img align="right" src="https://habrastorage.org/getpro/habr/post_images/8be/10e/4fe/8be10e4feba94de1b3661c1e59690e75.jpg"/>Как это часто бывает с археологическими находками, комплектов для игры было найдено довольно много, но как в них играть, было совершенно непонятно. Набор для игры включал в себя доску, весьма оригинальной формы, по 7 плоских фишек, для каждого из игроков (одна сторона каждой фишки была помечена 5 точками), а также набор из 3 игровых "костей". Кости также были необычными. Каждая из них представляла собой <a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%82%D1%80%D0%B0%D1%8D%D0%B4%D1%80">тэтраэдр</a>, две из четырёх вершин которого были окрашены в белый цвет. Чуть позже, археолог Ирвин Финкель нашёл глиняную табличку со сводом правил.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/457/d75/07b/457d7507bfe7a038f49cf995b3199840.png"/>Впрочем, какой то особой ясности она не внесла. Прочитать её, в наше время, могут немногие, а древние летописцы, по всей видимости, не особенно утруждали себя описанием вопросов, считавшихся им очевидными. Кроме того, вообще нет уверенности в том, что найденная табличка описывала ту самую игру. В то же время, вопрос о правилах стоял остро, поскольку Британский музей был весьма заинтересован в продажах сувенирных копий игры. Археологами было предложено несколько <a href="http://skyruk.livejournal.com/211326.html">вариантов</a>, обладавших, к сожалению, одним "фатальным недостатком". Эти, во многих отношениях, безусловно, весьма уважаемые люди, по всей видимости, никогда не пытались играть по тем правилам, что они предложили. Исправить эту досадную оплошность взялся наш соотечественник, писатель-фантаст, историк настольных игр и просто очень хороший человек - <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрий Скирюк</a>. Скажу сразу, что из всех предложенных вариантов правил, его вариант представляется мне наиболее интересным, в игровом отношении.

<a href="http://skyruk.livejournal.com/231444.html?thread=4494868">Статья</a> Дмитрия представляет собой великолепный образчик применения "дедуктивного метода" в реальной жизни и сделала бы честь самому Шерлоку Холмсу. На мой взгляд, он предложил правила, объясняющие практически всё:

<ul>
	<li>Странную форму доски и её разметку</li>
	<li>Использование для игры плоских фишек</li>
	<li>Использование пометок на фишках</li>
	<li>Непривычный набор игровых "костей"</li>
</ul>
Геймплей полученной игры великолепен. Конечно возможно, что древние шумеры играли в неё как то иначе, но, в этом случае, я считаю, что они просто сами себя наказали. После знакомства с предложенными правилами, просто невозможно представить себе, что в эту игру можно играть по другому.

<img src="https://habrastorage.org/getpro/habr/post_images/162/8f2/b85/1628f2b850141153c56cc0438ec32b50.jpg"/>

Итак, каждый игрок имеет по семь фишек. Цель игры - провести каждую из фишек по показанной выше траектории, убрав их, тем самым, с доски. Для выполнения последнего хода, убирающего фишку с доски, требуется "точный" бросок. Легко заметить, что по центральной (общей для игроков) линии, каждая фишка движется сначала по направлению к малому блоку, а затем, в противоположном направлении. 

Для того, чтобы не запутаться в направлениях движения, после прохождения "поля превращения" (крайняя, ближняя к игроку клетка в малом блоке), фишка переворачивается. Фишки могут "рубить" друг друга, встав на занятую клетку (срубленная фишка возвращается в стартовый набор игрока), но Дмитрий предполагает, что рубить друг друга могут только одинаковые фишки - перевёрнутая не может "рубить" не перевёрнутую и наоборот. От себя могу заметить, что это действительно делает игру более интересной. В одних случаях вражеские фишки представляют собой цель, в других - препятствие.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/be9/46c/b66/be946cb666f142fc9dc7f3130ef69ab8.png"/>На какое число шагов может сдвинуться фишка, определяет бросок "костей". Дмитрий предлагает следующую интерпретацию результатов этих бросков:

<ul>
	<li>Одна пирамидка из трёх упала белой вершиной вверх - можно передвинуть любую фишку на одну клетку или выставить на первое поле доски одну из фишек стартового набора</li>
	<li>Две белых вершины вверх - две клетки или выставление новой фишки на вторую клетку</li>
	<li>Три белых вершины - ход на три клетки или третья позиция по ходу движения на доске</li>
	<li>Все пирамидки упали чёрной стороной вверх - ход на четыре клетки или выставление фишки на первую по движению "розетку"</li>
</ul>
Странный набор "костей" вполне осмысленен. Вместо трёх костей с двумя возможными состояниями, можно было бы использовать одну с четырьмя (хотя бы тот же тэтраэдр, раскрашенный в 4 цвета), но, в этом случае, все возможные результаты бросков были бы равновероятны. В случае использования набора из трёх костей, одно и двухочковые броски более вероятны чем выброс трёх или четырёх очков. Этот факт самым непосредственным образом влияет на игровой процесс.

При такой интерпретации ходов, "розетки" обретают смысл. Дмитрий предполагает, что остановившись на такой клетке, игрок имеет право сделать дополнительный ход. Выбрасывая одни "четверки", можно быстро пробежать через всю доску, не дав противнику даже возможности хода! Даже выбрасывая очки отличные от "четвёрок", мне удавалось, двигаясь несколькими фишками, делать подряд 3-4 хода. Игра превращается в настоящую битву за "розетки".

<video>https://www.youtube.com/watch?v=XLmDzqquyQU</video>

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/c20/68b/124/c2068b124abe561c40a65b32c5e0d970.jpg"/>Даже в таком виде, правила вполне играбельны, но Дмитрий пошёл дальше, постаравшись объяснить разметку остальных полей. По его версии, единственной причиной использования для игры плоских фишек является возможность установки их друг на друга. Но возможность "срубания" вражеских фишек также является очень важной в тактическом отношении. Возможно, "срубать" фишки можно, но не везде? Поля, имеющие странную разметку с четырьмя "глазами", расположены в очень удобных местах, позволяющих "разгрузить" доску, избежав излишних "заторов" в игре. По версии Дмитрия, на этих полях, фишки можно выстраивать в столбик, до четырёх штук, но при условии, что все они одного цвета. Сходным образом могут работать поля с разметкой из четырёх групп по пять точек (напомню, что аналогичным образом помечена одна из сторон у каждой игровой фишки). На этих полях можно выстраивать "столбики" из фишек любого цвета, таким образом, запирая вражеские фигуры (ходить может только верхняя фишка в столбике).

Понятно, что здесь мы вступаем в область предположений, но с введением этих правил, игра буквально обретает новое измерение. Дополнительно, Дмитрий вводит правило, не позволяющее "срубать" перевёрнутую фишку, стоящую на последней клетке доски. Поскольку это поле "запирает" выход не перевёрнутых фишек с начальных полей, в тактическом отношении, это правило также интересно.

Впервые прочитав про "Ур", я загорелся целью реализовать его. В самом деле, я видел несколько вариантов <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BD%D0%B5%D1%82">Сенета</a>, но ни одной реализации Ура мне найти не удалось. А ведь эта игра не менее интересна! В техническом отношении, работа над игрой полностью оправдала все мои ожидания. Мне пришлось повозиться и с необычным "превращением" фишек (фишка переворачивается не при установке на поле превращения, а при прохождении через него) и с выстраиванием фишек в столбик. Историю всех этих мытарств желающие могут посмотреть на <a href="https://github.com/GlukKazan/ZoG/commits/master/Rules/07.Ur.zrf">GitHub</a>-е. Практически под занавес, <a href="http://zillionsofgames.com/">ZoG</a> нанёс свой удар:

<img src="https://habrastorage.org/getpro/habr/post_images/b03/1df/6be/b031df6bea52d0c03e4046872b8d0aa6.png"/>

Под конец игры, в результате постоянного "срубания" и возвращения в игру фишек, накапливается "критическая масса" повторяющихся позиций. ZoG отсчитывает третье повторение и объявляет, что игра закончилась вничью! Могу сказать, что это очень обидно, практически закончив игру, на последнем ходу, узнать, что, по мнению программы, произошла ничья. Самое печальное, что отменить эту проверку (очевидно не имеющую большого смысла в играх со случайной генерацией) никак нельзя. Нельзя даже увеличить значение количества повторений, при котором игра завершается! Это именно то, что я называю <a href="http://habrahabr.ru/post/221779/">тёмной стороной ZRF</a>.

Мне пришлось добавить варианты игры с рандомным противником (поскольку игры для одного игрока рассматриваются в ZoG как головоломки, в них, по понятным причинам, отключен контроль повторения позиций), попутно отказавшись от использования весьма удобного предиката <b>friend?</b> (внезапно выяснилось, что у рэндома нет друзей). В конечном итоге, все проблемы с реализацией удалось решить, вернув к жизни игру, в которую, возможно, играли 5000 лет назад.

<i><b>Мы очень многое забыли...
Но мы вспоминаем потерянное...
Или создаём что то новое</b></i>
</habracut>

Тёмная сторона ZRF

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/781/ba3/9a2/781ba39a2338bbc0815f8a69a7d3ca07.jpg"/>У тех, кто читал цикл моих <a href="http://habrahabr.ru/post/211100/">статей</a>, посвященных <a href="http://zillionsofgames.com/">Zillions of Games</a>, могло сложиться впечатление, что я полностью удовлетворен этим продуктом. Разумеется, это не так. ZoG уникален тем, что позволяет быстро и практически "на коленке" разработать прототип почти любой логической игры, но это вовсе не означает, что он идеален. Сегодня, я хочу рассказать о том, что мне не нравится в этом проекте.
Конечно, эта критика нужна не сама по себе. Я вполне отдаю себе отчет в том, что при полностью остановившейся разработке продукта (кстати, это один из тех моментов, которые мне не нравятся), подобная критика, как средство обратной связи с разработчиком, совершенно бесполезна. Поэтому, я не собираюсь писать каких либо писем создателям продукта - паровоз уже давно ушёл.

ZoG показал возможное направление действий, саму возможность создания подобного универсального игрового движка, но, если хочешь, чтобы что-то было сделано, делать это придется самому. Работа эта не простая и я совсем не уверен, что мне удастся с ней справиться (по крайней мере в одиночку). В любом случае, в качестве самого первого шага, будет полезно разобраться, чем плохо то, что уже имеется. Для чего затевать разработку нового продукта? Я постараюсь рассказать об этом ...
<habracut>
<img align="right" src="https://habrastorage.org/getpro/habr/post_images/3c5/642/2ca/3c56422ca18c006cbbb91611776f61af.jpg"/>По сравнению с тем многообразием всевозможных правил, о котором я рассказывал в предыдущей <a href="http://habrahabr.ru/post/219989/">статье</a>, концепция <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Шахмат</a> выглядит очень простой. Отчасти, эта иллюзия поддерживается тем, что, большинство из нас, знакомо с Шахматами с раннего детства. Конечно, эта простота обманчива! И дело здесь даже не в экзотических правилах "<a href="http://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятия на проходе</a>" и <a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировки</a> (из-за которой в ZRF пришлось добавить команды <b>cascade</b> и <b>set-attribute</b>). Я предлагаю разобраться с более глубоким вопросом, лежащим в основе самой игры. Что должен делать Король, оказавшись под шахом?

Во первых, оставаться под шахом Король не может! Следующим ходом мы обязаны устранить угрозу (если это невозможно, ситуация имеет другое название - мат). Мы можем уйти Королем на поле не находящееся под боем, закрыться от шаха другой фигурой (это невозможно если шах поставлен Конем) или съесть атакующую фигуру. С последним вариантом все тоже не просто. Съесть атакующую фигуру Королем возможно только при условии, что она не защищена другой фигурой, а в случае двойного шаха, есть одну из атакующих фигур, не уводя Короля из под боя другой, также невозможно. Все это может показаться очевидным, но я хочу, чтобы было понятно, что реализация такого поведения может оказаться очень сложной. Как это реализуется в ZRF?

очень просто:

<source lang="lisp">
(loss-condition (White Black) (checkmated King))
</source>
Если в условии поражения игрока фигурирует волшебное слово <b>checkmated</b>, ядро программы <b>знает</b> как фиксировать мат, а, заодно, и то, как нужно уводить Короля из под шаха. Но подобное "зашивание" столь сложной логики в ядро продукта может оказаться не самой удачной мыслью, при реализации универсального движка. Само понятие мата имеется далеко не во всех играх семейства Шахмат, а уводить Короля из под "шаха" в них, все равно, приходится. Я уже рассказывал <a href="http://habrahabr.ru/post/213391/">ранее</a>, что логика обработки <b>checkmated</b>, может привести к не вполне адекватному поведению Короля, а отказ от использования этого условия, практически полностью ломает в ZoG всю игру в эндшпиле.  

Вполне закономерно, что ситуация с правильным матованием осложняется в различных "национальных" разновидностях Шахмат. Так в <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a>, запрещено ставить мат сбросом пешки (при этом можно ставить мат обычным ходом пешки и шаховать сбросом пешки), а в <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D0%B0%D1%80_%D0%B8_%D1%85%D0%B8%D0%B0%D1%88%D0%B0%D1%82%D0%B0%D1%80">Шатар</a>, процесс матования еще более запутан (например, нельзя ставить мат Конем). Очевидно, что возможностей одного единственного ключевого слова <b>checkmated</b> совершенно недостаточно для корректного описания правил этих игр. 

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/614/7cc/0f7/6147cc0f70458f80cf5244ab61b9c322.jpg"/>С Шашками все тоже совсем не гладко. Главным отличием от Шахмат является обязательность взятия и возможность серии взятий. Для реализации этих правил, в ZRF введены частичные ходы (<b>add-partial</b>) и приоритеты ходов (<b>move-priorities</b>). Механизм приоритетов не очень удобен в использовании, но работает. Игрок не сможет выполнить не приоритетный ход, если имеет возможность приоритетного хода. Но на этом дело не ограничивается! В некоторых разновидностях Шашек (например в международных 100-клеточных Шашках), из всех возможных ходов со взятием, игрок должен выбрать вариант берущий максимальное количество фигур (при этом, особым образом могут учитываться или не учитываться дамки).

Эта логика вновь зашита в ядро:

<source lang="lisp">
(option "maximal captures" true)
</source>
Кроме этой опции, имеется ряд других опций, используемых AI ZoG:

<ul>
	<li><b>"include off-pieces"</b> - включающая или отключающая учет фигур находящихся в резерве при определении условий победы и поражения</li>
	<li><b>"pass partial"</b> - управляющая возможностью прерывания цепочки взятий, формируемой командой <b>add-partial</b></li>
	<li><b>"pass turn"</b> - управляющая возможностью пропуска хода</li>
	<li><b>...</b></li>
</ul>
В качестве управляющего параметра, опции передаётся булевское значение, включающее или отключающее опцию. Для некоторых опций, разрешено передавать значение <b>2</b> или <b>forced</b>. Например, следующая команда:

<source lang="lisp">
(option "maximal captures" 2)
</source>
... включает режим "максимального взятия" с учетом дамок. 

Какой либо системы в списке предоставляемых опций нет. Более того, в том же списке присутствуют опции, не имеющие к AI никакого отношения, например "<b>animate captures</b>", "<b>highlight goals</b>", "<b>show moves list</b>",... Этот механизм вряд ли можно назвать универсальным.

Подобное отсутствие системного подхода проходит через весь ZRF "красной нитью". Например, для определения позиций типа "3 в ряд" имеется удобная команда <b>relative-config</b>. Вот как она используется в "<a href="http://ru.wikipedia.org/wiki/Zillions_of_Games">Крестиках-ноликах</a>":

<source lang="lisp">
(win-condition (X O)
	  	(or (relative-config man n man n man)
                    (relative-config man e man e man)
                    (relative-config man ne man ne man)
                    (relative-config man nw man nw man)
		)
</source>
Просто и удобно. Проблема только в том, что эту команду разрешено использовать только внутри проверок завершения игры <b>win-condition</b>, <b>loss-condition</b> или <b>draw-condition</b>. Кроме того, она реагируют на любое возникновение указанной конфигурации (не важно на чьём ходу оно происходит). В результате, в реализации "<a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=956">Мельницы</a>" приходится городить:

<spoiler title="трехэтажные проверки">
<source lang="lisp">
(define Check-for-3
     (set-flag first? false)
     (set-flag second? false)
     (set-flag third? false)
     (set-flag fourth? false)

     a1 
     (while (and (on-board? next)(not-flag? fourth?)) 
        (if friend? 
           (if (not-flag? first?)  
             (set-flag first? true)
           else
             (if (not-flag? second?) 
               (set-flag second? true)
             else
               (if (not-flag? third?) 
                 (set-flag third? true)
               else
                 (set-flag fourth? true)
               ) 
             )
           )
        )
        next
     )
     (verify (not-flag? fourth?)) 
     
     (if (am-Black?)
       (change-type Jumping z0)   ;set permanent flag
     else
       (change-type Jumping z1)   ;set permanent flag
     )
)
</source>
</spoiler>
Чем-то подобным пришлось заниматься и мне, при реализации одного из вариантов <a href="http://habrahabr.ru/post/212835/">Thud</a>. А ведь возможность использования аналога <b>relative-config</b>, при выполнении хода, была бы очень полезна во многих играх, например в <a href="http://skyruk.livejournal.com/274559.html">Чатуранга</a> с её "триумфом слонов". В <a href="http://en.wikipedia.org/wiki/Hasami_shogi">Hasami Shogi</a> подобная возможность позволила бы корректно реализовать <a href="http://www.youtube.com/watch?v=5EcpCGDu1Bw&list=PL587865CAE59EB84A">сложные правила</a> запирания фигур у края и в углу доски. 

Еще одной крайне полезной возможностью могла бы стать реализация команд <b>mark/back</b> <a href="http://www.di.fc.ul.pt/~jpn/cv/ZRF2.htm">без ограничения уровня вложенности</a>. Команда <b>mark</b> запоминает текущую позицию в процессе рассчета хода, а <b>back</b> позволяет в нее вернуться. Казалось бы, что может быть естественней чем использование стека для сохранения позиций? Но нет, вложенные вызовы <b>mark</b> не поддерживаются! Жаль, было бы удобно...

Но, вернёмся к фундаментальному. Что происходит в Шахматах если мы ставим фигуру на поле, занятое фигурой противника? Это всем известно - фигура противника будет удалена с доски. Именно так все и реализовано в ZoG (и изменить такое поведение нельзя). Если мы даём команду <b>add</b> на занятом поле, то фигура, которая размещалась там ранее, будет удалена с доски. Выполнять команду <b>capture</b> при этом не нужно (более того, если мы выполним <b>capture</b>, будет удалена та фигура, которой мы ходим). Ячейка доски не может содержать более одной фигуры. 

Но ведь это верно далеко не для всех игр! Например, в "<a href="http://cyclowiki.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Русских шахматах</a>" было бы гораздо удобнее хранить в ячейке доски упорядоченный список фигур. То же касается "<a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%BE%D0%BB%D0%B1%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">Столбовых шашек</a>". Конечно, я не могу сказать, что это послужило непреодолимым препятствием при реализации последних. Столбовые шашки были <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1767">реализованы</a>, но сложность решения не сказалась положительно ни на его производительности ни на качестве игры.

И это не единственная (и даже не самая главная) беда команды <b>add</b>! В ZRF, команды семейства <b>add</b> совмещают в себе две функции:

<ol>
	<li>Указание поля на которое помещается фигура, выполнившая ход</li>
	<li>Завершение формирования варианта (или части) хода</li>
</ol>
Вы уже понимаете в чем проблема? Из этого совершенно неуместного объединения двух принципиально различных действий в одной команде, немедленно следует, что ход (перемещение или сброс) должен завершаться постановкой своей фигуры на какое-то поле доски (при этом, могут быть съедены другие фигуры). Других вариантов нет! Попробуйте реализовать на ZRF <a href="http://en.wikipedia.org/wiki/Andernach_chess">Андернах</a>. Я пробовал трижды, ничего не получилось! Дело в том, что, в этом варианте игры, при взятии, фигура меняет цвет, на цвет взятой фигуры. Это означает, что ход мы завершаем уже не своей фигурой...

Стоило разработчикам разделить команду <b>add</b> на собственно команду постановки фигуры на доску и команду явного завершения хода (<b>end-move</b> например) и кучи проблем удалось бы избежать! Например, были бы возможны взятия фигур противника без перемещения своих фигур. Кстати, в ZSG (нотации ходов ZoG) такая возможность имеется, но используется она только для "первоначальной настройки" доски. В общем, этот момент, действительно, серьезно осложняет процесс разработки с использованием ZRF.

То, что ходить можно только своей фигурой, также не всегда верно. Например в "<a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A1.D1.82.D0.B0.D0.B2.D1.80.D0.BE.D0.BF.D0.BE.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">Ставропольских шашках</a>", игрок может ходить фигурами противника. В ZRF этого можно добиться, сделав все фигуры нейтральными (принадлежащими третьему игроку, не участвующему в игре), но такое решение совсем не очевидно и довольно громоздко.

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/6d1/d1f/86c/6d1d1f86c70fb3e01927b6072f6c867b.jpg"/>Еще одним недостатком ZRF является полное отсутсвие в нём каких либо арифметических операций. Это не страшно, пока мы ограничиваемся Шахматами и Шашками, но существуют игры, в которых выполнение арифметических действий необходимо, при рассчете хода! Конечно, я говорю о <a href="https://en.wikipedia.org/wiki/Rithmomachy">Ритмомахии</a>. Эта средневековая игра не особенно популярна в наше время, но она определенно бросает вызов универсальности игрового "движка". Вот при каких условиях может производиться бой фигур в этой игре:

<ul>
	<li>Если числовое значение совпадает со значением фигуры выполняющей бой</li>
	<li>Если результат умножения числового значения фигуры на количество пустых клеток, отделяющих её от фигуры противника, совпадает со значением этой фигуры</li>
	<li>Если числовое значение фигуры совпадает с суммой значений окруживших её фигур противника</li>
	<li>Если фигура окружена фигурами противника со всех четырёх сторон (по вертикали и горизонтали)</li>
</ul>
Арифметика может пригодиться не только при рассчете хода. В <a href="https://play.google.com/store/apps/details?id=air.hirobado.mod">этой</a> игре, например, для определения победителя, требуется рассчитать площадь всех квадратов, построенных на доске. Также, может быть полезна возможность связывания с фигурами и полями доски числовых значений (например hitpoint-ов). ZRF позволяет привязывать к фигурам только булевские значения (атрибуты), что касается полей, булевские флаги, привязываемые к ним, могут быть использованы только локально, при рассчете хода. Глобальные числовые значения (не привязанные к полям или фигурам), могли бы быть использованы для реализации разнообразных счетчиков (например игрового времени).

В стандартном ZoG нет таких возможностей, но они реализованы в <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1452">Axiom Development Kit</a>. Об этом стоит рассказать подробнее. Дело в том, что ZoG позволяет использовать <a href="http://zillionsofgames.com/progsample.html">расширения</a>, которые можно разрабатывать, например, с использованием С++. Платой за использование таких расширений является полный отказ от использования встроенного AI ZoG. Фактически, расширение использует ZoG исключительно как средство визуализации ходов. При разработке такого расширения, об AI приходится заботиться самостоятельно.

Разумеется, эта возможность мало подходит для рядовых пользователей ZoG. Разработчики Axiom позаботились о них, предоставив вместе с расширением, AI собственной разработки. Помимо всего прочего, этот вариант AI гораздо лучше штатного справляется с играми на "захват территории" и "соединение", такими как <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1471">Hex</a>. Кроме того, в качестве языка программирования, Axiom использует <a href="http://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth Script</a>, предоставляющий поддержку арифметических операций. 

К сожалению, являясь расширением ZoG, Axiom вынужден использовать интерфейс, разработанный для взаимодействия с расширениями. Я позволю себе привести ёго здесь:

<spoiler title="Engine.h">
<source lang="cpp">
// Engine.h
//
// Copyright 1998-2000 Zillions Development
//
// Header file for plug-in DLL engine to Zillions

#include "EngineDLL.h"

DLL_Result FAR PASCAL DLL_Search(long lSearchTime, long lDepthLimit, long lVariety,
    Search_Status *pSearchStatus, LPSTR bestMove, LPSTR currentMove,
    long *plNodes, long *plScore, long *plDepth);
DLL_Result FAR PASCAL DLL_MakeAMove(LPCSTR move);
DLL_Result FAR PASCAL DLL_StartNewGame(LPCSTR variant);
DLL_Result FAR PASCAL DLL_CleanUp();
DLL_Result FAR PASCAL DLL_IsGameOver(long *lResult, LPSTR zcomment);
DLL_Result FAR PASCAL DLL_GenerateMoves(LPCSTR moveBuffer);
</source>
</spoiler>
<spoiler title="EngineDLL.h">
<source lang="cpp">
// EngineDLL.h
//
// Copyright 1998-2000 Zillions Development
//
// Shared DLL plug-in for DLL engine and Zillions

#include "windows.h"

typedef enum {
    kKEEPSEARCHING = 0,
    kSTOPSOON = 1,
    kSTOPNOW = 2
} Search_Status;

typedef enum {
    DLL_OK = 0,
    DLL_OK_DONT_SEND_SETUP = 1, // only supported in 1.0.2 and higher!

    DLL_GENERIC_ERROR = -1,
    DLL_OUT_OF_MEMORY_ERROR = -2,
    DLL_UNKNOWN_VARIANT_ERROR = -3,
    DLL_UNKNOWN_PLAYER_ERROR = -4,
    DLL_UNKNOWN_PIECE_ERROR = -5,
    DLL_WRONG_SIDE_TO_MOVE_ERROR = -6,
    DLL_INVALID_POSITION_ERROR = -7,
    DLL_NO_MOVES = -8
} DLL_Result;

enum {
    UNKNOWN_SCORE = -2140000000L,
    LOSS_SCORE = -2130000000L,
    DRAW_SCORE = 0,
    WIN_SCORE = 2130000000L
};

// ***** REQUIRED ROUTINES

// DLL_Search
//
// The DLL should search from the current position. If it returns DLL_OK it should
// also return the best move found in str; however, it should not make the move
// internally. A separate call to MakeAMove() will follow to make the move the
// engine returns.
//
// -> lSearchTime: Target search time in milliseconds
// -> lDepthLimit: Maximum moves deep the engine should search
// -> lVariety: Variety setting for engine. 0 = no variety, 10 = most variety
// -> pSearchStatus: Pointer to variable where Zillions will report search status
// -> bestMove: Pointer to a string where engine can report the best move found so far
// -> currentMove: Pointer to a string where engine can report the move being searched
// -> plNodes: Pointer to a long where engine can report # of positions searched so far
// -> plScore: Pointer to a long where engine can report current best score in search
// -> plDepth: Pointer to a long where engine can report current search depth
//
// Returns DLL_OK or a negative error code 

typedef DLL_Result (FAR PASCAL *SEARCH)(long lSearchTime, long lDepthLimit, long lVariety,
    const Search_Status *pSearchStatus, LPSTR bestMove, LPSTR currentMove,
    long *plNodes, long *plScore, long *plDepth);


// DLL_MakeAMove
//
// The DLL should try to make the given move internally.
//
// -> move: notation for the move that the engine should make
//
// Returns DLL_OK or a negative error code 

typedef DLL_Result (FAR PASCAL *MAKEAMOVE)(LPCSTR move);


// DLL_StartNewGame
//
// The DLL should reset the board for a new game.
//
// -> variant: The variant to be played as it appears in the variant menu
//
// Returns DLL_OK, DLL_OK_DONT_SEND_SETUP, DLL_OUT_OF_MEMORY_ERROR, or
//   DLL_GENERIC_ERROR

typedef DLL_Result (FAR PASCAL *STARTNEWGAME)(LPCSTR variant);

// DLL_CleanUp
//
// The DLL should free memory and prepare to be unloaded.
//
// Returns DLL_OK, DLL_OUT_OF_MEMORY_ERROR, or DLL_GENERIC_ERROR

typedef DLL_Result (FAR PASCAL *CLEANUP)(void);


// ***** OPTIONAL ROUTINES

// DLL_IsGameOver
//
// This optional function is called by Zillions to see if a game is over.  If 
// not present, Zillions uses the goal in the ZRF to decide the winner.
//
// -> lResult: Pointer to the game result which the DLL should fill in when
//              called.  If the game is over the routine should fill in WIN_SCORE,
//              DRAW_SCORE, or LOSS_SCORE.  Otherwise the routine should fill in
//              UNKNOWN_SCORE.
// -> zcomment: Pointer to a 500-char string in Zillions which the DLL can optionally 
//              fill in, to make an announcement about why the game is over, such
//              as "Draw by third repetition".  The DLL should not modify this 
//              string if there is nothing to report.
//
// Returns DLL_OK or a negative error code 

typedef DLL_Result (FAR PASCAL *ISGAMEOVER)(long *lResult, LPSTR zcomment);


// DLL_GenerateMoves
//
// You can use GenerateMoves in your DLL to tell Zillions the legal moves for 
// any position in the game.
//  
// -> moveBuffer: Pointer to a 1024-char sting which the DLL should fill in when
//              called.  Initial call should be with moveBuffer set to "".  Each call 
//              to GenerateMoves should fill in the next available move from the 
//              current position, with a final "" when no more moves are available.
//              All moves must be in valid Zillions move string format.
//
// Returns DLL_OK or a negative error code 

typedef DLL_Result (FAR PASCAL *GENERATEMOVES)(LPCSTR moveBuffer);
</source>
</spoiler>
Как можно видеть, этот интерфейс предназначен исключительно для передачи ядру ZoG, ходов, сгенерированных AI. Ход должен формироваться (в недокументированной) ZSG-нотации. Дополнительно, расширение может определять условие завершение игры, но оно не занимается контролем корректности ходов - эта часть остаётся в ZRF! Из этого простого факта следует, что все недостатки ZRF, о которых я говорил выше (за исключением отсутствия поддержки арифметики) остаются в силе.

На самом, деле, в случае Axiom, ситуация еще хуже. Интерфейс взаимодействия с расширениями не предоставляет доступа к правилам игры, написанным на ZRF (напомню, что без них мы обойтись не можем). Поскольку Axiom AI, для своей работы, должен иметь доступ к этим правилам, их приходится <b>дублировать</b> на языке Forth Script! Имеется, правда, утилита, автоматизирующая этот процесс. Всё это превращает разработку, с использованием Axiom, в совсем не простое дело.

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/9d5/d81/716/9d5d817168bafb37bf3773ad09a598b0.jpg"/>Продолжая свой рассказ о недостатках ZRF, я просто не могу пройти мимо <a href="http://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%D1%81_%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B9_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B5%D0%B9#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B_.D0.B8.D0.B3.D1.80_.D1.81_.D0.BD.D0.B5.D0.BF.D0.BE.D0.BB.D0.BD.D0.BE.D0.B9_.D0.B8.D0.BD.D1.84.D0.BE.D1.80.D0.BC.D0.B0.D1.86.D0.B8.D0.B5.D0.B9">игр с неполной информацией</a>. На ZRF имеются реализации <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1524">таких</a> <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=201">игр</a>, но являются ли они честными? Они всего лишь скрывают часть информации от <b>человека</b>. AI прекрасно видит все фигуры! Согласитесь, подобная игра "в одни ворота" имеет мало общего с тем, когда неполную информацию имеют все игроки. Видимо, это одна из причин, по которой для ZoG реализовано так мало карточных игр. Не очень интересно играть с тем, кто знает все твои карты. Имеется и другая сторона этого вопроса. Я уже не раз <a href="http://habrahabr.ru/post/213391/">упоминал</a> о <a href="http://www.battlevschess.com/en/">Battle vs Chess</a>. Большая часть миссий в кампании этой игры построены на том, что человек и компьютер играют по разным правилам. Например в миссии "Точка невозврата" требуется заманивать фигуры противника на мины, расположенные на поле. Но если AI будет знать расположение мин, он просто не будет ходить на эти поля! Какой смысл делать ход, в результате которого просто теряешь фигуру? Чтобы игра протекала так, как она задумана разработчиками, компьютер должен "думать", что он играет по обычным правилам. Это тоже вариант игры с неполной информацией.

Еще одна больная тема ZRF - отсутствие поддержки коалиций. Хорошим "пробным камнем", в этом отношении, могут послужить <a href="http://ru.wikipedia.org/wiki/%D0%95%D0%BD%D0%BE%D1%85%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B">Енохианские шахматы</a>. Эта игра играется "пара на пару". Союзные короли не угрожают друг другу и могут запросто находиться на соседних клетках. Если один из королей союзников взят (мата в Енохианских шахматах нет), его фигуры "замораживаются". Они не могут ходить, их нельзя брать. Они просто стоят и блокируют поля. Но второй король может вернуть себе контроль над этими фигурами, взойдя на "престол" потерянного союзника! В результате, очередность ходов остаётся прежней, но игрок ходит "за себя, и за того парня". Очень сложно реализовать всё это в ZRF.

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/cc2/605/060/cc2605060350a4029bca4bc2233f92ed.jpg"/>Мы много говорили об AI, теперь можно немножко поговорить о том, что может показаться не очень важным - об оформлении. В качестве иллюстрации, я предлагаю рассмотреть игру <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=821">Суракарта</a>. Да, она реализована на ZRF, но попробуйте понаблюдать за тем, как она <a href="http://www.youtube.com/watch?v=2itOq_vh9jY">играет</a>. Всё понятно? Мне не очень. Взятие, в этой игре, осуществляется по совершенно уникальным правилам. Фигура должна "прокатиться" по одной или нескольким боковым петлям и ударить фигуру противника сзади. Но ZoG не умеет анимировать такое сложное движение! В результате, партия превращается в ребус. Было бы неплохо, на уровне игры, иметь возможность подключать свой визуализатор. Но, даже в ZRF-файле, правила визуализации перемешаны с правилами AI. Понятно, что разработчикам так было легче, но теперь, 3D-визуализацию, так просто, уже не подключить (хотя бы потому, что для неё нужны совсем другие ресурсы).

Резюмируя эту длинную статью, можно заметить, что большая часть проблем упирается в закрытые исходные коды продукта. Если бы исходные коды были открыты, можно было бы "допилить" функциональность и "прикрутить" свои визуализаторы. Можно было бы добиться лучшей игры, для отдельных игр, вроде Шахмат, добавив свои библиотеки дебютов и эвристики. Можно было бы портировать продукт на различные платформы, включая iOS и Android. Но исходников нет. И если нам придётся писать свои, стоит не забывать о том, что не следует повторять чужие ошибки. Стоит сделать исходники открытыми!
</habracut>

История шашек (в иллюстрациях)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/274/d7c/7c5/274d7c7c5756a456206a1f4c46cd09c6.jpg" alt="image"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Эволюция? - оживился Главный. - Что-то новенькое?

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Французская выдумка. Я в этом пробовал разобраться. Если, к примеру, взять дождевого червя и вместо него сразу подсунуть африканского носорога, то все увидят, что их надули. Но если тот же фокус растянуть надолго, то никто и не заметит. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом вся штука: кто видел червяка - все давно повымерли, а кому встретился носорог - тому некогда рассуждать о всяких пустяках.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Евгений Чемеревский "<a href="http://www.proza.ru/2010/10/22/698">Вариации на тему черепахи</a>"</i></b>

Так всегда бывает, когда чем то интересуешься. Чем больше узнаешь, тем больше появляется возможностей узнать что то новенькое. Потом нескончаемый поток этого самого новенького захлестывает тебя с головой, и ты начинаешь тонуть. Но пока это не произошло - жизнь прекрасна.

Я хочу рассказать о том, с чем знакомы почти все. О том, чем мало кто интересуется. О том, о чем никто практически ничего не знает. Я хочу рассказать о <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">Шашках</a>. Не спешите ухмыляться. Если вы думаете, что знаете о Шашках все, ответьте (для себя) на несколько простых вопросов:

<ul>
	<li>Какие разновидности Шашек существуют?</li>
	<li>Чем отличаются Шашки от Шахмат?</li>
	<li>Что общего у Шашек и "Крестиков-ноликов"?</li>
</ul>
Эти вопросы кажутся вам глупыми? Это нормально, мне тоже казались ... пока я не заинтересовался историей Шашек
<habracut>
Я всегда интересовался логическими играми, но разнообразие всевозможных правил привлекало меня больше чем сам процесс игры. Правда материальная база подкачала. Сами посудите, поиграть с кем то (да хоть и самому с собой) в Шашки или в Шахматы не сложно. Доска и комплекты фигур продаются в любом специализированном магазине. С <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%91%D0%B3%D0%B8">Сёги</a> или <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%8F%D0%BD%D1%86%D0%B8">Сянцы</a> все гораздо сложнее. В магазинах этих игр не найти (по крайней мере у нас в глубинке), а собственные конечности, прямо скажем, больше приспособлены для нажимания кнопок, чем для обработки дерева.

Разумеется, в наше время, почти для любой игры можно найти компьютерную программу. Ключевых слов в этой фразе ровно два - <b>найти</b> и <b>почти</b>. Именно поэтому я так обрадовался, когда обнаружил <a href="http://zillionsofgames.com/">ZoG</a>. Да, она не очень сильна в Шахматах, но зато позволяет запрограммировать практически любую игру своими силами (чем очень многие не замедлили <a href="http://zillionsofgames.com/games/index.html">воспользоваться</a>). Наткнувшись на этот клондайк настольного игростроя я невольно заинтересовался логическими играми (в том числе историей их развития) более серьезно.

Долго ли, коротко ли, но после продолжительного шатания по википедиям и тематическим форумам, я наткнулся на замечательный <a href="http://skyruk.livejournal.com">блог</a> <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B8%D1%80%D1%8E%D0%BA,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%98%D0%B3%D0%BE%D1%80%D0%B5%D0%B2%D0%B8%D1%87">Дмитрия Скирюка</a>. Забавно, что вышел я на этот блог в поисках внятного описания некой средневековой игры под названием <a href="http://ru-boardgames.livejournal.com/176430.html">Ритмомахия</a>. Вот что, по этому поводу, <a href="http://skyruk.livejournal.com/334947.html?thread=5808483">написал</a> сам Дмитрий:

<blockquote>... Ритмомахия, признаюсь, меня заинтересовала. Я начал копать в этом направлении, и прямо скажем, не очень преуспел, зато наткнулся на след, который привёл меня к Чейзу ...</blockquote>
Ну, как я уже говорил, если что то ищешь, то очень часто находишь совсем не то что искал. Зато я познакомился с "Чейзом". Скажу сразу, размещение описания этой игры в теме "История шашек" меня озадачило. Для начала, я понял, что практически ничего не знаю о Шашках. Это, впрочем, не удивительно. Как, вероятно, и большинство моих соотечественников знаю я о Шашках с детства, но, при этом, никогда не рассматривал эту игру как что то серьезное (такое, как например, Шахматы). 

Каюсь, <b>я был не прав</b> ... Тематический <a href="http://skyruk.livejournal.com/tag/%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%20%D1%88%D0%B0%D1%88%D0%B5%D0%BA">блог</a> Дмитрия предоставил достаточно материала для размышлений об этом. А потом я заметил, что почти для всех игр, упомянутых Дмитрием имеются ZoG реализации. Так родилась идея создания обзора, посвященного истории Шашек. Разумеется, мой обзор вторичен. Я во многом опираюсь на обширный материал, собранный Дмитрием Скирюком и прошу рассматривать мой пост лишь как иллюстрацию к проделанной им гигантской работе.

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/820/787/ac8/820787ac8cfc194d9ed2d766bdd96581.jpg"/>Итак, начнем ...

Думаю, что, из числа читающих этот пост, будет сложно найти человека ни разу не игравшего в "Крестики-Нолики". Конечно, скажете вы, но какое отношение это имеет к Шашкам? Давайте не будем торопиться. Итак, "Крестики-Нолики". Простые правила, доступный "инвентарь"... У этой замечательной игры есть всего один недостаток - при правильной игре сторон она <b>всегда</b> (и очень быстро) завершается вничью. Это очень скучно, поскольку полностью отсутствует какая либо интрига. В результате, в такую игру (часами) способны играть разьве что младшие школьники.

Разумеется, предпринимались неоднократные попытки сделать эту игру более интересной. Лично я знаю два принципиально различных подхода к усложненению этой игры (на самом деле, больше, но об этом позже). Во первых, можно увеличить размер или размерность доски. Таким образом, можно играть на 3D, <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=418">4D</a> или <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=465">гексагональной</a> доске, либо на доске <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1161">большого</a> размера. Само собой, на большой доске нет смысла играть по правилам "три в ряд". Чтобы игра была интересной, требуется построить ряд из пяти фишек. Добавив к этому неcколько правил, для исправления игрового баланса, получим <a href="http://ru.wikipedia.org/wiki/%D0%A0%D1%8D%D0%BD%D0%B4%D0%B7%D1%8E">Рэндзю</a>: 

<video>http://www.youtube.com/watch?v=DcpW7httzo0</video>

В отличии от своего прародителя, Рэндзю является вполне "взрослой" игрой. По ней имеется учебная литература, проводятся международные чемпионаты. Но увеличение размера доски не единственный способ усложнения игры. Вместо того, чтобы увеличивать размер доски, можно разрешить двигать фишки. В начале игры, игроки могут выставлять их на доску так же как в "Крестиках-ноликах", но исчерпав выделенный лимит фишек (и получив на доске закономерную ничейную позицию) игроки могут начать двигать фишки по доске, с целью построения линии "3 в ряд". Вероятно, первоначально, игра велась на поле 3x3. Именно в таком виде игра под названием "Танец 3 мужчин" описана в книге <a href="http://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%B4%D0%BD%D0%B5%D1%80,_%D0%9C%D0%B0%D1%80%D1%82%D0%B8%D0%BD">Мартина Гарднера</a> "Математические головоломки и развлечения".

Это более интересная игра чем "Крестики-нолики", но ее можно сделать еще интереснее. Во первых, можно увеличить и усложнить игровое поле, дать игрокам более 3 фишек и, самое главное, изменить условие победы. Поставив линию из 3 фишек игрок не выигрывает, а имеет право убрать с поля <b>любую</b> фишку противника. Цель игры - убрать с доски все фишки противника. Именно так выглядит игра "Танец 9 мужчин", также известная как "<a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BB%D1%8C%D0%BD%D0%B8%D1%86%D0%B0_%28%D0%B8%D0%B3%D1%80%D0%B0%29">Мельница</a>". Варианты игровых полей для "Мельницы" весьма <a href="http://letidor.ru/article/589_nastolnyie_igryi_melnitsa_24642/">разнообразны</a>. Вот как выглядит партия игры в "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=956">Мельницу</a>" на одной из таких досок:

<video>http://www.youtube.com/watch?v=UhNUrrtH9Kg</video>

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/3b0/99c/272/3b099c2722ada9071e399543956b91c2.jpg"/>Как и любая другая история, история Шашек не могла обойтись без египтян. Именно в Египте была придумана игра под названием <a href="http://boardgamegeek.com/wiki/page/thing:11347">Seega</a>. Хотя эта игра и не очень популярна, она дожила до наших дней. Таким образом, это, по всей видимости, наиболее древний вариант "зажимных шашек", правила которого нам известны. Греки и римляне также внесли свой вклад в развитие шашечной игры, придумав игры "<a href="http://skyruk.livejournal.com/244920.html">Петтейя</a>" и "<a href="http://skyruk.livejournal.com/246450.html">Латрункули</a>", соответвенно. Вне всякого сомнения, эти игры существовали, но, к сожалению, об их правилах практически ничего не известно. Некоторые исследователи считают, что "Сиджа" произошла от "Петтейи", но и в этом твердой уверенности нет.

Все эти игры представляли собой метафору боевых действий, характерных для того времени. Каждый игрок имел набор однотипных фигур (своего цвета) и мог перемещать их по доске, в соответсвии с правилами. Фигура противника убиралась с доски (во всяком случае в "Сиджа") после "зажимания" с двух сторон (по вертикали или горизонтали) своими фигурами (два солдата побеждали в бою одного). В "Сиджа" игра начиналась с выставления фигур на доску (как в "Мельнице"). Только выставив все свои фигуры игроки могли начать перемещать их на одну клетку по вертикали или горизонтали. Вот как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1142">это</a> выглядело:

<video>http://www.youtube.com/watch?v=pwarMzh1zyo</video>

Другой игрой "зажимного" типа, дошедшей до наших дней, является японская <a href="http://en.wikipedia.org/wiki/Hasami_shogi">Hasami Shogi</a>. Эту игру, по праву, можно назвать "японскими шашками". Удаление фигур противника с доски, также, осуществляется путем их "зажимания" с двух сторон (что и отражено в названии игры Hasami - "клещи"), но "зажимать" можно не одну, а несколько фигур сразу (также имеются сложные правила "зажимания" фигур в углу доски, посмотреть которые можно в следующем <a href="http://www.youtube.com/watch?v=5EcpCGDu1Bw&list=PL587865CAE59EB84A">видео</a>). Фигуры могут ходить не на одну, а на несколько клеток сразу (как Ладьи в Шахматах). Интересно, что целью игры не является удаление с доски всех фигур противника. В различных вариантах, для победы, требуется либо снять с доски 5 фигур противника, либо (привет от "Крестиков-ноликов") поставить 5 своих фигур в ряд. Надо сказать, что все эти правила идут игре на пользу, делая ее гораздо более динамичной, по сравнению, например, с Seega:

<video>http://www.youtube.com/watch?v=ml7amUL_lmY</video>

По тем же "зажимным" принципам построена тибетская игра <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1819">Gundru</a>, также известная под названием "<a href="http://skyruk.livejournal.com/353918.html">Мин Манг</a>". Так же как и в Hasami Shogi, "зажимать" можно по несколько фигур сразу, но захваченные фигуры не убираются с доски, а меняют цвет (фишки просто переворачиваются):

<video>http://www.youtube.com/watch?v=oc9dDCPgEc4</video>

В конце видео можно заметить, каким образом игрок может свести партию к ничьей. К сожалению, подобная тактика возможна для всех игр "зажимного" типа, целью которых является захват всех фигур противника. Впрочем, это не делает игру менее интересной. Знатоки настольных игр несомненно уже обратили внимание на сходство принципов этой игры с другой игрой:

<video>http://www.youtube.com/watch?v=_RzqXN5VLls</video>

В отличии от игр упомянутых ранее, "<a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B2%D0%B5%D1%80%D1%81%D0%B8">Reversi</a>" это относительно молодая игра, со сложной судьбой. Она была изобретена в Великобритании в конце XIX века, но впоследствии забыта, в связи с социальными катаклизмами начала XX века. В 1971 году она была возрождена в Японии под названием "Отелло".

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/6af/80f/d5a/6af80fd5a365964f6326382b551b36bc.jpg"/>Но вернемся к нашей истории. Вслед за греками и римлянами, свой вклад в развитие настольных игр внесли викинги. Совершая свои набеги, они распространяли по всему миру "Кости", "Мельницу", <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%82%D1%80%D0%B0%D0%BD%D0%B4%D0%B6">Шатрандж</a>...
Но была и еще одна игра. В 1880 году, в одном из могильных курганов был обнаружен фрагмент доски, размеченный с двух сторон. Одна сторона предназначалась для игры в "Мельницу", другая - для неизвестной игры на поле 13x13 клеток. Были найдены еще несколько досок для этой игры, но правила оставались неизвестными. Вероятно, таковыми они остались бы и до сих пор, если бы не дневники <a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%BD%D0%B5%D0%B9,_%D0%9A%D0%B0%D1%80%D0%BB">Карла Линнея</a>. В 1732 году, в Лапландии, он обнаружил  игру, которую, впоследствии, удалось связать со сделанными находками.

Хотя в точности воссоздать правила всех игр семейства <a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B2%D0%BB%D0%B5%D0%B8">Тафл</a> так и не удалось, несомненно, что они относились к играм "зажимного" типа. В отличии от игр, упомянутых здесь ранее, Тафл является не симметричной игрой. Целью одного из игроков "Обороняющегося" является вывод фигуры Короля "из окружения". Другой игрок - должен блокировать его, "зажав" своими фигурами с двух или более сторон (здесь в реконструкциях правил имеются разночтения). Взятие "рядовых" фигур  осуществляется "зажиманием" их фигурами противника с двух сторон, но такое уничтожение фигур не является целью игры ни для одного из игроков. Интересующихся историей и правилами Тафла, я <a href="http://skyruk.livejournal.com/246910.html">вновь</a> <a href="http://skyruk.livejournal.com/247072.html">отсылаю</a> к блогу Дмитрия Скирюка, добавив, от себя, пример партии одной из таких игр:

<video>http://www.youtube.com/watch?v=Weaop9VKhuo</video>

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/fbf/a90/e4b/fbfa90e4b77ec664c24db03e4fb4bf14.jpg"/>Описанные выше игры относятся к играм "зажимного" типа. Но когда взятие фигуры стало осуществляться прыжком через фигуру противника? Существует еще одна <a href="http://skyruk.livejournal.com/248462.html">игра</a>, бывшая весьма популярной в средние века. На поле, напоминающем доску для игры в "Мельницу", 13 или более "гусей" (в зависимости от варианта игры) должны заблокировать (лишить возможности хода) одну "лису". "Гусей" больше, но возможности их хода ограничены (они могут ходить на один шаг только по вертикали или горизонтали). "Лиса", дополнительно, может ходить по диагоналям и, кроме того, может "есть" гусей, по шашечным правилам, перепрыгивая через фигуру противника. Разрешены даже цепочки взятий! Это, действительно, очень похоже на современные Шашки!

Хотя игра "Лиса и гуси" весьма интересна, в историческом плане, на мой взгляд, она несколько нудновата. Процесс запирания "лисы" может растянуться на очень долгое время. Мне больше нравится другая игра, на очень похожей доске. Девять полей, на ней, специальным образом выделены и представляют собой "крепость". В крепости находятся 2 стражника, цель которых - не дать нападающим занять все поля "крепости". Стражники могут есть нападающих так же, как "лиса", в игре "Лиса и гуси". Нападающие могут двигаться в любом направлении, по направлению к "крепости". Вот как всё это выглядит:

<video>http://www.youtube.com/watch?v=o_lx_5lNhVs</video>

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/08e/d8b/981/08ed8b9810cdd3363c5f6621cb3ce80a.jpg"/>Следующей важной вехой в развитии Шашек стал испанский "Алькуерк". Эта игра велась на поле для игры "Аль Киркат", позаимствованной у арабов и представлявшей собой (скорее всего) вариант "Мельницы". Двигаться разрешено по размеченным линиям. Это не очевидно, на первый взгляд, но поля такой доски не одинаковы. Некоторые имеют восемь соседей, а некоторые всего четырех. Эта особенность делает игру весьма своеобразной, в тактическом плане. Из расстановки фигур, очевидно, что игрок, делающий ход вторым, имеет преимущество. Проблема, связанная с этим дисбалансом, обычно, решается проведением сериии игр, с достаточно сложной системой <a href="http://skyruk.livejournal.com/249847.html">подсчета очков</a>. К сожалению, нам не известны детали правил этой игры (было ли взятие обязательным, разрешалось ли ходить назад, происходило ли превращение фигур), но имеется множество её реконструкций.

<video>http://www.youtube.com/watch?v=P8PfZ6ZgDuI</video>

Хотя Алькуерк не лишен недостатков, в игровом плане, он является важной переходной формой в истории Шашек. Поскольку эта игра была разнесена испанцами по всему миру, появилось множество её <a href="http://skyruk.livejournal.com/250301.html#cutid1">модификаций</a>. Наиболее очевидным решением проблемы дисбаланса первоначальной игры было увеличение размера игрового поля. Так появились Харбага и еще большая по размерам Замма (в этой игре уже присутствуют "дальнобойные" дамки):

<video>http://www.youtube.com/watch?v=5QRzGpv3Jt8</video> 

Простое увеличение размеров - не единственный вариант изменения доски. По аналогии с "Мельницей" было придумано невероятное количество разнообразных не квадратных досок для игры по правилам Алькуерка. Такие игры обнаружены в Индии, Америке, Африке и Азии и условно объединяются термином <a href="http://skyruk.livejournal.com/249944.html">"военные" игры</a>:

<video>http://www.youtube.com/watch?v=vFCH4g9MtaY</video>

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/af5/73d/6af/af573d6af9b599e25f0f8adf990fb0ca.jpg"/>Другим подходом стало усложнение правил игры. Например в Дабло, сохранению которого мы также обязаны лапландцам, были добавлены фигуры "Принца" и "Короля". Эти фигуры, в отличии от "солдат", ходивших только вперед, могли ходить в любую сторону и "есть" по желанию. Кроме того, эти фигуры были "имунны" для обычных "солдат". "Короля" мог взять только вражеский "король", "принца" - "король" или "принц". Не думаю, что это решение было очень удачной мыслью, но игра получилась довольно интересная:

<video>http://www.youtube.com/watch?v=24vKfKcmN2o</video>

В условиях территориальной изоляции, возникли и более причудливые игровые системы на основе Алькуерка. Национальной гордостью жителей Мадагаскара, к примеру, является <a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%BE%D1%80%D0%BE%D0%BD%D0%B0">Фанорона</a>, отличающаяся весьма оригинальным способом взятия фигур. Различаются два способа взятия - атакой и отступлением. При взятии атакой, игрок перемещает один из своих камней на некоторую точку так, что следующая точка на той же линии занята камнем противника, при этом, камень противника и все расположенные за ним камни того же цвета, снимаются с доски. При выполнении взятия отступлением, игрок перемещает один из своих камней с некоторой точки так, что предыдущая точка на той же линии занята камнем противника, при этом, с доски также удаляется непрерывная цепочка камней противника. Пожалуй, проще показать это:

<video>http://www.youtube.com/watch?v=odcF1hHsPl8</video>

Не менее интересна игра обитателей острова Ява. Края доски для игры в <a href="http://skyruk.livejournal.com/250752.html">Суракарту</a> замкнуты дополнительными двойными петлями, на каждом из углов доски. Для обычных ходов (на один шаг по вертикали, горизонтали или диагоналям) эти петли не используются, но выполняя взятие, фигура должна пройти по одной или нескольким петлям и занять поле, ранее занятое фигурой противника. Взятия осуществляются как в Шахматах, без прыжка через фигуру (с обязательным проходом по петле). Цепочек взятий нет:

<video>http://www.youtube.com/watch?v=2itOq_vh9jY</video>

Чуть менее оригинальна (но не менее интересна) африканская Йотай. Эта игра, как и Seega, начинается на пустом поле, размером 5x6 клеток. У каждого игрока по 12 фишек. Игроки поочередно выставляют фишки на доску или делают ход ранее выставленной фишкой (не обязательно после выставления всех фишек). Ходить можно только по вертикалям и горизонталям на одно поле. Взятия осуществляются по правилам Алькуерка, перепрыгиванием через фишку противника (цепочки взятий разрешены), но, при выполнении каждого взятия, игрок имеет право снять с доски одну (любую) дополнительную фишку противника. Такая "положительная обратная связь", в совокупности со скоростной манерой игры, делает партии Йотай совершенно непредсказуемыми:

<video>http://www.youtube.com/watch?v=dVf8XQ76eqE</video>

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/e04/581/78d/e0458178d32d28337e6fc1f6269941c2.gif"/>Ну вот мы и добрались до новейшей истории. Революция в мире шашек грянула, когда их стали играть на шахматной доске. Поскольку игры семейства Шахмат были (и остаются) на пике популярности, использование их инвентаря для игры сказалось на распространении Шашек более чем благотворно. Стоит заметить, что ситуация с Hasami Shogi (о которой я говорил ранее), отражает ту же картину, но как бы, в уменьшенном масштабе. Для этой игры используется стандартный комплект Shogi, чрезвычайно распространенный в Японии. Сама же Hasami Shogi считается игрой куда менее серьезной (играют в нее, в основном, дети). Если бы Hasami Shogi не использовала доску и комплект фигур Shogi, вряд ли бы про неё хоть кто-нибудь знал.

Наиболее древними шашечными системами считаются игры с ортогональным ходом фигур. К ним относятся <a href="http://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%B5%D1%86%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">турецкие</a>, <a href="http://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BC%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8">армянские</a> и <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D0%BD%D1%8B">осетинские</a> шашки. Как уже наверное понятно, обычные фигуры могут ходить на одну клетку только вперед, влево или вправо (исключением являются армянские шашки, в которых разрешены ходы по диагонали). Бой фигур производится только ортогонально, "перепрыгиванием" через фигуру противника, на следующую за ней пустую клетку. Взятие обязательно. При достижении последней линии, происходит превращение в усиленный вариант фигуры - "дамку". Дамка дальнобойная. Цель игры - лишить противника возможности хода ("съесть" или "запереть" все его фигуры). Вот как выглядит партия в турецкие шашки:

<video>http://www.youtube.com/watch?v=Wk2sqkn1rfE</video>

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/1a1/8bd/dcf/1a18bddcf05a4128f4e12764a451c0f3.jpg"/>Другое, более знакомое нам семейство <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8">игр</a> пошло по пути сознательного отказа от использования половины шахматных полей, разрешив фигурам перемещаться только по диагоналям. Это решение может показаться странным, но, <a href="http://skyruk.livejournal.com/256132.html">возможно</a>, именно ему мы обязаны знаменитой разметкой шахматной доски. Современных разновидностей шашечной игры, порой незначительно различающихся правилами, довольно много. Пожалуй, главным камнем преткновения является вопрос о дальнобойности дамок. В английских <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.90.D0.BD.D0.B3.D0.BB.D0.B8.D0.B9.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8_.28.D1.87.D0.B5.D0.BA.D0.B5.D1.80.D1.81.29">Checkers</a>, дамки тихоходные. От обычных шашек они отличаются только возможностью хода и "рубки" назад. Более привычный нам <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.A0.D1.83.D1.81.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">русский</a> вариант гораздо более динамичен, за счет использования "дальнобойных" дамок:

<video>http://www.youtube.com/watch?v=LQc9x9mhEwg</video>

Пожалуй, наиболее оригинальным является <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.98.D1.82.D0.B0.D0.BB.D1.8C.D1.8F.D0.BD.D1.81.D0.BA.D0.B8.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">итальянский</a> вариант. В нем, как и в Dablot, о котором я говорил ранее, проводится в жизнь мысль, о том, что некоторые шашки <a href="http://www.bibliotekar.ru/encSlov/3/183.htm">более равны чем другие</a>. Обычные шашки не могут есть дамок, правда, в отличии от Dablot, могут быть в них превращены, за особые заслуги (дойдя до полей превращения). Предком этого варианта игры, несомненно, является итальянская же Damone (цель игры - захватить все фишки или главную дамку противника):

<video>http://www.youtube.com/watch?v=jb48l6TUaXw</video>

Разумеется, история Шашек, на этом, не заканчивается. С учетом того, что, в отличии от Шахмат, Шашки уже полностью просчитаны на компьютерах, для дальнейшего существования, они просто обязаны развиваться. Существует множество вариантов усложнения игры. Наиболее очевидным из них, как и множество раз до этого, является <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.9C.D0.B5.D0.B6.D0.B4.D1.83.D0.BD.D0.B0.D1.80.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8">увеличение</a> размеров доски. Помните, в начале этой статьи, я говорил, что знаю более двух способов усложнения игры в "Крестики-нолики"? На самом деле, таких способов множество. Существуют, к примеру, "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=882">вертикальные</a>" крестики-нолики. А можно поменять саму цель игры. Что если считать проигравшим игрока, <b>вынужденного</b> построить линию "3 в ряд"? 

Аналогичный подход применим и к Шашкам. Это может показаться странным, но подобные "<a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BA%D0%B8#.D0.9F.D0.BE.D0.B4.D0.B4.D0.B0.D0.B2.D0.BA.D0.B8_.28.D0.BE.D0.B1.D1.80.D0.B0.D1.82.D0.BD.D1.8B.D0.B5_.D1.88.D0.B0.D1.88.D0.BA.D0.B8.29">обратные</a>" игры, оказываются гораздо сложнее их "прямых" аналогов (особенно при наличии правила обязательного взятия фигур). Во всяком случае, насколько мне известно, до сих пор, не удалось разработать компьютерную программу, адекватно играющую в "Поддавки". К сожалению, эта игра незаслуженно обойдена вниманием мирового сообщества. Возможно дело в уничижительном названии, возможна сама идея "поддать" все свои фигуры не кажется достойной, я не знаю. В любом случае, я считаю, что <a href="http://skyruk.livejournal.com/321551.html">Поддавки</a> - одна из игр будущего. Другим возможным вариантом "улучшения" Шашек могут оказаться <a href="http://skyruk.livejournal.com/322288.html">Столбовые шашки</a>.

Отдельного упоминания заслуживают различные варианты <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D1%88%D0%BC%D0%B0%D1%82%D1%8B">Шашмат</a>, наглядным историческим примером которых может служить <a href="http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D1%82%D0%B0%D0%B9%D1%81%D0%BA%D0%B8%D0%B5_%D1%88%D0%B0%D1%88%D0%BA%D0%B8_(%D1%88%D0%B0%D1%82%D1%80%D0%B0)">алтайская</a> <a href="http://skyruk.livejournal.com/339712.html">Шатра</a>. В ней грань между Шашками и Шахматами становится совсем тонкой и практически невидимой. Хотя нет твердой уверенности в том, что в древности на Алтае играли именно таким образом, реконструкция получилась весьма интересная и, несомненно, очень оригинальная:

<video>http://www.youtube.com/watch?v=XvmG5kbHHMI</video>

<img align="right" src="https://habrastorage.org/getpro/habr/post_images/52d/f9d/3fd/52df9d3fd7b493f37198ef8f6598ab3d.jpg"/>Существуют и еще более <a href="http://skyruk.livejournal.com/334394.html">оригинальные</a> игровые системы, такие как, например, Abalone, разработанная Мишелем Лале и Лораном Леви в 1987 году. В ней, игрокам разрешается перемещать одновременно по нескольку фигур (до трёх), расположенных на соседних полях, за ход. Цель игры - "вытолкать" за пределы доски заданное количество фигур противника. При этом, для успешного выталкивания, группа фигур, совершающих ход, должна быть большей, чем группа фигур другой стороны. Две фигуры могут "толкнуть" одну, а три, в свою очередь, две или одну фигуру противника. В результате, игра очень напоминает чемпионат по <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BC%D0%BE">Сумо</a>, проводимый среди гусениц:

<video>http://www.youtube.com/watch?v=gF772r8JXIc</video>

Как бы там ни было, развитие Шашек продолжается, и это не может не радовать!

<spoiler title="Приложения">
<h4>N в ряд</h4>
<ul>
	<li>Vincent Everaert "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1161">In Love Go-Moku</a>"</li>
</ul>
<h4>Мельница</h4>
<ul>
	<li>Uwe Wiedemann "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=593">Morris Games</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=428">German Morris</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=956">Windmill</a>"</li>
</ul>
<h4>Сиджа</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1142">Egyptian Siga</a>"</li>
</ul>
<h4>Петтейя</h4>
<ul>
	<li>Uwe Wiedemann "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=670">Petteia</a>"</li>
</ul>
<h4>Латрункули</h4>
<ul>
	<li>Roger Cooper "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=633">Military Latrunculi</a>"</li>
	<li>L. Lynn Smith "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=547">Latrunculi</a>"</li>
</ul>
<h4>Хнефатафл</h4>
<ul>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=471">Hnefatafl</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1210">Tablut</a>"</li>
</ul>
<h4>Лиса и гуси</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1133">Fox Classic</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=238">Cows and Leopards</a>"</li>
</ul>
<h4>Асальто</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1128">Asalto</a>"</li>
	<li>K. Franklin "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=234">Contra</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=417">Fortress</a>"</li>
</ul>
<h4>Агон</h4>
<ul>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=721">Queen's Guard</a>"</li>
</ul>
<h4>Халатафл</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1129">Halatafl</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1130">Damiano</a>"</li>
</ul>
<h4>Мин Манг</h4>
<ul>
	<li>Greg Schmidt "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1819">Tibetan Gundru</a>"</li>
</ul>
<h4>Реверси</h4>
<ul>
	<li>Laszlo Nagy "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=728">Reversi Board Variations</a>"</li>
	<li>Roland Johansson "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=727">Reversi 3D</a>"</li>
</ul>
<h4>Алькуерк</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1249">Medieval Alquerque</a>"</li>
	<li>Brandon Burkholder "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=318">Double Alquerque</a>"</li>
</ul>
<h4>"Военные" игры</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1138">Indian War-games</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1528">Permainan-Tabal</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=573">Ljura</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=456">Hageby</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=529">Kneippen</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=794">Seth</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1016">Slottsholmen</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=498">Ingelsta</a>"</li>
</ul>
<h4>Харбага</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1248">Kharbaga</a>"</li>
</ul>
<h4>Замма</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1190">Zamma</a>"</li>
</ul>
<h4>Чоко</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1284">Choko</a>"</li>
</ul>
<h4>Дабло</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1816">Dablo Daares</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1267">Dablot Prejjesne</a>"</li>
</ul>
<h4>Фанорона</h4>
<ul>
	<li>Vincent Everaert "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1220">Fliporona</a>"</li>
	<li>Markus Salo "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1010">Grindtorp</a>"</li>
	<li>Chris Huntoon "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=407">Fandango</a>"</li>
</ul>
<h4>Йотай</h4>
<ul>
	<li>Peter Aronson "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=960">Yote</a>"</li>
</ul>
<h4>Суракарта</h4>
<ul>
	<li>Chris Lusby Taylor, Steve Evans, Steve Evans "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=821">Surakarta</a>"</li>
</ul>
<h4>Шашки</h4>
<ul>
	<li>Alfred Pfeiffer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1432">Dama (Turkish Checkers)</a>"</li>
	<li>Jeremy Deane "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=893">Turkish Draughts</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1800">Ossetian Checkers</a>"</li>
	<li>Uwe Wiedemann "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=218">Checker Games</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=679">Russian Checkers</a>"</li>
	<li>Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=427">German Checkers</a>"</li>
	<li>Malcolm Maynard "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=678">Polish Draughts</a>"</li>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1230">Frisian Draughts</a>"</li>
</ul>
<h4>Дамоне</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1260">Italian Damone</a>"</li>
</ul>
<h4>Хальма</h4>
<ul>
	<li>Mats Winther "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1151">Halma variants</a>"</li>
	<li>Sid Sackson, Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=460">Halma Star</a>"</li>
</ul>
<h4>Столбовые шашки</h4>
<ul>
	<li>Peter Michaelsen, Victor M. Pakhomov, Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1767">Bashne</a>"</li>
	<li>Emanuel Lasker, Karl Scherer "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1493">Laska</a>"</li>
	<li>Christian Freeling, Ed van Zon, Christian Freeling "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show&id=355">Emergo</a>"</li>
	<li>Christian Freeling, Ed van Zon, Christian Freeling "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=356">HexEmergo</a>"</li>
	<li>Ed van Zon, Christian Freeling "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1507">HExplocus</a>"</li>
</ul>
<h4>Шашматы</h4>
<ul>
	<li>Francis Monkman "<a href="http://www.chessvariants.org/index/zillions.php?itemid=zShatra">Shatra</a>"</li>
	<li>Harvey Patterson "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=177">Chessers</a>"</li>
</ul>
<h4>Абалоне</h4>
<ul>
	<li>Jens Markmann, Laszlo Nagy "<a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=12">Abalone vari</a>"</li>
</ul>
</spoiler>
<spoiler title="Источники">
<ol>
	<li>Дмитрий Скирюк "<a href="http://skyruk.livejournal.com/tag/%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%20%D1%88%D0%B0%D1%88%D0%B5%D0%BA">История шашек</a>"</li>
	<li>Мартин Гарднер "<a href="http://rutracker.org/forum/viewtopic.php?t=3140600">Математические головоломки и развлечения</a>"</li>
	<li>Александр Носовский "<a href="http://rutracker.org/forum/viewtopic.php?t=4490234">Японские логические игры: самоучитель</a>"</li>
	<li>Вирный А.Я. "<a href="http://rutracker.org/forum/viewtopic.php?t=4357845">Немного о шашках, но по существу</a>"</li>
	<li>М.Г.Дебец, А.И.Назаров "<a href="http://rutracker.org/forum/viewtopic.php?t=4523539">Поддавки</a>"</li>
</ol>
</spoiler>
</habracut>

Приручаем ZoG (Часть 5: Сбор маны)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/d10/e3a/469/d10e3a46907ba64c8ab326cec83c733e.gif"/>Сегодня я завершаю цикл <a href="http://habrahabr.ru/post/213391/">статей</a>, рассказывающих о возможностях языка ZRF, используемого для разработки игр в <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Поскольку я намеренно двигался от простого к сложному, логично предположить, что сегодняшняя игра (в плане реализации) будет сложнее всех предыдущих. Это действительно так. Дело в том, что ZRF ни в коем случае нельзя отнести к универсальным языкам программирования. Он предназначен для описания игр похожих на Шахматы. Чем более "шахматоподобна" игра, тем более очевидно её описание (если, конечно, не обращать внимание на описание правил таких хитрых ходов как <a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">рокировка</a> или <a href="http://ru.wikipedia.org/wiki/%D0%92%D0%B7%D1%8F%D1%82%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B5">взятие на проходе</a>). Описание такой игры может быть довольно большим по объему (в этом случае может помочь <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1663">PreZRF</a>, о котором я писал <a href="http://habrahabr.ru/post/214713/">ранее</a>), но довольно тривиальным по содержанию.

Все меняется когда приходится делать что-то на Шахматы совсем не (или не совсем) похожее. Создание таких приложений как <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=5">Game of Life</a> или <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1543">Mine Finder</a> является серьезным вызовом, в случае использования чистого ZRF, без каких либо <a href="http://www.zillions-of-games.com/progsample.html">расширений</a>. Сегодня я постараюсь показать с какими сложностями может быть связана подобная разработка.
<habracut>
Источником вдохновения, на этот раз, мне послужила миниигра "Сбор маны" из уже упоминавшейся мной ранее <a href="http://www.battlevschess.com/en/">Battle vs Chess</a>. Игроку предоставляется одна или несколько шахматных фигур, которыми он должен ставить <a href="http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BB%D0%BA%D0%B0_%28%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D1%8B%29">вилки</a>, убирая с поля расставляемые случайным образом "кристаллы":

<video>http://www.youtube.com/watch?v=tJQGtj_Ltxc&feature=youtu.be</video>

Попробуем разобраться, с какими сложностями мы столкнемся, пытаясь реализовать аналогичную миниигру, используя ZRF. Первая сложность - это подсчет количества фигур, находящихся под боем, необходимый для определения наличия "вилки". Как я уже говорил, с разного рода подсчетами в ZRF туго, но, в частных случаях, задача вполне решаема:

<spoiler title='Определение "вилок"'>
<source lang="lisp">
(define common-check
   mark
   (if (on-board? $1)
        $1
        (while (and empty? (on-board? $1)) $1)
        (if enemy?
             (if (flag? is-first)
                 (set-flag is-second true)
              else
                 (set-flag is-first true)
             )
        )
   )
   back
)

(define common-capture
   mark
   (if (on-board? $1)
        $1
        (while (and empty? (on-board? $1)) $1)
        (if enemy? capture)
   )
   back
)

(define queen-slide
   ($1
       (while empty?
           (set-flag is-first false)
           (set-flag is-second false)
           (common-check n)
           (common-check s)
           (common-check w)
           (common-check e)
           (common-check nw)
           (common-check ne)
           (common-check sw)
           (common-check se)
           (if (flag? is-second)
               (common-capture n)
               (common-capture s)
               (common-capture w)
               (common-capture e)
               (common-capture nw)
               (common-capture ne)
               (common-capture sw)
               (common-capture se)
          )
          add
          $1
       )
   )
)
</source>
</spoiler>
Поскольку нам не обязательно знать точное количество фигур, находящихся "под боем", для "подсчета", достаточно двух булевских флагов. Если, после серии проверок <b>common-check</b> в различных направлениях, флаг <b>is-second</b> взведен, необходимо снять все фигуры, находящиеся "под боем". 

Важным (и не очевидным для понимания) моментом является то, что все эти проверки и взятия должны быть выполнены до формирования команды <b>add</b>, завершающей <b>возможный</b> ход (поскольку они являются частью этого хода). Кроме того, в отличии от обычных шахмат, на занятое (фигурой противника) поле ходить мы не можем.

Уже в этом месте, в полной мере, проявляется "коварство" ZRF. Поиграв немного, можно заметить следующий баг:

<video>http://www.youtube.com/watch?v=Ckmg6saMJAs&feature=youtu.be</video>

Можно заметить, что фигура находящаяся за стартовой позицией, в противоположном от хода направлении, не рассматривается как находящаяся "под боем". Это связано с тем, что, в момент рассчета хода, начальное поле не считается пустым. Поняв причину ошибки, легко её исправить:

<spoiler title='Исправленное определение "вилок"'>
<source lang="lisp">
(define common-check
   mark
   (if (on-board? $1)
        $1
        (while (and (or (position-flag? is-start) empty?) (on-board? $1)) $1)
        (if enemy?
             (if (flag? is-first)
                 (set-flag is-second true)
              else
                 (set-flag is-first true)
             )
        )
   )
   back
)

(define common-capture
   mark
   (if (on-board? $1)
        $1
        (while (and (or (position-flag? is-start) empty?) (on-board? $1)) $1)
        (if enemy? capture)
   )
   back
)

(define queen-slide
   ( (set-position-flag is-start true)
       $1
       (while empty?
           (set-flag is-first false)
           (set-flag is-second false)
           (common-check n)
           (common-check s)
           (common-check w)
           (common-check e)
           (common-check nw)
           (common-check ne)
           (common-check sw)
           (common-check se)
           (if (flag? is-second)
               (common-capture n)
               (common-capture s)
               (common-capture w)
               (common-capture e)
               (common-capture nw)
               (common-capture ne)
               (common-capture sw)
               (common-capture se)
          )
          add
          $1
       )
   )
)
</source>
</spoiler>
Мы просто помечаем начальное поле позиционным флагом и рассматриваем его далее как пустое.

Обобщение сформулированных правил на ходы остальных фигур является делом техники. <a href="https://github.com/GlukKazan/ZoG/blob/dd708dc0cbf1cfa8248ad3a7e66e024207a35c04/Rules/04.Forks.zrf">Это</a> решение прекрасно работает, в случае игры одним ферзём, но уже при игре, например, двумя ладьями оно не полно.

<video>http://www.youtube.com/watch?v=MWxXIljOGcg&feature=youtu.be</video>

Программа не учитывает, что одна фигура, перемещаясь, может "открыть" вилку другой фигурой. Это как раз тот случай, когда вполне понятно, что надо делать для исправления ошибки, но (пока) не вполне понятно как. Очевидно, требуется перебрать все свои фигуры и проверить возможные вилки от каждой из них. Для автоматизации поиска всех фигур, находящихся на доске, полезно создать "направление", связывающее все поля в цепочку:

<spoiler title="Связывание всех полей">
<source lang="lisp">
(define Next-Definitions
      (dummy offboard)
      (links next (a1 b1) (b1 c1) (c1 d1) (d1 e1) (e1 f1) (f1 g1) (g1 h1) (h1 a2) 
                  (a2 b2) (b2 c2) (c2 d2) (d2 e2) (e2 f2) (f2 g2) (g2 h2) (h2 a3) 
                  (a3 b3) (b3 c3) (c3 d3) (d3 e3) (e3 f3) (f3 g3) (g3 h3) (h3 a4) 
                  (a4 b4) (b4 c4) (c4 d4) (d4 e4) (e4 f4) (f4 g4) (g4 h4) (h4 a5) 
                  (a5 b5) (b5 c5) (c5 d5) (d5 e5) (e5 f5) (f5 g5) (g5 h5) (h5 a6) 
                  (a6 b6) (b6 c6) (c6 d6) (d6 e6) (e6 f6) (f6 g6) (g6 h6) (h6 a7) 
                  (a7 b7) (b7 c7) (c7 d7) (d7 e7) (e7 f7) (f7 g7) (g7 h7) (h7 a8) 
                  (a8 b8) (b8 c8) (c8 d8) (d8 e8) (e8 f8) (f8 g8) (g8 h8) (h8 offboard)
      )
)

(game
    ...
    (board (Board-Definitions) (Next-Definitions))
)
</source>
</spoiler>
Помимо направления <b>next</b>, мы также определяем фиктивное поле <b>offboard</b>, используемое для завершения перебора. Это достаточно распространенная идиома ZRF. Кроме того, помимо возможности связывания всех полей, команда <b>links</b> может использоваться для создания разнообразных досок с "измененной топологией". С её помощью, можно, например, "склеить" края доски, превратив её в цилиндр, тор или ленту Мебиуса.

Теперь можно использовать созданное направление. К сожалению, попытка "перебрать" свои фигуры непосредственно в рамках хода одной из них сталкивается с техническими сложностями. Перед началом перебора, требуется запомнить текущую позицию (для того, чтобы, впоследствии, сформировать завершающую ход команду <b>add</b>). Обычно, для этого используется пара команд <b>mark</b>/<b>back</b>, но мы уже используем их в <b>common-check</b> и <b>common-capture</b>, а стэк сохраняемых позиций командой <b>mark</b> не поддерживается.

Для того, чтобы решить эту проблему, создадим фиктивного игрока <b>?Clean</b>:

<source lang="lisp">
(game
    ...
    (players Black ?White ?Clean)
    (turn-order ?White ?White ?White ?White ?White ?White ?White ?White Black ?Clean)
)
</source>
Как я уже рассказывал в предыдущей <a href="http://habrahabr.ru/post/213391/">статье</a>, знак вопроса в начале имени игрока означает, что непосредственно он в игре не участвует и будет выполнять свои ходы случайным образом. Но как именно будет ходить <b>?Clean</b>? Ходы этого игрока нужны нам исключительно ради побочного эффекта (во время его хода будет выполняться проверка наличия на доске вилок и снятие попавших под них фигуры). Очевидно, не стоит <b>?Clean</b>-ом двигать фигуры, значит придется выставлять (<b>drop</b>) их на доску:

<spoiler title="Поиск всех вилок">
<source lang="lisp">
(define common-check
   mark
   (if (on-board? $1)
        $1
        (while (and (or (position-flag? is-start) (or (piece? Cleaner) empty?)) (on-board? $1)) $1)
        (if (piece? Stone)
             (if (flag? is-first)
                 (set-flag is-second true)
              else
                 (set-flag is-first true)
             )
        )
   )
   back
)

(define common-capture
   mark
   (if (on-board? $1)
        $1
        (while (and (or (position-flag? is-start) (or (piece? Cleaner) empty?)) (on-board? $1)) $1)
        (if (piece? Stone) capture)
   )
   back
)

(define clean-queen
  ( (verify empty?)
    (set-position-flag is-cleaner true)
    a1
    (while (not-position? offboard) 
       (if (piece? Queen)
           (set-flag is-first false)
           (set-flag is-second false)
           (common-check n)(common-check nw)
           (common-check s)(common-check ne)
           (common-check w)(common-check sw)
           (common-check e)(common-check se)
           (if (flag? is-second)
               (common-capture n)(common-capture nw)
               (common-capture s)(common-capture ne)
               (common-capture w)(common-capture sw)
               (common-capture e)(common-capture se)
           )
       )
       next
    )
    a1
    (while (not-position? offboard) 
       (if (position-flag? is-cleaner)
            add
       )
       next
    )
  )
)

(define slide
   (   (set-position-flag is-start true)
       $1 
       (while empty? 
           add 
           $1
       ) 
   )
)

(game
    ...

    (players Black ?White ?Clean)
    (turn-order ?White ?White ?White ?White ?White ?White ?White ?White Black ?Clean)
    (board (Board-Definitions) (Next-Definitions))

    (board-setup
       (?Clean
          (Cleaner off 1)
       )
       (?White
          (Stone off 8)
       )
       (Black
          (Queen e4)
       )
    )

    (piece
      (name Stone)
      (image ?White "images\Chess\SHaag\wpawn.bmp")
      (help " ")
      (drops 
         (add-to-empty)
      )
    )
    (piece
      (name Cleaner)
      (image ?Clean "images\DarkChess\Invisible.bmp")
      (drops 
         (clean-queen)
      )
    )
    (piece
      (name Queen)
      (image Black "images\Chess\SHaag\bqueen.bmp")
      (help "Queen: can slide any number of squares in any direction")
      (moves
         (slide n)(slide ne)
         (slide e)(slide nw)
         (slide s)(slide se)
         (slide w)(slide sw)
      )
    )
)
</source>
</spoiler>
Здесь довольно много изменений, но общий смысл, я думаю, понятен. Мы разрешили игроку <b>?Clean</b> ставить на поле его фигуру (сразу после хода <b>Black</b>), проверяя, в процессе, наличие вилок. Поскольку эта фигура не имеет отношения к игровому процессу, желательно сделать ее невидимой. Ресурс полностью прозрачной фигуры можно взять, например, из этой забавной <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=201">игры</a>.

<b>?Clean</b> прекрасно справляется со своей работой по обнаружению вилок, но как быть с добавляемой им фигурой? Будь эта фигура хоть трижды невидима, чтобы она не мешала игровому процессу, желательно снимать её с доски. Будем делать это на ходе <b>?White</b>:

<spoiler title="Чистка мусора">
<source lang="lisp">
(define add-to-empty 
  ( (verify empty?) 
    (set-position-flag is-cleaner true)
    a1
    (while (not-position? offboard) 
       (if (piece? Cleaner)
            capture
       )
       next
    )
    a1
    (while (not-position? offboard) 
       (if (position-flag? is-cleaner)
            add
       )
       next
    )
  )
)
</source>
</spoiler>
Чтобы <b>?Clean</b> мог использовать свою фигуру многократно, включим соответствующую опцию:

<source lang="lisp">
(option "recycle captures" true)
</source>
В принципе, все это работает, но если <b>Black</b> во время хода не поставит вилку, <b>?Clean</b> потратит свою фигуру, а <b>?White</b> не сможет ее очистить, поскольку не сможет сделать ход (так как все его 8 фигур уже на доске). Очевидно, мы должны давать возможность завершить ход <b>?Clean</b> только при условии, что ему удалось найти хотя-бы одну вилку:

<spoiler title="Исправленный поиск вилок">
<source lang="lisp">
(define clean-queen
  ( (verify empty?)
    (set-flag is-succeed false)
    (set-position-flag is-cleaner true)
    a1
    (while (not-position? offboard) 
       (if (piece? Queen)
           (set-flag is-first false)
           (set-flag is-second false)
           (common-check n)(common-check nw)
           (common-check s)(common-check ne)
           (common-check w)(common-check sw)
           (common-check e)(common-check se)
           (if (flag? is-second)
               (set-flag is-succeed true)
               (common-capture n)(common-capture nw)
               (common-capture s)(common-capture ne)
               (common-capture w)(common-capture sw)
               (common-capture e)(common-capture se)
           )
       )
       next
    )
    a1
    (while (not-position? offboard) 
       (if (and (flag? is-succeed) (position-flag? is-cleaner))
            add
       )
       next
    )
  )
)
</source>
</spoiler>
Для того, чтобы игра не завершалась внезапно, при невозможности хода одним из игроков, нам поможет следующая опция:

<source lang="lisp">
(option "pass turn" 2)
</source>
Уффф... Теперь все <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/04.Forks.zrf">работает</a> (правда не так красиво как в оригинале, но зато мы сами решаем, каким набором фигур будем играть). Конечно, вся эта конструкция сильно напоминает сооружение из подпирающих друг друга костылей, но такова уж плата за то, чтобы сделать в ZRF что либо не тривиальное.

В качестве десерта, предлагаю насладиться следующим <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/ForkChess.zrf">вариантом</a> Шахмат:

<video>http://www.youtube.com/watch?v=lOtxkCGTPFc</video>

Все фигуры ходят также, как и в обычных Шахматах. Я внес всего лишь одно изменение, но оно кардинально изменило весь ход игры. Поскольку я субъективен, мне сложно оценить её достоинства, но могу сказать, что, мне лично, выиграть в неё у компьютера гораздо сложнее, чем в обычные Шахматы. Игра очень динамична и редко продолжается дольше 10 ходов. Ставьте вилки, чтобы победить!
</habracut>

ZoG на стероидах

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/3b0/c70/243/3b0c7024373782fd04ee4cba3d51693d.jpg"/>Когда я <a href="http://habrahabr.ru/post/212237/">писал</a> о разработке игры "<a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/02.Thud.zrf">Thud!</a>", я уже сетовал на некоторую избыточность полученного описания. Простота языка ZRF имеет свою оборотную сторону - для того чтобы написать на нем что-то более менее сложное, часто, приходится дублировать значительные фрагменты кода. Подобная избыточность, как известно, приводит не только к увеличению объема ручной работы, но и значительно усиливает риск появления в коде разнообразных ошибок (поскольку процесс отладки ZoG приложений весьма не тривиален, это является существенным моментом).

Как можно бороться с подобной избыточностью?

Разумеется, с помощью макросов! Проблема в том, что макросы ZRF недостаточно выразительны для этого. Адриан Кинг, в процессе разработки игр <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=848">Scirocco</a> и <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1669">Typhoon</a>, пришел к аналогичному выводу и разработал свой собственный, расширенный язык макросов, работающий как внешний <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1663">препроцессор</a>. Сегодня, я расскажу о возможностях этого языка и постараюсь, на примере Thud!, показать его использование в процессе разработки ZRF-приложений.

<habracut>
Как я уже сказал выше, речь идет о внешнем препроцессоре, преобразующем исходные файлы (с расширением .prezrf) в обычные zrf-файлы. Сам препроцессор разработан на языке Java и представляет собой jar-файл. Для обработки prezrf-файла, достаточно выполнить следующую команду (при условии, что на вашем компьютере установлена Java):

<source lang="bash">
java -jar prezrf.jar MyFile.prezrf
</source>
Если обработка пройдет без ошибок, результирующий zrf-файл будет сформирован в том же каталоге. 

Какие возможности предлагает нам новый язык? Во первых, он вводит новый тип макросов. Для определения макроса prezrf используется ключевое слово <b>define!</b> (ко всем новым ключевым словам, в конце, добавлен восклицательный знак). Оригинальные <b>define</b> макросы ZRF игнорируются препроцессором и просто копируются в вывод. Определение макросов нового образца можно отменять командой <b>undefine!</b>. Эта возможность может быть полезна, поскольку новые макросы могут определяться локально, в других макросах (ZRF подобного делать не позволяет).

Ключевое слово <b>expand!</b> приводит к "развертыванию" ранее определенного макроса в указанном им месте кода. Поскольку это действие выполняется очень часто, для него определено сокращение '<b>!</b>'. Таким образом, обработав следующий код:

<source lang="lisp">
(define! swap
  ($2 $1)
)

(! swap a b)
</source>
... мы получим на выходе:

<source lang="lisp">
(b a)
</source>
Этот макрос был бы раскрыт и без восклицательного знака, командой (swap a b), но использование <b>expand!</b> спасает нас от возможных опечаток. Например, если мы, по какой то причине, забыли добавить восклицательный знак к <b>define</b> в определении swap, конструкция (swap a b) была бы просто продублирована в вывод, а вызов макроса констукцией <b>expand!</b>, привел бы к формированию ошибки: <i><b>expand!: undefined macro "swap"</b></i>.

Все это, пожалуй, было бы не очень интересно, если бы не новые возможности, предоставляемые prezrf. В макросах нового типа мы можем использовать аргументы-списки! Кроме того, для нашего удобства, добавлена возможность ссылки на несколько аргументов, передаваемых в макрос, как на список. Конструкция <b>$2*4</b> последовательно выведет значения 2-го, 3-го и 4-го аргументов, переданных в макрос (при условии того, что передано не менее четырех аргументов). Также, определены сокращенные конструкции <b>$n*</b> и <b>$*m</b> имеющие очевидную семантику. Используя эту возможность, мы можем, например, подсчитать количество аргументов, переданных в макрос:

<source lang="lisp">
(define! count
  (length! ($1*))
)

(! count a b c) ; => 3
</source>
Обращаю ваше внимание на то, что скобки вокруг <b>$1*</b>, в этом примере обязательны - мы формируем список, в котором перечисляем значения всех аргументов макроса, начиная с первого. Отсутствие скобок приведет к ошибке обработки, поскольку <b>length!</b> принимает только один списковый аргумент. Тем не менее, наш макрос недостаточно защищен от ошибок входных данных. Вызов <b>(count)</b> без аргументов закончится ошибкой. Мы можем исправить это следующим образом:

<source lang="lisp">
(define! count
  ($?1
    (length! ($1*))
  )
  ($!1 0)
)
</source>
Здесь <b>$?1</b> выполняется в случае, если в макрос передан один или более аргументов, а <b>$!1</b> - в противном случае. Кроме того, имеется возможность нумеровать элементы с конца списка, используя конструкцию <b>$-n</b>. Все эти возможности будут нам весьма полезны в дальнейшем.

Как и любой уважающий себя язык программирования, prezrf предоставляет нам конструкции условного выполнения (<b>if-less!</b>, <b>if-less-or-equal!</b>) и цикла (<b>for!</b>). If-конструкции (а их в языке несколько больше перечисленных выше), в отличии от аналогичной конструкции ZRF, не определяют ветвь <b>else</b>, а <b>for!</b> может использоваться только для обхода элементов списка. Например, мы можем повторить выполнение некоторого действия для всех определенных в игре направлений (это требуется очень часто):

<source lang="lisp">
(define! -all-directions (n ne e se s sw w nw))

(define! shift-all
  (for! $d ($ -all-directions)
     (shift $d)
  )
)

(! shift-all)
</source>
В этом коде, используется управляющая конструкция '<b>$</b>', о которой я еще не успел рассказать. Что она делает? Фактически, это сокращение для очень часто использующейся конструкции:

<source lang="lisp">
(!! (! macro))
</source>
<b>expand!</b> здесь нам уже знаком, но что означает '<b>!!</b>'? Эта команда (<b>expand-first!</b>) сообщает препроцессору о том, что нужно использовать значение элемента, а не сам элемент в вышестоящей конструкции (<b>for!</b> в нашем примере). Этот момент может быть не очень понятен, но он весьма важен для понимания языка. Вот как будет выглядеть вывод, если использовать просто <b>(! -all-directions)</b>:

<source lang="lisp">
(shift !)

(shift -all-directions)
</source>
Это явно не то, чего мы хотели. К сожалению, <b>for!</b> работает только со списками и не сможет нам помочь в оптимизации следующего безобразия:

<spoiler title="Так ходят Тролли">
<source lang="lisp">
( define troll-1 
  ( $1 
    (verify empty?) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-2 
  ( mark
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-3 
  ( mark
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-4 
  ( mark
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-5 
  ( mark
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-6
  ( mark
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)

( define troll-7
  ( mark
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)
</source>
</spoiler>
Но там где пасуют циклы, нам на помощь придет рекурсия:

<spoiler title="Рекурсия, как и было сказано">
<source lang="lisp">
(define! repeat
    (if-less! 0 $1
        $2*
        (! repeat (!! (sum! $1 -1)) $2*)
    )
)

(define! troll-n
  (if-less! 0 $1
     (for! $d ($ -all-directions)
        ( (if-less! 1 $1
             mark
             (repeat $1
                 (opposite $d)
                 (verify friend?)
             )
             back
          )
          (repeat $1
             $d
             (verify empty?)
          )
          (if-less! 1 $1
             (verify (or
                 (for! $dd ($ -all-directions)
                     (enemy? $dd)
                 )
             ) )
          )
          (for! $dd ($ -all-directions)
             (if (enemy? $dd)
                 (capture $dd)
             )
          )
          add
        )
     )
     (! troll-n (!! (sum! $1 -1)))
  )
)
...
(! troll-n 7)
</source>
</spoiler>
Это несколько сложнее для понимания, чем исходная версия, но зато никакого копипаста. Прошу особо обратить внимание на реализацию <b>repeat</b>. Этот макрос очень полезен и будет неоднократно использоваться нами в дальнейшем.

<source lang="lisp">
(! repeat 3 a b c) ; => a b c a b c a b c
</source>
В исходной реализации Thud! есть еще одно место, которое хотелось бы оптимизировать:

<source lang="lisp">
( define check-rock
  ( check-rock-direction n  ne e  se s  sw w  nw)
  ( check-rock-direction ne e  se s  sw w  nw n)
  ( check-rock-direction e  se s  sw w  nw n  ne)
  ( check-rock-direction se s  sw w  nw n  ne e)
  ( check-rock-direction s  sw w  nw n  ne e  se)
  ( check-rock-direction sw w  nw n  ne e  se s)
  ( check-rock-direction w  nw n  ne e  se s  sw)
  ( check-rock-direction nw n  ne e  se s  sw w)
)
</source>
Перечисляя вручную все циклические перестановки набора из восьми элементов легко наделать ошибок. Первым делом, определим макрос, позволяющий нам "вырезать" кусок списка:

<source lang="lisp">
(define! range
  (if-less-or-equal! $1 $2
    (nth! $1 $3)
    (! range (!! (sum! $1 1)) $2*)
  )
)

(! range 3 4 (a b c d e)) ; => c d
</source>
Функция <b>(nth! n list)</b>, здесь, позволяет получить n-ый элемент списка. Попробуем "повертеть" список:

<source lang="lisp">
(define! rotate
  (if-less! 0 $1
     $2
     (! rotate (!! (sum! $1 -1)) ((splice! ((! range 2 8 $2)) ((nth! 1 $2)))))
  )
)

(! rotate 2 (a b c d e f g h)) ; => (a b c d e f g h) (b c d e f g h a)
</source>
Вроде бы нормально, но уже <b>(! rotate 3 (a b c d e f g h))</b> дает ошибку:

<spoiler title="Сообщение об ошибке">
Expanding [list "(nth! 2 ((splice! ((! range 2 8 (a b c "... at argument substitution in [list "(nth! $1 $3)" at t.prezrf, line 3] for [list "(range 2 8 ((splice! ((! range 2 8 (a b"... at expand! of [list "(! range 2 8 ((splice! ((! range 2 8 (a"... at argument substitution in [list "(! range 2 8 $2)" at t.prezrf, line 11] for [list "(rotate 2 ((splice! ((! range 2 8 (a b "... at expand! of [list "(! rotate 2 ((splice! ((! range 2 8 (a "... at argument substitution in [list "(! rotate (!! (sum! $1 -1)) ((splice! ("... at t.prezrf, line 11] for [list "(rotate 3 (a b c d e f g h))" at expand! of [list "(! rotate 3 (a b c d e f g h))" at t.prezrf, line 15]]]]]]]:
In [list "(nth! 2 ((splice! ((! range 2 8 (a b c "... at argument substitution in [list "(nth! $1 $3)" at t.prezrf, line 3] for [list "(range 2 8 ((splice! ((! range 2 8 (a b"... at expand! of [list "(! range 2 8 ((splice! ((! range 2 8 (a"... at argument substitution in [list "(! range 2 8 $2)" at t.prezrf, line 11] for [list "(rotate 2 ((splice! ((! range 2 8 (a b "... at expand! of [list "(! rotate 2 ((splice! ((! range 2 8 (a "... at argument substitution in [list "(! rotate (!! (sum! $1 -1)) ((splice! ("... at t.prezrf, line 11] for [list "(rotate 3 (a b c d e f g h))" at expand! of [list "(! rotate 3 (a b c d e f g h))" at t.prezrf, line 15]]]]]]]:
Trying to get item #2 of list with 1 items
</spoiler>
Как можно заметить, оно не такое пространное как сообщения об ошибках при компиляции шаблонов C++, но не намного их понятнее. Я довольно долго возился с prezrf и вывел для себя два эмпирических правила в части относительно безболезненной работы с ним:

<ol>
	<li>Не передавать изменяемые списки в качестве аргументов рекурсивных макросов</li>
	<li>Ограничивать использование <b>for!</b> наиболее простыми случаями</li>
</ol>
Любое отступление от этих правил, временами, грозит взорвать мне мозг, в тщетных попытках понять суть произошедшего. Попробуем перефразировать наш <b>rotate</b> в духе первого правила:

<source lang="lisp">
(define! rotate
  (if-less! 0 $1
     ((splice! ((! range (!! (sum! $1 1)) (!! (length! $2)) $2))
               ((! range 1 $1 $2))
     ))
     (! rotate (!! (sum! $1 -1)) $2)
  )
  (if-equal! 0 $1
     $2
  )
)
</source>
Он стал выглядеть страшнее, но он работает! Что же нам теперь с ним делать? Перестановки нам нужны не просто так, мы должны передать эти аргументы в <b>check-rock-direction</b>. Конечно, можно было бы внести в <b>rotate</b> соответствующие изменения, вызывая макрос из него, но это сделало бы <b>rotate</b> не универсальным. Видимо, пришло время расчехлять секретное оружие функционального программирования - <a href="http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0">функции высшего порядка</a>:

<source lang="lisp">
(define! map
  ($!3
    (! map $1 $2 (!! (length! $2)))
  )
  ($?3
     (if-less! 0 $3
        ($1 (!! (nth! $3 $2)))
        (! map $1 $2 (!! (sum! $3 -1)))
     )
  )
)

(define check-rock
  (! map check-rock-direction
      (!! ((! rotate
              (!! (sum! (!! (length! ($ -all-directions)))))
              ($ -all-directions)
      )))       
  )
)
</source>
Над этим пришлось повозиться, но оно того стоило. Главное место во всем этом коде здесь: <b>($1...)</b>. Это тоже работает, что не может не радовать. Собственно, на <a href="https://github.com/GlukKazan/ZoG/tree/25c2bc9b374312d1706c0525f2570ffb49d9faa6/Prezrf">этом варианте</a> можно было бы остановиться, если бы не размер результирующего ZRF-файла. Развертывая все макросы, из 14-килобайтного исходника, препроцессор получает на выходе более чем мегабайтный файл описания! Стоит ли говорить о том, что ZoG загружает эту ZRF-ку довольно неторопливо.

Как победить эту беду? Да с помощью макросов же (у нас же больше нет ничего):

<spoiler title="Макросы создают макросы">
<source lang="lisp">
(define! troll-n
  (if-less! 0 $1
     (define (concat! troll - $1)
        ( (if-less! 1 $1
             mark
             (repeat (!! (sum! $1 -1))
                 (opposite (concat! $ 1)) 
                 (verify friend?) 
             )
             back 
          )
          (repeat $1
             (concat! $ 1)
             (verify empty?) 
          )
          (if-less! 1 $1
             (verify (or
                 (for! $dd ($ -all-directions)
                     (enemy? $dd)
                 )
             ) )
          )
          (for! $dd ($ -all-directions)
             (if (enemy?  $dd)
                 (capture $dd)
             )
          )
          add
        )
     )
     (! troll-n (!! (sum! $1 -1)))
  )
)

(! troll-n 7)

(define! troll-all
  (if-less! 0 $1
     (for! $d ($ -all-directions)
        ( (concat! troll - $1) $d
        )
     )
     (! troll-all (!! (sum! $1 -1)))
  )
)
</source>
</spoiler>
Конструкция <b>(! troll-n 7)</b> последовательно создает определения ZRF-макросов troll-1, troll-2, ... troll-7 (порядок их следования для нас не важен), а <b>(! troll-all)</b>, будучи вызвана в нужном месте, перечислит их вызовы. Здесь стоит обратить внимание на конструкцию <b>(concat! $ 1)</b>. Таким замысловатым образом, мы формируем <b>$1</b> в теле ZRF-макроса. Если мы просто скажем <b>$1</b>, получится не очень хорошо.

<a href="https://github.com/GlukKazan/ZoG/tree/master/Prezrf">Результат</a> не замедливает сказаться. Размер итогового ZRF-файла снижается до 28-килобайт. Можно было бы сделать его еще меньше, но я не видел в этом большого смысла. Он работает так же как и оригинал, а это значит, что на нашем длинном пути мы не наделали ошибок.

Хочу отметить, что описываемый мной <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1663">препроцессор</a> совершенно бесплатен в использовании и кроссплатформенен. Каждый счастливый обладатель установленной Java может с ним поэкспериментировать. Разумеется результаты его трудов запустить в демо-версии ZoG не удастся, но мы ведь тут ненормальным программированием занимаемся?

<spoiler title="Примечание">
В качестве иллюстрации к статье, использована работа знаменитого художника <a href="http://ru.wikipedia.org/wiki/%D0%AD%D1%88%D0%B5%D1%80,_%D0%9C%D0%B0%D1%83%D1%80%D0%B8%D1%86_%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%BB%D0%B8%D1%81">Мориса Эшера</a>.
</spoiler>
</habracut>

Приручаем ZoG (Часть 4: Осторожно — мины!)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/41e/5ce/563/41e5ce56384db64501865faea7565a7b.png"/>Сегодня я хочу продолжить рассказ о возможностях языка описания игр ZRF, используемого <a href="http://zillionsofgames.com/">Zillions of Games</a>. В предыдущих <a href="http://habrahabr.ru/post/212835/">статьях</a> цикла я показал как описываются ходы фигур, но есть еще одна важная разновидность хода, оставшаяся не рассмотренной. Помимо перемещения фигур по доске (возможно со взятием фигур противника), игрок (если ему это разрешено), может добавлять новые фигуры на поле. Эта разновидность хода называется сбросом (<b>drops</b>).
Кроме того, в сегодняшней статье, я расскажу о том, как в ZoG осуществляется генерация случайных ходов. Этот функционал необходим, например, при реализации игр, использующих броски игровых костей, для выполнения ходов, таких как <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1476">Ludo</a> или <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=1191">Chaturanga</a>.

В качестве примера, я предлагаю, взяв за основу классические Шахматы, реализовать игру по мотивам одной из миссий сюжетной кампании <a href="http://www.battlevschess.com/en/">Battle vs Chess</a>. Большинство миссий в кампании играются по измененным правилам. Миссии различаются по сложности, в некоторых, для победы, достаточно провести одну из пешек в ферзи, в других - поставить мат за ограниченное число ходов. Я предлагаю рассмотреть четвертую миссию кампании Хаоса под названием "Точка невозврата".
<habracut>
В этой миссии часть центральных полей доски "заминирована". Фигура, остановившаяся на таком поле, исчезает (вместе с миной). При этом, "мины" видимы только игроку, играющему за Черных. Компьютер, играющий за Белых, "думает", что играет по обычным правилам, что позволяет заманивать его фигуры на "заминированные" позиции. Надо сказать, что подобный подход используется в большинстве из миссий кампании. Один из игроков в них обладает неполной информацией. В некоторых случаях (как например в рассматриваемой нами миссии) это является своеобразной "форой", позволяющей даже не очень сильному шахматисту выиграть у довольно сильного шахматного "движка" <a href="http://ru.wikipedia.org/wiki/Fritz_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%29">Fritz</a>, используемого Battle vs Chess.

Разумеется, в описанном виде, реализовать игру в ZoG не удастся. В силу своей универсальности, игровое ядро ZoG будет учитывать наличие мин при выполнении ходов. Ход на "заминированную" клетку очевидно не выгоден, поскольку попросту приводит к потере фигуры. Попробуем изменить правила таким образом, чтобы сделать подрыв "мин" выгодным, даже с учетом потери своей фигуры. 

Пусть при взрыве теряется не только фигура, вставшая на заминированную клетку, но и все фигуры, оказавшиеся рядом с ней. Также, чтобы сделать игру более комбинационной, будем взрывать мины, оказавшиеся рядом с исходной, убирая с поля фигуры, оказавшиеся и вблизи них тоже. Далее цепочку взрывов распространять не будем, поскольку это связано с некоторыми техническими сложностями. Кроме того, возможный подрыв цепочкой "мин" большей части фигур, расположенных на доске, привнесет в игру слишком большой элемент случайности и может сделать её не интересной.

Начнем разработку, взяв за основу описание традиционных Шахмат (<b>Chess.zrf</b>), входящее в комплект поставки ZoG. Из нее мы возьмем описание доски и ходов шахматных фигур. Подходящий графический ресурс "бомбы" можно взять, например, из игры <a href="http://zillionsofgames.com/cgi-bin/zilligames/submissions.cgi?do=show;id=124">Bombalot</a>.

<spoiler title="Начнем с описания взрыва бомбы">
<source lang="lisp">
(define bomb-capture
  (if (not (piece? Bomb $1))
     (capture $1)
  )
)

(define check-bomb-direction
  mark
  $1
  (if (piece? Bomb)
     (bomb-capture n) (bomb-capture nw)
     (bomb-capture s) (bomb-capture sw)
     (bomb-capture e) (bomb-capture ne)
     (bomb-capture w) (bomb-capture se)
  )
  capture
  back
)

(define check-bomb
  (if (piece? Bomb)
     (check-bomb-direction n) (check-bomb-direction nw)
     (check-bomb-direction s) (check-bomb-direction sw)
     (check-bomb-direction e) (check-bomb-direction ne)
     (check-bomb-direction w) (check-bomb-direction se)
     capture
  )
)
</source>
</spoiler>
Здесь все нам знакомо. Если фигура встала на бомбу, взрываем все вокруг. Если вблизи оказалась другая бомба, взрываем и ее тоже (ее соседок не трогаем). Вот как это используется:

<source lang="diff">
(define leap1 
  ($1 
  (verify not-friend?) 
+ (check-bomb)
  add
  )
 )
</source>
Просто добавляем наш макрос перед завершением каждого хода. Теперь, запретим королям завершать игру суицидом:

<source lang="diff">
+(define check_safe
+ (verify (not (piece? Bomb) ) )
+)

(define king-shift   
  ($1    
+ (check_safe) 
  (verify not-friend?) 
  (set-attribute never-moved? false) 
  add
  ) 
)
</source>
Здесь макрос <b>check-bomb</b> можно не применять, поскольку мы специально проверяем, что не встаем на бомбу.

<spoiler title="Расставим бомбы">
<source lang="diff">
+(define drop-bomb
+ ( (verify (and empty? (empty? n) (empty? s) (empty? w) (empty? e) ) )
+   add
+ )
+)

(game
   (title "Chess")
   ...
-  (players White Black)
+  (players White Black ?Init)
-  (turn-order White Black)
+  (turn-order ?Init ?Init White Black)
   (board (Board-Definitions))
   (board-setup
+     (?Init
+        (Bomb off 8)
+     )
      (White
         (Pawn a2 b2 c2 d2 e2 f2 g2 h2)
         (Knight b1 g1)
         (Bishop c1 f1)
         (Rook a1 h1)
         (Queen d1)
         (King e1)
      )
      (Black
         (Pawn a7 b7 c7 d7 e7 f7 g7 h7)
         (Knight b8 g8)
         (Bishop c8 f8)
         (Rook a8 h8)
         (Queen d8)
         (King e8)
      )
   )

+  (piece
+     (name Bomb)
+     (image ?Init "images\Bombalot\BlackBomb.bmp" "images\Bombalot\BlackBomb.bmp")
+     (drops
+       (drop-bomb)
+     )
+  )
   ...
)
</source>
</spoiler>
Можно заметить, что мы добавили третьего игрока, по имени <b>?Init</b>. Вопросительный знак в начале имени игрока означает, что он будет делать случайные ходы (в соответствии с тем что ему разрешено). Кроме того, этот игрок не будет отображаться в списке игроков (это означает, что сыграть за него будет невозможно). Новый игрок делает по два хода каждый раз перед ходом Белых. Какие ходы он может делать?

В <b>board-setup</b> ему выданы 8 бомб, которые он может выставлять на поле. Хочу обратить внимание на ключевое слово <b>off</b> в этом описании. Именно таким образом должны описываться фигуры, доступные для сброса на поле. Также описываются фигуры в играх начинающихся с пустой доски, например в реализации <a href="http://ru.wikipedia.org/wiki/Zillions_of_Games">Крестиков-ноликов</a>.

В описании фигуры <b>Bomb</b> разрешена всего одна разновидность хода - сброс фигуры на пустое поле доски, при условии того, что соседние поля по вертикали и горизонтали также пусты. Бомбы могу соседствовать с другими фигурами (в том числе бомбами) по диагонали, что, на мой взгляд, делает игру интереснее.

<spoiler title="Примечание">
Можно заметить, что графические ресурсы доски и всех фигур описываются дважды. Такой подход позволяет использовать несколько вариантов оформления, переключать которые можно в процессе игры. Поскольку наша бомба во всех вариантах будет выглядеть одинаково, просто указываем дважды путь к одному и тому же файлу.
</spoiler>
Осталось внести пару почти косметических изменений. Добавим в описание игры включение следующих опций:

<source lang="lisp">
(option "pass turn" forced)
(option "animate captures" false)
</source>
Первая из них означает, что игрок (<b>?Init</b>) может пропускать ход, при условии того, что он не может его сделать в соответствии с правилами (если не включить эту опцию, игра может завершиться, если <b>?Init</b> не найдет место для сброса бомбы). Вторая отключает анимацию взятия фигур (она выглядела слишком неестественно). Ознакомиться со списком всех доступных опций можно в документации к Zillions of Games.

Игра <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/03.Bombs.zrf">готова</a>. Можно посмотреть, как все это выглядит:

<video>http://www.youtube.com/watch?v=gS4Y2zOLmeo</video>
В целом, можно сказать, что ZoG играет по новым правилам вполне адекватно, но иногда его ходы ставят меня в тупик. Например, он подрывает своих ферзей на одиноко стоящих бомбах. Объяснить это я не могу. Видимо ядро ZoG считает бомбу настолько опасной фигурой, что её "размен" на ферзя становится выгодным. 

Я обнаружил и еще один интересный эффект, который можно пронаблюдать на следующем видео (белый король перенесен на третью горизонталь вручную):

<video>http://www.youtube.com/watch?v=gc2S7b_j-Gg</video>
По подсветке полей при ходе Короля заметно, что наличие бомб на соседних полях (напомню, что на само поле с бомбой Король ходить не может) не считается угрозой для Короля, при условии того, что их не могут "подорвать" вражеские фигуры. Как только на бомбы нападают, Король обязан от них отойти также, как если бы он уходил из под шаха. В общем то это вполне логичное поведение, если не рассматривать небольшой нюанс:

<img src="https://habrastorage.org/getpro/habr/post_images/66e/675/951/66e675951184891459c9ae01a65168e1.png"/>

Эта позиция считается матовой. Король не может съесть ферзя, так как не может подойти к бомбам, поскольку на них нападает ферзь. К сожалению, такое поведение исправить нельзя, поскольку требование ухода королем из под шаха "прибито гвоздями" к условию проигрыша:

<source lang="lisp">
(loss-condition (White Black) (checkmated King) )
</source>
Если разрешить есть королей и заменить условие проигрыша на потерю Короля:

<source lang="lisp">
(loss-condition (White Black) (pieces-remaining 0 King) )
</source>
... то ферзь будет благополучно съеден. Но я заметил, что в этом режиме, ZoG играет в эндшпиле существенно хуже. В частности, я так и не смог дождаться классического матом ладьей и королем одинокого короля. При использовании условия <b>checkmated</b>, мат ставится очень быстро.
</habracut>

Приручаем ZoG (Часть 3: Футбол Кумской долины)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/344/ef9/d5d/344ef9d5d1a94f75723e9ee57b40d1a2.png"/><b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Но мы говорим: здесь в этой пещере на краю света, дварфы и тролли заключили мир, чтобы рука об руку пройти под дланью Смерти. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И мы говорим: враг наш не Тролль и не Дварф, а злоба, клевета, трусость, сосуды омерзения, те, кто творят зло под личиной добра. Вот с кем мы сражались сегодня, но упрямство глупцов вечно и скажут... что это ложь

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Праттчетт</i></b>

В предыдущей <a href="http://habrahabr.ru/post/212237/">статье</a>, я рассказывал об оригинальной настольной <a href="http://en.wikipedia.org/wiki/Games_of_the_Discworld#Thud">игре</a>, разработанной Тревором Трураном, по мотивам произведений знаменитого английского писателя Терри Пратчетта. В 2005 году, Труран разработал новую <a href="http://en.wikipedia.org/wiki/Games_of_the_Discworld#Koom_Valley_Thud">игру</a>, использующую тот же набор фигур, на той же доске. Название этой игры - "<b>Koom Valley Thud</b>" и, сегодня, я постараюсь ее реализовать, попутно рассказав о тех возможностях языка ZRF, о которых не успел рассказать ранее. 

Напомню, что ZRF - это язык описания игровых правил (напоминающий <a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">Lisp</a>), используемый <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Несмотря на то, что в нём имеются определенные сложные моменты, в целом, он довольно прост и может быть освоен любым человеком, даже очень далеким от программирования. Главным достоинством игрового ядра ZoG является его универсальность. Описав правила мы, фактически сразу, получаем новую игру. Хотя AI ZoG уступает специализированным игровым движкам, играет он, на удивление, сильно. К сожалению, бесплатная демонстрационная версия приложения позволяет запускать лишь ограниченный набор игр и не позволяет загружать ZRF-описания собственной разработки.
<habracut>
Как обычно, начну с правил игры. Доска для <b>Koom Valley Thud</b> имеет единственное отличие от оригинальной доски <b>Thud</b> - центральное поле доступно для ходов фигур. "Скала", расположенная на нем в начале игры, может перемещаться по полю. Цель игры гномов - перетащить "скалу" на последнюю горизонталь доски. Троллям, для того чтобы победить, необходимо окружить "Cкалу" как минимум тремя фигурами, причем, сделать это они должны на своем ходу.

Ходы фигур претерпели более серьезные изменения. Тролли, в этой игре, могут перемещаться на одну, две или три клетки в любом направлении (по вертикали, горизонтали или диагоналям). Взятие фигур противника осуществляется по правилам Шашек - тролль перепрыгивает через гнома (расположенного на соседней клетке) и снимает его фигуру с доски, останавливаясь на следующей клетке. Также как в Шашках, цепочка взятий может быть продолжена, но, в отличии от них, взятие осуществляется по желанию игрока. Также как перемещения, взятия могут осуществляться в любом направлении. Через свои фигуры и "Скалу" тролли перепрыгивать не могут.

Гномы, как и раньше, могут ходить на любое количество клеток по вертикали, горизонтали или диагоналям (как Ферзь в Шахматах). Для того чтобы снять с поля фигуру тролля, гномы должны "окружить" его с двух сторон (в этом отношении, игра напоминает <a href="http://ru.wikipedia.org/wiki/%D0%A5%D0%BD%D0%B5%D1%84%D0%B0%D1%82%D0%B0%D1%84%D0%BB">Тафл</a>, с тем отличием, что "окружать" можно и по диагоналям). За ход, с доски могут быть сняты несколько троллей (если все они были "окружены" гномами). Вместо хода фигурой, гномы могут переместить "Скалу" на одну клетку в любом направлении. Обязательным условием для такого перемещения является соседство с фигуркой гнома как в начальной, так и в конечной точке перемещения (соседом не обязательно должен быть один и тот же гном). Гномы не могут перепрыгивать через фигуры.

Осмыслив правила, можно приступить к их описанию на ZRF. Я не буду приводить здесь макросы описания доски и игры. Отличия их от <b>Thud</b> минимальны, кроме того, полное описание игры всегда можно посмотреть на <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/02.Thud.zrf">GitHub</a>. Сосредоточимся на менее очевидных вещах. Со стороны троллей, нам требуется описать возможности двух принципиально разных ходов (со взятием и без). При этом, если выполняется взятие фигуры, следующим ходом может быть только взятие. Делается это следующим образом:

<spoiler title="Вначале, описываем обычный ход тролля">
<source lang="lisp">
( define kv-troll 
  ( $1 
    (verify empty?) 
    add
    $1
    (verify empty?) 
    add
    $1
    (verify empty?) 
    add
  )
)
</source>
</spoiler>
Здесь сказано, что фигура может ходить по пустым клеткам на одну, две или три клетки, в указанном направлении.

<spoiler title="Далее, описываем ход со взятием">
<source lang="lisp">
( define kv-troll-capturing
  ( $1
    (verify (piece? Dwarf) )
    capture
    $1
    (verify empty?)
    (add-partial capturing-type)
  )
)
</source>
</spoiler>
Мы двигаемся в указанном направлении и, если на клетке расположен гном, снимаем его с доски. Двигаемся далее, если следующая клетка пустая, и завершаем ход новой директивной <b>add-partial</b>. В отличии от <b>add</b>, она позволяет выполнить частичный ход. В качестве параметра, директиве <b>add-partial</b> передается тип хода, к которому должно принадлежать продолжение. Типы ходов определяются в описании фигуры:

<spoiler title="Типы ходов">
<source lang="lisp">
   (piece
      (name Troll)
      (image Trolls "images\gluk\T.bmp")
      (description "Troll")
      (moves
         (move-type capturing-type)
            (kv-troll-capturing n) (kv-troll-capturing ne)
            (kv-troll-capturing e) (kv-troll-capturing nw)
            (kv-troll-capturing s) (kv-troll-capturing se)
            (kv-troll-capturing w) (kv-troll-capturing sw)
         (move-type non-capturing-type)
            (kv-troll n) (kv-troll ne)
            (kv-troll e) (kv-troll nw)
            (kv-troll s) (kv-troll se)
            (kv-troll w) (kv-troll sw)
      )
   )
</source>
</spoiler>
На уровне описания игры (<b>game</b>), директивой <b>move-priorities</b> можно задать приоритеты для типов ходов, сделав взятие обязательным (как в Шашках), но мы этого делать не будем, предоставляя возможность выбора игроку. Ход гнома описывается просто:

<spoiler title="Ход гнома">
<source lang="lisp">
( define check-troll
  ( if (enemy? $1)
    mark
    $1
    ( if (piece? Dwarf $1) 
      capture
    )
    back
  )
)

( define kv-dwarf
  ( $1 
    ( while empty? 
      ( if on-board?
        (check-troll n) (check-troll nw)
        (check-troll s) (check-troll sw)
        (check-troll w) (check-troll ne)
        (check-troll e) (check-troll se)
        add
      )
      $1 
    )
  )
)
</source>
</spoiler>
Завершая ход, мы проверяем все направления, на предмет наличия тролля, "окруженного" гномом с противоположной стороны и снимаем с доски найденные фигуры. Стоит обратить внимание на то, что предикат <b>piece?</b> может принимать два параметра - тип фигуры и направление (что позволяет выполнить проверку не перемещаясь на соседнюю клетку). Осталось описать перемещение "Скалы":

<spoiler title='Двигаем "Скалу"'>
<source lang="lisp">
( define rock
  ( (verify (or (piece? Dwarf n) (piece? Dwarf nw) 
                (piece? Dwarf s) (piece? Dwarf sw) 
                (piece? Dwarf w) (piece? Dwarf ne) 
                (piece? Dwarf e) (piece? Dwarf se) ) )
    $1
    (verify empty?)
    (verify (or (piece? Dwarf n) (piece? Dwarf nw) 
                (piece? Dwarf s) (piece? Dwarf sw) 
                (piece? Dwarf w) (piece? Dwarf ne) 
                (piece? Dwarf e) (piece? Dwarf se) ) )
    add
  )
)
</source>
</spoiler>
Главная сложность, как обычно, связана с подсчетом. Нам необходимо определить условие победы троллей, как соседство "Скалы" с тремя их фигурами. Этого можно было бы добиться, используя директиву <b>relative-config</b>, аналогично тому, как это сделано в реализации <a href="http://ru.wikipedia.org/wiki/Zillions_of_Games">крестиков-ноликов</a>, но нам потребовалось бы описать все взаимные расположения четырех соседствующих фигур (что само по себе является довольно интересной комбинаторной задачей) и, что самое главное, такое условие срабатывало бы как на ходе троллей, так и на ходе гномов (что противоречит условиям игры).

<spoiler title="Есть другой способ">
<source lang="lisp">
( define check-proximity
  ( if (on-board? $1)
    ( if (friend? $1)
        ( if (flag? is-second)
            change-owner
          else
            ( set-flag is-second true )
        )
    )
  )
)

( define check-rock-direction
  ( set-flag is-second false )
  ( if (on-board? $1)
    $1
    ( if (and enemy? (piece? Rock) ) 
      ( check-proximity $2 )
      ( check-proximity $3 )
      ( check-proximity $4 )
      ( check-proximity $5 )
      ( check-proximity $6 )
      ( check-proximity $7 )
      ( check-proximity $8 )
    )
    $5
  )
)

( define check-rock
  ( check-rock-direction n  ne e  se s  sw w  nw)
  ( check-rock-direction ne e  se s  sw w  nw n)
  ( check-rock-direction e  se s  sw w  nw n  ne)
  ( check-rock-direction se s  sw w  nw n  ne e)
  ( check-rock-direction s  sw w  nw n  ne e  se)
  ( check-rock-direction sw w  nw n  ne e  se s)
  ( check-rock-direction w  nw n  ne e  se s  sw)
  ( check-rock-direction nw n  ne e  se s  sw w)
)
</source>
</spoiler>
Этот макрос позволяет, выполнив ход троллем, осуществить проверку, не соседствует ли с конечной точкой хода "Скала", соседствующая также с двумя другими троллями. Используется он следующим образом:

<spoiler title="Измененные ходы троллей">
<source lang="lisp">
( define kv-troll 
  ( $1 
    (verify empty?) 
    (check-rock)
    add
    $1
    (verify empty?) 
    (check-rock)
    add
    $1
    (verify empty?) 
    (check-rock)
    add
  )
)

( define kv-troll-capturing
  ( $1
    (verify (piece? Dwarf) )
    capture
    $1
    (verify empty?)
    (check-rock)
    (add-partial capturing-type)
  )
)
</source>
</spoiler>
Если условие соседства с тремя троллями выполняется, мы меняем владельца "Скалы" командой <b>change-owner</b>. Теперь мы можем легко сформулировать условие поражения гномов, как потерю всех фигур типа "Скала":

<source lang="lisp">
(loss-condition (Dwarfs) (pieces-remaining 0 Rock))
</source>
В реализации макроса, также стоит обратить внимание на работу с флагом командами <b>flag?</b> и <b>set-flag</b>. Флаги позволяют хранить состояние в процессе генерации хода. Помимо глобальных флагов, имеется возможность связывать булевские значения с позициями доски (командой <b>set-position-flag</b>), а также с фигурами (командой <b>set-attribute</b>). Сразу замечу, что любые попытки использовать флаги для хранения глобальных состояний, наподобие <a href="http://zillionsofgames.com/discus/messages/3/407.html?1336232540">этой</a>, обречены на неудачу.

В первую очередь, это связано с тем, что флаги и флаги позиций сбрасываются в начале каждого хода, но главная причина заключается в том, что использовать их можно только в процессе расчета ходов, а порядок вызова макросов, на этом этапе, не определен (что приводит к нежелательным побочным эффектам). Помимо этого, разработчики ZoG рекомендуют не злоупотреблять позиционными флагами, так как их использование негативно влияет на производительность. В принципе, для хранения состояния между ходами, можно использовать атрибуты фигур, но этот способ весьма трудоемок.

Осталось описать игру. Поскольку мы добавляем новый вариант игры к уже существующему ZRF-описанию, используется ключевое слово <b>variant</b>:

<spoiler title="Koom Valley Thud">
<source lang="lisp">
(variant
   (title "Koom Valley Thud")
   (description "...")
   (history "...")
   (strategy "") 
   (players Dwarfs Trolls)
   (turn-order Dwarfs Trolls)
   (kv-game-defs)
   (piece
      (name Rock)
      (image Dwarfs "images\gluk\R.bmp"
             Trolls "images\gluk\R.bmp" )
      (description "Rock")
      (moves
          (rock w) (rock sw)
          (rock e) (rock se)
          (rock n) (rock nw)
          (rock s) (rock ne)
      )
   )
   (piece
      (name Dwarf)
      (image Dwarfs "images\gluk\d.bmp")
      (description "Dwarf")
      (moves
         (kv-dwarf ne) (kv-dwarf n)
         (kv-dwarf nw) (kv-dwarf s)
         (kv-dwarf se) (kv-dwarf e)
         (kv-dwarf sw) (kv-dwarf w)
      )
   )
   (piece
      (name Troll)
      (image Trolls "images\gluk\T.bmp")
      (description "Troll")
      (moves
         (move-type capturing-type)
         (kv-troll-capturing n) (kv-troll-capturing ne)
         (kv-troll-capturing e) (kv-troll-capturing nw)
         (kv-troll-capturing s) (kv-troll-capturing se)
         (kv-troll-capturing w) (kv-troll-capturing sw)
         (move-type non-capturing-type)
         (kv-troll n) (kv-troll ne)
         (kv-troll e) (kv-troll nw)
         (kv-troll s) (kv-troll se)
         (kv-troll w) (kv-troll sw)
      )
   )
)
</source>
</spoiler>
Мы можем добавить в меню вариантов разделители, используя следующую конструкцию:

<source lang="lisp">
(variant
   (title "-")
)
</source>
Запустив эту игру на выполнение, можно заметить, что гномы заняты, в основном, беготней от троллей (как и в предыдущей игре, тролли получились слишком сильными) и времени на перемещение "Скалы" у них не остается. Поскольку я, как и старина <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D1%80%D0%BA%D0%BE%D1%83_%D0%96%D0%B5%D0%BB%D0%B5%D0%B7%D0%BE%D0%B1%D0%B5%D1%82%D0%BE%D0%BD%D1%81%D1%81%D0%BE%D0%BD">Моркоу</a>, выступаю за мир между гномами и троллями, я воспользовался гибкостью ZoG и внес в правила небольшие изменения:

<spoiler title="Я запретил все взятия вражеских фигур">
<source lang="lisp">
( define shift 
  ( $1 
    ( while empty? 
      add 
      $1
    )
  )
)

( define kvb-troll 
  ( $1 
    (verify empty?) 
    (verify (on-board? $1) ) 
    (check-rock)
    add
    $1
    (verify empty?) 
    (verify (on-board? $1) ) 
    (check-rock)
    add
    $1
    (verify empty?) 
    (verify (on-board? $1) ) 
    (check-rock)
    add
  )
)
</source>
</spoiler>
<spoiler title="И разрешил двигать мяч (пусть это будет мяч) более чем на одну клетку">
<source lang="lisp">
( define ball
  ( ( verify (or (piece? Dwarf n) (piece? Dwarf nw) 
                 (piece? Dwarf s) (piece? Dwarf sw) 
                 (piece? Dwarf w) (piece? Dwarf ne) 
                 (piece? Dwarf e) (piece? Dwarf se) ) 
    )
    $1
    ( while empty?
      ( if (or (piece? Dwarf n) (piece? Dwarf nw) 
               (piece? Dwarf s) (piece? Dwarf sw) 
               (piece? Dwarf w) (piece? Dwarf ne) 
               (piece? Dwarf e) (piece? Dwarf se) )
        add
      )
      $1
    )
  )
)
</source>
</spoiler>
Кроме того, как можно заметить, я запретил троллям подходить к краю доски. Если этого не сделать, у троллей появляется беспроигрышная стратегия - заполнить последнюю горизонталь своими фигурами, устроив оставшимися троллями (их как раз будет три) охоту за мячом. В <b>Koom Valley Thud</b> это также возможно, но там троллей можно есть (к слову сказать, компьютер, под управлением ZoG, до такой тактики ни разу не додумался). 

Результат получился, на мой взгляд, неплохим. Игра осталась достаточно сложной и позиционной, став более динамичной. Гномы (под управлением компьютера) теперь легко справляются с задачей (что говорит о том, что я слишком уж облегчил им жизнь) и, после некоторого количества головокружительных пасов через все поле, закатывают мяч в ворота. Желающие могут посмотреть, как это выглядит, на видео:

<video>http://www.youtube.com/watch?v=FtCxPQ4DBCg</video>
</habracut>

Приручаем ZoG (Часть 2: Бац!)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/1fa/0fe/17b/1fa0fe17b61c43084e5a0a89e7c4c7f6.png"/><b><i>Бац…

…с этим звуком тяжелая дубинка соприкоснулась с чьей то головой. Тело дернулось и завалилось назад. Дело было сделано, никем неуслышанное, неувиденное: идеальный конец, идеальное решение, идеальная история. 

Но, как говорят гномы, за любой бедой стоит тролль.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;сэр Терри Праттчетт</i></b>

<a href="http://en.wikipedia.org/wiki/Games_of_the_Discworld#Thud">Thud!</a> Разумеется, я не мог пройти мимо этой игры. Не только потому, что мне очень нравятся произведения Терри Пратчета, но, главным образом, по той причине, что игра эта ни на что не похожа. Начнем с того, что играется она на восьмиугольной доске. Гномы сражаются с троллями (и последних существенно меньше). Как тролли могут победить, пребывая в меньшинстве? Очень просто - за один ход тролль может снять с доски несколько гномов. А гномам, даже действуя сообща, чтобы снять с доски одного тролля приходится попотеть.

Настольная игра, по произведению Пратчетта, была разработана в 2002 году Тревором Трураном и выпущена в продажу. С того самого момента, как я узнал про эту игру, мне очень хотелось в нее сыграть. Я долго и безуспешно искал ее компьютерную реализацию, но все, что я нашел, это рассуждения о том, что игра эта слишком сложная, чтобы компьютер мог в нее играть. Теперь, у меня есть возможность проверить это утверждение.
<habracut>
Для начала разберемся с правилами игры.

Как я уже сказал ранее, игра ведется на восьмиугольной доске, в центре которой расположена "Скала", занимающая одну клетку. В игре участвуют 8 троллей, с одной стороны и 32 гнома (Dwarfs) с другой. Задача каждой стороны - максимально уменьшить численность противника. 

Игра ведется в два этапа (этот пункт правил существенным образом используется в сюжете одноименной <a href="http://en.wikipedia.org/wiki/Thud!">книги</a>). Каждый из игроков должен сыграть как за гномов, так и за троллей. Как правило, снять с доски все фигуры противника не удается. Партия заканчивается по договоренности игроков, после чего считаются очки. Каждый оставшийся на доске гном оценивается в 1 очко, тролль - 4 очка. Результаты двух сыгранных партий складываются. Кто набрал больше очков - тот и победил.

Гномы ходят на любое количество свободных клеток по вертикали, горизонтали или диагоналям (как ферзь в Шахматах), но, для того, чтобы снять с доски тролля, гном должен на него "запрыгнуть". Несколько гномов, образующих линию (по вертикали, горизонтали или диагонали), позволяют крайнему гному прыгнуть (в противоположном от линии направлении) на количество клеток меньшее или равное количеству гномов в линии (при условии того, что в конечной точке прыжка располагается тролль). Одиночно стоящий гном также образует линию и, таким образом, может прыгнуть на 1 клетку в любом направлении, сняв тролля (если ему конечно удалось подобраться к нему вплотную).

Тролли могут ходить на одну клетку в любом направлении (как король в Шахматах). Все гномы, оказавшиеся на расстоянии одной клетки от точки завершения хода, снимаются с доски. Таким образом, за один ход, тролль может снять с доски до 7 гномов (если очень сильно повезет). Для того, чтобы снять гнома с доски, тролль должен сходить (даже если вплотную к нему уже стоит гном). Тролли также могут выстраиваться в линии (хотя им это нужно в гораздо меньшей степени чем гномам). Линия из N троллей (по вертикали, горизонтали или диагонали) может "толкнуть" крайнего тролля на N (или менее) клеток, при условии, что, в результате этого хода, с доски будет снят хотя бы один гном.

Фигуры не могут перепрыгивать друг через друга или через "Скалу" в центре доски.

Можно заметить, что нам требуется подсчитывать количество фигур в "линии". Поскольку с подсчетом чего-бы то ни было в <a href="http://zillionsofgames.com/">ZoG</a> все очень непросто (скорее всего, я еще неоднократно буду говорить об этом), реализация этих правил станет, для нас, в некотором роде, испытанием, а заодно, позволит более полно проиллюстрировать возможности языка описаний ZRF. Начнем, впрочем, с простого:

<spoiler title="Доска">
<source lang="lisp">
(define board-defs
  (image "images\gluk\Thud.bmp")
  (grid
     (start-rectangle 45 35 60 58)
     (dimensions
         ("a/b/c/d/e/f/g/h/i/j/k/l/m/n/o" (35 0)) ; files
         ("15/14/13/12/11/10/9/8/7/6/5/4/3/2/1" (0 35)) ; ranks
     )
     (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0)
                 (nw -1 -1) (ne 1 -1) (se 1 1) (sw -1 1))
  )
  (kill-positions a15 b15 c15 d15 e15    k15 l15 m15 n15 o15
                  a14 b14 c14 d14            l14 m14 n14 o14
                  a13 b13 c13                    m13 n13 o13 
                  a12 b12                            n12 o12
                  a11                                    o11
                                      h8
                  a5                                     o5
                  a4  b4                             n4  o4
                  a3  b3  c3                     m3  n3  o3
                  a2  b2  c2  d2             l2  m2  n2  o2
                  a1  b1  c1  d1  e1     k1  l1  m1  n1  o1 )
  (symmetry Black (n s)(s n) (ne sw) (sw ne) (nw se) (se nw))
)
</source>
</spoiler>
В этом описании, по сравнению с тем, о чем я говорил в предыдущей <a href="http://habrahabr.ru/post/211100/">статье</a>, добавилось новое ключевое слово <b>kill-positions</b>. Этот раздел описания позволяет запретить ряд позиций доски, превратив ее, таким образом, из четырехугольной в восьмиугольную. В центре, как я и обещал, находится "Скала". Фигуры через нее проходить не могут. Фактически, это не часть игрового поля.

<spoiler title="Идем дальше">
<source lang="lisp">
( define game-defs
   ( board
      (board-defs)
   )
   ( board-setup
      (White (Dwarf f1  g1  i1  j1  e2  k2  d3  l3  c4  m4  b5 
                    n5  a6  o6  a7  o7  a9  o9  a10 o10 b11 n11
                    c12 m12 d13 l13 e14 k14 f15 g15 i15 j15) )
      (Black (Troll g7  h7  i7  g8  i8  g9  h9  i9) )
   )
   (loss-condition (White Black) stalemated)
   (draw-condition (White Black) repetition)
)
</source>
</spoiler>
Здесь ничего нового. Расставляем фигуры, определяем условия проигрыша (для каждой из сторон - невозможность сделать очередной ход) и ничьей (повторение позиции). Теперь, начинается самое интересное. Нам необходимо придумать способ подсчитывать фигуры в линии.

<spoiler title="Прыжок гнома">
<source lang="lisp">
( define dwarf-3
  ( mark
    (opposite $1) (verify friend?)
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    $1 (verify enemy?) 
    add
  )
)
</source>
</spoiler>
Для того, чтобы прыгнуть фигурой на 3 клетки, я делаю следующее:

<ol>
	<li>Запоминаю текущую позицию командой mark</li>
	<li>Дважды двигаюсь в направлении противоположном указанному, проверяя наличие на клетке дружественной фигуры</li>
	<li>Возвращаюсь на исходную клетку, командой back</li>
	<li>Дважды двигаюсь в направлении хода, проверяя, что клетка пуста</li>
	<li>Двигаюсь еще раз, если на целевой клетке находится вражеская фигура</li>
	<li>Если все условия соблюдены, завершаю ход командой add (вражеская фигура убирается с доски автоматически)</li>
</ol>
Теперь гномы умеют прыгать на три клетки (при наличии подходящей линии), вынося с доски тролля. Чтобы помимо трех, гномы могли прыгать и на другое количество клеток, необходимо доопределить макросы dwarf-1, dwarf-2 и так далее, до dwarf-7 включительно. Далее макросы можно не определять, поскольку на большее количество клеток, на нашей доске, прыгнуть не получится (даже для того, чтобы имелась возможность прыгнуть на 7 клеток, гномам должно очень сильно повезти, так что, скорее всего, этот макрос никогда не будет использоваться). Это решение несколько многословно, но оно работает. 

Помимо взятия, гномы должны уметь делать обычный ход (на любое количество клеток по указанному направлению). Здесь все просто:

<spoiler title="Ход гнома">
<source lang="lisp">
( define shift 
  ( $1 
    ( while empty? 
      add 
      $1
    )
  )
)
</source>
</spoiler>
Мы используем цикл. Пока клетки пустые, двигаемся в указанном направлении, добавляя возможные ходы. Это не означает, что мы будем ходить на <b>все</b> эти клетки. Мы просто сообщаем ядру ZoG, что на эти клетки <b>можно</b> ходить, остальное - его дело.

Реализация хода троллей несколько осложнена тем обстоятельством, что в конце хода они могут снимать с доски фигурки гномов, находящиеся на соседних клетках. Вот как выглядит реализация хода тролля на две клетки:

<spoiler title="Ход тролля">
<source lang="lisp">
( define troll-2 
  ( mark
    (opposite $1) (verify friend?) 
    back 
    $1 (verify empty?)
    $1 (verify empty?)
    (verify (or (enemy? n) (enemy? nw) (enemy? s) (enemy? ne)
                (enemy? w) (enemy? sw) (enemy? e) (enemy? se))) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)
</source>
</spoiler>
Помимо проверки наличия подходящей линии, здесь осуществляется проверка того, что, в результате хода, будет взят хотя бы один гном. Также, перед завершением хода, добавлено взятие соседей по всем восьми направлениям (при условии того, что это вражеские фигуры). Следует отметить, что такие предикаты как <b>enemy?</b> или <b>empty?</b> допускают форму вызова с передачей параметра направления, что позволяет выполнить проверку, не перемещаясь на другую клетку. Зачастую, это очень удобно. В реализации хода на одну клетку, просто убираем лишние проверки:

<spoiler title="Ход тролля на одну клетку">
<source lang="lisp">
( define troll-1 
  ( $1 
    (verify empty?) 
    (if (enemy? n) (capture n)) (if (enemy? nw) (capture nw))
    (if (enemy? s) (capture s)) (if (enemy? ne) (capture ne))
    (if (enemy? w) (capture w)) (if (enemy? sw) (capture sw))
    (if (enemy? e) (capture e)) (if (enemy? se) (capture se))
    add
  )
)
</source>
</spoiler>
Осталось собрать игру воедино и убедиться, что все работает:

<spoiler title="Thud!">
<source lang="lisp">
(game
   (title "Thud")
   (description "...")
   (history "...")
   (strategy "...")

   (players White Black)
   (turn-order White Black)
   (game-defs)
   (piece
      (name Dwarf)
      (image White "images\gluk\d.bmp")
      (description "d")
      (moves
         (dwarf-1 n) (dwarf-1 ne) (dwarf-2 n) (dwarf-2 ne)
         (dwarf-1 e) (dwarf-1 nw) (dwarf-2 e) (dwarf-2 nw)
         (dwarf-1 s) (dwarf-1 se) (dwarf-2 s) (dwarf-2 se)
         (dwarf-1 w) (dwarf-1 sw) (dwarf-2 w) (dwarf-2 sw)

         (dwarf-3 n) (dwarf-3 ne) (dwarf-4 n) (dwarf-4 ne)
         (dwarf-3 e) (dwarf-3 nw) (dwarf-4 e) (dwarf-4 nw)
         (dwarf-3 s) (dwarf-3 se) (dwarf-4 s) (dwarf-4 se)
         (dwarf-3 w) (dwarf-3 sw) (dwarf-4 w) (dwarf-4 sw)

         (dwarf-5 n) (dwarf-5 ne) (dwarf-6 n) (dwarf-6 ne)
         (dwarf-5 e) (dwarf-5 nw) (dwarf-6 e) (dwarf-6 nw)
         (dwarf-5 s) (dwarf-5 se) (dwarf-6 s) (dwarf-6 se)
         (dwarf-5 w) (dwarf-5 sw) (dwarf-6 w) (dwarf-6 sw)

         (dwarf-7 n) (dwarf-7 ne) (shift n) (shift ne)
         (dwarf-7 e) (dwarf-7 nw) (shift e) (shift nw)
         (dwarf-7 s) (dwarf-7 se) (shift s) (shift se)
         (dwarf-7 w) (dwarf-7 sw) (shift w) (shift sw)
      )
   )
   (piece
      (name Troll)
      (image Black "images\gluk\T.bmp")
      (description "T")
      (moves
         (troll-1 n) (troll-1 ne) (troll-2 n) (troll-2 ne)
         (troll-1 e) (troll-1 nw) (troll-2 e) (troll-2 nw)
         (troll-1 s) (troll-1 se) (troll-2 s) (troll-2 se)
         (troll-1 w) (troll-1 sw) (troll-2 w) (troll-2 sw)

         (troll-3 n) (troll-3 ne) (troll-4 n) (troll-4 ne)
         (troll-3 e) (troll-3 nw) (troll-4 e) (troll-4 nw)
         (troll-3 s) (troll-3 se) (troll-4 s) (troll-4 se)
         (troll-3 w) (troll-3 sw) (troll-4 w) (troll-4 sw)

         (troll-5 n) (troll-5 ne) (troll-6 n) (troll-6 ne)
         (troll-5 e) (troll-5 nw) (troll-6 e) (troll-6 nw)
         (troll-5 s) (troll-5 se) (troll-6 s) (troll-6 se)
         (troll-5 w) (troll-5 sw) (troll-6 w) (troll-6 sw)

         (troll-7 n) (troll-7 ne)
         (troll-7 e) (troll-7 nw)
         (troll-7 s) (troll-7 se)
         (troll-7 w) (troll-7 sw)
      )
   )
)
</source>
</spoiler>
Следует заметить, что тролли, в этой игре, получились очень сильными фигурами. Будь доска побольше, гномы успели бы убежать подальше и собраться в компактный блок, подойти к которому было бы уже не так просто. Но, на нашей доске, благодаря возможности прыжка, тролли добираются до гномов уже на 2-3 ходу. Я запускал эту игру в режиме управления компьютером за обе стороны на продолжительное время. В конечном итоге, с обоих сторон оставалось по 5 фигур, после чего тролли уже не могли догнать гномов, в силу мобильности последних. Допускаю, что человек мог бы сыграть за гномов лучше. С другой стороны, играя за троллей, компьютер с поставленной задачей безусловно справляется.

Исходники, как всегда, можно забрать на <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/02.Thud.zrf">GitHub</a>.

На всякий случай напоминаю, что запустить их на Demo-версии Zillions of Games не получится. Можете даже не пытаться.
</habracut>

Приручаем ZoG (Часть 1: Волки и Козленок)

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/b67/468/6e1/b674686e19f28b2b00e47a264e44ad15.png" alt="Волки и Козленок"/> В <a href="http://habrahabr.ru/post/210468/">предыдущей</a> статье я рассказывал об уникальном, на мой взгляд, проекте <a href="http://www.zillions-of-games.com/">Zillions of Games</a>. Как я и обещал, я начинаю небольшой цикл учебных статей по описанию возможностей декларативного языка, предназначенного для разработки новых (и описания уже существующих) игр, в рамках этого проекта.

Для того чтобы не загромождать изложение излишними (на этом этапе) подробностями, я выбрал для реализации очень простую игру. Я играл в нее в детстве. Она называется "Волки и Козленок". Правила следующие: Волки (черные фигуры) - ходят на одну клетку по диагонали, только вперед. Козленок (белая фигура) - также ходит на одну клетку по диагонали, но в любую сторону. Задача белых - пройти на любую из четырех клеток своего цвета последней горизонтали. Задача черных - лишить белых возможности хода.

Поскольку на стандартной шахматной доске 8x8 черные побеждают элементарно, используем для игры доску 9x9 клеток. Эта игра очень простая (и нравится детям). При правильной игре, белые всегда побеждают.
<habracut>
Язык описания правил (ZRF) очень напоминает <a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">LISP</a>. Как и в LISP-е, очень важно следить за балансом открывающихся и закрывающихся скобок (в противном случае, игра просто не загрузится). Также как и в LISP-е, комментарии начинаются с символа точки с запятой и продолжаются до конца строки. 

<source lang="lisp">
; *****************************************************************
; *** Волки и Козленок
; *****************************************************************

(version "2.0")
</source> 
Здесь, в комментарии, мы кратко описываем игру и указываем версию Zillions of Games, на которой она должна работать. На более младшей версии "движка" игра не запустится.

В ZRF, активно используются макросы. Они довольно просты, но могут использовать параметры. Следующая запись, представляет собой макрос, описывающий единственно возможный в нашей игре ход - на одну клетку в указанном направлении:

<source lang="lisp">
(define checker-shift ($1 (verify empty?) add))
</source> 
При использовании в коде записи:

<source lang="lisp">
(checker-shift ???)
</source> 
Макрос раскрывается следующим образом:

<source lang="lisp">
(??? (verify empty?) add)
</source> 
Смысл передаваемого параметра и всей этой записи я объясню ниже. Пока, нам важно понимать, что макросы спасают нас от большого количества писанины и связанной с ней возможностью ошибок в описании.

Далее описывается доска. Ее описание также принято выносить в макрос:

<source lang="lisp">
(define board-defs
  (image "images\gluk\Board.bmp")
  (grid
     (start-rectangle 2 2 48 48)
     (dimensions
         ("a/b/c/d/e/f/g/h/i" (48 0)) ; files
         ("9/8/7/6/5/4/3/2/1" (0 48)) ; ranks
     )
     (directions (nw -1 -1) (ne 1 -1) (se 1 1) (sw -1 1))
  )
  (symmetry Black (ne sw) (sw ne) (nw se) (se nw))
  (zone (name goals) (players White) (positions b9 d9 f9 h9) )
)
</source> 
Смысл описания image понятен - это имя файла рисунка, загружаемого для отображения доски. Далее следует описание квадратной доски (grid). Следует заметить, что возможности ZRF не ограничиваются описанием прямоугольных досок. Используя этот язык, можно описывать треугольные и шестиугольные доски, можно описывать многомерные доски, вплоть до 5-ти измерений, можно "склеивать" края доски, определяя ее топологию и т.д. Мы не будем сейчас на этом останавливаться. Подробности таких описаний можно найти в chm-файле, описывающем язык ZRF (поставляемом вместе с игрой), а также в огромном количестве уже реализованных игр на всевозможных досках.

Для нашей игры важны три ключевые фразы описания grid: start-rectangle описывает каким образом доска "накладывается" на загруженный рисунок. Фраза dimensions - описывает измерения (у нас их два). Строки в начале описания каждого измерения важны - они описывают порядок нумерации клеток (определяя, таким образом, систему координат). Следующий далее параметр определяет, каким образом "линейка" измерения накладывается на доску. Следует сказать, что при использовании изображения доски, разработанного самостоятельно, могут возникнуть сложности с подбором этих числовых значений, а также значений, указанных в start-rectangle. Может потребоваться множество попыток, для того, чтобы изображения фигур попадали в нужные места на изображении доски.

Следующая, очень важная фраза (directions) определяет направления, в которых могут двигаться фигуры. Мы определяем четыре направления - северо-запад (nw), северо-восток (ne), юго-запад (sw) и юго-восток (se). Фразой symmetry, мы определяем правила, по которым эти направления преобразуются для черного игрока.

Последняя строка (zone) - определяет набор клеток, который мы будет использовать далее, при определении условия победы Белых.

<source lang="lisp">
(define game-defs
   (board
      (board-defs)
   )
   (board-setup
      (White (WC e2) )
      (Black (BC b9 d9 f9 h9) )
   )
   (win-condition (White) (absolute-config WC (goals)))
   (loss-condition (White Black) stalemated)
)
</source>
В этом макросе, мы определяем условия игры. Фразой board задается ранее определенная нами доска (макрос board-defs раскрывается). В board-setup определяются начальные позиции игроков, после чего, фразами win-condition и loss-condition определяются условия победы и поражения для игроков. Условием победы для Белых мы определяем прохождение в ранее определенную нами зону, а условием поражения, для обеих сторон, отсутствие возможности сделать очередной ход.

Осталось определить игру:

<source lang="lisp">
(game
   (title "Волки и Козленок")
   (description "Провести белую фишку на последнюю горизонталь")
   (players White Black)
   (turn-order White Black)
   (game-defs)
   (piece
      (name WC)
      (image White "images\gluk\W.bmp")
      (description "Козленок")
      (help "Ходит на 1 клетку по диагонали вперед и назад")
      (moves
         (checker-shift ne)
         (checker-shift nw)
         (checker-shift se)
         (checker-shift sw)
      )
   )
   (piece
      (name BC)
      (image Black "images\gluk\B.bmp")
      (description "Волк")
      (help "Ходит на 1 клетку по диагонали только вперед")
      (moves
         (checker-shift ne)
         (checker-shift nw)
      )
   )
)
</source>
Большинство из определений здесь интуитивно понятны. Стоит остановиться лишь на нескольких моментах. Фраза players описывает тех самых игроков White и Black, которых мы уже использовали ранее. Игроков может быть больше двух, а в головоломках может быть определен один игрок (имеется даже возможность определить игрока делающего случайные ходы, но это тема для отдельного разговора). Фраза turn-order определяет порядок очередности хода для игроков (он также может отличаться от простого чередования хода двух игроков).

Далее, после описания настроек игры (game-defs), следует описание фигур, используемых в игре (piece). Большинство описаний в них также  понятны. В разделе moves перечисляются все возможные для фигуры ходы. Именно здесь мы используем макрос checker-shift, о котором говорили в самом начале. Как легко видеть, в качестве параметра, ему передается возможное направление движения фигуры. В результате развертывания макроса, получается что-то наподобие следующего:

<source lang="lisp">
( ne
  (verify empty?)
  add
)
</source>
Мы выполняем три шага - двигаемся в указанном направлении, проверяем, пуста ли клетка и ставим фигуру (здесь имеется сложный для понимания момент. Для себя, я считаю, что в начале хода фигура снимается с доски, а в конце хода возвращается на доску). Подробнее, о возможностях описания правил ходов я планирую рассказать в следующих статьях, на примере более сложных игр.

Новая игра готова. Желающие могут загрузить ее из репозитория на <a href="https://github.com/GlukKazan/ZoG/blob/master/Rules/01.Wolfs.zrf">GitHub</a>.

<spoiler title="Важная ремарка">
<b>Внимание:</b> для того, чтобы запустить этот код, вам потребуется, каким либо образом, разлочить ядро Zillions of Games (например - купить серийный номер)
</spoiler>
</habracut>

Xalan, Saxon и 8 ферзей

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/bc5/fea/674/bc5fea6746e919f2eda0823e322fcd7d.png"/>
Сегодня я хочу рассказать об <a href="http://ru.wikipedia.org/wiki/XSLT">XSLT</a>. Этот, весьма своеобразный, язык может оказаться очень полезным в тех случаях, когда требуется обработать XML-данные, сколь нибудь не тривиальным образом. Я расскажу о двух наиболее популярных (в среде Java-разработчиков) реализациях XSLT-процессора, подробно остановлюсь на вопросах их использования из Java-кода и попытаюсь сравнить их производительность. В качестве теста для сравнения производительности, я буду использовать широко известную <a href="http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%B2%D0%BE%D1%81%D1%8C%D0%BC%D0%B8_%D1%84%D0%B5%D1%80%D0%B7%D1%8F%D1%85">задачу</a> о расстановке 8-ми ферзей на шахматной доске. 

Поскольку решение подобных задач, с использованием XSLT вряд ли можно отнести к категории нормальной деятельности, топик помещен в соответствующий раздел. В то же время, я надеюсь, что эта статья будет полезна, в качестве учебного материала.
<habracut>
<h4><a href="http://xml.apache.org/xalan-j/">Xalan</a> vs <a href="http://saxon.sourceforge.net/">Saxon</a></h4>
Несмотря на достаточно большое количество существующих реализаций XSLT, в случае, если мы говорим о разработке на языке Java, выбор (на мой взгляд) сводиться к двум упомянутым в заголовке. Действительно, использование реализации от <a href="http://ru.wikipedia.org/wiki/MSXML">Microsoft</a>, затруднено тем, что она поставляется в виде нейтивной dll, а реализация от <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions229.htm">Oracle</a> предназначена для использования непосредственно в базе данных. Другие реализации гораздо менее известны (меня действительно интересует этот вопрос и я буду рад дополнительно рассмотреть любую из Java-совместимых реализаций XSLT, предложенную участниками Хабра).

Saxon, на мой взгляд, является наиболее развитым, на сегодняшний день, XSLT-процессором. <a href="http://www.saxonica.com/feature-matrix.html">Матрица</a> предоставляемых им возможностей действительно впечатляет. Хотя наиболее интересные из этих возможностей поддерживаются только коммерческими дистрибутивами, поставляемый по условиям <a href="http://en.wikipedia.org/wiki/Mozilla_Public_License">Mozilla Public License version 1.0</a> <a href="http://saxon.sourceforge.net/#F9.4HE">Saxon HE</a> также предоставляет полноценную поддержку XPath и XSLT как версии 1.0, так и версии 2.0. Для того, чтобы понять, насколько поддержка XSLT 2.0 может облегчить жизнь, достаточно бегло ознакомиться с содержанием популярного учебника <a href="http://shop.oreilly.com/product/9780596003722.do">XSLT Cookbook</a> за авторством Sal Mangano.

Главным достоинством Xalan, в отличии от Saxon, является использование менее ограничивающей <a href="http://xml.apache.org/xalan-j/#license1.1">Apache License Version 1.1</a>. Эта реализация обеспечивает полноценную поддержку XSLT версии 1.0. Еще одним козырем, как Xalan так и Saxon, является заявленная ими полная поддержка промышленного стандарта <a href="http://xml.apache.org/xalan-j/trax.html">TrAX</a>. О том, что это такое и для чего оно нужно, я расскажу в следующем разделе.

<h4>Именем TrAX-а и JAXP-а его</h4>
TrAX - это API для выполнения XML-преобразований, разработанное рядом заинтересованных организаций с целью унификации взаимодействия с XSLT-процессорами. В части относящейся к Java API он был опубликован Sun как <a href="http://ru.wikipedia.org/wiki/JAXP">JAXP</a> 6 февраля 2001 года. Для ознакомления с возможностями использования JAXP я рекомендую прочитать <a href="http://www.ibm.com/developerworks/ru/library/x-jaxp/">следующие</a> <a href="http://www.ibm.com/developerworks/ru/library/x-jaxp2/">статьи</a>.

Коротко говоря, JAXP позволяет работать с XML-документами в Java, используя как <a href="http://ru.wikipedia.org/wiki/Document_Object_Model">DOM</a>, так и <a href="http://ru.wikipedia.org/wiki/SAX">SAX</a> (в том числе, реализуя XSLT-преобразования), не привязывая код к используемой реализации и версии обработчика. Для корректной работы достаточно обеспечить присутствие используемого jar-а в classpath и установить соответствующее System Property (последнее не обязательно если нет разницы какой из обработчиков упомянутых в classpath использовать).

Посмотрим, как это выглядит на практике. Для начала, попробуем загрузить XML-файл в память и получить из него некоторое значение, используя выражение XPath.

XML-файл будет выглядеть следующим образом:

<source lang="xml">
<?xml version="1.0"?>
<size>5</size>
</source>
Здесь не так много данных, но начинать надо всегда с простого (в дальнейшем, мы будем использовать это значение для задания размера шахматной доски).

<spoiler title="Достаем значение используя DOM">
<source lang="java">
	private void test_xpath_dom() throws Exception {
		InputSource in = new InputSource(new FileInputStream("xml/data.xml"));
		DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
		Document doc = df.newDocumentBuilder().parse(in);
		
		NodeIterator nl = XPathAPI.selectNodeIterator(doc, "/size");
		Node n;
	    while ((n = nl.nextNode())!= null) {
	    	if (n.getNodeType() == Node.TEXT_NODE) {
	    		System.out.println(n.getNodeValue());
	    	} else {
	    		System.out.println(n.getTextContent());
	    	}
	    }
	}
</source>
</spoiler>
Здесь мы получаем итератор по простому XPath-запросу, проходим по набору узлов (состоящему из одного узла) и выводим его значение (если это текстовый узел) или текстовое содержимое (в случае использованного запроса всегда будет работать этот вариант). Как мы видим, все совсем не сложно, но если мы достаем скалярное значение, можно поступить еще проще:

<spoiler title="Достаем скалярное значение используя DOM">
<source lang="java">
	private void test_xpath_dom() throws Exception {
		System.setProperty(JAVAX_TRANSFORM_FACTORY, XALAN_TRANSFORM_FACTORY);
		InputSource in = new InputSource(new FileInputStream("xml/data.xml"));
		DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
		Document doc = df.newDocumentBuilder().parse(in);
		
		XPathFactory xpathFactory = XPathFactory.newInstance();
		XPath xpath = xpathFactory.newXPath();
		XPathExpression xpathExpression = xpath.compile("/size");
		System.out.println(xpathExpression.evaluate(doc));
	}
</source>
</spoiler>
Иногда (особенно при обработке XML-файлов большого объема) использования DOM стараются избегать (поскольку данные требуется целиком загружать в память). В таких случаях, для разбора XML применяют SAX. JAXP позволяет преобразовать один формат в другой (например SAX в DOM) используя следующую трансформацию (если при выполнении трансформации не указана таблица стилей, выполняется тождественное преобразование, что зачастую бывает весьма удобно):

<spoiler title="Используем SAX-парсер">
<source lang="java">
	private void test_xpath_sax_file() throws Exception {
		TransformerFactory tf = TransformerFactory.newInstance();
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(DOMResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler h = stf.newTransformerHandler();
	    	XMLReader reader = XMLReaderFactory.createXMLReader();
	        reader.setContentHandler(h);
	        reader.setProperty("http://xml.org/sax/properties/lexical-handler", h);

			DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
			Document doc = df.newDocumentBuilder().newDocument();
			Result out = new DOMResult(doc);
			h.setResult(out);
			reader.parse("xml/data.xml");
	        
	        XPathFactory xpathFactory = XPathFactory.newInstance();
	        XPath xpath = xpathFactory.newXPath();
	        XPathExpression xpathExpression = xpath.compile("/size");
	        System.out.println(xpathExpression.evaluate(doc));
	    } else {
	    	throw new Exception("Can''t support SAXSource or DOMResult");
	    }
	}
</source>
</spoiler>
Понятно, что таким образом мы не избавимся от загрузки XML-файла в оперативную память, поскольку для промежуточного хранения мы все равно используем DOM. Как мы можем обрабатывать большие файлы? Например, мы можем получить SAX-поток при разборе большого XML-файла и преобразовать его таким образом, чтобы в память загружался не один большой, а множество мелких файлов поочередно. Попробуем сформировать SAX-события вручную:

<spoiler title="Загрузка SAX-потока">
<source lang="java">
	private void generateData(ContentHandler h, String data) throws SAXException {
		h.startDocument();
		h.startElement("", "size", "size", new AttributesImpl());
		h.characters(data.toCharArray(), 0, data.length());
		h.endElement("", "size", "size");
		h.endDocument();
	}
	

	private void test_xpath_sax_stream(String size) throws Exception {
		TransformerFactory tf = TransformerFactory.newInstance();
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(DOMResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler h = stf.newTransformerHandler();

			DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
			Document doc = df.newDocumentBuilder().newDocument();
			Result out = new DOMResult(doc);
			h.setResult(out);
			generateData(h, size);
	        
	        XPathFactory xpathFactory = XPathFactory.newInstance();
	        XPath xpath = xpathFactory.newXPath();
	        XPathExpression xpathExpression = xpath.compile("/size");
	        System.out.println(xpathExpression.evaluate(doc));
	    } else {
	    	throw new Exception("Can''t support SAXSource or DOMResult");
	    }
	}
</source>
</spoiler>
Как мы видим, здесь также нет ничего сложного. Хочу лишь предостеречь от возможной передачи в параметр uri вызовов startElement и endElement null-значений. Для Xalan это работает нормально, но Saxon выбрасывает NullPointerException.

Для полноты картины, осталось добавить, что преобразования можно связывать в цепочки, образуя конвейер. На выходе, результат можно сохранять, например, в файл:

<spoiler title="Конвейер">
<source lang="java">
	private void test_solution(String size) throws Exception {
		TransformerFactory tf = TransformerFactory.newInstance();
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(SAXResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler solve  = stf.newTransformerHandler();
	        TransformerHandler filter = stf.newTransformerHandler();
	        TransformerHandler view   = stf.newTransformerHandler();
	        Result result = new StreamResult(new File("xml/result.xml"));
	        
	        solve.setResult(new SAXResult(filter));
	        filter.setResult(new SAXResult(view));
	        view.setResult(result);
			generateData(solve, size);
	    } else {
	    	throw new Exception("Can''t support SAXSource or SAXResult");
	    }
	}
</source>
</spoiler>
Пока, мы видим здесь три пустых обработчика, выполняющих тождественное преобразование. В следующем разделе мы начнем наполнять их XSLT-кодом.

<h4>Первый подход к снаряду</h4>
Итак, нам надо расставить ферзей на шахматной доске таким образом, чтобы они не били друг-друга. Для начала нам требуется сгенерировать список позиций, удовлетворяющих условию задачи. Определимся с кодированием позиций. Поскольку, по условиям задачи, фигуры не могут располагаться на одной вертикали, мы можем использовать строку десятичных цифр для кодирования корректных позиций. 

Позиция цифры будет означать номер вертикали, а само значение - номер горизонтали, на которой расположена фигура. Поскольку мы используем десятичные цифры, начиная с единицы, мы сможем решать задачу для квадратной доски размером от 1x1 до 9x9 клеток. Чтобы расчеты выполнялись быстрее, рекомендую установить размер меньше 8-ми (5x5 клеток будет в самый раз). Код на XSLT (несмотря на свою излишнюю многословность) вполне понятный:

<spoiler title="solution.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="1.0">

  <xsl:template match="size">
    <result>
      <xsl:call-template name="queens">
        <xsl:with-param name="r"/>
        <xsl:with-param name="n" select="."/>
        <xsl:with-param name="s" select="."/>
      </xsl:call-template>
    </result>
  </xsl:template>

  <xsl:template name="queens">
    <xsl:param name="r"/>
    <xsl:param name="n"/>
    <xsl:param name="s"/>
    <xsl:choose>
      <xsl:when test="$n = 0">
        <position>
          <xsl:copy-of select="$r"/>
        </position>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="step">
          <xsl:with-param name="r" select="$r"/>
          <xsl:with-param name="n" select="$n"/>
          <xsl:with-param name="v" select="$s"/>
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="step">
    <xsl:param name="r"/>
    <xsl:param name="n"/>
    <xsl:param name="v"/>
    <xsl:param name="s"/>
    <xsl:if test="$v != 0">
      <xsl:variable name="c">
        <xsl:call-template name="check">
          <xsl:with-param name="r" select="$r"/>
          <xsl:with-param name="v" select="$v"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:if test="$c != 0">
        <xsl:variable name="l">
          <xsl:value-of select="concat($v,$r)"/> 
        </xsl:variable>
        <xsl:call-template name="queens">
          <xsl:with-param name="r" select="$l"/>
          <xsl:with-param name="n" select="$n - 1"/>
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:if>
      <xsl:call-template name="step">
        <xsl:with-param name="r" select="$r"/>
        <xsl:with-param name="n" select="$n"/>
        <xsl:with-param name="v" select="$v - 1"/>
        <xsl:with-param name="s" select="$s"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <xsl:template name="check">
    <xsl:param name="r"/>
    <xsl:param name="v"/>
    <xsl:if test="contains($r,$v)">0</xsl:if>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
Здесь мы используем упрощенную проверку на взаимный бой фигур, не выполняя проверку боя по диагонали. Запустив следующую программу на выполнение:

<spoiler title="8 ладей">
<source lang="java">
	private void test_solution(String size) throws Exception {
		TransformerFactory tf = TransformerFactory.newInstance();
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(SAXResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler solve  = stf.newTransformerHandler(new StreamSource("xsl/solution.xsl"));
	        TransformerHandler filter = stf.newTransformerHandler();
	        TransformerHandler view   = stf.newTransformerHandler();
	        Result result = new StreamResult(new File("xml/result.xml"));
	        
	        solve.setResult(new SAXResult(filter));
	        filter.setResult(new SAXResult(view));
	        view.setResult(result);
			generateData(solve, size);
	    } else {
	    	throw new Exception("Can''t support SAXSource or SAXResult");
	    }
	}
</source>
</spoiler>
... можно получить список возможных решений задачи "8 ладей".

Чтобы исключить возможные обвинения в подмене условий задачи, усложним проверку взаимного боя фигур. Для упрощения повторного использования кода, XSLT предлагает использовать возможность импорта. Ей мы и воспользуемся:

<spoiler title="queens.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="1.0">

  <xsl:import href="solution.xsl"/>

  <xsl:template name="check">
    <xsl:param name="r"/>
    <xsl:param name="v"/>
    <xsl:choose>
      <xsl:when test="contains($r,$v)">0</xsl:when>
      <xsl:otherwise>
        <xsl:variable name="y">
          <xsl:call-template name="additional_check">
            <xsl:with-param name="r" select="$r"/>
            <xsl:with-param name="v" select="$v"/>
            <xsl:with-param name="d" select="1"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$y"/> 
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="additional_check">
    <xsl:param name="r"/>
    <xsl:param name="v"/>
    <xsl:param name="d"/>
    <xsl:if test="$d &amp;lt;= string-length($r)">
      <xsl:variable name="u" select="substring($r,$d,1)"/>
      <xsl:variable name="b">
        <xsl:call-template name="abs">
          <xsl:with-param name="x" select="$v - $u"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$b = $d">0</xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="additional_check">
            <xsl:with-param name="r" select="$r"/>
            <xsl:with-param name="v" select="$v"/>
            <xsl:with-param name="d" select="$d + 1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>

  <xsl:template name="abs">
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="$x &amp;lt; 0">
        <xsl:value-of select="$x * -1"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$x"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
Замечу, что здесь необходимо использовать именно инструкцию import, а не инструкцию include, чтобы обеспечить более высокий приоритет шаблонов в импортирующей таблице по сравнению с импортируемой (это очень похоже на наследование).

Чтобы весь этот импорт заработал, необходимо внести еще одно небольшое изменение в Java-код. Определим URIResolver, который будет вызываться при запросе URI в процессе разбора XSLT:

<spoiler title="Resolver.java">
<source lang="java">
import java.io.File;

import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.stream.StreamSource;

public class Resolver implements URIResolver {

	public Source resolve(String href, String base) throws TransformerException {
		return new StreamSource(new File("xsl/" + href));
	}
}
</source>
</spoiler>
... и передадим его фабрике:

<spoiler title="8 ферзей">
<source lang="diff">
	private void test_queens(String size) throws Exception {
		TransformerFactory tf = TransformerFactory.newInstance();
+	tf.setURIResolver(new Resolver());
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(SAXResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler solve  = stf.newTransformerHandler(new StreamSource("xsl/queens.xsl"));
	        TransformerHandler filter = stf.newTransformerHandler();
	        TransformerHandler view   = stf.newTransformerHandler();
	        Result result = new StreamResult(new File("xml/result.xml"));
	        
	        solve.setResult(new SAXResult(filter));
	        filter.setResult(new SAXResult(view));
	        view.setResult(result);
			generateData(solve, size);
	    } else {
	    	throw new Exception("Can''t support SAXSource or SAXResult");
	    }
	}
</source>
</spoiler>
Конечно, в нашем случае, когда все xsl-файлы загружаются из одного дискового каталога, XSLT-процессор и сам прекрасно разберется в том откуда подгрузить файл, но представьте себе, например, что XSLT-код загружается из LOB-поля в базе данных!

Запустив программу на выполнение, мы получим список решений задачи.

<h4>Что нам с ним делать?</h4>
Список решений в том виде, в котором мы его составили, не очень удобен для человека. Он компактен, но не дает наглядного представления о позициях (без некоторого мысленного усилия). Считать количество решений вручную, используя его, также не слишком удобно. К счастью, обработка таких данных - это именно то, для чего предназначен XSLT. Добавив в конец цепочки трансформаций вызов еще одного обработчика, мы сможем легко подсчитать количество решений:

<spoiler title="count.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="1.0">

  <xsl:template match="result">
    <result>
      <xsl:value-of select="count(position)"/> 
    </result>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
... либо, показать их в наглядной форме:

<spoiler title="boards.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:redirect="http://xml.apache.org/xalan/redirect"
  extension-element-prefixes="redirect"
  version="1.0">

<xsl:output method="html"/>

  <xsl:template match="/result/position">
    <a href="{concat(. , '.html')}">
      <xsl:value-of select="."/>
    </a><br/>
    <redirect:write select="concat('xml/', . , '.html')">
      <style>
      table {
       display:block;
       margin:10px;
       border:0;
       border-collapse: collapse;
      }
      table tr {
       border:0;
      }
      table tr td {
       border:1px solid #999;
       width:15px;
       height:15px;
       padding: 0;
      }
      .active {
       background: #898989;
      }
      </style>
      <table border="1" style="border-collapse:collapse">
        <xsl:call-template name="line">
          <xsl:with-param name="r" select="."/>
          <xsl:with-param name="s" select="string-length(.)"/>
        </xsl:call-template>
      </table>
    </redirect:write>
  </xsl:template>

  <xsl:template name="line">
    <xsl:param name="r"/>
    <xsl:param name="s"/>
    <xsl:if test="string-length($r) != 0">
      <xsl:variable name="x" select="substring($r,1,1)"/>
      <tr>
        <xsl:call-template name="col">
          <xsl:with-param name="x" select="$x"/>
          <xsl:with-param name="i" select="$s"/>
        </xsl:call-template>
      </tr>
      <xsl:call-template name="line">
        <xsl:with-param name="r" select="substring($r,2)"/>
        <xsl:with-param name="s" select="$s"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <xsl:template name="col">
    <xsl:param name="x"/>
    <xsl:param name="i"/>
    <xsl:if test="$i != 0">
      <xsl:choose>
        <xsl:when test="$x = $i"><td class="active"/></xsl:when>
        <xsl:otherwise><td/></xsl:otherwise>
      </xsl:choose>
      <xsl:call-template name="col">
        <xsl:with-param name="x" select="$x"/>
        <xsl:with-param name="i" select="$i - 1"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
например такой:

<img src="https://habrastorage.org/getpro/habr/post_images/3a9/93e/aa9/3a993eaa9d4a594225f5f049c4abea34.png" alt="image"/>

В этом примере следует обратить внимание на нестандартное расширение Xalan redirect:write, позволяющее перенаправить вывод в другой файл (в XSLT 2.0, для этих целей, добавлена стандартная инструкция). К сожалению, мне не удалось перенаправить результат такого redirect-а в произвольный SAX-поток, что, на мой взгляд, несколько снижает его ценность.

<h4>Магия отражений</h4>
Мы получили решения, но их как-то слишком много. Это потому, что мы не отсеиваем повторы с учетом возможных поворотов и отражений доски. Давайте получим список уникальных решений?

Если немного подумать, становиться понятно, что всевозможных поворотов и отражений доски всего 8 (учитывая первоначальный вариант). Реализуем вспомогательные шаблоны для отражения позиции (в нашем внутреннем представлении) по вертикали (flip), горизонтали (reverse) и поворота доски на 90 градусов (rotate):

<spoiler title="utils.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="1.0">

  <xsl:template match="result">
    <result>
      <xsl:apply-templates/>
    </result>
  </xsl:template>

  <xsl:template match="position">
    <position>
      <xsl:value-of select="."/>
    </position>
    <flip>
      <xsl:call-template name="flip">
        <xsl:with-param name="x" select="."/>
      </xsl:call-template>
    </flip>
    <reverse>
      <xsl:call-template name="reverse">
        <xsl:with-param name="x" select="."/>
      </xsl:call-template>
    </reverse>
    <rotate>
      <xsl:call-template name="rotate">
        <xsl:with-param name="x" select="."/>
      </xsl:call-template>
    </rotate>
  </xsl:template>

  <xsl:template name="flip">
    <xsl:param name="x"/>
    <xsl:call-template name="flip_internal">
      <xsl:with-param name="x" select="$x"/>
      <xsl:with-param name="s" select="string-length($x) + 1"/>
    </xsl:call-template>
  </xsl:template>

  <xsl:template name="flip_internal">
    <xsl:param name="x"/>
    <xsl:param name="s"/>
    <xsl:if test="string-length($x) != 0">
      <xsl:value-of select="$s - substring($x,1,1)"/>
      <xsl:call-template name="flip_internal">
        <xsl:with-param name="x" select="substring($x,2)"/>
        <xsl:with-param name="s" select="$s"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <!-- XSLT Cookbook By Sal Mangano http://shop.oreilly.com/product/9780596003722.do -->
  <xsl:template name="reverse">
    <xsl:param name="x"/>
    <xsl:variable name="len" select="string-length($x)"/>
    <xsl:choose>
      <xsl:when test="$len &amp;lt; 2">
        <xsl:value-of select="$x"/>
      </xsl:when>
      <xsl:when test="$len = 2">
        <xsl:value-of select="substring($x,2,1)"/>
        <xsl:value-of select="substring($x,1,1)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="mid" select="floor($len div 2)"/>
        <xsl:call-template name="reverse">
          <xsl:with-param name="x" select="substring($x,$mid+1,$mid+1)"/>
        </xsl:call-template>
        <xsl:call-template name="reverse">
          <xsl:with-param name="x" select="substring($x,1,$mid)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="rotate">
    <xsl:param name="x"/>
    <xsl:call-template name="rotate_internal">
      <xsl:with-param name="x" select="$x"/>
      <xsl:with-param name="i" select="1"/>
      <xsl:with-param name="r"/>
    </xsl:call-template>
  </xsl:template>

  <xsl:template name="rotate_internal">
    <xsl:param name="x"/>
    <xsl:param name="i"/>
    <xsl:param name="r"/>
    <xsl:variable name="p">
      <xsl:call-template name="index-of">
        <xsl:with-param name="input" select="$x"/>
        <xsl:with-param name="substr" select="$i"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$p = 0">
        <xsl:value-of select="$r"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="rotate_internal">
          <xsl:with-param name="x" select="$x"/>
          <xsl:with-param name="i" select="$i + 1"/>
          <xsl:with-param name="r" select="concat($p,$r)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- XSLT Cookbook By Sal Mangano http://shop.oreilly.com/product/9780596003722.do -->
  <xsl:template name="index-of">
    <xsl:param name="input"/>
    <xsl:param name="substr"/>
    <xsl:choose>
      <xsl:when test="contains($input,$substr)">
        <xsl:value-of select="string-length(substring-before($input,$substr))+1"/>
      </xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
Здесь использованы реализации функций reverse и index-of из замечательной <a href="http://www.proklondike.com/books/codingproch/xslt_sbornik_receptov.html">книги</a> Сэл Мангано "XSLT Сборник рецептов". Сама фильтрация уникальных значений - классическая задача на использование оси preceding-sibling:

<spoiler title="distinct.xsl">
<source lang="xml">
<?xml version="1.0"?> 

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="1.0">

  <xsl:import href="utils.xsl"/>

  <xsl:template match="result">
    <result>
      <xsl:apply-templates/>
    </result>
  </xsl:template>

  <xsl:template match="position">
    <xsl:variable name="l" select="preceding-sibling::position"/>
    <xsl:variable name="a" select="."/>
    <xsl:variable name="b">
      <xsl:call-template name="flip">
        <xsl:with-param name="x" select="$a"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="c">
      <xsl:call-template name="reverse">
        <xsl:with-param name="x" select="$b"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="d">
      <xsl:call-template name="flip">
        <xsl:with-param name="x" select="$c"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="e">
      <xsl:call-template name="rotate">
        <xsl:with-param name="x" select="$a"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="f">
      <xsl:call-template name="flip">
        <xsl:with-param name="x" select="$e"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="g">
      <xsl:call-template name="reverse">
        <xsl:with-param name="x" select="$f"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="h">
      <xsl:call-template name="flip">
        <xsl:with-param name="x" select="$g"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$b = $l"></xsl:when>
      <xsl:when test="$c = $l"></xsl:when>
      <xsl:when test="$d = $l"></xsl:when>
      <xsl:when test="$e = $l"></xsl:when>
      <xsl:when test="$f = $l"></xsl:when>
      <xsl:when test="$g = $l"></xsl:when>
      <xsl:when test="$h = $l"></xsl:when>
      <xsl:otherwise>
        <position>
          <xsl:value-of select="$a"/>
        </position>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
</source>
</spoiler>
К сожалению, в XSLT 1.0 , мы не можем решить эту задачу одним XPath выражением, но в XSLT 2.0 добавлена возможность "обертывания" шаблонов в пользовательские функции.

На этом все! Мы решили задачу.

Осталось померять ...

<h4>Кто быстрее?</h4>
Измерения будем проводить при помощи следующего кода:

<spoiler title="Меряем производительность">
<source lang="java">
	private final static String JAVAX_TRANSFORM_FACTORY = "javax.xml.transform.TransformerFactory";
	private final static String SAXON_TRANSFORM_FACTORY = "net.sf.saxon.TransformerFactoryImpl";
	private final static String XALAN_TRANSFORM_FACTORY = "org.apache.xalan.processor.TransformerFactoryImpl";

	private void test_full(String size) throws Exception {
		System.setProperty(JAVAX_TRANSFORM_FACTORY, SAXON_TRANSFORM_FACTORY);
		TransformerFactory tf = TransformerFactory.newInstance();
		tf.setURIResolver(new Resolver());
	    if (tf.getFeature(SAXSource.FEATURE) && tf.getFeature(SAXResult.FEATURE)) {
	        SAXTransformerFactory stf = (SAXTransformerFactory)tf;	  
	        TransformerHandler solve  = stf.newTransformerHandler(new StreamSource("xsl/queens.xsl"));
	        TransformerHandler filter = stf.newTransformerHandler(new StreamSource("xsl/distinct.xsl"));
	        TransformerHandler view   = stf.newTransformerHandler(new StreamSource("xsl/count.xsl"));
	        Result result = new StreamResult(new File("xml/result.xml"));
	        
	        solve.setResult(new SAXResult(filter));
	        filter.setResult(new SAXResult(view));
	        view.setResult(result);
	        
	        Long timestamp = System.currentTimeMillis();
			generateData(solve, size);
			System.out.println("Elapsed Time: " + Long.toString(System.currentTimeMillis() - timestamp));
	    } else {
	    	throw new Exception("Can''t support SAXSource or SAXResult");
	    }
	}
</source>
</spoiler>
Заменяя константу SAXON_TRANSFORM_FACTORY на XALAN_TRANSFORM_FACTORY можно переключаться с одного XSLT-процессора на другой.

К сожалению (по непонятной мне причине) мне не удалось заставить нормально работать ни одну из версий ветки <a href="http://sourceforge.net/projects/saxon/files/Saxon-HE/">Saxon-HE</a>. Код работает, но каждый вызов отрабатывает невероятно медленно. Например вызов TransformerFactory.newInstance() отрабатывал несколько минут! При этом один из CPU утилизировался полностью, а код (судя по отладчику) большую часть времени находился где-то в районе реализации SHA-2.

К счастью, более ранняя <a href="http://sourceforge.net/projects/saxon/files/Saxon-B/9.1.0.8/">версия</a> из соседней ветки работает нормально. Вот итоговые картинки:

<img src="https://habrastorage.org/getpro/habr/post_images/75b/f3e/801/75bf3e80166297d877ef7628ddd335ee.png" alt="image"/>

<img src="https://habrastorage.org/getpro/habr/post_images/e8c/f9f/2a4/e8cf9f2a475faf41dfd2b455b74d3e92.png" alt="image"/>

Можно заметить, что, в этой задаче, оба XSLT-процессора работают приблизительно с одинаковой скоростью. Таким образом, использование Saxon может быть оправдано только при использовании функциональности XSLT 2.0 или XSLT 3.0.

Все исходные тексты, как обычно, выложены на <a href="https://github.com/GlukKazan/XSLT_Queens">GitHub</a>.

Напоследок, хочу поблагодарить <hh user="jonic"/> за помощь оказанную им при подготовке статьи.
</habracut>

Что-то посложнее факториала

Давным-давно, когда трава была зеленее, а деревья выше, жил-был тролль, по имени Xenocephal. Жил он, в принципе, во многих местах, но мне повезло встретить его на одном <a href="http://www.sql.ru/forum/afsearch.aspx?s=Xenocephal">форуме</a>,  где я, в то время, набирался ума-разума. Я уже не вспомню топика, в котором протекала беседа, но суть ее сводилась к тому, что Xenocephal пытался убедить всех окружающих, что Lisp (с его макросами) - всему голова, а C++, с его шаблонами, жалкое подобие левой руки. Также утверждалось, что наметапрограммировать в нем что-то сложнее набившего оскомину <a href="http://www.solarix.ru/for_developers/cpp/snippets/factorial.shtml">факториала</a> не представляется возможным.
<habracut>
У меня, в принципе, не было возражений, что макросы Lisp-а - это непомерно круто и, в то время, мне нечего было ему ответить, но фраза про шаблоны C++ и факториал глубоко засела в мой неокрепший мозг и продолжала терзать меня изнутри. И в один ужасный день, я подумал: "Какого черта??? Давайте пометапрограммируем!"

Другим источником вдохновения послужила <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B:_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B,_%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8_%D0%B8_%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B">Книга Дракона</a>. Задача нашлась быстро. Я счел, что алгоритм преобразования Недетерминированного Конечного Автомата (<a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">НКА</a>) в Детерминированный Конечный Автомат (<a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">ДКА</a>) достаточно нетривиальна, чтобы попытаться реализовать ее при помощи шаблонов C++. Нетленный <a href="http://www.proklondike.com/books/cpp/alexandresku_cpp_modern_design.html">труд</a> Александреску позволил набрать критическую массу ...

Начал я, разумеется, с примитивов. Мне требовалось, каким-то образом представлять графы:

<source lang="cpp">
template <class T, int Src, int Dst, char Chr = 0>
struct Edge
{ enum { Source  = Src,
         Dest    = Dst,
         Char    = Chr
       };
  typedef T Next;
  static void Dump(void) {printf("%3d -%c-> %3d\n",Src,Chr,Dst);T::Dump();}
};
</source>
Дуга графа задавалась индексами начальной (Src) и конечной (Dst) вершин и могла быть поименована символом (Chr). Не именованные дуги (используемые алгоритмом преобразования), по умолчанию, помечались нулевым символом. Тип Next, определенный в этом шаблоне, превращал его в список типов. Добавление дуги в этот список было реализовано следующим рекурсивным образом:

<source lang="cpp">
struct NullType {static void Dump(void) {printf("\n");}};

template <int S, int D, int C, class T, class R> struct AddEdge;
template <int S, int D, int C, class R> struct AddEdge<S,D,C,NullType,R> {
    typedef typename Edge<R,S,D,C> Result;
};
template <int S, int D, int C, class T, class R> struct AddEdge<S,D,C,Edge<T,S,D,C>,R> {
    typedef typename AddEdge<S,D,C,T,R>::Result Result;
};
template <int S, int D, int C, int s, int d, int c, class T, class R> 
struct AddEdge<S,D,C,Edge<T,s,d,c>,R> {
    typedef typename AddEdge<S,D,C,T,Edge<R,s,d,c> >::Result Result;
};
</source>
Аналогично, было организовано слияние списков (благодаря утиной типизации, любых, а не только тех, которые представляют графы):

<spoiler title="Append">
<source lang="cpp">
template <class A, class B> struct Append;
template <class T> struct Append<NullType,T> {
    typedef T Result;
};
template <int S, int D, int C, class T, class B> 
struct Append<Edge<T,S,D,C>,B> {
    typedef typename Append<T,Edge<B,S,D,C> >::Result Result;
};
</source>
</spoiler>
<spoiler title="Join">
<source lang="cpp">
template <class A, class B> struct Join;
template <class B> struct Join<NullType,B> {
    typedef B Result;
};
template <int N, class T, class B> struct Join<Set<N,T>,B> {
    typedef typename Join<T,typename AddSet<N,B,NullType>::Result>::Result Result;
};
template <int S, int D, int C, class T, class B> struct Join<Edge<T,S,D,C>,B> {
    typedef typename Join<T,typename AddEdge<S,D,C,B,NullType>::Result>::Result Result;
};
template <int N, class S, class T, class B> struct Join<StateList<N,S,T>,B> {
    typedef typename Join<T,typename AddState<N,S,B,NullType>::Result>::Result Result;
};
template <int Src, int Dst, int a, class S, class T, class B> 
struct Join<StateListEx<Src,Dst,a,S,T>,B> {
    typedef typename Join<T,typename AddState<Dst,S,B,NullType>::Result>::Result Result;
};
</source>
</spoiler>
... и применение произвольного функтора к каждому элементу списка:

<spoiler title="Map">
<source lang="cpp">
template <class T, int V, class R, template <int,int> class F> struct Map;
template <int V, class R, template <int,int> class F> struct Map<NullType,V,R,F> {
    typedef R Result;
};
template <int N, class T, int V, class R, template <int,int> class F> 
struct Map<Set<N,T>,V,R,F> { 
    typedef typename Map<T,V,Set<F<N,V>::Result,R>,F>::Result Result;
};
template <class T, int S, int D, int C, int V, class R, template <int,int> class F> 
struct Map<Edge<T,S,D,C>,V,R,F> { 
    typedef typename Map<T,V,Edge<R,F<S,V>::Result,F<D,V>::Result,C>,F>::Result Result;
};
</source>
</spoiler>
Теперь, требовалось реализовать построение НКА на основе регулярного выражения. Сама методика этого построения хорошо описана в <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B:_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B,_%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8_%D0%B8_%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B">книге</a>, упомянутой выше и сводится к тому, что элементы регулярного выражения заменяются некими базовыми конструкциями, связанными не именованными дугами. 

Именованная дуга создается элементарно:

<spoiler title="C">
<source lang="cpp">
template <char Chr>
struct C
{ typedef typename Edge<NullType,0,1,Chr> Result;
  enum {Count = 2};
};
</source>
</spoiler>
Начальная и конечная вершины получают индексы 0 и 1 соответственно.

Два графа могут быть связаны в конструкцию альтернативы /A|B/ следующим образом:

<img src="https://habrastorage.org/getpro/habr/post_images/b3a/24e/a15/b3a24ea1579290fff5301a212f7bed24.png" alt="image"/>

<spoiler title="D">
<source lang="cpp">
template <int X, int N>
struct Add { enum { Result = X+N }; };

template <class A, class B>
struct DImpl
{ private:
    typedef typename Append<
              typename Map<typename A::Result, 2, NullType, Add>::Result,
              typename Map<typename B::Result, A::Count+2, NullType, Add>::Result
              >::Result N0;
    typedef typename   Edge<N0,0,2> N1;
    typedef typename   Edge<N1,0,A::Count+2> N2;
    typedef typename   Edge<N2,3,1> N3;
  public:
    typedef typename   Edge<N3,A::Count+3,1> Result;
    enum {Count = A::Count+B::Count+2};
};
template <class T1, class T2, class T3 = NullType, class T4 = NullType, class T5 = NullType>
struct D: public DImpl<T1, D<T2,T3,T4,T5> > {};
template <class T1, class T2>
struct D<T1,T2,NullType,NullType,NullType>: public DImpl<T1,T2> {};
</source>
</spoiler>
Здесь, мы "сливаем" два входных графа (A и B) (при этом их вершины перенумеруются), после чего, соединяем их не именованными дугами, по схеме, приведенной выше. Начальная и конечная вершины по прежнему имеют индексы 0 и 1 соответственно.

Несколько более сложной для понимания оказалась реализация следования /AB/:

<img src="https://habrastorage.org/getpro/habr/post_images/d0d/c49/c21/d0dc49c212c30951d572b092fda0dddf.png" alt="image"/>

<spoiler title="E">
<source lang="cpp">
template <int X, int N>
struct ConvA { enum { Result = (X==1) ? (X+N-1) : X }; };

template <int X, int N>
struct ConvB { enum { Result = (X==1) ? 1 : (X+N) }; };

template <class A, class B>
struct EImpl
{ private:
    typedef typename Map<typename A::Result, A::Count, NullType, ConvA>::Result A1;
    typedef typename Map<typename B::Result, A::Count, NullType, ConvB>::Result B1;
  public:
    typedef typename Append<A1,B1>::Result Result;
    enum {Count = A::Count+B::Count};
};
template <class T1, class T2, class T3 = NullType, class T4 = NullType, class T5 = NullType>
struct E: public EImpl<T1, E<T2,T3,T4,T5> > {};
template <class T1, class T2>
struct E<T1,T2,NullType,NullType,NullType>: public EImpl<T1,T2> {};
</source>
</spoiler>
Здесь, дополнительные дуги не строятся, а графы соединяются общей вершиной (начальной для B и конечной для A).

Самой сложной оказалась реализация квантификатора /T*/:

<img src="https://habrastorage.org/getpro/habr/post_images/8cc/c9f/bc9/8ccc9fbc9324547cbafb5a6a9d0a1fc5.png" alt="image"/>

<spoiler title="Q">
<source lang="cpp">
template <class T, int Min = 0, int Max = 0> struct Q { 
 Q() {STATIC_ASSERT(Min<=Max, Q_Spec);}
 private:
  typedef typename Map<typename T::Result, T::Count, NullType, ConvA>::Result A1;
  typedef typename Map<typename Q<T,Min,Max-1>::Result,T::Count,NullType,ConvB>::Result B1;
 public:
  typedef typename Edge<typename Append<A1,B1>::Result,0,T::Count> Result;
  enum {Count = T::Count+Q<T,Min,Max-1>::Count};
};
template <class T, int N> struct Q<T,N,N>
{ private:
  typedef typename Map<typename T::Result, T::Count, NullType, ConvA>::Result A1;
  typedef typename Map<typename Q<T,N-1,N-1>::Result, T::Count, NullType, ConvB>::Result B1;
 public:
  typedef typename Append<A1,B1>::Result Result;
  enum {Count = T::Count+Q<T,N-1,N-1>::Count};
};
</source>
</spoiler>
Поскольку квантификаторы /T*/ и /T+/ встречаются довольно часто, были перегружены их оптимизированные реализации:

<spoiler title="Q">
<source lang="cpp">
template <class T> struct Q<T,1,1>: public T {};
template <class T>
struct Q<T,0,0>
{ private:
    typedef typename Edge<typename Map<typename T::Result,2,NullType,Add>::Result,0,2> N0;
    typedef typename Edge<N0,3,1> N1;
    typedef typename Edge<N1,3,2> N2;
  public:
    typedef typename Edge<N2,0,1> Result;
    enum {Count = T::Count+2};
};
template <class T>
struct Q<T,1,0>
{ public:
    typedef typename Edge<typename T::Result,1,0> Result;
    enum {Count = T::Count};
};
template <class T>
struct Q<T,0,1>
{ public:
    typedef typename Edge<typename T::Result,0,1> Result;
    enum {Count = T::Count};
};
</source>
</spoiler>
Теперь, можно было собрать НКА, представляющий регулярное выражение /(a|b)*abb/, описанное в книге:

<source lang="cpp">
typedef E< Q< D< C<'a'>, C<'b'> > >, C<'a'>, C<'b'>, C<'b'> >::Result G;
</source>

Осталось преобразовать его в ДКА:

<spoiler title="DFA">
<source lang="cpp">
enum CONSTS {
   MAX_FIN_STATE = 9
};

template <class Graph> class DFAImpl;
template <class T, int Src, int Dst, char Chr>
class DFAImpl<Edge<T,Src,Dst,Chr> >: public DFAImpl<typename T>
{ public:
    typedef typename    DFAImpl<typename T>::ResultType ResultType;
    ResultType          Parse(char C)
    {
      if ((State==Src)&&(C==Chr)) {
           State = Dst;
           if (State<MAX_FIN_STATE) {
               State = 0;
               return rtSucceed;
           }
           return rtNotCompleted;
      }
      return DFAImpl<typename T>::Parse(C);
    }
    void Dump(void) {T::Dump();}
};
template <>
class DFAImpl<NullType>
{ public:
    DFAImpl():          State(0) {}
    enum ResultType {
       rtNotCompleted = 0,
       rtSucceed      = 1,
       rtFailed       = 2
    };
    ResultType          Parse(char C)
    {  State = 0;
       return rtFailed;
    }
  protected:
    int                 State;
};

// Вычисление хода (списка состояний) из вершины (При a==0 - e-ход) 
// N - Узел
// T - Граф
// R - Результирующее состояние
// a - Символ алфавита
template <int N, class T, class R, int a = 0> struct Move;
template <int N, class R, int a> struct Move<N,NullType,R,a> {typedef R Result;};
template <int N, class T, int D, class R, int a> struct Move<N,Edge<T,N,D,a>,R,a>
{ typedef typename Move<N,T,typename AddSet<D,R,NullType>::Result,a>::Result Result;
};
template <int N, int M, class T, int D, class R, int a, int b> 
struct Move<N,Edge<T,M,D,b>,R,a>
{ typedef typename Move<N,T,R,a>::Result Result;
};

// Фильтрация списка по условию F
// T - Исходный список (Set, StateListEx)
// С - Значение параметра предиката F
// R - Результирующий список (Set, StateListEx)
// F - Предикат (Exist, NotExist, Important)
template <class T, class C, class R, template <int,class> class F> struct Filter;
template <class C, class R, template <int,class> class F> 
struct Filter<NullType,C,R,F> {typedef R Result;};
template <int N, class T, class C, class R, template <int,class> class F> 
struct Filter<Set<N,T>,C,R,F>
{ typedef typename If<F<N,C>::Result,
                      typename Filter<T,C,typename Set<N,R>,F>::Result,
                      typename Filter<T,C,R,F>::Result
                     >::Result Result;
};
template <int Src, int Dst, int a, class S, class T, class C, class R, template <int,class> class F> 
struct Filter<StateListEx<Src,Dst,a,S,T>,C,R,F>
{ typedef typename If<F<Dst,C>::Result,
                      typename Filter<T,C,typename StateListEx<Src,Dst,a,S,R>,F>::Result,
                      typename Filter<T,C,R,F>::Result
                     >::Result Result;
};

// Вычисление e-замыкания
// T - Начальный список узлов
// G - Граф
// R - Результирующий список узлов
template <class T, class G, class R> struct EClos;
template <class G, class R> struct EClos<NullType,G,R> {typedef R Result;};
template <int N, class T, class G, class R> 
struct EClos<Set<N,T>,G,R>
{ private:
    typedef typename Move<N,G,NullType>::Result L;
    typedef typename Filter<L,typename Append<T,R>::Result,NullType,NotExist>::Result F;
  public:
    typedef typename EClos<typename Append<T,F>::Result,G,
                           typename Set<N,R>
                          >::Result Result;
};

// Вычисление хода из множества вершин
// T - Состояние
// G - Граф
// R - Результирующее состояние
// a - Символ алфавита
template <class T, class G, class R, int a> struct MoveSet;
template <class G, class R, int a> struct MoveSet<NullType,G,R,a> {typedef R Result;};
template <int N, class T, class G, class R, int a> 
struct MoveSet<Set<N,T>,G,R,a>
{ typedef typename MoveSet<T,G,typename Join<R,typename Move<N,G,NullType,a>::Result>::Result,a>::Result Result;
};

// Вычисление списка состояний, полученных всеми ходами из вершины
// N - Генератор номеров узлов
// K - Генератор номеров финальных узлов
// T - Алфавит
// n - Текущий узел
// S - Текущее состояние (Set)
// G - Граф
// R - Результирующий список расширенных состояний
template <int N, int K, class T, int n, class S, class G, class R> struct MoveList;
template <int N, int K, int n, class S, class G, class R> 
struct MoveList<N,K,NullType,n,S,G,R> {typedef R Result;};
template <int N, int K, int a, class T, int n, class S, class G, class R> 
struct MoveList<N,K,Set<a,T>,n,S,G,R>
{ private:
    typedef typename MoveSet<S,G,NullType,a>::Result S0;
    typedef typename EClos<S0,G,NullType>::Result S1;
    enum { N1 = (NotExist<1,S1>::Result)?K:N };
  public:
    typedef typename MoveList<(N==N1)?(N+1):N,
                              (K==N1)?(K+1):K,
                              T,n,S,G,
                              StateListEx<n,N1,a,S1,R> >::Result Result;
};

// Построение алфавита языка по графу NFA (вычислять однократно на верхнем уровне)
// T - Граф
// R - Результирующий алфавит
template <class T, class R> struct Alf;
template <class R> struct Alf<NullType,R> {typedef R Result;};
template <class T, int S, int D, class R> struct Alf<Edge<T,S,D,0>,R> {
    typedef typename Alf<T,R>::Result Result;
};
template <class T, int S, int D, int a, class R> struct Alf<Edge<T,S,D,a>,R>{ 
    typedef typename Alf<T, typename AddSet<a,R,NullType>::Result>::Result Result;
};

// Инкремент генератора узлов
// T - Список состояний (StateListEx)
// R - Результирующее значение генератора
// F - Предикат (Exist, NotExist)
template <class T, int R, template <int,class> class F> struct Incr;
template <int R, template <int,class> class F> 
struct Incr<NullType,R,F> {enum {Result = R};};
template <int Src, int N, int a, class S, class T, int R, template <int,class> class F> 
struct Incr<StateListEx<Src,N,a,S,T>,R,F>
{ enum { Result = Incr<T, (F<1,S>::Result)?((N>=R)?(N+1):R):R, F>::Result};
};

// Определение значимого узла
// N - Узел
// G - Граф
template <int N, class G> struct Important;
template <int N> struct Important<N,NullType> {enum {Result = (N==1)};};
template <int N, class T, int D> 
struct Important<N,Edge<T,N,D,0> > {
    enum { Result = Important<N,T>::Result };
};
template <int N, class T, int D, int C> 
struct Important<N,Edge<T,N,D,C> > {
    enum {Result = true};
};
template <int N, class T, int S, int D, int C> 
struct Important<N,Edge<T,S,D,C> > {
    enum { Result = Important<N,T>::Result };
};

// Оптимизированное построение списка значимых узлов
// T - Граф
// R - Результирующий список
template <class T, class R> struct ImportantOpt;
template <class R> struct ImportantOpt<NullType,R> {
    typedef typename AddSet<1,R,NullType>::Result Result;
};
template <class T, int S, int D, class R> 
struct ImportantOpt<Edge<T,S,D,0>,R>{ 
    typedef typename ImportantOpt<T,R>::Result Result;
};
template <class T, int S, int D, int C, class R> 
struct ImportantOpt<Edge<T,S,D,C>,R> { 
    typedef typename ImportantOpt<T,typename AddSet<S,R,NullType>::Result>::Result Result;
};

// Сравнение состояний по совокупности значимых узлов
// A - Список узлов (Set)
// B - Список узлов (Set)
// G - Граф
// I - Список значимых узлов (вычислять однократно на верхнем уровне)
template <class A, class B, class G> struct EquEx
{ private:
    typedef typename Filter<A,G,NullType,Important>::Result A1;
    typedef typename Filter<B,G,NullType,Important>::Result B1;
  public:
    enum { Result = Equ<A1,B1>::Result };
};
template <class A, class B, class I> struct EquExOpt
{ private:
    typedef typename Filter<A,I,NullType,Exist>::Result A1;
    typedef typename Filter<B,I,NullType,Exist>::Result B1;
  public:
    enum { Result = Equ<A1,B1>::Result };
};

// Получение списка узлов
// G - Граф
// R - Результирующий список
template <class T, class R> struct EdgeList;
template <class R> 
struct EdgeList<NullType,R> {typedef R Result;};
template <class T, int S, int D, int C, class R> 
struct EdgeList<Edge<T,S,D,C>,R>
{ private:
    typedef typename AddSet<S,R, NullType>::Result R0;
    typedef typename AddSet<D,R0,NullType>::Result R1;
  public:
    typedef typename EdgeList<T,R1>::Result Result;
};

// Проверка вхождения (по равенству состояний)
// T - Контрольный список (StateList)
// S - Искомое состояние (Set)
// I - Список значимых узлов
template <class T, class S, class I> struct ExistS;
template <class S, class I> 
struct ExistS<NullType,S,I> {enum {Result = false};};
template <int N, class s, class T, class S, class I> 
struct ExistS<StateList<N,s,T>,S,I>
{ enum { Result = (Equ<s,S>::Result) ? // EquExOpt<s,S,I>::Result
                  true :
                  ExistS<T,S,I>::Result
       };
};

// Отброс ранее найденных узлов
// T - Исходный список (StateListEx)
// С - Контрольный список (StateList)
// I - Список значимых узлов (Set)
// R - Результирующий список (StateListEx)
template <class T, class C, class I, class R> struct FilterT;
template <class C, class I, class R> 
struct FilterT<NullType,C,I,R> {typedef R Result;};
template <int Src, int Dst, int a, class S, class T, class C, class I, class R> 
struct FilterT<StateListEx<Src,Dst,a,S,T>,C,I,R>
{ typedef typename If<ExistS<C,S,I>::Result,
                      typename FilterT<T,C,I,R>::Result,
                      typename FilterT<T,C,I,StateListEx<Src,Dst,a,S,R> >::Result
                     >::Result Result;
};

// Формирование результирующего графа
// T - Множество ранее сформированных вершин (StateList)
// a - Символ перехода к искомой вершине
// S - Исходное состояние (Set)
// I - Список значимых узлов
// R - Формируемый граф
template <class T, int Src, int Dst, int a, class S, class I, class R> struct GenImpl;
template <int Src, int Dst, int a, class S, class I, class R> 
struct GenImpl<NullType,Src,Dst,a,S,I,R> {typedef R Result;};
template <int n, class s, class T, int Src, int Dst, int a, class S, class I, class R> 
struct GenImpl<StateList<n,s,T>,Src,Dst,a,S,I,R>
{ typedef typename If<Equ<s,S>::Result, // EquExOpt<s,S,I>
                      Edge<R,Src,n,a>,
                      typename GenImpl<T,Src,Dst,a,S,I,R>::Result
                     >::Result Result;
};

// Формирование результирующего графа
// T - Множество новых узлов
// С - Ранее сформированные узлы
// I - Множество значимых узлов
// R - Результирующий граф
template <class T, class C, class I, class R> struct Gen;
template <class C, class I, class R> 
struct Gen<NullType,C,I,R> {typedef R Result;};
template <int Src, int Dst, int a,class S, class T, class C, class I, class R> 
struct Gen<StateListEx<Src,Dst,a,S,T>,C,I,R> { 
    typedef typename Gen<T,C,I,typename GenImpl<C,Src,Dst,a,S,I,R>::Result>::Result Result;
};

// Шаг преобразования
// N - Генератор номеров результирующих узлов
// K - Генератор номеров финальных узлов
// G - Граф (NFA)
// A - Алфавит (Set)
// I - Список значимых узлов (Set)
// R - Результирующий граф (DFA)
// M - Список помеченных состояний (StateList)
// D - Список непомеченных состояний (StateListEx)
template <int N, int K, class G, class A, class I, class R, class M, class D> struct ConvertImpl;
template <int N, int K, class G, class A, class I, class R, class M> 
struct ConvertImpl<N,K,G,A,I,R,M,NullType> {typedef R Result;};
template <int N, int K, class G, class A, class I, class R, class M, int Src, int Dst, int a, class S, class D> 
struct ConvertImpl<N,K,G,A,I,R,M,StateListEx<Src,Dst,a,S,D> >
{ private:
    typedef typename MoveList<N,K,A,Dst,S,G,NullType>::Result T;
    typedef typename StateList<Dst,S,M> M1;
    typedef typename Append<D,M1>::Result MD;
    typedef typename FilterT<T,MD,I,NullType>::Result T1;
    typedef typename AppendSafe<T1,D>::Result D1;
    typedef typename Gen<T,typename Append<T1,MD>::Result,I,R>::Result R1;
    enum { N1 = Incr<T1,N,Exist>::Result,
           K1 = Incr<T1,K,NotExist>::Result
         };
  public:
    typedef typename ConvertImpl<N1,K1,G,A,I,R1,M1,D1>::Result Result;
};

// Преобразование NFA -> DFA
// G - Граф
// R - Результирующий граф
template <class G, class R> struct Convert
{ private:
    typedef typename Alf<G,NullType>::Result A;
    typedef typename ImportantOpt<G,NullType>::Result I;
  public:
    typedef typename ConvertImpl<1,MAX_FIN_STATE+1,G,A,I,NullType,NullType,
                                 StateListEx<0,0,0,typename EClos<Set<0,NullType>,G,NullType>::Result,NullType> >::Result Result;
};

template <class T>
class DFA: public DFAImpl<typename Convert<typename T::Result,NullType>::Result> {};
</source>
</spoiler>
Я не буду подробно описывать все мытарства связанные с отладкой этого кода (чего стоили одни только километровые листинги с сообщениями об ошибках компиляции), замечу только, что "лобовая" реализация алгоритма вешала компилятор напрочь, в результате чего пришлось реализовать оптимизированный шаблон ImportantOpt.

Теперь можно запустить на выполнение следующий код:

<source lang="cpp">
    typedef E< Q< D< C<'a'>, C<'b'> > >, C<'a'>, C<'b'>, C<'b'> >::Result G;
    typedef Convert<G,NullType>::Result R;
    R::Dump();
</source>
... и убедиться, что выдаваемый им результат:

<source>
  1 -a->  10
  1 -b->  11
 13 -a->  10
 13 -b->   1
 10 -a->  10
 10 -b->  13
 11 -a->  10
 11 -b->  11
  0 -a->  10
  0 -b->  11
</source>
Соответствует искомому графу ДКА:

<img src="https://habrastorage.org/getpro/habr/post_images/116/951/049/11695104965008698f0620c47f87d3fb.png" alt="image"/> 

Как обычно, исходники выложены на <a href="https://github.com/GlukKazan/ConvertToDFA">GitHub</a>.
</habracut>

Приручаем JMeter

<img align="left" src="https://habrastorage.org/getpro/habr/post_images/ca8/e04/a17/ca8e04a173979bddb7168d39ffd9f6a9.jpg" alt="image"/>Сегодня я хочу рассказать о замечательном инструменте, название которого вынесено в заголовок статьи. Разумеется, моей целью не является написание подробного руководства по <a href="http://jmeter.apache.org/">Apache JMeter</a>. В своей статье я хочу лишь зафиксировать ряд, на мой взгляд, не очевидных моментов, с которыми мне пришлось столкнуться в своей повседневной работе. Я надеюсь, что моя статья будет полезна (сразу предупреждаю, картинок будет много).&nbsp;
<habracut>
Конечно, я не первый, кто пишет про JMeter на <a href="http://habrahabr.ru/search/?q=JMeter">Хабре</a>, но практически во всех предыдущих статьях, акцент делается на нагрузочное тестирование. Хотя это и основное применение JMeter, но только им его возможности не ограничиваются. Давайте, просто посмотрим, по каким протоколам может работать этот продукт:

<ul>
	<li>Web - HTTP, HTTPS</li>
	<li>SOAP / REST</li>
	<li>FTP</li>
	<li>Database via JDBC</li>
	<li>LDAP</li>
	<li>Message-oriented middleware (MOM) via JMS</li>
	<li>Mail - SMTP(S), POP3(S) and IMAP(S)</li>
	<li>MongoDB (NoSQL)</li>
	<li>Native commands or shell scripts</li>
	<li>TCP</li>
</ul>
Таким образом, если перед вами стоит какая-то задача автоматизации и всё, что вам требуется, перечислено в этом списке, определённо стоит подумать об использовании JMeter, перед тем как с головой погрузиться в программирование на любимом Perl, Python или Java. Возможно, такой подход позволит сэкономить очень много времени.

<h4><b>Установка</b></h4>
С этим всё просто:

<ol>
	<li>Устанавливаем <a href="http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html">Java</a> (если она еще не установлена)</li>
	<li>Выкачиваем и распаковываем свежую сборку <a href="http://jmeter.apache.org/download_jmeter.cgi">JMeter</a></li>
	<li>Устанавливаем переменную среды <b>JMETER_BIN</b> на каталог с исполняемыми файлами JMeter (только для Windows)</li>
	<li>Запускаем <b>jmeter.bat</b> или <b>jmeter.sh</b> (в зависимости от операционной системы) из каталога <b>bin</b></li>
</ol>
Единственная проблема, с которой я столкнулся на Windows, связана с тем, что значение переменной JMETER_BIN должно завершаться символом прямого или обратного слэша. Подробности можно посмотреть в запускаемом скрипте. Чтение <a href="http://jmeter.apache.org/usermanual/get-started.html">инструкции</a> также не будет лишним.

<h4><b>Запись скрипта</b></h4>
Это, пожалуй, самая эффектная возможность JMeter. Она уже описывалась <a href="http://habrahabr.ru/post/140310/">ранее</a>, но я повторюсь, поскольку в той статье речь шла об уже немного устаревшей версии. JMeter можно запустить в режиме proxy, таким образом, чтобы весь HTTP-трафик проходил через него. Все подробности взаимодействия будут автоматически записываться в выбранную <b>Thread Group</b> или <b>Recording Controller</b>. Для добавления новых узлов в дерево, просто нажимаем на правую кнопку мыши и выбираем требуемый тип из выпадающего меню:

<img align="center" src="https://habrastorage.org/files/a95/393/1b5/a953931b51d94dad927de4d122529f6a.PNG"/>
<b>Thread Group</b>, управляющая такими настройками как количество потоков, используемых для тестирования и количество запросов в тесте, находится в категории <b>Treads (Users)</b>, а сам <b>HTTP(S) Test Script Recorder</b> в <b>Non-Test Elements</b>. 

<img align="center" src="https://habrastorage.org/files/bba/78c/859/bba78c859d70442a98f3d38b666b4e02.png"/>
Я выделил на рисунке настройки, на которые следует обратить внимание. Порт возможно придётся изменить, если на 8080 уже что-то поднято. В сложных случаях, в <b>Test Plan</b> придётся добавить <b>HTTP Cookie Manager</b> и <b>HTTP Authorization Manager</b>. После нажатия кнопки Start, идём в настройки любимого браузера:

<img align="center" src="https://habrastorage.org/files/138/95a/c79/13895ac798d24089b5916b6afe092998.png"/>
Взаимодействие с Яндекс, внезапно, оказывается очень непростым:

<img align="center" src="https://habrastorage.org/files/55e/320/62c/55e32062c7c44ff8866dc5df3175f640.PNG"/>
Полученные запросы (<b>HTTP Request</b>) вместе с их настройками (<b>HTTP Header Manager</b>) можно перенести в любое место скрипта, используя любимые всеми команды Copy&Paste (Drag&Drop тоже работает). Даже если вы твердо уверены в том, что происходит на вашем сайте, Script Recorder может быть очень полезен, для того чтобы узнать подробности. Кроме того, автоматическая генерация скриптов куда веселее чем вбивание их руками. Более подробно процесс записи скриптов описан в этой <a href="https://jmeter.apache.org/usermanual/jmeter_proxy_step_by_step.pdf">инструкции</a>.

<h4><b>Переменные</b></h4>
Для чего-то мало-мальски серьёзного, нам потребуется возможность параметризации. Для примера, предположим, что нам требуется задать таймауты, в течение которых JMeter будет ожидать ответа сервера. Вбивать их заново в каждый <b>HTTP Request</b>, при любом изменении, было бы слишком утомительно. Заодно определим настройки HTTP Proxy (если он используется):

<img align="center" src="https://habrastorage.org/files/0f4/b89/7fa/0f4b897fa3574a169b52595aee9ec119.PNG"/>
В поле Password забито значение <b>${user_pass}</b>, тут уж вам придётся поверить мне на слово. Сами настройки удобно держать в <b>User Defined Variables</b> (этот элемент можно найти в категории <b>Config Element</b>):

<img align="center" src="https://habrastorage.org/files/9db/f3a/697/9dbf3a697b854594a30678b113a4e599.PNG"/>
Пустые значения переменных проблемой не являются. В соответствующие настройки будут подставлены пустые строки, как того и требуется, в случае если HTTP Proxy не используется. Можно пойти ещё дальше и действительно разместить все HTTP-настройки в одном месте:

<img align="center" src="https://habrastorage.org/files/cf1/8de/f4a/cf18def4a8ab41ec9db6d167ef9dd1d7.PNG"/>
Элемент <b>HTTP Request Defaults</b>, также как и <b>User Defined Variables</b> расположен в категории <b>Config Element</b>.

<h4><b>Отладка</b></h4>
Теперь, было бы неплохо видеть, что происходит при выполнении сценария. Различного вида визуализаторы размещаются в категории <b>Listener</b>. Нам понадобится <b>View Results Tree</b>. Добавим его и запустим сценарий на выполнение командой <b>Run/Start</b> (Ctrl+R). Можно видеть, что ответ сервера также бывает непростым:

<img align="center" src="https://habrastorage.org/files/adf/167/5d3/adf1675d3a8d4c439adbbab91299b85f.PNG"/>
Такая картина наблюдается, если адрес редиректит нас на другую страницу и с этим может быть связана одна проблема. Если мы попытаемся анализировать ответ сервера (как это делать я покажу ниже), нам будет доступен лишь последний ответ (той страницы на которую произошёл redirect). Если ответ с предыдущей страницы нам также интересен, автоматический redirect придётся отключить. За это отвечает настройка <b>Follow Redirects</b> элемента <b>HTTP Request</b>. Разобрав ответ, мы сможем получить адрес целевой страницы и выполнить повторный запрос вручную.

Есть ещё один элемент, крайне полезный для отладки сценариев. Он находится в категории <b>Sampler</b> и называется <b>Debug Sampler</b>. Каждый раз, когда до него доходит управление, он выводит текущие значения всех переменных. Добавим его в <b>Thread Group</b> и запустим сценарий ещё раз (для того, чтобы очистить вывод предыдущего запуска, удобно использовать комбинацию клавиш Ctrl+E):

<img align="center" src="https://habrastorage.org/files/161/592/074/1615920742704943a243e4180a974359.PNG"/>
Все переменные как на ладони. Удобно.

<h4><b>JDBC Request</b></h4>
Этот Sampler открывает нам доступ в любую базу данных, поддерживающую протокол <a href="https://ru.wikipedia.org/wiki/Java_Database_Connectivity">JDBC</a>. Для начала, добавим в <b>Test Plan</b> конфигурационный элемент с настройками подключения к серверу БД (<b>JDBC Connection Configuration</b>):

<img align="center" src="https://habrastorage.org/files/252/710/a90/252710a902a74ad9b4545901d118b373.PNG"/>
Помимо собственно настроек подключения к БД, здесь важно заполнить поле <b>Variable Name</b>. Это имя будет использоваться в <b>JDBC Request</b> (<b>Sampler</b>) для доступа к пулу сессий:

<img align="center" src="https://habrastorage.org/files/70e/448/dbf/70e448dbf25a4f2289f839f5f4fd3f8a.PNG"/>
Если вам интересны результаты select-а, придётся заполнить <b>Variable Names</b>. Сам JMeter парсить SQL-запросы на предмет имён столбцов не умеет. Можно перечислять имена столбцов через запятую и пропускать столбцы, не давая им имени. Вставляем <b>Debug Sampler</b> и смотрим, что получилось:

<img align="center" src="https://habrastorage.org/files/c17/1b2/1c6/c171b21c61be454785e4a45d3d4c4881.PNG"/>
Видим, что <a href="http://jmeter.apache.org/usermanual/component_reference.html#JDBC_Request">документация</a> не врёт. Появились переменные <b>urls_1</b> и <b>urls_2</b> (количество строк, как и обещали, в <b>urls_#</b>). В этом месте, стоит соблюдать осторожность. Записи выбираются не по одной, а все сразу и прочитав >1000 строк можно легко отожрать слишком много памяти. Теперь, было бы неплохо обойти полученные адреса в цикле:

<img align="center" src="https://habrastorage.org/files/d0a/fa3/f91/d0afa3f916f043498974abe25be6ea3f.PNG"/>
Да, именно вот так заковыристо. Набор переменных <b>urls</b> перебираем от 0 до <b>${urls_#}</b> и текущее значение помещаем в <b>url</b>. Сам <b>ForEach Controller</b> можно найти в категории <b>Logic Controller</b>. Внутри него создадим параметризованный <b>HTTP Request</b>. Запускаем, смотрим:

<img align="center" src="https://habrastorage.org/files/c9a/5a0/c11/c9a5a0c1156d4df99c9e60e6f5853a8c.PNG"/>
Всё работает.

<h4><b>Регулярные выражения</b></h4>
Теперь, результаты обращений к Web-серверам хотелось бы проанализировать. Для этого, нам предоставлена вся мощь <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">регулярных выражений</a>. <b>Regular Expression Extractor</b> можно найти в <b>Post Processors</b>. Добавим его в <b>HTTP Request</b> и сконфигурируем:

<img align="center" src="https://habrastorage.org/files/d45/208/b0e/d45208b0ed7844d683a54ae17e22a8fc.PNG"/>
Здесь, нас интересует только код ответа по HTTP (но, по иллюстрации видно, что можно обрабатывать и содержимое ответа). Будем извлекать цепочку цифр (<b>Regular Expression</b>) и помещать результат применения шаблона (<b>Template</b>) в переменную <b>http_result</b> (<b>Reference Name</b>):

<img align="center" src="https://habrastorage.org/files/7a0/e45/205/7a0e4520593c436e9005ddd6fd7a4657.PNG"/>
Как и ожидалось, получаем 200. Заодно, можно видеть, каким образом осуществляется захват в переменные регулярным выражением.

<h4><b>Что-то там внутри</b></h4>
Теперь, допустим, что нас интересует время, в течение которого выполнялся HTTP-запрос. И интересует оно нас не просто для статистики, а мы его хотим как-то использовать в сценарии (например сложить в БД). С этой задачей поможет справиться <a href="http://jmeter.apache.org/usermanual/best-practices.html#bsh_scripting">BeanShell</a>. Конкретно, мы используем его <b>Pre</b>- и <b>PostProcessor</b>-ы.

<img align="center" src="https://habrastorage.org/files/a5c/ad4/78b/a5cad478bb18429f893c172bf82f8c17.PNG"/>
В первом будем получать timestamp:

<source lang="java">
Long t = ctx.getPreviousResult().currentTimeInMillis();
vars.put("timestamp", t.toString());
</source>
А во втором, получать с его помощью временную задержку:

<source lang="java">
Long d = ctx.getPreviousResult().currentTimeInMillis() - Long.parseLong(vars.get("timestamp"));
vars.put("delay", d.toString());
</source>
В общем, это тоже работает:

<img align="center" src="https://habrastorage.org/files/710/a55/2f7/710a552f784246bd97fa318621b34307.PNG"/>
Но здесь следует сделать важное замечание. Поскольку, в настоящий момент, я занимаюсь <b>не</b> нагрузочным тестированием, производительность этой конструкции для меня не очень важна. Если в вашем случае это не так, стоит ознакомиться со следующей <a href="http://habrahabr.ru/post/250731/">статьёй</a>.

<h4><b>Запуск</b></h4>
Если бы не было этой возможности, не стоило бы и весь этот разговор заводить. В случае нагрузочного тестирования, сценарий можно запускать из GUI, нет проблем. Но если нас интересует автоматизация, необходимо уметь запускать его молча (например по <a href="https://ru.wikipedia.org/wiki/Cron">cron</a>-у). Разумеется такая возможность тоже есть:

<source>
./jmeter.sh -n -t test.jmx -l test.log
</source>
Сохраняем сценарий в файл с расширением jmx (внутри это XML) и запускаем эту команду. Сценарий отрабатывает без запуска GUI и заодно пишет результаты своей работы в лог. Всё просто и удобно.
</habracut>
